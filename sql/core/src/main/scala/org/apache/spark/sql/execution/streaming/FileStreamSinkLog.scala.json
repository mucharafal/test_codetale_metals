[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Add basic doc string on what this class represents.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T19:57:13Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Dont like the name. This class is not a \"log\". FileStreamSinkLog is a log, each line in it is not a log.\nI think this is a general problem with a number of method names as well. E.g. allLogs(). Maybe call it `allFiles` or `allSinkFiles`?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:03:05Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: doing a compaction\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:17:00Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: read all old log files\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:17:23Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: `MS -> Ms`\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:20:10Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "The value is not validated? if someone sets < 0\n\nnit: Add comment on what the length is\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:21:22Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: logs -> logData\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T20:25:37Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "What happens in file systems where getModificationTime is not reported, or reported as 0. Then this would always delete all the files. \n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:03:01Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {",
    "line": 206
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I made a mistake about `getModificationTime`. Only the directory's `getModificationTime` in S3 returns 0. File's getModificationTime returns the correct value. See https://issues.apache.org/jira/browse/HADOOP-12837\n\nI also verified that in S3 by myself.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:55:01Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {",
    "line": 206
  }, {
    "author": {
      "login": "steveloughran"
    },
    "body": "Note that granularity of modification time can be 1s (azure)\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-21T09:07:42Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {",
    "line": 206
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Can you move the public method higher up over the private methods?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:03:59Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Also mention that it deletes expired files as well, if enabled.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:04:31Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file."
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: can you explain the loop?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:08:00Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: can you elaborate a little .. who is writing and who is reading.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:09:32Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: Can you put an example like the isCompletionBatch\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:38:23Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {\n+        fileManager.delete(f.getPath)\n+      }\n+    }\n+  }\n+}\n+\n+object FileStreamSinkLog {\n+  val VERSION = \"v1\"\n+  val COMPACT_FILE_SUFFIX = \".compact\"\n+  val DELETE_ACTION = \"delete\"\n+  val ADD_ACTION = \"add\"\n+\n+  def getBatchIdFromFileName(fileName: String): Long = {\n+    fileName.stripSuffix(COMPACT_FILE_SUFFIX).toLong\n+  }\n+\n+  /**\n+   * Returns if this is a compaction batch. FileStreamSinkLog will compact old logs every\n+   * `compactLength` commits.\n+   *\n+   * E.g., if `compactLength` is 3, then 2, 5, 8, ... are all compaction batches.\n+   */\n+  def isCompactionBatch(batchId: Long, compactLength: Int): Boolean = {\n+    (batchId + 1) % compactLength == 0\n+  }\n+\n+  /**\n+   * Returns all valid batches before the specified `compactionBatchId`. They contain all logs we\n+   * need to do a new compaction.",
    "line": 235
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Added.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T22:57:52Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {\n+        fileManager.delete(f.getPath)\n+      }\n+    }\n+  }\n+}\n+\n+object FileStreamSinkLog {\n+  val VERSION = \"v1\"\n+  val COMPACT_FILE_SUFFIX = \".compact\"\n+  val DELETE_ACTION = \"delete\"\n+  val ADD_ACTION = \"add\"\n+\n+  def getBatchIdFromFileName(fileName: String): Long = {\n+    fileName.stripSuffix(COMPACT_FILE_SUFFIX).toLong\n+  }\n+\n+  /**\n+   * Returns if this is a compaction batch. FileStreamSinkLog will compact old logs every\n+   * `compactLength` commits.\n+   *\n+   * E.g., if `compactLength` is 3, then 2, 5, 8, ... are all compaction batches.\n+   */\n+  def isCompactionBatch(batchId: Long, compactLength: Int): Boolean = {\n+    (batchId + 1) % compactLength == 0\n+  }\n+\n+  /**\n+   * Returns all valid batches before the specified `compactionBatchId`. They contain all logs we\n+   * need to do a new compaction.",
    "line": 235
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: format should be one param per line.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-18T21:38:52Z",
    "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class FileLog(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[FileLog]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a compact,\n+ * it will read all history logs and merge them with the new batch. During the compaction, it will\n+ * also delete the files that are deleted (marked by [[FileLog.action]]). When the reader uses\n+ * `allLogs` to list all files, this method only returns the visible files (drops the deleted\n+ * files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[FileLog]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileExpiredTimeMS`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileExpiredTimeMS = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_EXPIRED_TIME)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_DELETE)\n+\n+  private val compactLength = sqlContext.getConf(SQLConf.FILE_STREAM_SINK_LOG_COMPACT_LEN)\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logs: Seq[FileLog]): Array[Byte] = {\n+    (VERSION +: logs.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[FileLog] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[FileLog](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    if (isCompactionBatch(batchId, compactLength)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n+   * corresponding `batchId` file.\n+   */\n+  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n+    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n+    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n+    if (super.add(batchId, compactLogs(allLogs))) {\n+      if (isDeletingExpiredLog) {\n+        deleteExpiredLog(batchId)\n+      }\n+      true\n+    } else {\n+      // Return false as there is another writer.\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Returns all file logs except the deleted files.\n+   */\n+  def allLogs(): Array[FileLog] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactLength)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process may delete the batch files when we are reading. However, it only\n+            // happens when there is a compaction done. If so, we should retry to read the batches.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            val preLatestId = latestId\n+            latestId = getLatest().map(_._1).getOrElse(-1L)\n+            if (preLatestId == latestId) {\n+              throw e\n+            }\n+        }\n+      } else {\n+        return Array.empty\n+      }\n+    }\n+    Array.empty\n+  }\n+\n+  /**\n+   * Since all logs before `compactionBatchId` are compacted and written into the\n+   * `compactionBatchId` log file, they can be removed. However, due to the eventual consistency of\n+   * S3, the compaction file may not be seen by other processes at once. So we only delete files\n+   * created `fileExpiredTimeMS` milliseconds ago.\n+   */\n+  private def deleteExpiredLog(compactionBatchId: Long): Unit = {\n+    val expiredTime = System.currentTimeMillis() - fileExpiredTimeMS\n+    fileManager.list(metadataPath, new PathFilter {\n+      override def accept(path: Path): Boolean = {\n+        try {\n+          val batchId = getBatchIdFromFileName(path.getName)\n+          batchId < compactionBatchId\n+        } catch {\n+          case _: NumberFormatException =>\n+            false\n+        }\n+      }\n+    }).foreach { f =>\n+      if (f.getModificationTime <= expiredTime) {\n+        fileManager.delete(f.getPath)\n+      }\n+    }\n+  }\n+}\n+\n+object FileStreamSinkLog {\n+  val VERSION = \"v1\"\n+  val COMPACT_FILE_SUFFIX = \".compact\"\n+  val DELETE_ACTION = \"delete\"\n+  val ADD_ACTION = \"add\"\n+\n+  def getBatchIdFromFileName(fileName: String): Long = {\n+    fileName.stripSuffix(COMPACT_FILE_SUFFIX).toLong\n+  }\n+\n+  /**\n+   * Returns if this is a compaction batch. FileStreamSinkLog will compact old logs every\n+   * `compactLength` commits.\n+   *\n+   * E.g., if `compactLength` is 3, then 2, 5, 8, ... are all compaction batches.\n+   */\n+  def isCompactionBatch(batchId: Long, compactLength: Int): Boolean = {\n+    (batchId + 1) % compactLength == 0\n+  }\n+\n+  /**\n+   * Returns all valid batches before the specified `compactionBatchId`. They contain all logs we\n+   * need to do a new compaction.\n+   */\n+  def getValidBatchesBeforeCompactionBatch(\n+      compactionBatchId: Long, compactLength: Int): Seq[Long] = {"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: compact all sink files before ...\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-19T01:33:38Z",
    "diffHunk": "@@ -159,13 +151,31 @@ class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n   }\n \n   /**\n+   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Can you make this allSinkFile() so that its not ambiguous with the log files?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-19T01:35:47Z",
    "diffHunk": "@@ -112,28 +118,13 @@ class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n   }\n \n   /**\n-   * Compacts all logs before `batchId` plus the provided `logs`, and writes them into the\n-   * corresponding `batchId` file.\n-   */\n-  private def compact(batchId: Long, logs: Seq[FileLog]): Boolean = {\n-    val validBatches = getValidBatchesBeforeCompactionBatch(batchId, compactLength)\n-    val allLogs = validBatches.flatMap(batchId => get(batchId)).flatten ++ logs\n-    if (super.add(batchId, compactLogs(allLogs))) {\n-      if (isDeletingExpiredLog) {\n-        deleteExpiredLog(batchId)\n-      }\n-      true\n-    } else {\n-      // Return false as there is another writer.\n-      false\n-    }\n-  }\n-\n-  /**\n-   * Returns all file logs except the deleted files.\n+   * Returns all files except the deleted ones.\n    */\n-  def allLogs(): Array[FileLog] = {\n+  def allFiles(): Array[SinkFileStatus] = {"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "steveloughran"
    },
    "body": "all AWS S3 endpoints now implement create consistency: if a new object is created, then a GET made directly on it will return that object.\n\nwhat can take time to appear is the aggregate file in an ls of the parent \"directory\" that's really a wild card match on the path. If the processes can determine the final name of the compaction file, they can look for that file directly (getFileStatus() should suffice, open() even better). If the compact file isn't found, they can look for the non-aggregate files. All that should be required is the aggregate file fully written (with a close() at the end of output operation _which doesn't discard any raised exception_), before deleting the original files. Adding a minor delay is a low-harm feature, but having a direct check for the aggregate file is something which should be done first\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-19T13:18:18Z",
    "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[SinkFileStatus]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a\n+ * compaction, it will read all old log files and merge them with the new batch. During the\n+ * compaction, it will also delete the files that are deleted (marked by [[SinkFileStatus.action]]).\n+ * When the reader uses `allFiles` to list all files, this method only returns the visible files\n+ * (drops the deleted files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[SinkFileStatus]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileCleanupDelayMs`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileCleanupDelayMs = sqlContext.getConf(SQLConf.FILE_SINK_LOG_CLEANUP_DELAY)"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "@steveloughran thanks for pointing out it. I updated the codes. Now it will try to access the next compaction/aggregate file directly. However, a cleanup delay is still helpful to avoid a live lock.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-19T17:58:16Z",
    "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(path: String, size: Long, action: String)\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[SinkFileStatus]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a\n+ * compaction, it will read all old log files and merge them with the new batch. During the\n+ * compaction, it will also delete the files that are deleted (marked by [[SinkFileStatus.action]]).\n+ * When the reader uses `allFiles` to list all files, this method only returns the visible files\n+ * (drops the deleted files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[SinkFileStatus]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file. The user\n+   * should set a reasonable `fileCleanupDelayMs`. We will wait until then so that the compaction\n+   * file is guaranteed to be visible for all readers\n+   */\n+  private val fileCleanupDelayMs = sqlContext.getConf(SQLConf.FILE_SINK_LOG_CLEANUP_DELAY)"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Create / modified timestamp?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-19T20:26:10Z",
    "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path\n+ * @param size the file size\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(path: String, size: Long, action: String)"
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "Should this be 'version > VERSION' ?\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-20T21:48:22Z",
    "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{FileStatus, Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path.\n+ * @param size the file size.\n+ * @param isDir whether this file is a directory.\n+ * @param modificationTime the file last modification time.\n+ * @param blockReplication the block replication.\n+ * @param blockSize the block size.\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(\n+    path: String,\n+    size: Long,\n+    isDir: Boolean,\n+    modificationTime: Long,\n+    blockReplication: Int,\n+    blockSize: Long,\n+    action: String) {\n+\n+  def toFileStatus: FileStatus = {\n+    new FileStatus(size, isDir, blockReplication, blockSize, modificationTime, new Path(path))\n+  }\n+}\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[SinkFileStatus]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a\n+ * compaction, it will read all old log files and merge them with the new batch. During the\n+ * compaction, it will also delete the files that are deleted (marked by [[SinkFileStatus.action]]).\n+ * When the reader uses `allFiles` to list all files, this method only returns the visible files\n+ * (drops the deleted files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[SinkFileStatus]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file using\n+   * \"list\". The `allFiles` handles this by looking for the next compaction file directly, however,\n+   * a live lock may happen if the compaction happens too frequently: one processing keeps deleting\n+   * old files while another one keeps retrying. Setting a reasonable cleanup delay could avoid it.\n+   */\n+  private val fileCleanupDelayMs = sqlContext.getConf(SQLConf.FILE_SINK_LOG_CLEANUP_DELAY)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_SINK_LOG_DELETION)\n+\n+  private val compactInterval = sqlContext.getConf(SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL)\n+  require(compactInterval > 0,\n+    s\"Please set ${SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL.key} (was $compactInterval) \" +\n+      \"to a positive value.\")\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactInterval)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logData: Seq[SinkFileStatus]): Array[Byte] = {\n+    (VERSION +: logData.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[SinkFileStatus] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {",
    "line": 123
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "> Should this be 'version > VERSION' ?\n\nIt doesn't matter now. This is the first version. We will update the logic here when we add a new format in future.\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-20T21:56:36Z",
    "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{FileStatus, Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path.\n+ * @param size the file size.\n+ * @param isDir whether this file is a directory.\n+ * @param modificationTime the file last modification time.\n+ * @param blockReplication the block replication.\n+ * @param blockSize the block size.\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(\n+    path: String,\n+    size: Long,\n+    isDir: Boolean,\n+    modificationTime: Long,\n+    blockReplication: Int,\n+    blockSize: Long,\n+    action: String) {\n+\n+  def toFileStatus: FileStatus = {\n+    new FileStatus(size, isDir, blockReplication, blockSize, modificationTime, new Path(path))\n+  }\n+}\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[SinkFileStatus]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a\n+ * compaction, it will read all old log files and merge them with the new batch. During the\n+ * compaction, it will also delete the files that are deleted (marked by [[SinkFileStatus.action]]).\n+ * When the reader uses `allFiles` to list all files, this method only returns the visible files\n+ * (drops the deleted files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[SinkFileStatus]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file using\n+   * \"list\". The `allFiles` handles this by looking for the next compaction file directly, however,\n+   * a live lock may happen if the compaction happens too frequently: one processing keeps deleting\n+   * old files while another one keeps retrying. Setting a reasonable cleanup delay could avoid it.\n+   */\n+  private val fileCleanupDelayMs = sqlContext.getConf(SQLConf.FILE_SINK_LOG_CLEANUP_DELAY)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_SINK_LOG_DELETION)\n+\n+  private val compactInterval = sqlContext.getConf(SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL)\n+  require(compactInterval > 0,\n+    s\"Please set ${SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL.key} (was $compactInterval) \" +\n+      \"to a positive value.\")\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactInterval)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logData: Seq[SinkFileStatus]): Array[Byte] = {\n+    (VERSION +: logData.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[SinkFileStatus] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {",
    "line": 123
  }],
  "prId": 12435
}, {
  "comments": [{
    "author": {
      "login": "tedyu"
    },
    "body": "Maybe include latestId in the exception message\n",
    "commit": "e2cd25c0934ba8a0062c29524c27785326dde195",
    "createdAt": "2016-04-20T21:50:49Z",
    "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import java.io.IOException\n+import java.nio.charset.StandardCharsets.UTF_8\n+\n+import org.apache.hadoop.fs.{FileStatus, Path, PathFilter}\n+import org.json4s.NoTypeHints\n+import org.json4s.jackson.Serialization\n+import org.json4s.jackson.Serialization.{read, write}\n+\n+import org.apache.spark.sql.SQLContext\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * The status of a file outputted by [[FileStreamSink]]. A file is visible only if it appears in\n+ * the sink log and its action is not \"delete\".\n+ *\n+ * @param path the file path.\n+ * @param size the file size.\n+ * @param isDir whether this file is a directory.\n+ * @param modificationTime the file last modification time.\n+ * @param blockReplication the block replication.\n+ * @param blockSize the block size.\n+ * @param action the file action. Must be either \"add\" or \"delete\".\n+ */\n+case class SinkFileStatus(\n+    path: String,\n+    size: Long,\n+    isDir: Boolean,\n+    modificationTime: Long,\n+    blockReplication: Int,\n+    blockSize: Long,\n+    action: String) {\n+\n+  def toFileStatus: FileStatus = {\n+    new FileStatus(size, isDir, blockReplication, blockSize, modificationTime, new Path(path))\n+  }\n+}\n+\n+/**\n+ * A special log for [[FileStreamSink]]. It will write one log file for each batch. The first line\n+ * of the log file is the version number, and there are multiple JSON lines following. Each JSON\n+ * line is a JSON format of [[SinkFileStatus]].\n+ *\n+ * As reading from many small files is usually pretty slow, [[FileStreamSinkLog]] will compact log\n+ * files every \"spark.sql.sink.file.log.compactLen\" batches into a big file. When doing a\n+ * compaction, it will read all old log files and merge them with the new batch. During the\n+ * compaction, it will also delete the files that are deleted (marked by [[SinkFileStatus.action]]).\n+ * When the reader uses `allFiles` to list all files, this method only returns the visible files\n+ * (drops the deleted files).\n+ */\n+class FileStreamSinkLog(sqlContext: SQLContext, path: String)\n+  extends HDFSMetadataLog[Seq[SinkFileStatus]](sqlContext, path) {\n+\n+  import FileStreamSinkLog._\n+\n+  private implicit val formats = Serialization.formats(NoTypeHints)\n+\n+  /**\n+   * If we delete the old files after compaction at once, there is a race condition in S3: other\n+   * processes may see the old files are deleted but still cannot see the compaction file using\n+   * \"list\". The `allFiles` handles this by looking for the next compaction file directly, however,\n+   * a live lock may happen if the compaction happens too frequently: one processing keeps deleting\n+   * old files while another one keeps retrying. Setting a reasonable cleanup delay could avoid it.\n+   */\n+  private val fileCleanupDelayMs = sqlContext.getConf(SQLConf.FILE_SINK_LOG_CLEANUP_DELAY)\n+\n+  private val isDeletingExpiredLog = sqlContext.getConf(SQLConf.FILE_SINK_LOG_DELETION)\n+\n+  private val compactInterval = sqlContext.getConf(SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL)\n+  require(compactInterval > 0,\n+    s\"Please set ${SQLConf.FILE_SINK_LOG_COMPACT_INTERVAL.key} (was $compactInterval) \" +\n+      \"to a positive value.\")\n+\n+  override def batchIdToPath(batchId: Long): Path = {\n+    if (isCompactionBatch(batchId, compactInterval)) {\n+      new Path(metadataPath, s\"$batchId$COMPACT_FILE_SUFFIX\")\n+    } else {\n+      new Path(metadataPath, batchId.toString)\n+    }\n+  }\n+\n+  override def pathToBatchId(path: Path): Long = {\n+    getBatchIdFromFileName(path.getName)\n+  }\n+\n+  override def isBatchFile(path: Path): Boolean = {\n+    try {\n+      getBatchIdFromFileName(path.getName)\n+      true\n+    } catch {\n+      case _: NumberFormatException => false\n+    }\n+  }\n+\n+  override def serialize(logData: Seq[SinkFileStatus]): Array[Byte] = {\n+    (VERSION +: logData.map(write(_))).mkString(\"\\n\").getBytes(UTF_8)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): Seq[SinkFileStatus] = {\n+    val lines = new String(bytes, UTF_8).split(\"\\n\")\n+    if (lines.length == 0) {\n+      throw new IllegalStateException(\"Incomplete log file\")\n+    }\n+    val version = lines(0)\n+    if (version != VERSION) {\n+      throw new IllegalStateException(s\"Unknown log version: ${version}\")\n+    }\n+    lines.toSeq.slice(1, lines.length).map(read[SinkFileStatus](_))\n+  }\n+\n+  override def add(batchId: Long, logs: Seq[SinkFileStatus]): Boolean = {\n+    if (isCompactionBatch(batchId, compactInterval)) {\n+      compact(batchId, logs)\n+    } else {\n+      super.add(batchId, logs)\n+    }\n+  }\n+\n+  /**\n+   * Returns all files except the deleted ones.\n+   */\n+  def allFiles(): Array[SinkFileStatus] = {\n+    var latestId = getLatest().map(_._1).getOrElse(-1L)\n+    // There is a race condition when `FileStreamSink` is deleting old files and `StreamFileCatalog`\n+    // is calling this method. This loop will retry the reading to deal with the\n+    // race condition.\n+    while (true) {\n+      if (latestId >= 0) {\n+        val startId = getAllValidBatches(latestId, compactInterval)(0)\n+        try {\n+          val logs = get(Some(startId), Some(latestId)).flatMap(_._2)\n+          return compactLogs(logs).toArray\n+        } catch {\n+          case e: IOException =>\n+            // Another process using `FileStreamSink` may delete the batch files when\n+            // `StreamFileCatalog` are reading. However, it only happens when a compaction is\n+            // deleting old files. If so, let's try the next compaction batch and we should find it.\n+            // Otherwise, this is a real IO issue and we should throw it.\n+            latestId = nextCompactionBatchId(latestId, compactInterval)\n+            get(latestId).getOrElse {\n+              throw e",
    "line": 159
  }],
  "prId": 12435
}]