[{
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "I see this code is duplicated above. Maybe you can make it a function?",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:43:14Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "removed the other one. not needed. copied the docs to this location.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:21:19Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "specify which class docs",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:44:18Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:22:17Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "nit: remove empty line",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:44:56Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:22:36Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "where can the `joinCondition` be `None`?",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:48:37Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "When the join is like `select * from A, B where A.x = B.x`. The `A.x` and `B.x` becomes the join keys, and there is no other condition needed. ",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:23:53Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "why `-1`?",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:49:46Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "the generated the state watermark cleanup expression is inclusive of the state watermark. That is if state watermark is W, all state where timestamp <= W will be cleaned up. \r\nNow when the canonicalized join condition solves to leftTime >= W, then I dont want to clean up <= W. Rather I choose to cleanup <= W-1.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:27:32Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "added this as docs.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:36:56Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "if the above line is `-1`, then I would have assumed this should be `+1`",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:51:22Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "nit: `a @ Attribute`",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:52:54Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "ditto",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:54:57Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "nit: `Cast`",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:55:57Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "done. lol. \"cats\" would have been funnier.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:29:16Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "fancy stuff!",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:56:37Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "I don't think 31 is a standard anywhere. I would prefer if we just throw an AnalysisException here if we find months.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:58:17Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I think there is a problem with months. Overestimation (similar to what we do for watermark delay specific in months) is not correct in this case. It should not throw analysis exception though as this is fundamentally a best-effort extraction. ",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:32:04Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Updated to throw warning when month is present.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-20T00:41:28Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31"
  }],
  "prId": 19271
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "for timestamp, you can use `PreciseTimestamp` to get microsecond precision btw",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T20:59:19Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31\n+              val intervalMillis = calendarInterval.milliseconds +\n+                millisPerMonth * calendarInterval.months\n+              Literal(intervalMillis.toDouble)\n+            case DoubleType => Multiply(lit, Literal(1000.0))\n+            case _: NumericType | _: TimestampType =>\n+              Multiply(Cast(lit, DoubleType), Literal(1000.0))"
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "the current implementation actually doesn't allow joins at microsecond precision, which some use cases may require.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T21:00:07Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31\n+              val intervalMillis = calendarInterval.milliseconds +\n+                millisPerMonth * calendarInterval.months\n+              Literal(intervalMillis.toDouble)\n+            case DoubleType => Multiply(lit, Literal(1000.0))\n+            case _: NumericType | _: TimestampType =>\n+              Multiply(Cast(lit, DoubleType), Literal(1000.0))"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "if you are joining by equating timestamps, then it will work because its in the keys. the code path is used only when the time ranges are given, which is any way imprecise.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-19T22:34:29Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31\n+              val intervalMillis = calendarInterval.milliseconds +\n+                millisPerMonth * calendarInterval.months\n+              Literal(intervalMillis.toDouble)\n+            case DoubleType => Multiply(lit, Literal(1000.0))\n+            case _: NumericType | _: TimestampType =>\n+              Multiply(Cast(lit, DoubleType), Literal(1000.0))"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "updated the watermark extraction to calculate everything in microseconds.\r\nthough, event time is tracked at millisecond level, so i am not sure whether this helps much.",
    "commit": "d8116d0577bba516320c976debba9eb708fe2ce2",
    "createdAt": "2017-09-20T00:38:55Z",
    "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.streaming\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, Attribute, AttributeReference, BoundReference, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, NamedExpression, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.execution.streaming.WatermarkSupport.watermarkExpression\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for [[StreamingSymmetricHashJoinExec]].\n+ */\n+object StreamingSymmetricHashJoinExecHelper extends PredicateHelper with Logging {\n+\n+  sealed trait JoinSide\n+  case object LeftSide extends JoinSide { override def toString(): String = \"left\" }\n+  case object RightSide extends JoinSide { override def toString(): String = \"right\" }\n+\n+  sealed trait JoinStateWatermarkPredicate\n+  case class JoinStateKeyWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+  case class JoinStateValueWatermarkPredicate(expr: Expression) extends JoinStateWatermarkPredicate\n+\n+  case class JoinStateWatermarkPredicates(\n+    left: Option[JoinStateWatermarkPredicate] = None,\n+    right: Option[JoinStateWatermarkPredicate] = None)\n+\n+  def getStateWatermarkPredicates(\n+      leftAttributes: Seq[Attribute],\n+      rightAttributes: Seq[Attribute],\n+      leftKeys: Seq[Expression],\n+      rightKeys: Seq[Expression],\n+      condition: Option[Expression],\n+      eventTimeWatermark: Option[Long]): JoinStateWatermarkPredicates = {\n+    val joinKeyOrdinalForWatermark: Option[Int] = {\n+      leftKeys.zipWithIndex.collectFirst {\n+        case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+      } orElse {\n+        rightKeys.zipWithIndex.collectFirst {\n+          case (ne: NamedExpression, index) if ne.metadata.contains(delayKey) => index\n+        }\n+      }\n+    }\n+\n+    def getOneSideStateWatermarkPredicate(\n+        oneSideInputAttributes: Seq[Attribute],\n+        oneSideJoinKeys: Seq[Expression],\n+        otherSideInputAttributes: Seq[Attribute]): Option[JoinStateWatermarkPredicate] = {\n+      val isWatermarkDefinedOnInput = oneSideInputAttributes.exists(_.metadata.contains(delayKey))\n+      val isWatermarkDefinedOnJoinKey = joinKeyOrdinalForWatermark.isDefined\n+\n+      if (isWatermarkDefinedOnJoinKey) { // case 1 and 3 explained in the class docs\n+        val keyExprWithWatermark = BoundReference(\n+          joinKeyOrdinalForWatermark.get,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).dataType,\n+          oneSideJoinKeys(joinKeyOrdinalForWatermark.get).nullable)\n+        val expr = watermarkExpression(Some(keyExprWithWatermark), eventTimeWatermark)\n+        expr.map(JoinStateKeyWatermarkPredicate)\n+\n+      } else if (isWatermarkDefinedOnInput) { // case 2 explained in the class docs\n+        val stateValueWatermark = getStateValueWatermark(\n+          attributesToFindStateWatemarkFor = oneSideInputAttributes,\n+          attributesWithEventWatermark = otherSideInputAttributes,\n+          condition,\n+          eventTimeWatermark)\n+        val inputAttributeWithWatermark = oneSideInputAttributes.find(_.metadata.contains(delayKey))\n+        val expr = watermarkExpression(inputAttributeWithWatermark, stateValueWatermark)\n+        expr.map(JoinStateValueWatermarkPredicate)\n+\n+      } else {\n+        None\n+\n+      }\n+    }\n+\n+    val leftStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(leftAttributes, leftKeys, rightAttributes)\n+    val rightStateWatermarkPredicate =\n+      getOneSideStateWatermarkPredicate(rightAttributes, rightKeys, leftAttributes)\n+    JoinStateWatermarkPredicates(leftStateWatermarkPredicate, rightStateWatermarkPredicate)\n+  }\n+\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   *\n+   * @param attributesToFindStateWatemarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatemarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatemarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatemarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract constraint from conditions. For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatemarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: Seq[Attribute],\n+      attributesWithEventWatermark: Seq[Attribute],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a@AttributeReference(_, TimestampType, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+    // Find the term that has leftTime (i.e. the one present in attributesToFindConstraintFor\n+    val constraintTerms = terms.filter(containsAttributeToFindStateConstraintFor)\n+\n+    // Verify there is only one correct constraint term and of the correct type\n+    if (constraintTerms.size > 1) {\n+      logWarning(\"Failed to extract state constraint terms: multiple time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    if (constraintTerms.isEmpty) {\n+      logDebug(\"Failed to extract state constraint terms: no time terms in condition\\n\\t\" +\n+        terms.mkString(\"\\n\\t\"))\n+      return None\n+    }\n+    val constraintTerm = constraintTerms.head\n+    if (constraintTerm.collectFirst { case u: UnaryMinus => u }.isEmpty) {\n+      // Incorrect condition. We want the constraint term in canonical form to be `-leftTime`\n+      // so that resolve for it as `-leftTime + watermark + c < 0` ==> `watermark + c < leftTime`.\n+      // Now, if the original conditions is `rightTime-with-watermark > leftTime` and watermark\n+      // condition is `rightTime-with-watermark > watermarkValue`, then no constraint about\n+      // `leftTime` can be inferred. In this case, after canonicalization and collection of terms,\n+      // the constraintTerm would be `leftTime` and not `-leftTime`. Hence, we return None.\n+      return None\n+    }\n+\n+    // Replace watermark attribute with watermark value, and generate the resolved expression\n+    // from the other terms. That is,\n+    // rightTime-with-watermark, c1, -c2  =>  watermark, c1, -c2  =>  watermark + c1 + (-c2)\n+    logDebug(s\"Constraint term from join condition:\\t$constraintTerm\")\n+    val exprWithWatermarkSubstituted = (terms - constraintTerm).map { term =>\n+      term.transform {\n+        case a@AttributeReference(_, TimestampType, _, metadata)\n+          if attributesWithEventWatermark.contains(a) && a.metadata.contains(delayKey) =>\n+          Literal(eventWatermark.get)\n+      }\n+    }.reduceLeft(Add)\n+\n+    // Calculate the constraint value\n+    logInfo(s\"Final expression to evaluate constraint:\\t$exprWithWatermarkSubstituted\")\n+    val constraintValue = exprWithWatermarkSubstituted.eval().asInstanceOf[java.lang.Double]\n+    Some(Double2double(constraintValue).toLong)\n+  }\n+\n+  /**\n+   * Collect all the terms present in an expression after converting it into the form\n+   * a + b + c + d where each term be either an attribute or a literal casted to long,\n+   * optionally wrapped in a unary minus.\n+   */\n+  private def collectTerms(exprToCollectFrom: Expression): Seq[Expression] = {\n+    var invalid = false\n+\n+    /** Wrap a term with UnaryMinus if its needs to be negated. */\n+    def negateIfNeeded(expr: Expression, minus: Boolean): Expression = {\n+      if (minus) UnaryMinus(expr) else expr\n+    }\n+\n+    /**\n+     * Recursively split the expression into its leaf terms contains attributes or literals.\n+     * Returns terms only of the forms:\n+     *    Csat(AttributeReference), UnaryMinus(Cast(AttributeReference)),\n+     *    Cast(AttributeReference, Double), UnaryMinus(Cast(AttributeReference, Double))\n+     *    Multiply(Literal), UnaryMinus(Multiply(Literal))\n+     *    Multiply(Cast(Literal)), UnaryMinus(Multiple(Cast(Literal)))\n+     *\n+     * Note:\n+     * - If term needs to be negated for making it a commutative term,\n+     *   then it will be wrapped in UnaryMinus(...)\n+     * - Each terms will be representing timestamp value or time interval in milliseconds,\n+     *   typed as doubles.\n+     */\n+    def collect(expr: Expression, negate: Boolean): Seq[Expression] = {\n+      expr match {\n+        case Add(left, right) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case Subtract(left, right) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case TimeAdd(left, right, _) =>\n+          collect(left, negate) ++ collect(right, negate)\n+        case TimeSub(left, right, _) =>\n+          collect(left, negate) ++ collect(right, !negate)\n+        case UnaryMinus(child) =>\n+          collect(child, !negate)\n+        case CheckOverflow(child, _) =>\n+          collect(child, negate)\n+        case Cast(child, dataType, _) =>\n+          dataType match {\n+            case _: NumericType | _: TimestampType => collect(child, negate)\n+            case _ =>\n+              invalid = true\n+              Seq.empty\n+          }\n+        case a: AttributeReference =>\n+          val castedRef = if (a.dataType != DoubleType) Cast(a, DoubleType) else a\n+          Seq(negateIfNeeded(castedRef, negate))\n+        case lit: Literal =>\n+          // If literal of type calendar interval, then explicitly convert to millis\n+          // Convert other number like literal to doubles representing millis (by x1000)\n+          val castedLit = lit.dataType match {\n+            case CalendarIntervalType =>\n+              val calendarInterval = lit.value.asInstanceOf[CalendarInterval]\n+              val millisPerMonth = CalendarInterval.MICROS_PER_DAY / 1000 * 31\n+              val intervalMillis = calendarInterval.milliseconds +\n+                millisPerMonth * calendarInterval.months\n+              Literal(intervalMillis.toDouble)\n+            case DoubleType => Multiply(lit, Literal(1000.0))\n+            case _: NumericType | _: TimestampType =>\n+              Multiply(Cast(lit, DoubleType), Literal(1000.0))"
  }],
  "prId": 19271
}]