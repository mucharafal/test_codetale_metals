[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Column only has a few APIs what looks similar to DataFrame, I'd like to put these in Column, rather than make it inherit from DataFrame, it looks weird, such as Column.schema, Column.dtypes, Column.addColumn\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T07:21:48Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "It is not that unusual since a column is that a single column data frame. We will also add more methods over time, such as many of the RDD methods.\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T07:31:22Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Make Column similar to pandas.Series ? \n\n[1] http://pandas.pydata.org/pandas-docs/dev/generated/pandas.Series.html\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T07:44:09Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Does DataFrame have all the methods that RDD have? or need df.rdd.xxx ?\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T07:47:22Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "The goal is to add most of the rdd functions to DataFrame. \n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T07:58:39Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "It's easy to understand that Column is an RDD, each row is an object (not Row with single field). Also, we could add an implicit conversion for DataFrame (single column DataFrame).\n\nWhat's case that did not work if Column is not single column DataFrame?\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T08:04:29Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "For example, `df['A'].min()` should be `0` or `Row(A=0)`?\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T08:06:10Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "It's a tough call. The main use case is for some downstream library or application to consume them the same way.\n\nThat's why I was thinking everything should just return a Row. I am also considering creating a simple local structure that contains the schema information and rows. Then downstream applications can just inspect or accept a DataFrame and then apply any operation they want.\n\nOn the type side, again, we have the problem of runtime type vs compile time type. At compile, there is no type information for a column. If column is an RDD, then it has to be an RDD[Any], and all the closures will have to accept Any/Object.\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-24T08:15:20Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.analysis\n+import org.apache.spark.sql.catalyst.analysis.Star\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Literal {\n+  def apply(literal: Boolean): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Byte): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Short): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Int): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Long): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Float): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Double): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: String): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.math.BigDecimal): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Timestamp): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: java.sql.Date): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Array[Byte]): Column = new Column(LiteralExpr(literal))\n+  def apply(literal: Null): Column = new Column(LiteralExpr(null))\n+}\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi[Column] {"
  }],
  "prId": 4173
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "We might consider using `apply` instead or in addition to this.\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-27T21:46:55Z",
    "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, Star}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+/**\n+ * A column in a [[DataFrame]].\n+ *\n+ * `Column` instances can be created by:\n+ * {{{\n+ *   // 1. Select a column out of a DataFrame\n+ *   df(\"colName\")\n+ *\n+ *   // 2. Create a literal expression\n+ *   Literal(1)\n+ *\n+ *   // 3. Create new columns from\n+ * }}}\n+ *\n+ */\n+// TODO: Improve documentation.\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi {\n+\n+  /** Turn a Catalyst expression into a `Column`. */\n+  protected[sql] def this(expr: Expression) = this(None, None, expr)\n+\n+  /**\n+   * Create a new `Column` expression based on a column or attribute name.\n+   * The resolution of this is the same as SQL. For example:\n+   *\n+   * - \"colName\" becomes an expression selecting the column named \"colName\".\n+   * - \"*\" becomes an expression selecting all columns.\n+   * - \"df.*\" becomes an expression selecting all columns in data frame \"df\".\n+   */\n+  def this(name: String) = this(name match {\n+    case \"*\" => Star(None)\n+    case _ if name.endsWith(\".*\") => Star(Some(name.substring(0, name.length - 2)))\n+    case _ => UnresolvedAttribute(name)\n+  })\n+\n+  override def isComputable: Boolean = sqlContext.isDefined && plan.isDefined\n+\n+  /**\n+   * An implicit conversion function internal to this class. This function creates a new Column\n+   * based on an expression. If the expression itself is not named, it aliases the expression\n+   * by calling it \"col\".\n+   */\n+  private[this] implicit def toColumn(expr: Expression): Column = {\n+    val projectedPlan = plan.map { p =>\n+      Project(Seq(expr match {\n+        case named: NamedExpression => named\n+        case unnamed: Expression => Alias(unnamed, \"col\")()\n+      }), p)\n+    }\n+    new Column(sqlContext, projectedPlan, expr)\n+  }\n+\n+  /**\n+   * Unary minus, i.e. negate the expression.\n+   * {{{\n+   *   // Select the amount column and negates all values.\n+   *   df.select( -df(\"amount\") )\n+   * }}}\n+   */\n+  override def unary_- : Column = UnaryMinus(expr)\n+\n+  /**\n+   * Bitwise NOT.\n+   * {{{\n+   *   // Select the flags column and negate every bit.\n+   *   df.select( ~df(\"flags\") )\n+   * }}}\n+   */\n+  override def unary_~ : Column = BitwiseNot(expr)\n+\n+  /**\n+   * Invert a boolean expression, i.e. NOT.\n+   * {{\n+   *   // Select rows that are not active (isActive === false)\n+   *   df.select( !df(\"isActive\") )\n+   * }}\n+   */\n+  override def unary_! : Column = Not(expr)\n+\n+\n+  /**\n+   * Equality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA equals colB.\n+   *   df.select( df(\"colA\") === df(\"colB\") )\n+   *   df.select( df(\"colA\".equalTo(df(\"colB\")) )\n+   * }}}\n+   */\n+  override def === (other: Column): Column = EqualTo(expr, other.expr)\n+\n+  /**\n+   * Equality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA is \"Zaharia\".\n+   *   df.select( df(\"colA\") === \"Zaharia\")\n+   *   df.select( df(\"colA\".equalTo(\"Zaharia\") )\n+   * }}}\n+   */\n+  override def === (literal: Any): Column = this === Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Equality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA equals colB.\n+   *   df.select( df(\"colA\") === df(\"colB\") )\n+   *   df.select( df(\"colA\".equalTo(df(\"colB\")) )\n+   * }}}\n+   */\n+  override def equalTo(other: Column): Column = this === other\n+\n+  /**\n+   * Equality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA is \"Zaharia\".\n+   *   df.select( df(\"colA\") === \"Zaharia\")\n+   *   df.select( df(\"colA\".equalTo(\"Zaharia\") )\n+   * }}}\n+   */\n+  override def equalTo(literal: Any): Column = this === literal\n+\n+  /**\n+   * Inequality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA does not equal colB.\n+   *   df.select( df(\"colA\") !== df(\"colB\") )\n+   *   df.select( !(df(\"colA\") === df(\"colB\")) )\n+   * }}}\n+   */\n+  override def !== (other: Column): Column = Not(EqualTo(expr, other.expr))\n+\n+  /**\n+   * Inequality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA does not equal equal 15.\n+   *   df.select( df(\"colA\") !== 15 )\n+   *   df.select( !(df(\"colA\") === 15) )\n+   * }}}\n+   */\n+  override def !== (literal: Any): Column = this !== Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Greater than an expression.\n+   * {{{\n+   *   // The following selects people older than 21.\n+   *   people.select( people(\"age\") > Literal(21) )\n+   * }}}\n+   */\n+  override def > (other: Column): Column = GreaterThan(expr, other.expr)\n+\n+  /**\n+   * Greater than a literal value.\n+   * {{{\n+   *   // The following selects people older than 21.\n+   *   people.select( people(\"age\") > 21 )\n+   * }}}\n+   */\n+  override def > (literal: Any): Column = this > Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Less than an expression.\n+   * {{{\n+   *   // The following selects people younger than 21.\n+   *   people.select( people(\"age\") < Literal(21) )\n+   * }}}\n+   */\n+  override def < (other: Column): Column = LessThan(expr, other.expr)\n+\n+  /**\n+   * Less than a literal value.\n+   * {{{\n+   *   // The following selects people younger than 21.\n+   *   people.select( people(\"age\") < 21 )\n+   * }}}\n+   */\n+  override def < (literal: Any): Column = this < Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Less than or equal to an expression.\n+   * {{{\n+   *   // The following selects people age 21 or younger than 21.\n+   *   people.select( people(\"age\") <= Literal(21) )\n+   * }}}\n+   */\n+  override def <= (other: Column): Column = LessThanOrEqual(expr, other.expr)\n+\n+  /**\n+   * Less than or equal to a literal value.\n+   * {{{\n+   *   // The following selects people age 21 or younger than 21.\n+   *   people.select( people(\"age\") <= 21 )\n+   * }}}\n+   */\n+  override def <= (literal: Any): Column = this <= Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Greater than or equal to an expression.\n+   * {{{\n+   *   // The following selects people age 21 or older than 21.\n+   *   people.select( people(\"age\") >= Literal(21) )\n+   * }}}\n+   */\n+  override def >= (other: Column): Column = GreaterThanOrEqual(expr, other.expr)\n+\n+  /**\n+   * Greater than or equal to a literal value.\n+   * {{{\n+   *   // The following selects people age 21 or older than 21.\n+   *   people.select( people(\"age\") >= 21 )\n+   * }}}\n+   */\n+  override def >= (literal: Any): Column = this >= Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Equality test with an expression that is safe for null values.\n+   */\n+  override def <=> (other: Column): Column = EqualNullSafe(expr, other.expr)\n+\n+  /**\n+   * Equality test with a literal value that is safe for null values.\n+   */\n+  override def <=> (literal: Any): Column = this <=> Literal.anyToLiteral(literal)\n+\n+  /**\n+   * True if the current expression is null.\n+   */\n+  override def isNull: Column = IsNull(expr)\n+\n+  /**\n+   * True if the current expression is NOT null.\n+   */\n+  override def isNotNull: Column = IsNotNull(expr)\n+\n+  /**\n+   * Boolean OR with an expression.\n+   * {{{\n+   *   // The following selects people that are in school or employed.\n+   *   people.select( people(\"inSchool\") || people(\"isEmployed\") )\n+   * }}}\n+   */\n+  override def || (other: Column): Column = Or(expr, other.expr)\n+\n+  /**\n+   * Boolean OR with a literal value.\n+   * {{{\n+   *   // The following selects everything.\n+   *   people.select( people(\"inSchool\") || true )\n+   * }}}\n+   */\n+  override def || (literal: Boolean): Column = this || Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Boolean AND with an expression.\n+   * {{{\n+   *   // The following selects people that are in school and employed at the same time.\n+   *   people.select( people(\"inSchool\") && people(\"isEmployed\") )\n+   * }}}\n+   */\n+  override def && (other: Column): Column = And(expr, other.expr)\n+\n+  /**\n+   * Boolean AND with a literal value.\n+   * {{{\n+   *   // The following selects people that are in school.\n+   *   people.select( people(\"inSchool\") && true )\n+   * }}}\n+   */\n+  override def && (literal: Boolean): Column = this && Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise AND with an expression.\n+   */\n+  override def & (other: Column): Column = BitwiseAnd(expr, other.expr)\n+\n+  /**\n+   * Bitwise AND with a literal value.\n+   */\n+  override def & (literal: Any): Column = this & Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise OR with an expression.\n+   */\n+  override def | (other: Column): Column = BitwiseOr(expr, other.expr)\n+\n+  /**\n+   * Bitwise OR with a literal value.\n+   */\n+  override def | (literal: Any): Column = this | Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise XOR with an expression.\n+   */\n+  override def ^ (other: Column): Column = BitwiseXor(expr, other.expr)\n+\n+  /**\n+   * Bitwise XOR with a literal value.\n+   */\n+  override def ^ (literal: Any): Column = this ^ Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Sum of this expression and another expression.\n+   * {{{\n+   *   // The following selects the sum of a person's height and weight.\n+   *   people.select( people(\"height\") + people(\"weight\") )\n+   * }}}\n+   */\n+  override def + (other: Column): Column = Add(expr, other.expr)\n+\n+  /**\n+   * Sum of this expression and another expression.\n+   * {{{\n+   *   // The following selects the sum of a person's height and 10.\n+   *   people.select( people(\"height\") + 10 )\n+   * }}}\n+   */\n+  override def + (literal: Any): Column = this + Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Subtraction. Substract the other expression from this expression.\n+   * {{{\n+   *   // The following selects the difference between people's height and their weight.\n+   *   people.select( people(\"height\") - people(\"weight\") )\n+   * }}}\n+   */\n+  override def - (other: Column): Column = Subtract(expr, other.expr)\n+\n+  /**\n+   * Subtraction. Substract a literal value from this expression.\n+   * {{{\n+   *   // The following selects a person's height and substract it by 10.\n+   *   people.select( people(\"height\") - 10 )\n+   * }}}\n+   */\n+  override def - (literal: Any): Column = this - Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Multiply this expression and another expression.\n+   * {{{\n+   *   // The following multiplies a person's height by their weight.\n+   *   people.select( people(\"height\") * people(\"weight\") )\n+   * }}}\n+   */\n+  override def * (other: Column): Column = Multiply(expr, other.expr)\n+\n+  /**\n+   * Multiply this expression and a literal value.\n+   * {{{\n+   *   // The following multiplies a person's height by 10.\n+   *   people.select( people(\"height\") * 10 )\n+   * }}}\n+   */\n+  override def * (literal: Any): Column = this * Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Divide this expression by another expression.\n+   * {{{\n+   *   // The following divides a person's height by their weight.\n+   *   people.select( people(\"height\") / people(\"weight\") )\n+   * }}}\n+   */\n+  override def / (other: Column): Column = Divide(expr, other.expr)\n+\n+  /**\n+   * Divide this expression by a literal value.\n+   * {{{\n+   *   // The following divides a person's height by 10.\n+   *   people.select( people(\"height\") / 10 )\n+   * }}}\n+   */\n+  override def / (literal: Any): Column = this / Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Modulo (a.k.a. remainder) expression.\n+   */\n+  override def % (other: Column): Column = Remainder(expr, other.expr)\n+\n+  /**\n+   * Modulo (a.k.a. remainder) expression.\n+   */\n+  override def % (literal: Any): Column = this % Literal.anyToLiteral(literal)\n+\n+\n+  /**\n+   * A boolean expression that is evaluated to true if the value of this expression is contained\n+   * by the evaluated values of the arguments.\n+   */\n+  @scala.annotation.varargs\n+  override def in(list: Column*): Column = In(expr, list.map(_.expr))\n+\n+  override def like(other: Column): Column = Like(expr, other.expr)\n+\n+  override def like(literal: String): Column = this.like(Literal.anyToLiteral(literal))\n+\n+  override def rlike(other: Column): Column = RLike(expr, other.expr)\n+\n+  override def rlike(literal: String): Column = this.rlike(Literal.anyToLiteral(literal))\n+\n+\n+  override def getItem(ordinal: Int): Column = GetItem(expr, LiteralExpr(ordinal))\n+\n+  override def getItem(ordinal: Column): Column = GetItem(expr, ordinal.expr)\n+\n+  override def getField(fieldName: String): Column = GetField(expr, fieldName)",
    "line": 441
  }],
  "prId": 4173
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Is this only used for implicits?\n",
    "commit": "0a1a73bb0f5509e01315961c75e99bc1f96fd114",
    "createdAt": "2015-01-27T21:49:39Z",
    "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, Star}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.{Literal => LiteralExpr}\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LogicalPlan}\n+import org.apache.spark.sql.types._\n+\n+\n+object Column {\n+  def unapply(col: Column): Option[Expression] = Some(col.expr)\n+\n+  def apply(colName: String): Column = new Column(colName)\n+}\n+\n+\n+/**\n+ * A column in a [[DataFrame]].\n+ *\n+ * `Column` instances can be created by:\n+ * {{{\n+ *   // 1. Select a column out of a DataFrame\n+ *   df(\"colName\")\n+ *\n+ *   // 2. Create a literal expression\n+ *   Literal(1)\n+ *\n+ *   // 3. Create new columns from\n+ * }}}\n+ *\n+ */\n+// TODO: Improve documentation.\n+class Column(\n+    sqlContext: Option[SQLContext],\n+    plan: Option[LogicalPlan],\n+    val expr: Expression)\n+  extends DataFrame(sqlContext, plan) with ExpressionApi {\n+\n+  /** Turn a Catalyst expression into a `Column`. */\n+  protected[sql] def this(expr: Expression) = this(None, None, expr)\n+\n+  /**\n+   * Create a new `Column` expression based on a column or attribute name.\n+   * The resolution of this is the same as SQL. For example:\n+   *\n+   * - \"colName\" becomes an expression selecting the column named \"colName\".\n+   * - \"*\" becomes an expression selecting all columns.\n+   * - \"df.*\" becomes an expression selecting all columns in data frame \"df\".\n+   */\n+  def this(name: String) = this(name match {\n+    case \"*\" => Star(None)\n+    case _ if name.endsWith(\".*\") => Star(Some(name.substring(0, name.length - 2)))\n+    case _ => UnresolvedAttribute(name)\n+  })\n+\n+  override def isComputable: Boolean = sqlContext.isDefined && plan.isDefined\n+\n+  /**\n+   * An implicit conversion function internal to this class. This function creates a new Column\n+   * based on an expression. If the expression itself is not named, it aliases the expression\n+   * by calling it \"col\".\n+   */\n+  private[this] implicit def toColumn(expr: Expression): Column = {\n+    val projectedPlan = plan.map { p =>\n+      Project(Seq(expr match {\n+        case named: NamedExpression => named\n+        case unnamed: Expression => Alias(unnamed, \"col\")()\n+      }), p)\n+    }\n+    new Column(sqlContext, projectedPlan, expr)\n+  }\n+\n+  /**\n+   * Unary minus, i.e. negate the expression.\n+   * {{{\n+   *   // Select the amount column and negates all values.\n+   *   df.select( -df(\"amount\") )\n+   * }}}\n+   */\n+  override def unary_- : Column = UnaryMinus(expr)\n+\n+  /**\n+   * Bitwise NOT.\n+   * {{{\n+   *   // Select the flags column and negate every bit.\n+   *   df.select( ~df(\"flags\") )\n+   * }}}\n+   */\n+  override def unary_~ : Column = BitwiseNot(expr)\n+\n+  /**\n+   * Invert a boolean expression, i.e. NOT.\n+   * {{\n+   *   // Select rows that are not active (isActive === false)\n+   *   df.select( !df(\"isActive\") )\n+   * }}\n+   */\n+  override def unary_! : Column = Not(expr)\n+\n+\n+  /**\n+   * Equality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA equals colB.\n+   *   df.select( df(\"colA\") === df(\"colB\") )\n+   *   df.select( df(\"colA\".equalTo(df(\"colB\")) )\n+   * }}}\n+   */\n+  override def === (other: Column): Column = EqualTo(expr, other.expr)\n+\n+  /**\n+   * Equality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA is \"Zaharia\".\n+   *   df.select( df(\"colA\") === \"Zaharia\")\n+   *   df.select( df(\"colA\".equalTo(\"Zaharia\") )\n+   * }}}\n+   */\n+  override def === (literal: Any): Column = this === Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Equality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA equals colB.\n+   *   df.select( df(\"colA\") === df(\"colB\") )\n+   *   df.select( df(\"colA\".equalTo(df(\"colB\")) )\n+   * }}}\n+   */\n+  override def equalTo(other: Column): Column = this === other\n+\n+  /**\n+   * Equality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA is \"Zaharia\".\n+   *   df.select( df(\"colA\") === \"Zaharia\")\n+   *   df.select( df(\"colA\".equalTo(\"Zaharia\") )\n+   * }}}\n+   */\n+  override def equalTo(literal: Any): Column = this === literal\n+\n+  /**\n+   * Inequality test with an expression.\n+   * {{{\n+   *   // The following two both select rows in which colA does not equal colB.\n+   *   df.select( df(\"colA\") !== df(\"colB\") )\n+   *   df.select( !(df(\"colA\") === df(\"colB\")) )\n+   * }}}\n+   */\n+  override def !== (other: Column): Column = Not(EqualTo(expr, other.expr))\n+\n+  /**\n+   * Inequality test with a literal value.\n+   * {{{\n+   *   // The following two both select rows in which colA does not equal equal 15.\n+   *   df.select( df(\"colA\") !== 15 )\n+   *   df.select( !(df(\"colA\") === 15) )\n+   * }}}\n+   */\n+  override def !== (literal: Any): Column = this !== Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Greater than an expression.\n+   * {{{\n+   *   // The following selects people older than 21.\n+   *   people.select( people(\"age\") > Literal(21) )\n+   * }}}\n+   */\n+  override def > (other: Column): Column = GreaterThan(expr, other.expr)\n+\n+  /**\n+   * Greater than a literal value.\n+   * {{{\n+   *   // The following selects people older than 21.\n+   *   people.select( people(\"age\") > 21 )\n+   * }}}\n+   */\n+  override def > (literal: Any): Column = this > Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Less than an expression.\n+   * {{{\n+   *   // The following selects people younger than 21.\n+   *   people.select( people(\"age\") < Literal(21) )\n+   * }}}\n+   */\n+  override def < (other: Column): Column = LessThan(expr, other.expr)\n+\n+  /**\n+   * Less than a literal value.\n+   * {{{\n+   *   // The following selects people younger than 21.\n+   *   people.select( people(\"age\") < 21 )\n+   * }}}\n+   */\n+  override def < (literal: Any): Column = this < Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Less than or equal to an expression.\n+   * {{{\n+   *   // The following selects people age 21 or younger than 21.\n+   *   people.select( people(\"age\") <= Literal(21) )\n+   * }}}\n+   */\n+  override def <= (other: Column): Column = LessThanOrEqual(expr, other.expr)\n+\n+  /**\n+   * Less than or equal to a literal value.\n+   * {{{\n+   *   // The following selects people age 21 or younger than 21.\n+   *   people.select( people(\"age\") <= 21 )\n+   * }}}\n+   */\n+  override def <= (literal: Any): Column = this <= Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Greater than or equal to an expression.\n+   * {{{\n+   *   // The following selects people age 21 or older than 21.\n+   *   people.select( people(\"age\") >= Literal(21) )\n+   * }}}\n+   */\n+  override def >= (other: Column): Column = GreaterThanOrEqual(expr, other.expr)\n+\n+  /**\n+   * Greater than or equal to a literal value.\n+   * {{{\n+   *   // The following selects people age 21 or older than 21.\n+   *   people.select( people(\"age\") >= 21 )\n+   * }}}\n+   */\n+  override def >= (literal: Any): Column = this >= Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Equality test with an expression that is safe for null values.\n+   */\n+  override def <=> (other: Column): Column = EqualNullSafe(expr, other.expr)\n+\n+  /**\n+   * Equality test with a literal value that is safe for null values.\n+   */\n+  override def <=> (literal: Any): Column = this <=> Literal.anyToLiteral(literal)\n+\n+  /**\n+   * True if the current expression is null.\n+   */\n+  override def isNull: Column = IsNull(expr)\n+\n+  /**\n+   * True if the current expression is NOT null.\n+   */\n+  override def isNotNull: Column = IsNotNull(expr)\n+\n+  /**\n+   * Boolean OR with an expression.\n+   * {{{\n+   *   // The following selects people that are in school or employed.\n+   *   people.select( people(\"inSchool\") || people(\"isEmployed\") )\n+   * }}}\n+   */\n+  override def || (other: Column): Column = Or(expr, other.expr)\n+\n+  /**\n+   * Boolean OR with a literal value.\n+   * {{{\n+   *   // The following selects everything.\n+   *   people.select( people(\"inSchool\") || true )\n+   * }}}\n+   */\n+  override def || (literal: Boolean): Column = this || Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Boolean AND with an expression.\n+   * {{{\n+   *   // The following selects people that are in school and employed at the same time.\n+   *   people.select( people(\"inSchool\") && people(\"isEmployed\") )\n+   * }}}\n+   */\n+  override def && (other: Column): Column = And(expr, other.expr)\n+\n+  /**\n+   * Boolean AND with a literal value.\n+   * {{{\n+   *   // The following selects people that are in school.\n+   *   people.select( people(\"inSchool\") && true )\n+   * }}}\n+   */\n+  override def && (literal: Boolean): Column = this && Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise AND with an expression.\n+   */\n+  override def & (other: Column): Column = BitwiseAnd(expr, other.expr)\n+\n+  /**\n+   * Bitwise AND with a literal value.\n+   */\n+  override def & (literal: Any): Column = this & Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise OR with an expression.\n+   */\n+  override def | (other: Column): Column = BitwiseOr(expr, other.expr)\n+\n+  /**\n+   * Bitwise OR with a literal value.\n+   */\n+  override def | (literal: Any): Column = this | Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Bitwise XOR with an expression.\n+   */\n+  override def ^ (other: Column): Column = BitwiseXor(expr, other.expr)\n+\n+  /**\n+   * Bitwise XOR with a literal value.\n+   */\n+  override def ^ (literal: Any): Column = this ^ Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Sum of this expression and another expression.\n+   * {{{\n+   *   // The following selects the sum of a person's height and weight.\n+   *   people.select( people(\"height\") + people(\"weight\") )\n+   * }}}\n+   */\n+  override def + (other: Column): Column = Add(expr, other.expr)\n+\n+  /**\n+   * Sum of this expression and another expression.\n+   * {{{\n+   *   // The following selects the sum of a person's height and 10.\n+   *   people.select( people(\"height\") + 10 )\n+   * }}}\n+   */\n+  override def + (literal: Any): Column = this + Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Subtraction. Substract the other expression from this expression.\n+   * {{{\n+   *   // The following selects the difference between people's height and their weight.\n+   *   people.select( people(\"height\") - people(\"weight\") )\n+   * }}}\n+   */\n+  override def - (other: Column): Column = Subtract(expr, other.expr)\n+\n+  /**\n+   * Subtraction. Substract a literal value from this expression.\n+   * {{{\n+   *   // The following selects a person's height and substract it by 10.\n+   *   people.select( people(\"height\") - 10 )\n+   * }}}\n+   */\n+  override def - (literal: Any): Column = this - Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Multiply this expression and another expression.\n+   * {{{\n+   *   // The following multiplies a person's height by their weight.\n+   *   people.select( people(\"height\") * people(\"weight\") )\n+   * }}}\n+   */\n+  override def * (other: Column): Column = Multiply(expr, other.expr)\n+\n+  /**\n+   * Multiply this expression and a literal value.\n+   * {{{\n+   *   // The following multiplies a person's height by 10.\n+   *   people.select( people(\"height\") * 10 )\n+   * }}}\n+   */\n+  override def * (literal: Any): Column = this * Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Divide this expression by another expression.\n+   * {{{\n+   *   // The following divides a person's height by their weight.\n+   *   people.select( people(\"height\") / people(\"weight\") )\n+   * }}}\n+   */\n+  override def / (other: Column): Column = Divide(expr, other.expr)\n+\n+  /**\n+   * Divide this expression by a literal value.\n+   * {{{\n+   *   // The following divides a person's height by 10.\n+   *   people.select( people(\"height\") / 10 )\n+   * }}}\n+   */\n+  override def / (literal: Any): Column = this / Literal.anyToLiteral(literal)\n+\n+  /**\n+   * Modulo (a.k.a. remainder) expression.\n+   */\n+  override def % (other: Column): Column = Remainder(expr, other.expr)\n+\n+  /**\n+   * Modulo (a.k.a. remainder) expression.\n+   */\n+  override def % (literal: Any): Column = this % Literal.anyToLiteral(literal)\n+\n+\n+  /**\n+   * A boolean expression that is evaluated to true if the value of this expression is contained\n+   * by the evaluated values of the arguments.\n+   */\n+  @scala.annotation.varargs\n+  override def in(list: Column*): Column = In(expr, list.map(_.expr))\n+\n+  override def like(other: Column): Column = Like(expr, other.expr)\n+\n+  override def like(literal: String): Column = this.like(Literal.anyToLiteral(literal))\n+\n+  override def rlike(other: Column): Column = RLike(expr, other.expr)\n+\n+  override def rlike(literal: String): Column = this.rlike(Literal.anyToLiteral(literal))\n+\n+\n+  override def getItem(ordinal: Int): Column = GetItem(expr, LiteralExpr(ordinal))\n+\n+  override def getItem(ordinal: Column): Column = GetItem(expr, ordinal.expr)\n+\n+  override def getField(fieldName: String): Column = GetField(expr, fieldName)\n+\n+\n+  override def substr(startPos: Column, len: Column): Column =\n+    Substring(expr, startPos.expr, len.expr)\n+\n+  override def substr(startPos: Int, len: Int): Column =\n+    this.substr(Literal.anyToLiteral(startPos), Literal.anyToLiteral(len))\n+\n+  override def contains(other: Column): Column = Contains(expr, other.expr)\n+\n+  override def contains(literal: Any): Column = this.contains(Literal.anyToLiteral(literal))\n+\n+\n+  override def startsWith(other: Column): Column = StartsWith(expr, other.expr)\n+\n+  override def startsWith(literal: String): Column = this.startsWith(Literal.anyToLiteral(literal))\n+\n+  override def endsWith(other: Column): Column = EndsWith(expr, other.expr)\n+\n+  override def endsWith(literal: String): Column = this.endsWith(Literal.anyToLiteral(literal))\n+\n+  override def as(alias: String): Column = Alias(expr, alias)()\n+\n+  override def cast(to: DataType): Column = Cast(expr, to)\n+\n+  override def desc: Column = SortOrder(expr, Descending)\n+\n+  override def asc: Column = SortOrder(expr, Ascending)\n+}\n+\n+\n+class ColumnName(name: String) extends Column(name) {",
    "line": 473
  }],
  "prId": 4173
}]