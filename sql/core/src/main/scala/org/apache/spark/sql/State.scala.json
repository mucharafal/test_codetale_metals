[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "I think we want to say what state we are talking about.  Something like \"per-key state from previous invocations of the function in a StreamingQuery\"",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:40:20Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "`KeyState`?  State just feels very generic.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:40:43Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Agreed.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T23:12:26Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "A user defined type that can be stored for each key.  Must be encodable?",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:41:35Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "No `()`.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:41:49Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {\n+\n+  def exists: Boolean\n+\n+  def get(): S"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "No `()`.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:42:18Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {\n+\n+  def exists: Boolean\n+\n+  def get(): S\n+\n+  def update(newState: S): Unit\n+\n+  def remove(): Unit\n+\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None"
  }],
  "prId": 16758
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Scala doc for these, even though its pretty obvious.  In particular, I assume its safe to call update() get remove() more than once in the function?",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T21:43:03Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {\n+\n+  def exists: Boolean\n+\n+  def get(): S\n+\n+  def update(newState: S): Unit\n+\n+  def remove(): Unit"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Will do.",
    "commit": "f3d12311229a958fee5fb3cfcf4f6b33035fc87f",
    "createdAt": "2017-01-31T22:26:19Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.annotation.{Experimental, InterfaceStability}\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalState\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Wrapper class for interacting with state data in `mapGroupsWithState` and\n+ * `flatMapGroupsWithState` operations on\n+ * [[org.apache.spark.sql.KeyValueGroupedDataset KeyValueGroupedDataset]].\n+ *\n+ * @note Operations on state are not threadsafe.\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    def mappingFunction(key: String, value: Iterable[Int], state: State[Int]): Option[String] = {\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *        val existingState = state.get  // Get the existing state\n+ *        val shouldRemove = ...         // Decide whether to remove the state\n+ *        if (shouldRemove) {\n+ *          state.remove()     // Remove the state\n+ *        } else {\n+ *          val newState = ...\n+ *          state.update(newState)    // Set the new state\n+ *        }\n+ *      } else {\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *      }\n+ *      ... // return something\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example of using `State`:\n+ * {{{\n+ *    // A mapping function that maintains an integer state for string keys and returns a string.\n+ *    Function3<String, Iterable<Integer>, State<Integer>, String> mappingFunction =\n+ *       new Function3<String, Iterable<Integer>, State<Integer>, String>() {\n+ *\n+ *         @Override\n+ *         public String call(String key, Optional<Integer> value, State<Integer> state) {\n+ *           if (state.exists()) {\n+ *             int existingState = state.get(); // Get the existing state\n+ *             boolean shouldRemove = ...; // Decide whether to remove the state\n+ *             if (shouldRemove) {\n+ *               state.remove(); // Remove the state\n+ *             } else {\n+ *               int newState = ...;\n+ *               state.update(newState); // Set the new state\n+ *             }\n+ *           } else {\n+ *             int initialState = ...; // Set the initial state\n+ *             state.update(initialState);\n+ *           }\n+ *           ... // return something\n+ *         }\n+ *       };\n+ * }}}\n+ *\n+ * @tparam S Type of the state\n+ * @since 2.1.1\n+ */\n+@Experimental\n+@InterfaceStability.Evolving\n+trait State[S] extends LogicalState[S] {\n+\n+  def exists: Boolean\n+\n+  def get(): S\n+\n+  def update(newState: S): Unit\n+\n+  def remove(): Unit"
  }],
  "prId": 16758
}]