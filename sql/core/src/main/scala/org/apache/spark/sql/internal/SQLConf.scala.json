[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Maybe it's better to use `Utils.resolveURI` here? That resolves to `file:` by default like most of the rest of Spark, and the previous versions of this code. And handles absolute vs. relative paths too.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-07T16:35:01Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "`Utils.resolveURI` creates an `java.net.URI` from a String path, and returns the URI if it has schema. Apparently, it treats Windows paths as having a schema and breaks down with back slashes. `Utils.resolveURI` returns a different results comparing to hadoop `Path.toUri`:\n\n```\nscala> (new URI(\"/my\")).getScheme()\nres22: String = null\n\nscala> (new URI(\"c:/my\")).getScheme()\nres23: String = c\n\nscala> (new URI(\"c:\\\\my\")).getScheme()\njava.net.URISyntaxException: Illegal character\n```\n\nhadoop Path adds a slash to the path:\n\n```\nscala> new Path(\"c:/my\").toUri\nres25: java.net.URI = /c:/my\n```\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-07T18:41:25Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "@avulanov just so I'm testing the right things, what would a user set for the warehouse dir, on Windows, if they wanted to specify a local path? It would have to be like `file:///C:/...` right? That seems to be correctly resolved. That is, we can't expect \"C:/...\" or \"C:...\" to work, because we need this to be parsed as a URI or relative path -- is that right? If so then I suspect @vanzin is right, let me try that approach.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-08T14:01:15Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "There are two issues. Linux paths will work without adding `file://`, and Windows will not. That might lead to confusion. Also, I doubt that both Windows and Linux users typically add `file://` if they specify a local path. As a rule of thumb, if no schema is given, then by default it is a local path. The second issue is that `URI` requires percent encoded string, so it does not work with white spaces or special symbols in the path. As far as I understand, URI is for URIs and not for paths. If we want to use URI then we need to change the variable name to `warehouseURI` and add a proper documentation about this configuration parameter.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-08T18:08:05Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Agree, if the Utils method doesn't work well with Windows paths it should be avoided... I seem to remember at some point it used to handle those (using the `windowsDrive` method in Utils) but that seems to be gone.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-09T01:22:57Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I should say I'm assuming the input must be a URI, because we have to allow users to disambiguate by specifying a scheme. And if we do that, then Windows paths can't be allowed. Of course, Windows file URIs should work, like `file:///C:/...` So yes I am certainly assuming this must be a URI, not a path, because I think we have to? If so, sure, documenting it sounds good.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-09T11:49:08Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "URI standard might be too restrictive for something that a user has to manually specify as a string. According to [RFC 3986](https://tools.ietf.org/html/rfc3986#section-2.3), it allows only numbers, digits, dash, underscore, dot and tilde. Anything else is required to be [percent-encoded](https://tools.ietf.org/html/rfc3986#section-2.1). This means that we have to require user to always do percent-encoding of her path if we stick with URI. There are other paths in Spark that user can specify and they are not required to be encoded. This might add unnecessary confusion. I would suggest to keep it as a path, document that one can optionally add a schema if the path is not local, and try to handle different options within Spark.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-09T19:11:18Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Hm, yes I can see how that would be tricky, mostly because of spaces in a path.\nOK, how about this: if it parses as a URI with `java.net.URI`, parse it as a URI. If not, try to parse it as a URI with `java.io.File`. Does that present any problems I'm missing?\n\nI think we have to support URIs because they always have been (?), and that also enables non-file URIs, which is implicitly supported right now. Although I'm reluctant to expand the possibilities here I tend to be persuaded that it's worth trying here specially.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-10T08:32:21Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "You [mentioned](https://github.com/apache/spark/pull/13868#discussion_r82154809) that the original issue was as follows: _\"...the usages of the new makeQualifiedPath are a bit wrong in that they explicitly resolve the path against the Hadoop file system, which can be HDFS.\"_ Should we rather look into the code that does `makeQualifiedPath` on `warehousePath` given Hadoop FS configuration? The fix would be to have a special case with paths that do not have a schema. Actually, could you give a link to this code, I could not find it right away?\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-11T19:22:44Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "There I'm looking at, for example, https://github.com/avulanov/spark/blob/ea24b59fe83c37dbab27579141b5c63cccee138d/sql/core/src/test/scala/org/apache/spark/sql/execution/command/DDLSuite.scala#L141 in the test code.  In non-test code I think it's the same source you copied, in SessionCatalog, line 154. \n\nAlthough these code locations can also deal with a scheme vs no scheme, it seemed to be easier to deal with it upfront, where it's returned to the rest of the code from the conf object. I think it'll be the same code, same complexity either place.\n\nThe fact that `resolveURI` doesn't quite do what we want here suggests, I suppose, that lots of things in Spark aren't going to play well with a Windows path with spaces. See:\n\n```\nscala> resolveURI(\"file:///C:/My Programs/path\")\nres14: java.net.URI = file:/Users/srowen/file:/C:/My%20Programs/path\n\nscala> resolveURI(\"/C:/My Programs/path\")\nres15: java.net.URI = file:/C:/My%20Programs/path\n\nscala> resolveURI(\"C:/My Programs/path\")\nres16: java.net.URI = file:/Users/srowen/C:/My%20Programs/path\n\nscala> resolveURI(\"/My Programs/path\")\nres17: java.net.URI = file:/My%20Programs/path\n```\n\nThe second (possibly alternative absolute Windows path with space) and fourth examples (Linux path with space) happen to come out right. If we're willing to also accept here that it's just what's going to work and not work, then, at least there is a working syntax for all scenarios when using this method.\n\nI believe there's an argument for further changing resolveURI to work with more variants here, but I'd have to even figure out first what is supposed to work and not work!\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-11T20:14:12Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "`resolveURI` tries to use `new URI`, encounters a `URISyntaxException` due to the white space symbol and falls back to: `new File(path).getAbsoluteFile().toURI()`. The latter does not deal with schema. This is why the first example looks weird:\n\n```\nscala> resolveURI(\"file:///C:/My Programs/path\")\n(Spark)res28: java.net.URI = file:/c:/dis/dev/spark-2.0.0-preview-bin-hadoop2.7/bin/fil\ne:/C:/My%20Programs/path\n(Scala) res1: java.net.URI = file:/C:/Users/ulanov/file:/C:/My%20Programs/path\n-----no space----\nscala> resolveURI(\"file:///C:/MyPrograms/path\")\n(Spark)java.net.URI = file:///C:/MyPrograms/path\n(Scala) java.net.URI = file:///C:/MyPrograms/path\n```\n\nSecond example is OK.\nThird example works fine with white space on Windows (adds home on Linux) but breaks without it:\n\n```\nscala> resolveURI(\"C:/My Programs/path\")\nres41: java.net.URI = file:/C:/My%20Programs/path\n----no space---\nscala> resolveURI(\"C:/MyPrograms/path\")\nres42: java.net.URI = C:/MyPrograms/path\n```\n\nFourth works fine both with both. There is one more subtle thing, the letter drive becomes lower case in Spark.\n\n```\nscala>  resolveURI(\"/My Programs/path\")\n(Spark)res31: java.net.URI = file:/c:/My%20Programs/path\n(Scala) res4: java.net.URI = file:/C:/My%20Programs/path\n```\n\nA character in the string should not be a reason to execute a particular branch of code. We should rather check the schema and work from this.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-12T20:20:41Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Yeah I agree that's why this behaves this way, and it's how similar paths/URIs would be treated in a lot of places in Spark. Therefore I'm wondering if that's the right thing to do, locally, to accept the same behavior and quirks in parsing this path (and then consider changing that globally later if needed). If I'm right then there is at least a syntax available for hdfs: and file: URIs, and one that works for Linux and Windows, including paths with spaces. Not all possible strings work as expected, maybe, but the more common ones seem to.\n\nThe net change at this point is just to use `Utils.resolveURI` to resolve this thing like other places in Spark, and then default to \"spark-warehouse\" which will now go back to defaulting to a local working dir path as intended. The rest is just test/doc/example updates.\n\nWhat's your opinion on this current state, compared to the problem being solved here?\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-13T10:09:31Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "`resolveURI` function does not process correctly some of the inputs (even some Linux paths). It contains a bug and should be fixed. The name itself is a bit misleading, because it processes `String` rather than `URI`, and is capable of resolving Paths. I propose to rename it to `resolvePath`, and rewrite it according to its documentation (below). Then we can use it to fix the initial issue. Does it sound reasonable to you?\n\n```\n  /**\n   * Return a well-formed URI for the file described by a user input string.\n   *\n   * If the supplied path does not contain a scheme, or is a relative path, it will be\n   * converted into an absolute path with a file:// scheme.\n   */\n```\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-14T01:39:15Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Do you mean just updating the documentation or changing the behavior? Updating the docs are fine. Updating the behavior (and name I guess) would affect a bunch of other places in the code, and that seems like a bigger issue to tackle separately.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-14T12:18:37Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "I mean fixing the behavior because it is incorrect. We cannot use this function in its present state, it will introduce more issues. This seems to be a part of a bigger issue that paths in Spark are processed in many different ways that are not consistent. Here few examples: https://github.com/apache/spark/pull/12695#issuecomment-237824442, https://github.com/apache/spark/pull/13868#issuecomment-228932793\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-14T18:38:20Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Can we split the difference here and treat those two as different issues?\n- for this bug, let's hardcode `.transform(new File(_).toURI().toString())` into the config constant definition; that's on par with the previous version of this code modified in 11a6844beb, which hardcoded the `file:` scheme into the default value.\n- separately, if it's a real issue, let's make changes to make this support non-local directories.\n\nThat way we fix the immediate issue and can have more discussions about how to properly solve the other and maybe even fix `resolveURI`.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-14T19:23:09Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I could do that. I could make a different PR with a subset/variant of this PR that would assume the path must be local and then rebase this one on top.\n\nThe thing is, I'm not clear it was ever actually meant to only be a local path, even though its default is a local path. It was always parsed as a Hadoop Path. Right now in the 2.0.1 release it's definitely going to support non-local paths. And this is supposed to be some analog of the Hive warehouse path, right? which can be on HDFS.\n\nTherefore I kind of convinced myself that forcing this to a local file isn't going to be a valid intermediate state, and so we shouldn't stop there. Then we're just back to the change here.\n\nHow strongly do you feel about it, or rather, what's the problem with just allowing it to be non-local as is implemented here?\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-15T10:33:44Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I see. I just feel we're getting stuck in this \"how to fix resolveURI\" argument instead of focusing on fixing this bug. If resolveURI is broken then don't use it. Simple. If you care, file a separate bug to fix it.\n\nInstead, how about making `WAREHOUSE_PATH` an optional config and changing `warehousePath` to this:\n\n```\ngetConf(WAREHOUSE_PATH).getOrElse(new File(\"spark-warehouse\").toURI().toString())\n```\n\nMaybe with an extra check to make sure the resulting path is absolute. Then whoever wants to override the default value is required to provide a valid, complete URI.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-17T17:39:26Z",
    "diffHunk": "@@ -757,7 +758,10 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = {\n+    val path = new Path(getConf(WAREHOUSE_PATH))\n+    FileSystem.get(path.toUri, new Configuration()).makeQualified(path).toString"
  }],
  "prId": 15382
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "So, I know I suggested this, but looking at it now, it seems wrong.\n\nBefore, if a user explicitly set this value in the configuration to `\"/user/blah/warehouse\"`, that would be interpreted as an HDFS path (or rather a path under `fs.defaultFS`). With this change it would be a local path. Right? So `Utils.resolveURI` should really only apply to the default value.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T00:39:31Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Well, before SPARK-15899 it was always interpreted as a local file path. After that change (i.e. right now) it would be interpreted as an HDFS path if that's what `fs.defaultFS` says. My proposition is that:\n- It should default to `spark-warehouse` in the local filesystem working dir, because that's what the docs say (therefore, we have a bug at the moment after SPARK-15899)\n- It should be interpreted as a local path if no scheme is given, because other stuff in Spark works that way via `Utils.resolveURI`\n- It should be possible to set this to a non-local path, because you can do this with the Hive warehouse dir, which this option sort of parallels\n\nI think the current change matches those requirements. I think we do not want \"/user/blah/warehouse\" to be interpreted as an HDFS path by default because that's not how it worked historically, and that it works this way now is I believe an error.\n\nIs that convincing?\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T10:22:49Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "> interpreted as an HDFS path by default because that's not how it worked historically\n\nExcept that is how it's worked historically for this piece of code at least. Taking a small detour, the reason I really dislike the use of `resolveURI` everywhere (and I commented on this when that code was added) is that it makes it awkward to use HDFS. Instead of relying on `fs.defaultFS` now you have to know the HDFS scheme (which can be \"hdfs\", \"maprfs\", \"s3\", \"webhdfs\", \"viewfs\", or others depending on your particular configuration) or things will break in mysterious ways.\n\nAnyway, I don't really care that much for this particular setting, so if you think changing the behavior is better, it's fine with me.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T16:39:38Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "You are right, the difference was that the _default_ before was always a local path. Right now ends up defaulting to an HDFS path (when using with HDFS for example). But explicitly setting \"/foo/bar\" has been interpreted as a HDFS path in the past and that would change. Hm, OK I see your point about only applying this to the default value.\n\nLooking at `hive.metastore.warehouse.dir`, that seems to accept a path without scheme and that's supposed to be read as an HDFS path, I suppose.\n\nThe catch remains Windows paths. It should always be possible to write these as URIs, but, then becomes mandatory to write them as a URI, if I make this new change. That's a downside. That's only if you need to specify a local, non-default path on Windows, which might be a fairly corner case.\n\nI can make the change to have it available for consideration here which I assume @vanzin  would favor, and I can see the logic of. How about @avulanov ? I know this has dragged on but I want to get it right. It's complex.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T16:51:09Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }, {
    "author": {
      "login": "koertkuipers"
    },
    "body": "i agree with @vanzin about dislike for resolveURI. i expect paths without schemes to on my default filesystem.\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T18:35:07Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }, {
    "author": {
      "login": "mridulm"
    },
    "body": "@srowen Just for clarity, what is the proposed change in behavior expected (other than default being under cwd instead of $HOME) ? Thx\n",
    "commit": "69c538333ba02fc806fe7e8f794f269936ebdc28",
    "createdAt": "2016-10-18T19:09:25Z",
    "diffHunk": "@@ -741,7 +741,7 @@ private[sql] class SQLConf extends Serializable with CatalystConf with Logging {\n \n   def variableSubstituteDepth: Int = getConf(VARIABLE_SUBSTITUTE_DEPTH)\n \n-  def warehousePath: String = new Path(getConf(WAREHOUSE_PATH)).toString\n+  def warehousePath: String = Utils.resolveURI(getConf(WAREHOUSE_PATH)).toString"
  }],
  "prId": 15382
}]