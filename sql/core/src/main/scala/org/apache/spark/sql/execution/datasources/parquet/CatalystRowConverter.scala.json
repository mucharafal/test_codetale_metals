[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "For decimals whose precision is greater than 18, we still need to copy the byte array anyway to construct Java `BigInteger` instances.\n",
    "commit": "851f91fdcd9a82ef314d4436b768933f8c54875c",
    "createdAt": "2015-09-24T20:48:11Z",
    "diffHunk": "@@ -332,24 +338,30 @@ private[parquet] class CatalystRowConverter(\n     private def toDecimal(value: Binary): Decimal = {\n       val precision = decimalType.precision\n       val scale = decimalType.scale\n-      val bytes = value.getBytes\n \n       if (precision <= CatalystSchemaConverter.MAX_PRECISION_FOR_INT64) {\n-        // Constructs a `Decimal` with an unscaled `Long` value if possible.\n+        // Constructs a `Decimal` with an unscaled `Long` value if possible.  The underlying\n+        // `ByteBuffer` implementation is guaranteed to be `HeapByteBuffer`, so here we are using\n+        // `Binary.toByteBuffer.array()` to steal the underlying byte array without copying it.\n+        val buffer = value.toByteBuffer\n+        val bytes = buffer.array()\n+        val start = buffer.position()\n+        val end = buffer.limit()\n+\n         var unscaled = 0L\n-        var i = 0\n+        var i = start\n \n-        while (i < bytes.length) {\n+        while (i < end) {\n           unscaled = (unscaled << 8) | (bytes(i) & 0xff)\n           i += 1\n         }\n \n-        val bits = 8 * bytes.length\n+        val bits = 8 * (end - start)\n         unscaled = (unscaled << (64 - bits)) >> (64 - bits)\n         Decimal(unscaled, precision, scale)\n       } else {\n         // Otherwise, resorts to an unscaled `BigInteger` instead.\n-        Decimal(new BigDecimal(new BigInteger(bytes), scale), precision, scale)\n+        Decimal(new BigDecimal(new BigInteger(value.getBytes), scale), precision, scale)",
    "line": 48
  }],
  "prId": 8907
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this still allocates the byte buffer object, doesn't it?\n",
    "commit": "851f91fdcd9a82ef314d4436b768933f8c54875c",
    "createdAt": "2015-09-24T20:54:28Z",
    "diffHunk": "@@ -302,7 +302,13 @@ private[parquet] class CatalystRowConverter(\n     }\n \n     override def addBinary(value: Binary): Unit = {\n-      updater.set(UTF8String.fromBytes(value.getBytes))\n+      // The underlying `ByteBuffer` implementation is guaranteed to be `HeapByteBuffer`, so here we\n+      // are using `Binary.toByteBuffer.array()` to steal the underlying byte array without copying\n+      // it.\n+      val buffer = value.toByteBuffer",
    "line": 8
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Yeah, it allocates a wrapping ByteBuffer. I haven't tried your way yet (using fake `DataOutput` and `Binary.writeTo()` to steal the underlying array). Will give it a shot.\n",
    "commit": "851f91fdcd9a82ef314d4436b768933f8c54875c",
    "createdAt": "2015-09-24T20:59:03Z",
    "diffHunk": "@@ -302,7 +302,13 @@ private[parquet] class CatalystRowConverter(\n     }\n \n     override def addBinary(value: Binary): Unit = {\n-      updater.set(UTF8String.fromBytes(value.getBytes))\n+      // The underlying `ByteBuffer` implementation is guaranteed to be `HeapByteBuffer`, so here we\n+      // are using `Binary.toByteBuffer.array()` to steal the underlying byte array without copying\n+      // it.\n+      val buffer = value.toByteBuffer",
    "line": 8
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "I didn't mean to try mine - I think the best way is to change Parquet to give us exactly what we want (and we can include a fork version of it in Spark until all the changes we want make it back to Parquet).\n",
    "commit": "851f91fdcd9a82ef314d4436b768933f8c54875c",
    "createdAt": "2015-09-24T21:05:11Z",
    "diffHunk": "@@ -302,7 +302,13 @@ private[parquet] class CatalystRowConverter(\n     }\n \n     override def addBinary(value: Binary): Unit = {\n-      updater.set(UTF8String.fromBytes(value.getBytes))\n+      // The underlying `ByteBuffer` implementation is guaranteed to be `HeapByteBuffer`, so here we\n+      // are using `Binary.toByteBuffer.array()` to steal the underlying byte array without copying\n+      // it.\n+      val buffer = value.toByteBuffer",
    "line": 8
  }],
  "prId": 8907
}]