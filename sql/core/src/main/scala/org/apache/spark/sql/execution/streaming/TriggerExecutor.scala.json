[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Nit: comment style is off, we use [javadoc style](https://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide#SparkCodeStyleGuide-Codedocumentationstyle)\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-02T17:29:39Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs"
  }],
  "prId": 12797
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "This comment took me a while to understand,  what do you think about this?\n\n```\n/**\n * Returns the start time in milliseconds for the next batch interval, given the current time.\n * Note that a batch interval is inclusive with respect to its start time, and thus calling\n * `nextBatchTime` with the result of a previous call should return the next interval. (i.e. given \n * an interval of `100 ms`, `nextBatchTime(nextBatchTime(0)) = 200` rather than `0`).\n */\n```\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-02T17:44:37Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs\n+   *\n+   * e.g. for intervalMs = 100\n+   * nextBatchTime(0) = 100\n+   * nextBatchTime(1) = 100\n+   * ...\n+   * nextBatchTime(99) = 100\n+   * nextBatchTime(100) = 200\n+   * nextBatchTime(101) = 200\n+   * ...\n+   * nextBatchTime(199) = 200\n+   * nextBatchTime(200) = 300\n+   *\n+   * Note, this way, we'll get nextBatchTime(nextBatchTime(0)) = 200, rather than = 0"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "Let me update it with your much clearer verson! Thanks!\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-03T04:35:09Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs\n+   *\n+   * e.g. for intervalMs = 100\n+   * nextBatchTime(0) = 100\n+   * nextBatchTime(1) = 100\n+   * ...\n+   * nextBatchTime(99) = 100\n+   * nextBatchTime(100) = 200\n+   * nextBatchTime(101) = 200\n+   * ...\n+   * nextBatchTime(199) = 200\n+   * nextBatchTime(200) = 300\n+   *\n+   * Note, this way, we'll get nextBatchTime(nextBatchTime(0)) = 200, rather than = 0"
  }],
  "prId": 12797
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "When I wrote this method, I was trying to deal with one case: If a batch takes exactly `intervalMs`, we should run the next batch at once instead of sleeping `intervalMs`. This change will break it.\n\nHowever, I forgot to handle the case that a batch takes 0ms. How about changing [this line](https://github.com/apache/spark/blob/0513c3ac93e0a25d6eedbafe6c0561e71c92880a/sql/core/src/main/scala/org/apache/spark/sql/execution/streaming/TriggerExecutor.scala#L53) to:\n\n``` Scala\n        if (batchElapsedTimeMs == 0) {\n          clock.waitTillTime(intervalMs)\n        } else {\n          clock.waitTillTime(nextBatchTime(batchEndTimeMs))\n        }\n```\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-02T17:49:40Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs\n+   *\n+   * e.g. for intervalMs = 100\n+   * nextBatchTime(0) = 100\n+   * nextBatchTime(1) = 100\n+   * ...\n+   * nextBatchTime(99) = 100\n+   * nextBatchTime(100) = 200\n+   * nextBatchTime(101) = 200\n+   * ...\n+   * nextBatchTime(199) = 200\n+   * nextBatchTime(200) = 300\n+   *\n+   * Note, this way, we'll get nextBatchTime(nextBatchTime(0)) = 200, rather than = 0\n+   * */\n   def nextBatchTime(now: Long): Long = {\n-    (now - 1) / intervalMs * intervalMs + intervalMs\n+    now / intervalMs * intervalMs + intervalMs"
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "@zsxwing thanks for clarifying on this! :-)\n\n[1]\nThe issue is triggered when both `batchElapsedTimeMs == 0` and `batchEndTimeMs` is multiple of `intervalMS` hold, e.g. `batchStartTimeMs == 50` and `batchEndTimeMS == 50` given `intervalMS == 100` won't trigger the issue. So, we might have to do like this:\n\n``` scala\nif (batchElapsedTimeMs == 0 && batchEndTimeMs % intervalMS == 0) {\n  clock.waitTillTime(batchEndTimeMs + intervalMs)\n} else {\n  clock.waitTillTime(nextBatchTime(batchEndTimeMs))\n}\n```\n\nFor me It seems a little hard to interpret...\n\n[2]\n\n> ... deal with one case: If a batch takes exactly intervalMs, we should run the next batch at once instead of sleeping intervalMs\n\nThis is a good point! I've done some calculations based on your comments, and it seems we would still run the next batch at once when the last job takes exactly `intervalMs`?\n\nprior to this path:\n\n```\nbatch      | job\n---------------------------------------------------------\n[  0,  99] |\n[100, 199] | job x starts at 100, stops at 199, takes 100\n[200, 299] |\n```\n\nafter this patch, it's still the same:\n\n```\nbatch      | job\n---------------------------------------------------------\n[  0,  99] |\n[100, 199] | job y starts at 100, stops at 199, takes 100\n[200, 299] |\n```\n\n## \n\n@zsxwing given the above [1] and [2], maybe we should simply change `now - 1` to `now`?\nAny thoughts please? Thanks! :-)\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-03T04:26:40Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs\n+   *\n+   * e.g. for intervalMs = 100\n+   * nextBatchTime(0) = 100\n+   * nextBatchTime(1) = 100\n+   * ...\n+   * nextBatchTime(99) = 100\n+   * nextBatchTime(100) = 200\n+   * nextBatchTime(101) = 200\n+   * ...\n+   * nextBatchTime(199) = 200\n+   * nextBatchTime(200) = 300\n+   *\n+   * Note, this way, we'll get nextBatchTime(nextBatchTime(0)) = 200, rather than = 0\n+   * */\n   def nextBatchTime(now: Long): Long = {\n-    (now - 1) / intervalMs * intervalMs + intervalMs\n+    now / intervalMs * intervalMs + intervalMs"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "I see. I think your approach is better. Thanks for your clarifying.\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-03T18:12:02Z",
    "diffHunk": "@@ -65,8 +65,22 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /** Return the next multiple of intervalMs\n+   *\n+   * e.g. for intervalMs = 100\n+   * nextBatchTime(0) = 100\n+   * nextBatchTime(1) = 100\n+   * ...\n+   * nextBatchTime(99) = 100\n+   * nextBatchTime(100) = 200\n+   * nextBatchTime(101) = 200\n+   * ...\n+   * nextBatchTime(199) = 200\n+   * nextBatchTime(200) = 300\n+   *\n+   * Note, this way, we'll get nextBatchTime(nextBatchTime(0)) = 200, rather than = 0\n+   * */\n   def nextBatchTime(now: Long): Long = {\n-    (now - 1) / intervalMs * intervalMs + intervalMs\n+    now / intervalMs * intervalMs + intervalMs"
  }],
  "prId": 12797
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: `nextBatchTime(nextBatchTime(0)) = 200` -> `nextBatchTime(nextBatchTime(0)) = 100`\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-04T00:04:20Z",
    "diffHunk": "@@ -65,8 +65,13 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /**\n+   * Returns the start time in milliseconds for the next batch interval, given the current time.\n+   * Note that a batch interval is inclusive with respect to its start time, and thus calling\n+   * `nextBatchTime` with the result of a previous call should return the next interval. (i.e. given\n+   * an interval of `100 ms`, `nextBatchTime(nextBatchTime(0)) = 200` rather than `0`).",
    "line": 9
  }, {
    "author": {
      "login": "lw-lin"
    },
    "body": "`nextBatchTime(0) = 100`, so `nextBatchTime(nextBatchTime(0)) = 200`?\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-04T00:07:31Z",
    "diffHunk": "@@ -65,8 +65,13 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /**\n+   * Returns the start time in milliseconds for the next batch interval, given the current time.\n+   * Note that a batch interval is inclusive with respect to its start time, and thus calling\n+   * `nextBatchTime` with the result of a previous call should return the next interval. (i.e. given\n+   * an interval of `100 ms`, `nextBatchTime(nextBatchTime(0)) = 200` rather than `0`).",
    "line": 9
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Oh, right. Sorry for the mistake.\n",
    "commit": "bc899628fa67acfbe6bb3d8e2c0ba2aefc2422a6",
    "createdAt": "2016-05-04T00:12:02Z",
    "diffHunk": "@@ -65,8 +65,13 @@ case class ProcessingTimeExecutor(processingTime: ProcessingTime, clock: Clock =\n       s\"${intervalMs} milliseconds, but spent ${realElapsedTimeMs} milliseconds\")\n   }\n \n-  /** Return the next multiple of intervalMs */\n+  /**\n+   * Returns the start time in milliseconds for the next batch interval, given the current time.\n+   * Note that a batch interval is inclusive with respect to its start time, and thus calling\n+   * `nextBatchTime` with the result of a previous call should return the next interval. (i.e. given\n+   * an interval of `100 ms`, `nextBatchTime(nextBatchTime(0)) = 200` rather than `0`).",
    "line": 9
  }],
  "prId": 12797
}]