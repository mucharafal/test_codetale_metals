[{
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "Also i think this is not right, `between` can not indicate the frame type is `RangeFrame`\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-16T10:02:56Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   df.select(\n+ *     avg(\"value\")\n+ *       .over\n+ *       .partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .row\n+ *       .following(1)\n+ *       .toColumn.as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over\n+ *       .partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .between\n+ *       .preceding(4)\n+ *       .following(3)\n+ *       .toColumn.as(\"max_value\"))\n+ * }}}\n+ *\n+ *\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame) {\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over.partitionBy(\"k1\", \"k2\", ...)\n+   *   df.over.partitionBy($\"K1\", $\"k2\", ...)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over.partitionBy($\"col1\", $\"col2\")\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over.partitionBy(\"k1\").orderBy(\"k2\", \"k3\")\n+   *   df.over.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\")\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    orderBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition. For example\n+   * {{{\n+   *   df.over.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\")\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def orderBy(cols: Column*): WindowFunctionDefinition = {\n+    val sortOrder: Seq[SortOrder] = cols.map { col =>\n+      col.expr match {\n+        case expr: SortOrder =>\n+          expr\n+        case expr: Expression =>\n+          SortOrder(expr, Ascending)\n+      }\n+    }\n+    new WindowFunctionDefinition(column, partitionSpec, sortOrder, frame)\n+  }\n+\n+  /**\n+   * Returns a new ranged [[WindowFunctionDefinition]]. For example:\n+   * {{{\n+   *   df.over.partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").between\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def between: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec,\n+      SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, UnboundedFollowing))"
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "n >= 0\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T01:39:48Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame,\n+    bindLower: Boolean = true) {\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame, bindLower)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\", \"k3\"))\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    orderBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition. For example\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def orderBy(cols: Column*): WindowFunctionDefinition = {\n+    val sortOrder: Seq[SortOrder] = cols.map { col =>\n+      col.expr match {\n+        case expr: SortOrder =>\n+          expr\n+        case expr: Expression =>\n+          SortOrder(expr, Ascending)\n+      }\n+    }\n+    new WindowFunctionDefinition(column, partitionSpec, sortOrder, frame)\n+  }\n+\n+  /**\n+   * Returns the current [[WindowFunctionDefinition]]. This is a dummy function,\n+   * which makes the usage more like the SQL.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(1).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def between: WindowFunctionDefinition = {\n+    assert(this.frame.isInstanceOf[SpecifiedWindowFrame], \"Should be a WindowFrame.\")\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec, frame, true)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] indicate that we need to specify the\n+   * upper bound.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(3).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def and: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec, frame, false)\n+  }\n+\n+  /**\n+   * Returns a new Ranged [[WindowFunctionDefinition]].\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(3).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def range: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec,\n+      SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, UnboundedFollowing))\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]], with fixed number of records.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").rows)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def rows: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec,\n+      SpecifiedWindowFrame(RowFrame, UnboundedPreceding, UnboundedFollowing))\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]], with position specified preceding of CURRENT_ROW.\n+   * It can be either Lower or Upper Bound position depends on the semantic context.\n+   * For example:\n+   * {{{\n+   *   // [CURRENT_ROW - 1, ~)\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.preceding(1))\n+   *   // [CURRENT_ROW - 3, CURRENT_ROW - 1]\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.between.preceding(3).and.preceding(1))\n+   *   // (~, CURRENT_ROW - 1]\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.between.unboundedPreceding.and.preceding(1))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def preceding(n: Int): WindowFunctionDefinition = {\n+    assert(n > 0)"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Just confirm, Hive will take `0 preceding` as `CURRENT_ROW`, I will follow the same pattern\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T02:20:41Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame,\n+    bindLower: Boolean = true) {\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame, bindLower)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\", \"k3\"))\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def orderBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    orderBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] sorted by the specified column within\n+   * the partition. For example\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def orderBy(cols: Column*): WindowFunctionDefinition = {\n+    val sortOrder: Seq[SortOrder] = cols.map { col =>\n+      col.expr match {\n+        case expr: SortOrder =>\n+          expr\n+        case expr: Expression =>\n+          SortOrder(expr, Ascending)\n+      }\n+    }\n+    new WindowFunctionDefinition(column, partitionSpec, sortOrder, frame)\n+  }\n+\n+  /**\n+   * Returns the current [[WindowFunctionDefinition]]. This is a dummy function,\n+   * which makes the usage more like the SQL.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(1).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def between: WindowFunctionDefinition = {\n+    assert(this.frame.isInstanceOf[SpecifiedWindowFrame], \"Should be a WindowFrame.\")\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec, frame, true)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] indicate that we need to specify the\n+   * upper bound.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(3).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def and: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec, frame, false)\n+  }\n+\n+  /**\n+   * Returns a new Ranged [[WindowFunctionDefinition]].\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").range.between.preceding(3).and.currentRow)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def range: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec,\n+      SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, UnboundedFollowing))\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]], with fixed number of records.\n+   * For example:\n+   * {{{\n+   *   df.over(partitionBy(\"k1\").orderBy($\"k2\", $\"k3\").rows)\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def rows: WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, partitionSpec, orderSpec,\n+      SpecifiedWindowFrame(RowFrame, UnboundedPreceding, UnboundedFollowing))\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]], with position specified preceding of CURRENT_ROW.\n+   * It can be either Lower or Upper Bound position depends on the semantic context.\n+   * For example:\n+   * {{{\n+   *   // [CURRENT_ROW - 1, ~)\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.preceding(1))\n+   *   // [CURRENT_ROW - 3, CURRENT_ROW - 1]\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.between.preceding(3).and.preceding(1))\n+   *   // (~, CURRENT_ROW - 1]\n+   *   df.over(partitionBy(\"k1\").orderBy(\"k2\").rows.between.unboundedPreceding.and.preceding(1))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  def preceding(n: Int): WindowFunctionDefinition = {\n+    assert(n > 0)"
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "this is used only in `toColumn`, so i think you maybe do not need add it to constructor\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T01:42:23Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "I will agree we need to hide more properties.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T02:19:09Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,"
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "can users change this value?  seems you do not provide api to change this.\nand when it will be false?  \ni am thinking of remove this, since this is always true for hive sql syntax\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T01:46:22Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame,\n+    bindLower: Boolean = true) {"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "No, it's not always `true`, will be set `false` once the lower bound of the window specified.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T02:19:57Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame,\n+    bindLower: Boolean = true) {"
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "yes, you are right.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T03:33:10Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql](\n+    column: Column = null,\n+    partitionSpec: Seq[Expression] = Nil,\n+    orderSpec: Seq[SortOrder] = Nil,\n+    frame: WindowFrame = UnspecifiedFrame,\n+    bindLower: Boolean = true) {"
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "maybe `WindowSpecification` is a more descriptive name.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T01:50:08Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql]("
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "The `column` actually represents the `Function`, and I was thinking the name also, however, currently there are names like `WindowFunction`, `WindowSpecDefinition`, I just simply combine them.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T02:18:52Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql]("
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "then i will suggest `WindowSpecDef`\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T03:40:21Z",
    "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ * @param column The bounded the aggregate/window function\n+ * @param partitionSpec The partition of the window\n+ * @param orderSpec The ordering of the window\n+ * @param frame The Window Frame type\n+ * @param bindLower A hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+ *                  if bindLower == true, then we will set the lower bound, otherwise, we should\n+ *                  set the upper bound for the Row/Range Frame.\n+ */\n+@Experimental\n+class WindowFunctionDefinition protected[sql]("
  }],
  "prId": 6104
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "how about update the `partitionSpec` and return `this`?  we do not need to create new instance for each update.\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T03:28:59Z",
    "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class WindowFunctionDefinition {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  // Hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+  // if bindLower == true, then we will set the lower bound, otherwise, we should\n+  // set the upper bound for the Row/Range Frame.\n+  private var bindLower: Boolean = true\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame,\n+      bindLower: Boolean = true) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+    this.bindLower = bindLower\n+  }\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame, bindLower)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Making mutable status probably not a good idea, as we have cases like:\n\n``` scala\n   val w = orderBy(\"k1\")\n   avg(\"a\").over(w.partitionBy(\"c\"))\n   avg(\"a\").over(w) // We don't expect the `w` changed with partition \"c\" right?\n```\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T04:25:24Z",
    "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class WindowFunctionDefinition {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  // Hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+  // if bindLower == true, then we will set the lower bound, otherwise, we should\n+  // set the upper bound for the Row/Range Frame.\n+  private var bindLower: Boolean = true\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame,\n+      bindLower: Boolean = true) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+    this.bindLower = bindLower\n+  }\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame, bindLower)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)"
  }, {
    "author": {
      "login": "scwf"
    },
    "body": "right\n",
    "commit": "d625a642735e3b741c5d701e2fe28a0b6c8c845f",
    "createdAt": "2015-05-19T04:40:58Z",
    "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * :: Experimental ::\n+ * A set of methods for window function definition for aggregate expressions.\n+ * For example:\n+ * {{{\n+ *   // predefine a window\n+ *   val w = partitionBy(\"name\").orderBy(\"id\")\n+ *\n+ *   df.select(\n+ *     first(\"value\")\n+ *       over(w).as(\"first_value\"),\n+ *     last(\"value\")\n+ *       over(w).as(\"last_value\"),\n+ *     avg(\"value\")\n+ *       over(\n+ *       partitionBy(\"k1\")\n+ *       .orderBy(\"k2\", \"k3\")\n+ *       .rows\n+ *       .following(1)).as(\"avg_value\"),\n+ *     max(\"value\")\n+ *       .over(\n+ *       partitionBy(\"k2\")\n+ *       .orderBy(\"k3\")\n+ *       .range\n+ *       .between\n+ *       .preceding(4)\n+ *       .and\n+ *       .following(3)).as(\"max_value\"))\n+ *\n+ * }}}\n+ *\n+ */\n+@Experimental\n+class WindowFunctionDefinition {\n+  private var column: Column = _\n+  private var partitionSpec: Seq[Expression] = Nil\n+  private var orderSpec: Seq[SortOrder] = Nil\n+  private var frame: WindowFrame = UnspecifiedFrame\n+\n+  // Hint of when call the methods `.preceding(n)` `.currentRow()` `.following()`\n+  // if bindLower == true, then we will set the lower bound, otherwise, we should\n+  // set the upper bound for the Row/Range Frame.\n+  private var bindLower: Boolean = true\n+\n+  private def this(\n+      column: Column = null,\n+      partitionSpec: Seq[Expression] = Nil,\n+      orderSpec: Seq[SortOrder] = Nil,\n+      frame: WindowFrame = UnspecifiedFrame,\n+      bindLower: Boolean = true) {\n+    this()\n+    this.column = column\n+    this.partitionSpec = partitionSpec\n+    this.orderSpec = orderSpec\n+    this.frame     = frame\n+    this.bindLower = bindLower\n+  }\n+\n+  private[sql] def newColumn(c: Column): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(c, partitionSpec, orderSpec, frame, bindLower)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column.\n+   * {{{\n+   *   // The following 2 are equivalent\n+   *   df.over(partitionBy(\"k1\", \"k2\", ...))\n+   *   df.over(partitionBy($\"K1\", $\"k2\", ...))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(colName: String, colNames: String*): WindowFunctionDefinition = {\n+    partitionBy((colName +: colNames).map(Column(_)): _*)\n+  }\n+\n+  /**\n+   * Returns a new [[WindowFunctionDefinition]] partitioned by the specified column. For example:\n+   * {{{\n+   *   df.over(partitionBy($\"col1\", $\"col2\"))\n+   * }}}\n+   * @group window_funcs\n+   */\n+  @scala.annotation.varargs\n+  def partitionBy(cols: Column*): WindowFunctionDefinition = {\n+    new WindowFunctionDefinition(column, cols.map(_.expr), orderSpec, frame)"
  }],
  "prId": 6104
}]