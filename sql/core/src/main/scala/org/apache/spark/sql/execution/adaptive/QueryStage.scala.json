[{
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Change this line to:\r\n```scala\r\n    child = child match {\r\n      case s: WholeStageCodegenExec => s\r\n      case other => CollapseCodegenStages(sqlContext.conf).apply(other)\r\n    }\r\n```\r\n?",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2018-01-26T09:54:50Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray\n+    if (childMapOutputStatistics.length > 0) {\n+      val exchangeCoordinator = new ExchangeCoordinator(\n+        conf.targetPostShuffleInputSize,\n+        conf.minNumPostShufflePartitions)\n+\n+      val partitionStartIndices =\n+        exchangeCoordinator.estimatePartitionStartIndices(childMapOutputStatistics)\n+      child = child.transform {\n+        case ShuffleQueryStageInput(childStage, output, _) =>\n+          ShuffleQueryStageInput(childStage, output, Some(partitionStartIndices))\n+      }\n+    }\n+\n+    // 3. Codegen and update the UI\n+    child = CollapseCodegenStages(sqlContext.conf).apply(child)"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "`child` seems won't be `WholeStageCodegenExec`",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2018-01-26T11:29:14Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray\n+    if (childMapOutputStatistics.length > 0) {\n+      val exchangeCoordinator = new ExchangeCoordinator(\n+        conf.targetPostShuffleInputSize,\n+        conf.minNumPostShufflePartitions)\n+\n+      val partitionStartIndices =\n+        exchangeCoordinator.estimatePartitionStartIndices(childMapOutputStatistics)\n+      child = child.transform {\n+        case ShuffleQueryStageInput(childStage, output, _) =>\n+          ShuffleQueryStageInput(childStage, output, Some(partitionStartIndices))\n+      }\n+    }\n+\n+    // 3. Codegen and update the UI\n+    child = CollapseCodegenStages(sqlContext.conf).apply(child)"
  }, {
    "author": {
      "login": "yucai"
    },
    "body": "yes, @gczsjdy is correct.\r\nIn adaptive execution, there is no the whole stage codegen in QueryExecution.adaptivePreparations, so child could not be WholeStageCodegenExec.",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2018-01-26T14:19:24Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray\n+    if (childMapOutputStatistics.length > 0) {\n+      val exchangeCoordinator = new ExchangeCoordinator(\n+        conf.targetPostShuffleInputSize,\n+        conf.minNumPostShufflePartitions)\n+\n+      val partitionStartIndices =\n+        exchangeCoordinator.estimatePartitionStartIndices(childMapOutputStatistics)\n+      child = child.transform {\n+        case ShuffleQueryStageInput(childStage, output, _) =>\n+          ShuffleQueryStageInput(childStage, output, Some(partitionStartIndices))\n+      }\n+    }\n+\n+    // 3. Codegen and update the UI\n+    child = CollapseCodegenStages(sqlContext.conf).apply(child)"
  }],
  "prId": 20303
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "when `mapOutputStatistics` can be null?",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-10T07:18:30Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray"
  }, {
    "author": {
      "login": "carsonwang"
    },
    "body": "If the childStage's RDD has 0 partition, we will not submit that stage. See [ShuffleExchangeExec.eagerExecute](https://github.com/apache/spark/pull/20303/files#diff-3ceee31a3da1b7c71dddd32f666126fbR109). In that case, mapOutputStatistics will be null so we filter it.",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-10T09:36:20Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray"
  }],
  "prId": 20303
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why it's a var?",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-10T07:21:01Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray\n+    if (childMapOutputStatistics.length > 0) {\n+      val exchangeCoordinator = new ExchangeCoordinator(\n+        conf.targetPostShuffleInputSize,\n+        conf.minNumPostShufflePartitions)\n+\n+      val partitionStartIndices =\n+        exchangeCoordinator.estimatePartitionStartIndices(childMapOutputStatistics)\n+      child = child.transform {\n+        case ShuffleQueryStageInput(childStage, output, _) =>\n+          ShuffleQueryStageInput(childStage, output, Some(partitionStartIndices))\n+      }\n+    }\n+\n+    // 3. Codegen and update the UI\n+    child = CollapseCodegenStages(sqlContext.conf).apply(child)\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionId != null && executionId.nonEmpty) {\n+      val queryExecution = SQLExecution.getQueryExecution(executionId.toLong)\n+      sparkContext.listenerBus.post(SparkListenerSQLAdaptiveExecutionUpdate(\n+        executionId.toLong,\n+        queryExecution.toString,\n+        SparkPlanInfo.fromSparkPlan(queryExecution.executedPlan)))\n+    }\n+  }\n+\n+  // Caches the created ShuffleRowRDD so we can reuse that.\n+  private var cachedRDD: RDD[InternalRow] = null\n+\n+  def executeStage(): RDD[InternalRow] = child.execute()\n+\n+  /**\n+   * A QueryStage can be reused like Exchange. It is possible that multiple threads try to submit\n+   * the same QueryStage. Use synchronized to make sure it is executed only once.\n+   */\n+  override def doExecute(): RDD[InternalRow] = synchronized {\n+    if (cachedRDD == null) {\n+      prepareExecuteStage()\n+      cachedRDD = executeStage()\n+    }\n+    cachedRDD\n+  }\n+\n+  override def executeCollect(): Array[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeCollect()\n+  }\n+\n+  override def executeToIterator(): Iterator[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeToIterator()\n+  }\n+\n+  override def executeTake(n: Int): Array[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeTake(n)\n+  }\n+\n+  override def generateTreeString(\n+      depth: Int,\n+      lastChildren: Seq[Boolean],\n+      builder: StringBuilder,\n+      verbose: Boolean,\n+      prefix: String = \"\",\n+      addSuffix: Boolean = false): StringBuilder = {\n+    child.generateTreeString(depth, lastChildren, builder, verbose, \"*\")\n+  }\n+}\n+\n+/**\n+ * The last QueryStage of an execution plan.\n+ */\n+case class ResultQueryStage(var child: SparkPlan) extends QueryStage\n+\n+/**\n+ * A shuffle QueryStage whose child is a ShuffleExchange.\n+ */\n+case class ShuffleQueryStage(var child: SparkPlan) extends QueryStage {"
  }, {
    "author": {
      "login": "carsonwang"
    },
    "body": "This is a var so that we can update the plan at run time by directly assigning a new child to ShuffleQueryStage. This won't affect other query stages. ",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-10T09:44:42Z",
    "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.duration.Duration\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+import org.apache.spark.sql.execution.ui.SparkListenerSQLAdaptiveExecutionUpdate\n+import org.apache.spark.util.ThreadUtils\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages. Each\n+ * QueryStage is a sub-tree that runs in a single stage.\n+ */\n+abstract class QueryStage extends UnaryExecNode {\n+\n+  var child: SparkPlan\n+\n+  // Ignore this wrapper for canonicalizing.\n+  override def doCanonicalize(): SparkPlan = child.canonicalized\n+\n+  override def output: Seq[Attribute] = child.output\n+\n+  override def outputPartitioning: Partitioning = child.outputPartitioning\n+\n+  override def outputOrdering: Seq[SortOrder] = child.outputOrdering\n+\n+  /**\n+   * Execute childStages and wait until all stages are completed. Use a thread pool to avoid\n+   * blocking on one child stage.\n+   */\n+  def executeChildStages(): Unit = {\n+    // Handle broadcast stages\n+    val broadcastQueryStages: Seq[BroadcastQueryStage] = child.collect {\n+      case bqs: BroadcastQueryStageInput => bqs.childStage\n+    }\n+    val broadcastFutures = broadcastQueryStages.map { queryStage =>\n+      Future { queryStage.prepareBroadcast() }(QueryStage.executionContext)\n+    }\n+\n+    // Submit shuffle stages\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    val shuffleQueryStages: Seq[ShuffleQueryStage] = child.collect {\n+      case sqs: ShuffleQueryStageInput => sqs.childStage\n+    }\n+    val shuffleStageFutures = shuffleQueryStages.map { queryStage =>\n+      Future {\n+        SQLExecution.withExecutionId(sqlContext.sparkContext, executionId) {\n+          queryStage.execute()\n+        }\n+      }(QueryStage.executionContext)\n+    }\n+\n+    ThreadUtils.awaitResult(\n+      Future.sequence(broadcastFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+    ThreadUtils.awaitResult(\n+      Future.sequence(shuffleStageFutures)(implicitly, QueryStage.executionContext), Duration.Inf)\n+  }\n+\n+  /**\n+   * Before executing the plan in this query stage, we execute all child stages, optimize the plan\n+   * in this stage and determine the reducer number based on the child stages' statistics. Finally\n+   * we do a codegen for this query stage and update the UI with the new plan.\n+   */\n+  def prepareExecuteStage(): Unit = {\n+    // 1. Execute childStages\n+    executeChildStages()\n+    // It is possible to optimize this stage's plan here based on the child stages' statistics.\n+\n+    // 2. Determine reducer number\n+    val queryStageInputs: Seq[ShuffleQueryStageInput] = child.collect {\n+      case input: ShuffleQueryStageInput => input\n+    }\n+    val childMapOutputStatistics = queryStageInputs.map(_.childStage.mapOutputStatistics)\n+      .filter(_ != null).toArray\n+    if (childMapOutputStatistics.length > 0) {\n+      val exchangeCoordinator = new ExchangeCoordinator(\n+        conf.targetPostShuffleInputSize,\n+        conf.minNumPostShufflePartitions)\n+\n+      val partitionStartIndices =\n+        exchangeCoordinator.estimatePartitionStartIndices(childMapOutputStatistics)\n+      child = child.transform {\n+        case ShuffleQueryStageInput(childStage, output, _) =>\n+          ShuffleQueryStageInput(childStage, output, Some(partitionStartIndices))\n+      }\n+    }\n+\n+    // 3. Codegen and update the UI\n+    child = CollapseCodegenStages(sqlContext.conf).apply(child)\n+    val executionId = sqlContext.sparkContext.getLocalProperty(SQLExecution.EXECUTION_ID_KEY)\n+    if (executionId != null && executionId.nonEmpty) {\n+      val queryExecution = SQLExecution.getQueryExecution(executionId.toLong)\n+      sparkContext.listenerBus.post(SparkListenerSQLAdaptiveExecutionUpdate(\n+        executionId.toLong,\n+        queryExecution.toString,\n+        SparkPlanInfo.fromSparkPlan(queryExecution.executedPlan)))\n+    }\n+  }\n+\n+  // Caches the created ShuffleRowRDD so we can reuse that.\n+  private var cachedRDD: RDD[InternalRow] = null\n+\n+  def executeStage(): RDD[InternalRow] = child.execute()\n+\n+  /**\n+   * A QueryStage can be reused like Exchange. It is possible that multiple threads try to submit\n+   * the same QueryStage. Use synchronized to make sure it is executed only once.\n+   */\n+  override def doExecute(): RDD[InternalRow] = synchronized {\n+    if (cachedRDD == null) {\n+      prepareExecuteStage()\n+      cachedRDD = executeStage()\n+    }\n+    cachedRDD\n+  }\n+\n+  override def executeCollect(): Array[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeCollect()\n+  }\n+\n+  override def executeToIterator(): Iterator[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeToIterator()\n+  }\n+\n+  override def executeTake(n: Int): Array[InternalRow] = {\n+    prepareExecuteStage()\n+    child.executeTake(n)\n+  }\n+\n+  override def generateTreeString(\n+      depth: Int,\n+      lastChildren: Seq[Boolean],\n+      builder: StringBuilder,\n+      verbose: Boolean,\n+      prefix: String = \"\",\n+      addSuffix: Boolean = false): StringBuilder = {\n+    child.generateTreeString(depth, lastChildren, builder, verbose, \"*\")\n+  }\n+}\n+\n+/**\n+ * The last QueryStage of an execution plan.\n+ */\n+case class ResultQueryStage(var child: SparkPlan) extends QueryStage\n+\n+/**\n+ * A shuffle QueryStage whose child is a ShuffleExchange.\n+ */\n+case class ShuffleQueryStage(var child: SparkPlan) extends QueryStage {"
  }],
  "prId": 20303
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "We need to extend `LeafExecNode` for each stage and `AdaptiveSparkPlan`? Since a stage is not a leaf, I feel a bit weird...",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-29T11:47:31Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Also, based on the naming rule for `SparkPlan`, `QueryStageExec` instead of `QueryStage`?",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-29T12:03:39Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "carsonwang"
    },
    "body": "Original the `QueryStage` is a `UnaryExecNode` with a var child and `QueryStageInput` is a leaf node which acts as the input of a query stage. However that breaks the Spark rule as the child need to be immutable. So now `QueryStage` become a leaf node. Yes, let's follow the naming rule. ",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-01-30T03:39:04Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "jerrychenhf"
    },
    "body": "Folks, I suggest we reconsider whether it is good to name it as \"QueryStage\".  For all Spark developers have the concept of Stage and used widely in Spark and UI, although there might not be such as class named \"***Stage\".  I know that adaptive execution does use Shuffle/Exchange as boundaries and divide the stages which is very close to the Spark \"Stage\" concept. But my question is whether this \"QueryStage\" class is used only in adaptive case, for example when adaptive execution is enabled, or this class is used as the same concept as Spark \"Stage\" even not under adaptive case.  if it is the former case, we should avoid the \"QueryStage\" name which may be very misleading with the exist Spark \"Stage\" concept and make the code hard to understand.\r\n\r\nFor example, whether AdaptiveStage is a better name than \"QueryState\" to explicitly state the scope the stage concept is for.",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-02-01T04:25:53Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about `QueryFragment`?",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-02-01T05:47:04Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "carsonwang"
    },
    "body": "@maropu also proposed `QueryFragment`. I am fine to go with this. Let's leave this open for a while to see if any other opinion. ",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-02-01T07:36:22Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }, {
    "author": {
      "login": "JkSelf"
    },
    "body": "Here `Query` maybe have some misleading with the spark sql query. How about change to `AdaptiveFragment` ? And it is easier to understand in adaptive use case.",
    "commit": "2e087785d754dfabc84b333fffcf98c39d2fd497",
    "createdAt": "2019-02-21T09:23:25Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.adaptive\n+\n+import scala.concurrent.Future\n+\n+import org.apache.spark.MapOutputStatistics\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.physical.Partitioning\n+import org.apache.spark.sql.execution._\n+import org.apache.spark.sql.execution.exchange._\n+\n+/**\n+ * In adaptive execution mode, an execution plan is divided into multiple QueryStages w.r.t. the\n+ * exchange as boundary. Each QueryStage is a sub-tree that runs in a single Spark stage.\n+ */\n+abstract class QueryStage extends LeafExecNode {"
  }],
  "prId": 20303
}]