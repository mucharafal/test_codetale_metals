[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Cant his check happen once and make it a constant rather than call each time?\r\n\r\nThis is also the unfortunately the common case, little-endian architectures. Hm, I'm trying to think of an alternative that would introduce overhead only for big-endian, but not sure if it's possible. that said `reverseBytes` ought to be very fast. And I guess this only happens once before this terminates.",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-15T20:23:38Z",
    "diffHunk": "@@ -49,9 +51,13 @@ public int compare(\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n+          if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "To clarify the issue isn't endianness alone, but aligned access? varying either one could cause the result to change.",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-15T20:36:35Z",
    "diffHunk": "@@ -49,9 +51,13 @@ public int compare(\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n+          if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {"
  }],
  "prId": 26548
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Pulling together my comment with https://github.com/apache/spark/pull/25491#issuecomment-551957225 - maybe this also has to be `Long.compareUnsigned`?",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-15T21:33:26Z",
    "diffHunk": "@@ -49,9 +51,13 @@ public int compare(\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n+          if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {\n+            v1 = Long.reverseBytes(v1);\n+            v2 = Long.reverseBytes(v2);\n+          }\n           return v1 > v2 ? 1 : -1;"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "Yes, thanks for point out this. This is the same issue with https://github.com/apache/spark/pull/25491#issuecomment-551957225.  And this can be reproduced in our cluster.  ",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-15T22:05:46Z",
    "diffHunk": "@@ -49,9 +51,13 @@ public int compare(\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n+          if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {\n+            v1 = Long.reverseBytes(v1);\n+            v2 = Long.reverseBytes(v2);\n+          }\n           return v1 > v2 ? 1 : -1;"
  }],
  "prId": 26548
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "No need for this. It's a fixed property of the entire VM / JVM. Just:\r\n`private static final boolean LITTLE_ENDIAN = ByteOrder.nativeOrder.equals(ByteOrder.LITTLE_ENDIAN);`\r\n",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T14:31:06Z",
    "diffHunk": "@@ -22,6 +22,12 @@\n \n public final class RecordBinaryComparator extends RecordComparator {\n \n+  boolean isLittlenEndian;\n+\n+  public RecordBinaryComparator(boolean isLittlenEndian) {"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "updated",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T15:30:08Z",
    "diffHunk": "@@ -22,6 +22,12 @@\n \n public final class RecordBinaryComparator extends RecordComparator {\n \n+  boolean isLittlenEndian;\n+\n+  public RecordBinaryComparator(boolean isLittlenEndian) {"
  }],
  "prId": 26548
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "for better perf, shall we move the if out of the while loop? e.g.\r\n```\r\nif (LITTLE_ENDIAN) {\r\n  while ...\r\n    return Long.compareUnsigned(Long.reverseBytes(v1), Long.reverseBytes(v2))\r\n} else {\r\n  while ...\r\n    return Long.compareUnsigned(v1, v2);\r\n}\r\n```",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T16:10:24Z",
    "diffHunk": "@@ -38,32 +43,39 @@ public int compare(\n     // check if stars align and we can get both offsets to be aligned\n     if ((leftOff % 8) == (rightOff % 8)) {\n       while ((leftOff + i) % 8 != 0 && i < leftLen) {\n-        final int v1 = Platform.getByte(leftObj, leftOff + i) & 0xff;\n-        final int v2 = Platform.getByte(rightObj, rightOff + i) & 0xff;\n+        final int v1 = Platform.getByte(leftObj, leftOff + i);\n+        final int v2 = Platform.getByte(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          return (v1 & 0xff) > (v2 & 0xff) ? 1 : -1;\n         }\n         i += 1;\n       }\n     }\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          if (LITTLE_ENDIAN) {",
    "line": 38
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "hmm maybe doesn't matter as it's a constant. cc @kiszk @rednaxelafx ",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T16:13:05Z",
    "diffHunk": "@@ -38,32 +43,39 @@ public int compare(\n     // check if stars align and we can get both offsets to be aligned\n     if ((leftOff % 8) == (rightOff % 8)) {\n       while ((leftOff + i) % 8 != 0 && i < leftLen) {\n-        final int v1 = Platform.getByte(leftObj, leftOff + i) & 0xff;\n-        final int v2 = Platform.getByte(rightObj, rightOff + i) & 0xff;\n+        final int v1 = Platform.getByte(leftObj, leftOff + i);\n+        final int v2 = Platform.getByte(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          return (v1 & 0xff) > (v2 & 0xff) ? 1 : -1;\n         }\n         i += 1;\n       }\n     }\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          if (LITTLE_ENDIAN) {",
    "line": 38
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Probably won't matter much as this executes only once per comparison, when we know it's going to stop one way or the other.",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T16:25:23Z",
    "diffHunk": "@@ -38,32 +43,39 @@ public int compare(\n     // check if stars align and we can get both offsets to be aligned\n     if ((leftOff % 8) == (rightOff % 8)) {\n       while ((leftOff + i) % 8 != 0 && i < leftLen) {\n-        final int v1 = Platform.getByte(leftObj, leftOff + i) & 0xff;\n-        final int v2 = Platform.getByte(rightObj, rightOff + i) & 0xff;\n+        final int v1 = Platform.getByte(leftObj, leftOff + i);\n+        final int v2 = Platform.getByte(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          return (v1 & 0xff) > (v2 & 0xff) ? 1 : -1;\n         }\n         i += 1;\n       }\n     }\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          if (LITTLE_ENDIAN) {",
    "line": 38
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ah you are right. then nvm",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-18T17:07:53Z",
    "diffHunk": "@@ -38,32 +43,39 @@ public int compare(\n     // check if stars align and we can get both offsets to be aligned\n     if ((leftOff % 8) == (rightOff % 8)) {\n       while ((leftOff + i) % 8 != 0 && i < leftLen) {\n-        final int v1 = Platform.getByte(leftObj, leftOff + i) & 0xff;\n-        final int v2 = Platform.getByte(rightObj, rightOff + i) & 0xff;\n+        final int v1 = Platform.getByte(leftObj, leftOff + i);\n+        final int v2 = Platform.getByte(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          return (v1 & 0xff) > (v2 & 0xff) ? 1 : -1;\n         }\n         i += 1;\n       }\n     }\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          if (LITTLE_ENDIAN) {",
    "line": 38
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "Just to note: `LITTLE_ENDIAN` is declared as `static final boolean` here, which allows it to be a JIT-compile-time constant, so during JIT compilation this condition check can be completely folded away. So don't worry about it.",
    "commit": "753883d7f84552c7392295aa42f5023c0909c615",
    "createdAt": "2019-11-19T07:37:01Z",
    "diffHunk": "@@ -38,32 +43,39 @@ public int compare(\n     // check if stars align and we can get both offsets to be aligned\n     if ((leftOff % 8) == (rightOff % 8)) {\n       while ((leftOff + i) % 8 != 0 && i < leftLen) {\n-        final int v1 = Platform.getByte(leftObj, leftOff + i) & 0xff;\n-        final int v2 = Platform.getByte(rightObj, rightOff + i) & 0xff;\n+        final int v1 = Platform.getByte(leftObj, leftOff + i);\n+        final int v2 = Platform.getByte(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          return (v1 & 0xff) > (v2 & 0xff) ? 1 : -1;\n         }\n         i += 1;\n       }\n     }\n     // for architectures that support unaligned accesses, chew it up 8 bytes at a time\n     if (Platform.unaligned() || (((leftOff + i) % 8 == 0) && ((rightOff + i) % 8 == 0))) {\n       while (i <= leftLen - 8) {\n-        final long v1 = Platform.getLong(leftObj, leftOff + i);\n-        final long v2 = Platform.getLong(rightObj, rightOff + i);\n+        long v1 = Platform.getLong(leftObj, leftOff + i);\n+        long v2 = Platform.getLong(rightObj, rightOff + i);\n         if (v1 != v2) {\n-          return v1 > v2 ? 1 : -1;\n+          if (LITTLE_ENDIAN) {",
    "line": 38
  }],
  "prId": 26548
}]