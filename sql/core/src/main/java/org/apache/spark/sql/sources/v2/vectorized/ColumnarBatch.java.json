[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "remove this as it's for `WritableColumnVector` only",
    "commit": "c82fc5b160c9ef302be499f6d14ec1f5e6695196",
    "createdAt": "2017-12-29T16:29:57Z",
    "diffHunk": "@@ -87,19 +79,7 @@ public void remove() {\n   }\n \n   /**\n-   * Resets the batch for writing.\n-   */\n-  public void reset() {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "+1",
    "commit": "c82fc5b160c9ef302be499f6d14ec1f5e6695196",
    "createdAt": "2017-12-29T16:46:18Z",
    "diffHunk": "@@ -87,19 +79,7 @@ public void remove() {\n   }\n \n   /**\n-   * Resets the batch for writing.\n-   */\n-  public void reset() {"
  }],
  "prId": 20116
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "a table -> a portion of a table?",
    "commit": "c82fc5b160c9ef302be499f6d14ec1f5e6695196",
    "createdAt": "2017-12-29T23:54:50Z",
    "diffHunk": "@@ -14,26 +14,18 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.spark.sql.execution.vectorized;\n+package org.apache.spark.sql.sources.v2.vectorized;\n \n import java.util.*;\n \n import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.execution.vectorized.MutableColumnarRow;\n import org.apache.spark.sql.types.StructType;\n \n /**\n- * This class is the in memory representation of rows as they are streamed through operators. It\n- * is designed to maximize CPU efficiency and not storage footprint. Since it is expected that\n- * each operator allocates one of these objects, the storage footprint on the task is negligible.\n- *\n- * The layout is a columnar with values encoded in their native format. Each RowBatch contains\n- * a horizontal partitioning of the data, split into columns.\n- *\n- * The ColumnarBatch supports either on heap or offheap modes with (mostly) the identical API.\n- *\n- * TODO:\n- *  - There are many TODOs for the existing APIs. They should throw a not implemented exception.\n- *  - Compaction: The batch and columns should be able to compact based on a selection vector.\n+ * This class is a wrapper of multiple ColumnVectors and represents a table. It provides a row-view"
  }],
  "prId": 20116
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This can result an incorrect `numRows` after the column vectors are reset. May it be a potential error? ",
    "commit": "c82fc5b160c9ef302be499f6d14ec1f5e6695196",
    "createdAt": "2017-12-30T00:17:59Z",
    "diffHunk": "@@ -87,19 +79,7 @@ public void remove() {\n   }\n \n   /**\n-   * Resets the batch for writing.\n-   */\n-  public void reset() {\n-    for (int i = 0; i < numCols(); ++i) {\n-      if (columns[i] instanceof WritableColumnVector) {\n-        ((WritableColumnVector) columns[i]).reset();\n-      }\n-    }\n-    this.numRows = 0;"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "This doesn't matter. The `numRows` is only used when calling `rowsInterator`, and we always call `setNumRows` before calling `rowsIterator`",
    "commit": "c82fc5b160c9ef302be499f6d14ec1f5e6695196",
    "createdAt": "2018-01-02T13:40:09Z",
    "diffHunk": "@@ -87,19 +79,7 @@ public void remove() {\n   }\n \n   /**\n-   * Resets the batch for writing.\n-   */\n-  public void reset() {\n-    for (int i = 0; i < numCols(); ++i) {\n-      if (columns[i] instanceof WritableColumnVector) {\n-        ((WritableColumnVector) columns[i]).reset();\n-      }\n-    }\n-    this.numRows = 0;"
  }],
  "prId": 20116
}]