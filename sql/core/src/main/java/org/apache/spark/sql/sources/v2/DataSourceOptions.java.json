[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what do you mean by \"without any interpretation\"?",
    "commit": "c5e403c960cdfb68755df754abf7aa96ac6d40bc",
    "createdAt": "2018-02-07T17:56:28Z",
    "diffHunk": "@@ -27,6 +27,39 @@\n /**\n  * An immutable string-to-string map in which keys are case-insensitive. This is used to represent\n  * data source options.\n+ *\n+ * Each data source implementation can define its own options and teach its users how to set them.\n+ * Spark doesn't have any restrictions about what options a data source should or should not have.\n+ * Instead Spark defines some standard options that data sources can optionally adopt. It's possible\n+ * that some options are very common and many data sources use them. However different data\n+ * sources may define the common options(key and meaning) differently, which is quite confusing to\n+ * end users.\n+ *\n+ * The standard options defined by Spark:\n+ * <table>\n+ *   <tr>\n+ *     <th><b>Option key</b></th>\n+ *     <th><b>Option value</b></th>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>path</td>\n+ *     <td>A comma separated paths string of the data files/directories, like\n+ *     <code>path1,/absolute/file2,path3/*</code>. Each path can either be relative or absolute,\n+ *     points to either file or directory, and can contain wildcards. This option is commonly used\n+ *     by file-based data sources.</td>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>table</td>\n+ *     <td>A table name string representing the table name directly without any interpretation."
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "It means it's a pure string, there is not parsing rule for it like SQL identifier. I put some examples below and hopefully they can explain it well.",
    "commit": "c5e403c960cdfb68755df754abf7aa96ac6d40bc",
    "createdAt": "2018-02-08T03:45:48Z",
    "diffHunk": "@@ -27,6 +27,39 @@\n /**\n  * An immutable string-to-string map in which keys are case-insensitive. This is used to represent\n  * data source options.\n+ *\n+ * Each data source implementation can define its own options and teach its users how to set them.\n+ * Spark doesn't have any restrictions about what options a data source should or should not have.\n+ * Instead Spark defines some standard options that data sources can optionally adopt. It's possible\n+ * that some options are very common and many data sources use them. However different data\n+ * sources may define the common options(key and meaning) differently, which is quite confusing to\n+ * end users.\n+ *\n+ * The standard options defined by Spark:\n+ * <table>\n+ *   <tr>\n+ *     <th><b>Option key</b></th>\n+ *     <th><b>Option value</b></th>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>path</td>\n+ *     <td>A comma separated paths string of the data files/directories, like\n+ *     <code>path1,/absolute/file2,path3/*</code>. Each path can either be relative or absolute,\n+ *     points to either file or directory, and can contain wildcards. This option is commonly used\n+ *     by file-based data sources.</td>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>table</td>\n+ *     <td>A table name string representing the table name directly without any interpretation."
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I think this is clear with the examples.",
    "commit": "c5e403c960cdfb68755df754abf7aa96ac6d40bc",
    "createdAt": "2018-02-21T17:02:42Z",
    "diffHunk": "@@ -27,6 +27,39 @@\n /**\n  * An immutable string-to-string map in which keys are case-insensitive. This is used to represent\n  * data source options.\n+ *\n+ * Each data source implementation can define its own options and teach its users how to set them.\n+ * Spark doesn't have any restrictions about what options a data source should or should not have.\n+ * Instead Spark defines some standard options that data sources can optionally adopt. It's possible\n+ * that some options are very common and many data sources use them. However different data\n+ * sources may define the common options(key and meaning) differently, which is quite confusing to\n+ * end users.\n+ *\n+ * The standard options defined by Spark:\n+ * <table>\n+ *   <tr>\n+ *     <th><b>Option key</b></th>\n+ *     <th><b>Option value</b></th>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>path</td>\n+ *     <td>A comma separated paths string of the data files/directories, like\n+ *     <code>path1,/absolute/file2,path3/*</code>. Each path can either be relative or absolute,\n+ *     points to either file or directory, and can contain wildcards. This option is commonly used\n+ *     by file-based data sources.</td>\n+ *   </tr>\n+ *   <tr>\n+ *     <td>table</td>\n+ *     <td>A table name string representing the table name directly without any interpretation."
  }],
  "prId": 20535
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "I think it is more friendly when using this in scala to drop the `get` and use just `path` or `database`.",
    "commit": "c5e403c960cdfb68755df754abf7aa96ac6d40bc",
    "createdAt": "2018-02-21T17:03:39Z",
    "diffHunk": "@@ -97,4 +130,20 @@ public double getDouble(String key, double defaultValue) {\n     return keyLowerCasedMap.containsKey(lcaseKey) ?\n       Double.parseDouble(keyLowerCasedMap.get(lcaseKey)) : defaultValue;\n   }\n+\n+  public static final String KEY_PATH = \"path\";\n+  public static final String KEY_TABLE = \"table\";\n+  public static final String KEY_DATABASE = \"database\";\n+\n+  public Optional<String> getPath() {"
  }],
  "prId": 20535
}, {
  "comments": [{
    "author": {
      "login": "gengliangwang"
    },
    "body": "remove println :)",
    "commit": "c5e403c960cdfb68755df754abf7aa96ac6d40bc",
    "createdAt": "2018-04-09T17:31:11Z",
    "diffHunk": "@@ -97,4 +142,66 @@ public double getDouble(String key, double defaultValue) {\n     return keyLowerCasedMap.containsKey(lcaseKey) ?\n       Double.parseDouble(keyLowerCasedMap.get(lcaseKey)) : defaultValue;\n   }\n+\n+  /**\n+   * The option key for singular path.\n+   */\n+  public static final String PATH_KEY = \"path\";\n+\n+  /**\n+   * The option key for multiple paths.\n+   */\n+  public static final String PATHS_KEY = \"paths\";\n+\n+  /**\n+   * The option key for table name.\n+   */\n+  public static final String TABLE_KEY = \"table\";\n+\n+  /**\n+   * The option key for database name.\n+   */\n+  public static final String DATABASE_KEY = \"database\";\n+\n+  /**\n+   * Returns the value of the singular path option.\n+   */\n+  public Optional<String> path() {\n+    return get(PATH_KEY);\n+  }\n+\n+  /**\n+   * Returns all the paths specified by both the singular path option and the multiple\n+   * paths option.\n+   */\n+  public String[] paths() {\n+    String[] singularPath = path().map(s -> new String[]{s}).orElseGet(() -> new String[0]);\n+    Optional<String> pathsStr = get(PATHS_KEY);\n+    System.out.println(pathsStr);"
  }],
  "prId": 20535
}]