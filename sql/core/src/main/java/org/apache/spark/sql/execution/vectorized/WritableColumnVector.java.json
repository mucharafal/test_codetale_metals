[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "We could move this method into the constructor.",
    "commit": "8330870ef18b12dfeb51e5003c68aaff9dabb7a3",
    "createdAt": "2017-08-21T11:28:54Z",
    "diffHunk": "@@ -0,0 +1,653 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import org.apache.spark.sql.internal.SQLConf;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * This class adds write APIs to ColumnVector.\n+ * It supports all the types and contains put APIs as well as their batched versions.\n+ * The batched versions are preferable whenever possible.\n+ *\n+ * Capacity: The data stored is dense but the arrays are not fixed capacity. It is the\n+ * responsibility of the caller to call reserve() to ensure there is enough room before adding\n+ * elements. This means that the put() APIs do not check as in common cases (i.e. flat schemas),\n+ * the lengths are known up front.\n+ *\n+ * A ColumnVector should be considered immutable once originally created. In other words, it is not\n+ * valid to call put APIs after reads until reset() is called.\n+ */\n+public abstract class WritableColumnVector extends ColumnVector {\n+\n+  /**\n+   * Resets this column for writing. The currently stored values are no longer accessible.\n+   */\n+  public void reset() {\n+    if (isConstant) return;\n+\n+    if (childColumns != null) {\n+      for (ColumnVector c: childColumns) {\n+        ((WritableColumnVector) c).reset();\n+      }\n+    }\n+    numNulls = 0;\n+    elementsAppended = 0;\n+    if (anyNullsSet) {\n+      putNotNulls(0, capacity);\n+      anyNullsSet = false;\n+    }\n+  }\n+\n+  public void reserve(int requiredCapacity) {\n+    if (requiredCapacity > capacity) {\n+      int newCapacity = (int) Math.min(MAX_CAPACITY, requiredCapacity * 2L);\n+      if (requiredCapacity <= newCapacity) {\n+        try {\n+          reserveInternal(newCapacity);\n+        } catch (OutOfMemoryError outOfMemoryError) {\n+          throwUnsupportedException(requiredCapacity, outOfMemoryError);\n+        }\n+      } else {\n+        throwUnsupportedException(requiredCapacity, null);\n+      }\n+    }\n+  }\n+\n+  private void throwUnsupportedException(int requiredCapacity, Throwable cause) {\n+    String message = \"Cannot reserve additional contiguous bytes in the vectorized reader \" +\n+        \"(requested = \" + requiredCapacity + \" bytes). As a workaround, you can disable the \" +\n+        \"vectorized reader by setting \" + SQLConf.PARQUET_VECTORIZED_READER_ENABLED().key() +\n+        \" to false.\";\n+    throw new RuntimeException(message, cause);\n+  }\n+\n+  /**\n+   * Ensures that there is enough storage to store capacity elements. That is, the put() APIs\n+   * must work for all rowIds < capacity.\n+   */\n+  protected abstract void reserveInternal(int capacity);\n+\n+  /**\n+   * Sets the value at rowId to null/not null.\n+   */\n+  public abstract void putNotNull(int rowId);\n+  public abstract void putNull(int rowId);\n+\n+  /**\n+   * Sets the values from [rowId, rowId + count) to null/not null.\n+   */\n+  public abstract void putNulls(int rowId, int count);\n+  public abstract void putNotNulls(int rowId, int count);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putBoolean(int rowId, boolean value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putBooleans(int rowId, int count, boolean value);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putByte(int rowId, byte value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putBytes(int rowId, int count, byte value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putBytes(int rowId, int count, byte[] src, int srcIndex);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putShort(int rowId, short value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putShorts(int rowId, int count, short value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putShorts(int rowId, int count, short[] src, int srcIndex);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putInt(int rowId, int value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putInts(int rowId, int count, int value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putInts(int rowId, int count, int[] src, int srcIndex);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src[srcIndex], src[srcIndex + count])\n+   * The data in src must be 4-byte little endian ints.\n+   */\n+  public abstract void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putLong(int rowId, long value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putLongs(int rowId, int count, long value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putLongs(int rowId, int count, long[] src, int srcIndex);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src[srcIndex], src[srcIndex + count])\n+   * The data in src must be 8-byte little endian longs.\n+   */\n+  public abstract void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putFloat(int rowId, float value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putFloats(int rowId, int count, float value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putFloats(int rowId, int count, float[] src, int srcIndex);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src[srcIndex], src[srcIndex + count])\n+   * The data in src must be ieee formatted floats.\n+   */\n+  public abstract void putFloats(int rowId, int count, byte[] src, int srcIndex);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract void putDouble(int rowId, double value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to value.\n+   */\n+  public abstract void putDoubles(int rowId, int count, double value);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src + srcIndex, src + srcIndex + count)\n+   */\n+  public abstract void putDoubles(int rowId, int count, double[] src, int srcIndex);\n+\n+  /**\n+   * Sets values from [rowId, rowId + count) to [src[srcIndex], src[srcIndex + count])\n+   * The data in src must be ieee formatted doubles.\n+   */\n+  public abstract void putDoubles(int rowId, int count, byte[] src, int srcIndex);\n+\n+  /**\n+   * Puts a byte array that already exists in this column.\n+   */\n+  public abstract void putArray(int rowId, int offset, int length);\n+\n+  /**\n+   * Sets the value at rowId to `value`.\n+   */\n+  public abstract int putByteArray(int rowId, byte[] value, int offset, int count);\n+  public final int putByteArray(int rowId, byte[] value) {\n+    return putByteArray(rowId, value, 0, value.length);\n+  }\n+\n+  /**\n+   * Returns the value for rowId.\n+   */\n+  private ColumnVector.Array getByteArray(int rowId) {\n+    ColumnVector.Array array = getArray(rowId);\n+    array.data.loadBytes(array);\n+    return array;\n+  }\n+\n+  /**\n+   * Returns the decimal for rowId.\n+   */\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    if (precision <= Decimal.MAX_INT_DIGITS()) {\n+      return Decimal.createUnsafe(getInt(rowId), precision, scale);\n+    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n+      return Decimal.createUnsafe(getLong(rowId), precision, scale);\n+    } else {\n+      // TODO: best perf?\n+      byte[] bytes = getBinary(rowId);\n+      BigInteger bigInteger = new BigInteger(bytes);\n+      BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);\n+      return Decimal.apply(javaDecimal, precision, scale);\n+    }\n+  }\n+\n+  public void putDecimal(int rowId, Decimal value, int precision) {\n+    if (precision <= Decimal.MAX_INT_DIGITS()) {\n+      putInt(rowId, (int) value.toUnscaledLong());\n+    } else if (precision <= Decimal.MAX_LONG_DIGITS()) {\n+      putLong(rowId, value.toUnscaledLong());\n+    } else {\n+      BigInteger bigInteger = value.toJavaBigDecimal().unscaledValue();\n+      putByteArray(rowId, bigInteger.toByteArray());\n+    }\n+  }\n+\n+  /**\n+   * Returns the UTF8String for rowId.\n+   */\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    if (dictionary == null) {\n+      ColumnVector.Array a = getByteArray(rowId);\n+      return UTF8String.fromBytes(a.byteArray, a.byteArrayOffset, a.length);\n+    } else {\n+      byte[] bytes = dictionary.decodeToBinary(dictionaryIds.getDictId(rowId));\n+      return UTF8String.fromBytes(bytes);\n+    }\n+  }\n+\n+  /**\n+   * Returns the byte array for rowId.\n+   */\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    if (dictionary == null) {\n+      ColumnVector.Array array = getByteArray(rowId);\n+      byte[] bytes = new byte[array.length];\n+      System.arraycopy(array.byteArray, array.byteArrayOffset, bytes, 0, bytes.length);\n+      return bytes;\n+    } else {\n+      return dictionary.decodeToBinary(dictionaryIds.getDictId(rowId));\n+    }\n+  }\n+\n+  /**\n+   * Append APIs. These APIs all behave similarly and will append data to the current vector.  It\n+   * is not valid to mix the put and append APIs. The append APIs are slower and should only be\n+   * used if the sizes are not known up front.\n+   * In all these cases, the return value is the rowId for the first appended element.\n+   */\n+  public final int appendNull() {\n+    assert (!(dataType() instanceof StructType)); // Use appendStruct()\n+    reserve(elementsAppended + 1);\n+    putNull(elementsAppended);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendNotNull() {\n+    reserve(elementsAppended + 1);\n+    putNotNull(elementsAppended);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendNulls(int count) {\n+    assert (!(dataType() instanceof StructType));\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putNulls(elementsAppended, count);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendNotNulls(int count) {\n+    assert (!(dataType() instanceof StructType));\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putNotNulls(elementsAppended, count);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendBoolean(boolean v) {\n+    reserve(elementsAppended + 1);\n+    putBoolean(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendBooleans(int count, boolean v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putBooleans(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendByte(byte v) {\n+    reserve(elementsAppended + 1);\n+    putByte(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendBytes(int count, byte v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putBytes(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendBytes(int length, byte[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putBytes(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendShort(short v) {\n+    reserve(elementsAppended + 1);\n+    putShort(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendShorts(int count, short v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putShorts(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendShorts(int length, short[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putShorts(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendInt(int v) {\n+    reserve(elementsAppended + 1);\n+    putInt(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendInts(int count, int v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putInts(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendInts(int length, int[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putInts(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendLong(long v) {\n+    reserve(elementsAppended + 1);\n+    putLong(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendLongs(int count, long v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putLongs(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendLongs(int length, long[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putLongs(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendFloat(float v) {\n+    reserve(elementsAppended + 1);\n+    putFloat(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendFloats(int count, float v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putFloats(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendFloats(int length, float[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putFloats(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendDouble(double v) {\n+    reserve(elementsAppended + 1);\n+    putDouble(elementsAppended, v);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendDoubles(int count, double v) {\n+    reserve(elementsAppended + count);\n+    int result = elementsAppended;\n+    putDoubles(elementsAppended, count, v);\n+    elementsAppended += count;\n+    return result;\n+  }\n+\n+  public final int appendDoubles(int length, double[] src, int offset) {\n+    reserve(elementsAppended + length);\n+    int result = elementsAppended;\n+    putDoubles(elementsAppended, length, src, offset);\n+    elementsAppended += length;\n+    return result;\n+  }\n+\n+  public final int appendByteArray(byte[] value, int offset, int length) {\n+    int copiedOffset = arrayData().appendBytes(length, value, offset);\n+    reserve(elementsAppended + 1);\n+    putArray(elementsAppended, copiedOffset, length);\n+    return elementsAppended++;\n+  }\n+\n+  public final int appendArray(int length) {\n+    reserve(elementsAppended + 1);\n+    putArray(elementsAppended, arrayData().elementsAppended, length);\n+    return elementsAppended++;\n+  }\n+\n+  /**\n+   * Appends a NULL struct. This *has* to be used for structs instead of appendNull() as this\n+   * recursively appends a NULL to its children.\n+   * We don't have this logic as the general appendNull implementation to optimize the more\n+   * common non-struct case.\n+   */\n+  public final int appendStruct(boolean isNull) {\n+    if (isNull) {\n+      appendNull();\n+      for (ColumnVector c: childColumns) {\n+        if (c.type instanceof StructType) {\n+          ((WritableColumnVector) c).appendStruct(true);\n+        } else {\n+          ((WritableColumnVector) c).appendNull();\n+        }\n+      }\n+    } else {\n+      appendNotNull();\n+    }\n+    return elementsAppended;\n+  }\n+\n+  /**\n+   * Returns the data for the underlying array.\n+   */\n+  @Override\n+  public WritableColumnVector arrayData() { return (WritableColumnVector) childColumns[0]; }\n+\n+  /**\n+   * Returns the ordinal's child data column.\n+   */\n+  @Override\n+  public WritableColumnVector getChildColumn(int ordinal) {\n+    return (WritableColumnVector) childColumns[ordinal];\n+  }\n+\n+  /**\n+   * Returns the elements appended.\n+   */\n+  public final int getElementsAppended() { return elementsAppended; }\n+\n+  /**\n+   * Marks this column as being constant.\n+   */\n+  public final void setIsConstant() { isConstant = true; }\n+\n+  /**\n+   * Upper limit for the maximum capacity for this column.\n+   */\n+  @VisibleForTesting\n+  protected int MAX_CAPACITY = Integer.MAX_VALUE;\n+\n+  /**\n+   * Default size of each array length value. This grows as necessary.\n+   */\n+  protected static final int DEFAULT_ARRAY_LENGTH = 4;\n+\n+  /**\n+   * Current write cursor (row index) when appending data.\n+   */\n+  protected int elementsAppended;\n+\n+  /**\n+   * True if this column's values are fixed. This means the column values never change, even\n+   * across resets.\n+   */\n+  protected boolean isConstant;\n+\n+  /**\n+   * Update the dictionary.\n+   */\n+  public void setDictionary(Dictionary dictionary) {\n+    this.dictionary = dictionary;\n+  }\n+\n+  /**\n+   * Reserve a integer column for ids of dictionary.\n+   */\n+  public WritableColumnVector reserveDictionaryIds(int capacity) {\n+    WritableColumnVector dictionaryIds = (WritableColumnVector) this.dictionaryIds;\n+    if (dictionaryIds == null) {\n+      dictionaryIds = reserveNewColumn(capacity, DataTypes.IntegerType);\n+      this.dictionaryIds = dictionaryIds;\n+    } else {\n+      dictionaryIds.reset();\n+      dictionaryIds.reserve(capacity);\n+    }\n+    return dictionaryIds;\n+  }\n+\n+  /**\n+   * Returns the underlying integer column for ids of dictionary.\n+   */\n+  @Override\n+  public WritableColumnVector getDictionaryIds() {\n+    return (WritableColumnVector) dictionaryIds;\n+  }\n+\n+  /**\n+   * Reserve a new column.\n+   */\n+  protected abstract WritableColumnVector reserveNewColumn(int capacity, DataType type);\n+\n+  /**\n+   * Initialize child columns.\n+   */\n+  protected void initialize() {"
  }],
  "prId": 18958
}]