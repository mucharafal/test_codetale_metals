[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Can we use `nulls`? Ditto for other places.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T11:08:39Z",
    "diffHunk": "@@ -0,0 +1,510 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ColumnVector {\n+\n+  private ValueVector vector;\n+  private ValueVector.Accessor nulls;\n+\n+  private NullableBitVector boolData;\n+  private NullableTinyIntVector byteData;\n+  private NullableSmallIntVector shortData;\n+  private NullableIntVector intData;\n+  private NullableBigIntVector longData;\n+\n+  private NullableFloat4Vector floatData;\n+  private NullableFloat8Vector doubleData;\n+  private NullableDecimalVector decimalData;\n+\n+  private NullableVarCharVector stringData;\n+\n+  private NullableVarBinaryVector binaryData;\n+\n+  private UInt4Vector listOffsetData;\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), DataTypes.NullType, MemoryMode.OFF_HEAP);\n+    initialize(vector);\n+  }\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    vector.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public void putNotNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNotNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nulls.isNull(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public void putBoolean(int rowId, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putBooleans(int rowId, int count, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return boolData.getAccessor().get(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    assert(dictionary == null);\n+    NullableBitVector.Accessor accessor = boolData.getAccessor();"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "I'm afraid not, because the type of `nulls` is `ValueVector.Accessor` which has only simple methods such as `isNull()`.\r\nThe concrete accessor APIs are different for each types.\r\nOr should we cast `nulls` to the concrete type each time?",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T11:15:45Z",
    "diffHunk": "@@ -0,0 +1,510 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ColumnVector {\n+\n+  private ValueVector vector;\n+  private ValueVector.Accessor nulls;\n+\n+  private NullableBitVector boolData;\n+  private NullableTinyIntVector byteData;\n+  private NullableSmallIntVector shortData;\n+  private NullableIntVector intData;\n+  private NullableBigIntVector longData;\n+\n+  private NullableFloat4Vector floatData;\n+  private NullableFloat8Vector doubleData;\n+  private NullableDecimalVector decimalData;\n+\n+  private NullableVarCharVector stringData;\n+\n+  private NullableVarBinaryVector binaryData;\n+\n+  private UInt4Vector listOffsetData;\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), DataTypes.NullType, MemoryMode.OFF_HEAP);\n+    initialize(vector);\n+  }\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    vector.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public void putNotNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNotNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nulls.isNull(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public void putBoolean(int rowId, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putBooleans(int rowId, int count, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return boolData.getAccessor().get(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    assert(dictionary == null);\n+    NullableBitVector.Accessor accessor = boolData.getAccessor();"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. Can we keep `NullableBitVector.Accessor` instead of `NullableBitVector` while we keep the same reference in two instance variables. I am afraid about the cost of runtime cast in `getBoolean()` method rather than `getBooleans()` method.\r\nThis is why I expect `get()` method will be inlined into by a JIT compiler since each Accessor class is `final`.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T14:46:47Z",
    "diffHunk": "@@ -0,0 +1,510 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ColumnVector {\n+\n+  private ValueVector vector;\n+  private ValueVector.Accessor nulls;\n+\n+  private NullableBitVector boolData;\n+  private NullableTinyIntVector byteData;\n+  private NullableSmallIntVector shortData;\n+  private NullableIntVector intData;\n+  private NullableBigIntVector longData;\n+\n+  private NullableFloat4Vector floatData;\n+  private NullableFloat8Vector doubleData;\n+  private NullableDecimalVector decimalData;\n+\n+  private NullableVarCharVector stringData;\n+\n+  private NullableVarBinaryVector binaryData;\n+\n+  private UInt4Vector listOffsetData;\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), DataTypes.NullType, MemoryMode.OFF_HEAP);\n+    initialize(vector);\n+  }\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    vector.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public void putNotNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNotNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nulls.isNull(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public void putBoolean(int rowId, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putBooleans(int rowId, int count, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return boolData.getAccessor().get(rowId) == 1;\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    assert(dictionary == null);\n+    NullableBitVector.Accessor accessor = boolData.getAccessor();"
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Can we use `nulls`? Ditto for other places",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T11:09:05Z",
    "diffHunk": "@@ -0,0 +1,510 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ColumnVector {\n+\n+  private ValueVector vector;\n+  private ValueVector.Accessor nulls;\n+\n+  private NullableBitVector boolData;\n+  private NullableTinyIntVector byteData;\n+  private NullableSmallIntVector shortData;\n+  private NullableIntVector intData;\n+  private NullableBigIntVector longData;\n+\n+  private NullableFloat4Vector floatData;\n+  private NullableFloat8Vector doubleData;\n+  private NullableDecimalVector decimalData;\n+\n+  private NullableVarCharVector stringData;\n+\n+  private NullableVarBinaryVector binaryData;\n+\n+  private UInt4Vector listOffsetData;\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), DataTypes.NullType, MemoryMode.OFF_HEAP);\n+    initialize(vector);\n+  }\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    vector.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public void putNotNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNull(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putNotNulls(int rowId, int count) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return nulls.isNull(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public void putBoolean(int rowId, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public void putBooleans(int rowId, int count, boolean value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return boolData.getAccessor().get(rowId) == 1;"
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "Is this planned to be a public API right now?",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T17:42:28Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {"
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "BryanCutler"
    },
    "body": "Can this whole \"if else\" block be put into a pattern match instead?",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-19T17:45:56Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), MemoryMode.OFF_HEAP);\n+\n+    type = ArrowUtils.fromArrowField(vector.getField());\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {\n+      MapVector mapVector = (MapVector) vector;\n+      accessor = new StructAccessor(mapVector);\n+\n+      childColumns = new ArrowColumnVector[mapVector.size()];\n+      for (int i = 0; i < childColumns.length; ++i) {\n+        childColumns[i] = new ArrowColumnVector(mapVector.getVectorById(i));\n+      }\n+      resultStruct = new ColumnarBatch.Row(childColumns);\n+    } else {\n+      throw new UnsupportedOperationException();",
    "line": 318
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "Unfortunately, this class is written in Java, so we can't use a pattern match.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T05:01:57Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), MemoryMode.OFF_HEAP);\n+\n+    type = ArrowUtils.fromArrowField(vector.getField());\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {\n+      MapVector mapVector = (MapVector) vector;\n+      accessor = new StructAccessor(mapVector);\n+\n+      childColumns = new ArrowColumnVector[mapVector.size()];\n+      for (int i = 0; i < childColumns.length; ++i) {\n+        childColumns[i] = new ArrowColumnVector(mapVector.getVectorById(i));\n+      }\n+      resultStruct = new ColumnarBatch.Row(childColumns);\n+    } else {\n+      throw new UnsupportedOperationException();",
    "line": 318
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit: `a column vector`",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T07:59:57Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow."
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we don't need to address this now, but do we have a better implementation with arrow? cc @BryanCutler ",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T08:06:58Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "kind of a batch read API.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T08:07:26Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I checked Arrow's API docs. I didn't find batch read API.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T12:43:42Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);"
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "a unrelated question: why a vector for struct type is called `MapVector` in arrow? cc @BryanCutler ",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T08:09:51Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), ArrowUtils.fromArrowField(vector.getField()),\n+      MemoryMode.OFF_HEAP);\n+\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {",
    "line": 308
  }, {
    "author": {
      "login": "BryanCutler"
    },
    "body": "I'm not sure about the design decision behind it, but it's meant to lookup child vectors by name so uses a kind of hash map.  I agree that another name would have been more intuitive.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T17:56:04Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), ArrowUtils.fromArrowField(vector.getField()),\n+      MemoryMode.OFF_HEAP);\n+\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {",
    "line": 308
  }],
  "prId": 18680
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "If the given rowId is the last row, is it still valid to call `get(rowId + 1)`?",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T08:20:18Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), ArrowUtils.fromArrowField(vector.getField()),\n+      MemoryMode.OFF_HEAP);\n+\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {\n+      MapVector mapVector = (MapVector) vector;\n+      accessor = new StructAccessor(mapVector);\n+\n+      childColumns = new ArrowColumnVector[mapVector.size()];\n+      for (int i = 0; i < childColumns.length; ++i) {\n+        childColumns[i] = new ArrowColumnVector(mapVector.getVectorById(i));\n+      }\n+      resultStruct = new ColumnarBatch.Row(childColumns);\n+    } else {\n+      throw new UnsupportedOperationException();\n+    }\n+    numNulls = accessor.getNullCount();\n+    anyNullsSet = numNulls > 0;\n+  }\n+\n+  private static abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+    private final ValueVector.Accessor nulls;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+      this.nulls = vector.getAccessor();\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nulls.isNull(rowId);\n+    }\n+\n+    final int getNullCount() {\n+      return nulls.getNullCount();\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getArrayLength(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getArrayOffset(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableBitVector.Accessor accessor;\n+\n+    BooleanAccessor(NullableBitVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return accessor.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableTinyIntVector.Accessor accessor;\n+\n+    ByteAccessor(NullableTinyIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableSmallIntVector.Accessor accessor;\n+\n+    ShortAccessor(NullableSmallIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableIntVector.Accessor accessor;\n+\n+    IntAccessor(NullableIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableBigIntVector.Accessor accessor;\n+\n+    LongAccessor(NullableBigIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableFloat4Vector.Accessor accessor;\n+\n+    FloatAccessor(NullableFloat4Vector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableFloat8Vector.Accessor accessor;\n+\n+    DoubleAccessor(NullableFloat8Vector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableDecimalVector.Accessor accessor;\n+\n+    DecimalAccessor(NullableDecimalVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) return null;\n+      return Decimal.apply(accessor.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private static class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableVarCharVector.Accessor accessor;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(NullableVarCharVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      accessor.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(null,\n+          stringResult.buffer.memoryAddress() + stringResult.start,\n+          stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  private static class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableVarBinaryVector.Accessor accessor;\n+\n+    BinaryAccessor(NullableVarBinaryVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return accessor.getObject(rowId);\n+    }\n+  }\n+\n+  private static class ArrayAccessor extends ArrowVectorAccessor {\n+\n+    private final UInt4Vector.Accessor accessor;\n+\n+    ArrayAccessor(ListVector vector) {\n+      super(vector);\n+      this.accessor = vector.getOffsetVector().getAccessor();\n+    }\n+\n+    @Override\n+    final int getArrayLength(int rowId) {\n+      return accessor.get(rowId + 1) - accessor.get(rowId);",
    "line": 575
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "Yes, the offset vector for `ListVector` should have num of arrays + 1 values.",
    "commit": "2d1dad9ac6bc2cfa4a4dcad32ef99464bc7f6541",
    "createdAt": "2017-07-20T10:18:49Z",
    "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.vectorized;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.*;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+\n+import org.apache.spark.memory.MemoryMode;\n+import org.apache.spark.sql.execution.arrow.ArrowUtils;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A column backed by Apache Arrow.\n+ */\n+public final class ArrowColumnVector extends ReadOnlyColumnVector {\n+\n+  private final ArrowVectorAccessor accessor;\n+\n+  @Override\n+  public long nullsNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public long valuesNativeAddress() {\n+    throw new RuntimeException(\"Cannot get native address for arrow column\");\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (childColumns != null) {\n+      for (int i = 0; i < childColumns.length; i++) {\n+        childColumns[i].close();\n+      }\n+    }\n+    accessor.close();\n+  }\n+\n+  //\n+  // APIs dealing with nulls\n+  //\n+\n+  @Override\n+  public boolean isNullAt(int rowId) {\n+    return accessor.isNullAt(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Booleans\n+  //\n+\n+  @Override\n+  public boolean getBoolean(int rowId) {\n+    return accessor.getBoolean(rowId);\n+  }\n+\n+  @Override\n+  public boolean[] getBooleans(int rowId, int count) {\n+    boolean[] array = new boolean[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getBoolean(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Bytes\n+  //\n+\n+  @Override\n+  public byte getByte(int rowId) {\n+    return accessor.getByte(rowId);\n+  }\n+\n+  @Override\n+  public byte[] getBytes(int rowId, int count) {\n+    byte[] array = new byte[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getByte(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Shorts\n+  //\n+\n+  @Override\n+  public short getShort(int rowId) {\n+    return accessor.getShort(rowId);\n+  }\n+\n+  @Override\n+  public short[] getShorts(int rowId, int count) {\n+    short[] array = new short[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getShort(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Ints\n+  //\n+\n+  @Override\n+  public int getInt(int rowId) {\n+    return accessor.getInt(rowId);\n+  }\n+\n+  @Override\n+  public int[] getInts(int rowId, int count) {\n+    int[] array = new int[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getInt(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public int getDictId(int rowId) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Longs\n+  //\n+\n+  @Override\n+  public long getLong(int rowId) {\n+    return accessor.getLong(rowId);\n+  }\n+\n+  @Override\n+  public long[] getLongs(int rowId, int count) {\n+    long[] array = new long[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getLong(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with floats\n+  //\n+\n+  @Override\n+  public float getFloat(int rowId) {\n+    return accessor.getFloat(rowId);\n+  }\n+\n+  @Override\n+  public float[] getFloats(int rowId, int count) {\n+    float[] array = new float[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getFloat(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with doubles\n+  //\n+\n+  @Override\n+  public double getDouble(int rowId) {\n+    return accessor.getDouble(rowId);\n+  }\n+\n+  @Override\n+  public double[] getDoubles(int rowId, int count) {\n+    double[] array = new double[count];\n+    for (int i = 0; i < count; ++i) {\n+      array[i] = accessor.getDouble(rowId + i);\n+    }\n+    return array;\n+  }\n+\n+  //\n+  // APIs dealing with Arrays\n+  //\n+\n+  @Override\n+  public int getArrayLength(int rowId) {\n+    return accessor.getArrayLength(rowId);\n+  }\n+\n+  @Override\n+  public int getArrayOffset(int rowId) {\n+    return accessor.getArrayOffset(rowId);\n+  }\n+\n+  @Override\n+  public void loadBytes(Array array) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  //\n+  // APIs dealing with Decimals\n+  //\n+\n+  @Override\n+  public Decimal getDecimal(int rowId, int precision, int scale) {\n+    return accessor.getDecimal(rowId, precision, scale);\n+  }\n+\n+  //\n+  // APIs dealing with UTF8Strings\n+  //\n+\n+  @Override\n+  public UTF8String getUTF8String(int rowId) {\n+    return accessor.getUTF8String(rowId);\n+  }\n+\n+  //\n+  // APIs dealing with Binaries\n+  //\n+\n+  @Override\n+  public byte[] getBinary(int rowId) {\n+    return accessor.getBinary(rowId);\n+  }\n+\n+  public ArrowColumnVector(ValueVector vector) {\n+    super(vector.getValueCapacity(), ArrowUtils.fromArrowField(vector.getField()),\n+      MemoryMode.OFF_HEAP);\n+\n+    if (vector instanceof NullableBitVector) {\n+      accessor = new BooleanAccessor((NullableBitVector) vector);\n+    } else if (vector instanceof NullableTinyIntVector) {\n+      accessor = new ByteAccessor((NullableTinyIntVector) vector);\n+    } else if (vector instanceof NullableSmallIntVector) {\n+      accessor = new ShortAccessor((NullableSmallIntVector) vector);\n+    } else if (vector instanceof NullableIntVector) {\n+      accessor = new IntAccessor((NullableIntVector) vector);\n+    } else if (vector instanceof NullableBigIntVector) {\n+      accessor = new LongAccessor((NullableBigIntVector) vector);\n+    } else if (vector instanceof NullableFloat4Vector) {\n+      accessor = new FloatAccessor((NullableFloat4Vector) vector);\n+    } else if (vector instanceof NullableFloat8Vector) {\n+      accessor = new DoubleAccessor((NullableFloat8Vector) vector);\n+    } else if (vector instanceof NullableDecimalVector) {\n+      accessor = new DecimalAccessor((NullableDecimalVector) vector);\n+    } else if (vector instanceof NullableVarCharVector) {\n+      accessor = new StringAccessor((NullableVarCharVector) vector);\n+    } else if (vector instanceof NullableVarBinaryVector) {\n+      accessor = new BinaryAccessor((NullableVarBinaryVector) vector);\n+    } else if (vector instanceof ListVector) {\n+      ListVector listVector = (ListVector) vector;\n+      accessor = new ArrayAccessor(listVector);\n+\n+      childColumns = new ColumnVector[1];\n+      childColumns[0] = new ArrowColumnVector(listVector.getDataVector());\n+      resultArray = new Array(childColumns[0]);\n+    } else if (vector instanceof MapVector) {\n+      MapVector mapVector = (MapVector) vector;\n+      accessor = new StructAccessor(mapVector);\n+\n+      childColumns = new ArrowColumnVector[mapVector.size()];\n+      for (int i = 0; i < childColumns.length; ++i) {\n+        childColumns[i] = new ArrowColumnVector(mapVector.getVectorById(i));\n+      }\n+      resultStruct = new ColumnarBatch.Row(childColumns);\n+    } else {\n+      throw new UnsupportedOperationException();\n+    }\n+    numNulls = accessor.getNullCount();\n+    anyNullsSet = numNulls > 0;\n+  }\n+\n+  private static abstract class ArrowVectorAccessor {\n+\n+    private final ValueVector vector;\n+    private final ValueVector.Accessor nulls;\n+\n+    ArrowVectorAccessor(ValueVector vector) {\n+      this.vector = vector;\n+      this.nulls = vector.getAccessor();\n+    }\n+\n+    final boolean isNullAt(int rowId) {\n+      return nulls.isNull(rowId);\n+    }\n+\n+    final int getNullCount() {\n+      return nulls.getNullCount();\n+    }\n+\n+    final void close() {\n+      vector.close();\n+    }\n+\n+    boolean getBoolean(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte getByte(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    short getShort(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getInt(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    long getLong(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    float getFloat(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    double getDouble(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    Decimal getDecimal(int rowId, int precision, int scale) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    UTF8String getUTF8String(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    byte[] getBinary(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getArrayLength(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    int getArrayOffset(int rowId) {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  private static class BooleanAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableBitVector.Accessor accessor;\n+\n+    BooleanAccessor(NullableBitVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final boolean getBoolean(int rowId) {\n+      return accessor.get(rowId) == 1;\n+    }\n+  }\n+\n+  private static class ByteAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableTinyIntVector.Accessor accessor;\n+\n+    ByteAccessor(NullableTinyIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final byte getByte(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class ShortAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableSmallIntVector.Accessor accessor;\n+\n+    ShortAccessor(NullableSmallIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final short getShort(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class IntAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableIntVector.Accessor accessor;\n+\n+    IntAccessor(NullableIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final int getInt(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class LongAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableBigIntVector.Accessor accessor;\n+\n+    LongAccessor(NullableBigIntVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final long getLong(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class FloatAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableFloat4Vector.Accessor accessor;\n+\n+    FloatAccessor(NullableFloat4Vector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final float getFloat(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class DoubleAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableFloat8Vector.Accessor accessor;\n+\n+    DoubleAccessor(NullableFloat8Vector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final double getDouble(int rowId) {\n+      return accessor.get(rowId);\n+    }\n+  }\n+\n+  private static class DecimalAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableDecimalVector.Accessor accessor;\n+\n+    DecimalAccessor(NullableDecimalVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final Decimal getDecimal(int rowId, int precision, int scale) {\n+      if (isNullAt(rowId)) return null;\n+      return Decimal.apply(accessor.getObject(rowId), precision, scale);\n+    }\n+  }\n+\n+  private static class StringAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableVarCharVector.Accessor accessor;\n+    private final NullableVarCharHolder stringResult = new NullableVarCharHolder();\n+\n+    StringAccessor(NullableVarCharVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final UTF8String getUTF8String(int rowId) {\n+      accessor.get(rowId, stringResult);\n+      if (stringResult.isSet == 0) {\n+        return null;\n+      } else {\n+        return UTF8String.fromAddress(null,\n+          stringResult.buffer.memoryAddress() + stringResult.start,\n+          stringResult.end - stringResult.start);\n+      }\n+    }\n+  }\n+\n+  private static class BinaryAccessor extends ArrowVectorAccessor {\n+\n+    private final NullableVarBinaryVector.Accessor accessor;\n+\n+    BinaryAccessor(NullableVarBinaryVector vector) {\n+      super(vector);\n+      this.accessor = vector.getAccessor();\n+    }\n+\n+    @Override\n+    final byte[] getBinary(int rowId) {\n+      return accessor.getObject(rowId);\n+    }\n+  }\n+\n+  private static class ArrayAccessor extends ArrowVectorAccessor {\n+\n+    private final UInt4Vector.Accessor accessor;\n+\n+    ArrayAccessor(ListVector vector) {\n+      super(vector);\n+      this.accessor = vector.getOffsetVector().getAccessor();\n+    }\n+\n+    @Override\n+    final int getArrayLength(int rowId) {\n+      return accessor.get(rowId + 1) - accessor.get(rowId);",
    "line": 575
  }],
  "prId": 18680
}]