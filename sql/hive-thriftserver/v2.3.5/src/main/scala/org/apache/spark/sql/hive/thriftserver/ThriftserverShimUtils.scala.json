[{
  "comments": [{
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "nit: empty line between functions.",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-06T21:34:40Z",
    "diffHunk": "@@ -56,6 +56,11 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }\n   private[thriftserver] def addToClassPath(",
    "line": 20
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "Add it .",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-07T00:04:03Z",
    "diffHunk": "@@ -56,6 +56,11 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }\n   private[thriftserver] def addToClassPath(",
    "line": 20
  }],
  "prId": 25694
}, {
  "comments": [{
    "author": {
      "login": "wangyum"
    },
    "body": "Why do we skip `ARRAY_TYPE`, `MAP_TYPE`, `STRUCT_TYPE` and `USER_DEFINED_TYPE`?",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-07T15:15:32Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "> Why do we skip `ARRAY_TYPE`, `MAP_TYPE`, `STRUCT_TYPE` and `USER_DEFINED_TYPE`?\r\n\r\nSupport this type just convert to string to show.  Should add . ",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-08T01:09:50Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "I think we should add these types. Hive-3.1.2 also converted these types to strings.\r\n@juliuszsompolski What do you think?",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-08T13:23:52Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "How does the client handle it?\r\nIf you do\r\n```\r\nval stmt = conn.prepareStatement(\"SELECT array, map, struct, interval FROM table\")\r\nval rs = stmt.executeQuery()\r\nval md = rs.getMetaData()\r\n```\r\nThen what does `md.getColumnType(i)` return for each of these columns?\r\nWhat type of `rs.getXXX` call should the user use for each of these columns? For the array column, should it be `rs.getArray(i)` or `rs.getString(i)`?\r\nWhat is the mapping of types returned by md.getColumnType(i), with the getters that should be used for them in rs.getXXX(i)?\r\n",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T13:57:05Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "For getMetadataResult, it truly return ARRAY, MAP, STRUCT.\r\nReturn content is organized by HiveResult.toHiveString() method as each's DataType.\r\n\r\n",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T14:13:58Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "So if I run this:\r\n```\r\nClass.forName(\"org.apache.hive.jdbc.HiveDriver\")\r\nval jdbc_url = \"jdbc:hive2://localhost:10000/default;httpPath=cliservice\"\r\nval conn = DriverManager.getConnection(jdbc_url)\r\nval stmt = conn.prepareStatement(\"select collect_list(id) as arr from range(10)\")\r\nval rs = stmt.executeQuery()\r\nval md = rs.getMetaData()\r\n```\r\nand then:\r\n```\r\nscala> md.getColumnType(1)\r\nres2: Int = 2003\r\n\r\nscala> java.sql.Types.ARRAY\r\nres3: Int = 2003\r\n\r\nscala> rs.next()\r\nres4: Boolean = true\r\n\r\nscala> rs.getArray(1)\r\njava.sql.SQLException: Method not supported\r\n  at org.apache.hive.jdbc.HiveBaseResultSet.getArray(HiveBaseResultSet.java:113)\r\n  ... 33 elided\r\n\r\nscala> rs.getString(1)\r\nres6: String = [0,1,2,3,4,5,6,7,8,9]\r\n```\r\nAssuming that it's a generic JDBC application, not specific to Hive quirks, how is that application supposed to know that after getting a `getColumnType` of `Types.Array`, it needs to retrieve it with `getString`, and not with `getArray`?",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T14:16:40Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "@juliuszsompolski \r\nIn hive jdbc method. It will final treat ARRAY, MAP, STRUCT ..etc as String Type:\r\n\r\n```\r\nstatic String columnClassName(Type hiveType, JdbcColumnAttributes columnAttributes)\r\n      throws SQLException {\r\n    int columnType = hiveTypeToSqlType(hiveType);\r\n    switch(columnType) {\r\n      case Types.NULL:\r\n        return \"null\";\r\n      case Types.BOOLEAN:\r\n        return Boolean.class.getName();\r\n      case Types.CHAR:\r\n      case Types.VARCHAR:\r\n        return String.class.getName();\r\n      case Types.TINYINT:\r\n        return Byte.class.getName();\r\n      case Types.SMALLINT:\r\n        return Short.class.getName();\r\n      case Types.INTEGER:\r\n        return Integer.class.getName();\r\n      case Types.BIGINT:\r\n        return Long.class.getName();\r\n      case Types.DATE:\r\n        return Date.class.getName();\r\n      case Types.FLOAT:\r\n        return Float.class.getName();\r\n      case Types.DOUBLE:\r\n        return Double.class.getName();\r\n      case  Types.TIMESTAMP:\r\n        return Timestamp.class.getName();\r\n      case Types.DECIMAL:\r\n        return BigInteger.class.getName();\r\n      case Types.BINARY:\r\n        return byte[].class.getName();\r\n      case Types.OTHER:\r\n      case Types.JAVA_OBJECT: {\r\n        switch (hiveType) {\r\n          case INTERVAL_YEAR_MONTH_TYPE:\r\n            return HiveIntervalYearMonth.class.getName();\r\n          case INTERVAL_DAY_TIME_TYPE:\r\n            return HiveIntervalDayTime.class.getName();\r\n          default:\r\n            return String.class.getName();\r\n        }\r\n      }\r\n      case Types.ARRAY:\r\n      case Types.STRUCT:\r\n        return String.class.getName();\r\n      default:\r\n        throw new SQLException(\"Invalid column type: \" + columnType);\r\n    }\r\n  }\r\n```",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T14:33:12Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "wangyum"
    },
    "body": "OK. We can not fully support these type. Please remove them @AngersZhuuuu \r\nThanks @juliuszsompolski for you example.",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T16:17:46Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "Actually, thanks for explaining it @AngersZhuuuu, and you convinced me that ARRAY, MAP and STRUCT must be included.\r\n```\r\nscala> md.getColumnType(1)\r\nres11: Int = 2003 (== java.sql.Types.ARRAY)\r\n```\r\nbut then\r\n```\r\nscala> md.getColumnClassName(1)\r\nres10: String = java.lang.String\r\n```\r\nso that tells to the client that it is actually returned as String, and I should retrieve it as such, either with `rs.getObject(1).asInstance[String]` or as convenient shorthand with `rs.getString(1)`.\r\nIt would actually be incorrect to not include Array, Map, Struct, because we do return them in ResultSet schema (through `SparkExecuteStatement.getTableSchema`), so the client can get these type returned, and for any type that can be returned to the client there should be an entry in GetTypeInfo.\r\nWe therefore should not include INTERVAL (because we explicitly turn it to String return type after #25277), and not include UNIONTYPE or USER_DEFINED because they don't have any Spark equivalent, but ARRAY, MAP and STRUCT should be there.\r\nThank you for the explanation :+1: ",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T19:00:59Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "@juliuszsompolski \r\n```\r\ncase Types.OTHER:\r\n      case Types.JAVA_OBJECT: {\r\n        switch (hiveType) {\r\n          case INTERVAL_YEAR_MONTH_TYPE:\r\n            return HiveIntervalYearMonth.class.getName();\r\n          case INTERVAL_DAY_TIME_TYPE:\r\n            return HiveIntervalDayTime.class.getName();\r\n          default:\r\n            return String.class.getName();\r\n        }\r\n      }\r\n\r\n``` \r\nUSER_DEFINED  in java.sql.Types is OTHERS, in the convert progress, it's also converted to String , same as ARRAY, MAP, STRUCT. \r\nMaybe we should add USER_DEFINED.",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-09T23:03:25Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "juliuszsompolski"
    },
    "body": "But Spark will never return a USER_DEFINED type.\r\nThe current implementation of org.apache.spark.sql.types.UserDefinedType will return the underlying sqlType.simpleString as it's catalogString, so Thriftserver queries will return the underlying type in the schema.\r\nHence for USER_DEFINED (and UNIONTYPE) the argument is not that they wouldn't potentially work, but that Spark does not use them.",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-10T09:34:19Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }, {
    "author": {
      "login": "AngersZhuuuu"
    },
    "body": "> But Spark will never return a USER_DEFINED type.\r\n> The current implementation of org.apache.spark.sql.types.UserDefinedType will return the underlying sqlType.simpleString as it's catalogString, so Thriftserver queries will return the underlying type in the schema.\r\n> Hence for USER_DEFINED (and UNIONTYPE) the argument is not that they wouldn't potentially work, but that Spark does not use them.\r\n\r\nRemove it and resolve conflicts.",
    "commit": "3c488fcfc5a6e97db25f417d0dd8bdb339c99525",
    "createdAt": "2019-09-10T09:50:54Z",
    "diffHunk": "@@ -56,6 +56,12 @@ private[thriftserver] object ThriftserverShimUtils {\n \n   private[thriftserver] def toJavaSQLType(s: String): Int = Type.getType(s).toJavaSQLType\n \n+  private[thriftserver] def supportedType(): Seq[Type] = {\n+    Array(Type.NULL_TYPE, Type.BOOLEAN_TYPE, Type.TINYINT_TYPE, Type.SMALLINT_TYPE, Type.INT_TYPE,\n+      Type.BIGINT_TYPE, Type.FLOAT_TYPE, Type.DOUBLE_TYPE, Type.STRING_TYPE, Type.DATE_TYPE,\n+      Type.TIMESTAMP_TYPE, Type.DECIMAL_TYPE, Type.BINARY_TYPE)\n+  }",
    "line": 18
  }],
  "prId": 25694
}]