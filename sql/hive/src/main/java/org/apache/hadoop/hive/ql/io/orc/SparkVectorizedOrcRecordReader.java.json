[{
  "comments": [{
    "author": {
      "login": "zjffdu"
    },
    "body": "IOException instead of HiveException ?\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-06-22T08:54:42Z",
    "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+      case PRIMITIVE:\n+        {\n+          PrimitiveTypeInfo primitiveTypeInfo =\n+            (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+          switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+            case BOOLEAN:\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case DATE:\n+            case INTERVAL_YEAR_MONTH:\n+              return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+            case FLOAT:\n+            case DOUBLE:\n+              return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+            case BINARY:\n+            case STRING:\n+            case CHAR:\n+            case VARCHAR:\n+              BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              column.initBuffer();\n+              return column;\n+            case DECIMAL:\n+              DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+              return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                  tInfo.precision(), tInfo.scale());\n+            default:\n+              throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                  + primitiveTypeInfo.getPrimitiveCategory());\n+          }\n+        }\n+      default:\n+        throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+            + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) throws HiveException {\n+      if (cvList == null) {\n+        throw new HiveException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi\n+     * @return\n+     * @throws HiveException\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) throws HiveException {"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "zjffdu"
    },
    "body": "Should log the error instead of ignore it ?\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-06-22T08:55:52Z",
    "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+      case PRIMITIVE:\n+        {\n+          PrimitiveTypeInfo primitiveTypeInfo =\n+            (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+          switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+            case BOOLEAN:\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case DATE:\n+            case INTERVAL_YEAR_MONTH:\n+              return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+            case FLOAT:\n+            case DOUBLE:\n+              return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+            case BINARY:\n+            case STRING:\n+            case CHAR:\n+            case VARCHAR:\n+              BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              column.initBuffer();\n+              return column;\n+            case DECIMAL:\n+              DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+              return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                  tInfo.precision(), tInfo.scale());\n+            default:\n+              throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                  + primitiveTypeInfo.getPrimitiveCategory());\n+          }\n+        }\n+      default:\n+        throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+            + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) throws HiveException {\n+      if (cvList == null) {\n+        throw new HiveException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi\n+     * @return\n+     * @throws HiveException\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) throws HiveException {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {\n+      try {\n+        reader.nextBatch(value);\n+        if (value == null || value.endOfFile || value.size == 0) {\n+          return false;\n+        }\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+      progress = reader.getProgress();\n+      return true;\n+    }\n+\n+    @Override\n+    public NullWritable createKey() {\n+      return NullWritable.get();\n+    }\n+\n+    @Override\n+    public VectorizedRowBatch createValue() {\n+      try {\n+        return constructVectorizedRowBatch((StructObjectInspector)this.objectInspector);\n+      } catch (HiveException e) {\n+      }"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "The exception message is not actionable for end user. There are two options:\n- Automatically fallback to non-vectorised codepath which we know would work. OR\n- Suggest config change(s) to user so that they can do it and not have to google the solution.\n\nLater one is an easier path.\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T22:57:46Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\""
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "OK. Let's do the later one. Actually OrcFileFormat has the check for the data types not supported as you commented below. When we come to here, it might be hard to fallback to non-vectorised codepath.\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-18T07:53:03Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\""
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "nit: space after `for`. There are other places in this PR where the same comment will apply\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T22:58:12Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "Based on code below, I don't think this would ever happen\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T22:59:51Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "nit: have each param on a separate line for readability. There are other places in this PR where the same comment will apply\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:04:09Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "`tInfo` -> `decimalTypeInfo`\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:04:36Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "curious: why would object inspector be `null` ?\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:05:44Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "nit: you can get rid of the else and simply `return false;` in the end\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:08:09Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {\n+      if (reader.hasNext()) {\n+        try {\n+          reader.nextBatch(value);\n+          if (value == null || value.endOfFile || value.size == 0) {\n+            return false;\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n+        progress = reader.getProgress();\n+        return true;\n+      } else {"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "Do you really need this list ? I see this list is being used just for getting the column vectors and then add those to the `VectorizedRowBatch` below. Why not populate the `VectorizedRowBatch` directly ?\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:32:28Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "nit: space after `(StructObjectInspector)`\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:34:13Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {\n+      if (reader.hasNext()) {\n+        try {\n+          reader.nextBatch(value);\n+          if (value == null || value.endOfFile || value.size == 0) {\n+            return false;\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n+        progress = reader.getProgress();\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    }\n+\n+    @Override\n+    public NullWritable createKey() {\n+      return NullWritable.get();\n+    }\n+\n+    @Override\n+    public VectorizedRowBatch createValue() {\n+      return constructVectorizedRowBatch((StructObjectInspector)this.objectInspector);"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "you can simplify as : `return (value != null && !value.endOfFile && value.size > 0)`\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:36:08Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {\n+      if (reader.hasNext()) {\n+        try {\n+          reader.nextBatch(value);\n+          if (value == null || value.endOfFile || value.size == 0) {"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "The method name is bad. You have already allocated the list in the caller. I would either :\n- move the list creation in the method and not the caller OR\n- rename the method as `populateColumnVector()`\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:36:53Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,"
  }],
  "prId": 13775
}, {
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "curiosity: can a `VectorizedRowBatch` be ever empty while the next batch has some rows ?\n",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-10-17T23:38:06Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {",
    "line": 133
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Do you mean a batch is empty and then its next batch has some rows? I think it is not possible.",
    "commit": "0ac61b794146634887d184076aababfd25a22ff5",
    "createdAt": "2016-11-22T14:34:52Z",
    "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.io.orc;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DecimalColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.DoubleColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\n+import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructField;\n+import org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;\n+import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.io.NullWritable;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.hadoop.mapred.RecordReader;\n+\n+/**\n+ * A mapred.RecordReader that returns VectorizedRowBatch.\n+ */\n+public class SparkVectorizedOrcRecordReader\n+      implements RecordReader<NullWritable, VectorizedRowBatch> {\n+    private final org.apache.hadoop.hive.ql.io.orc.RecordReader reader;\n+    private final long offset;\n+    private final long length;\n+    private float progress = 0.0f;\n+    private ObjectInspector objectInspector;\n+\n+    SparkVectorizedOrcRecordReader(Reader file, Configuration conf,\n+        FileSplit fileSplit) throws IOException {\n+      this.offset = fileSplit.getStart();\n+      this.length = fileSplit.getLength();\n+      this.objectInspector = file.getObjectInspector();\n+      this.reader = OrcInputFormat.createReaderFromFile(file, conf, this.offset,\n+        this.length);\n+      this.progress = reader.getProgress();\n+    }\n+\n+    /**\n+     * Create a ColumnVector based on given ObjectInspector's type info.\n+     *\n+     * @param inspector ObjectInspector\n+     */\n+    private ColumnVector createColumnVector(ObjectInspector inspector) {\n+      switch(inspector.getCategory()) {\n+        case PRIMITIVE:\n+          {\n+            PrimitiveTypeInfo primitiveTypeInfo =\n+              (PrimitiveTypeInfo) ((PrimitiveObjectInspector)inspector).getTypeInfo();\n+            switch(primitiveTypeInfo.getPrimitiveCategory()) {\n+              case BOOLEAN:\n+              case BYTE:\n+              case SHORT:\n+              case INT:\n+              case LONG:\n+              case DATE:\n+              case INTERVAL_YEAR_MONTH:\n+                return new LongColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case FLOAT:\n+              case DOUBLE:\n+                return new DoubleColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+              case BINARY:\n+              case STRING:\n+              case CHAR:\n+              case VARCHAR:\n+                BytesColumnVector column = new BytesColumnVector(VectorizedRowBatch.DEFAULT_SIZE);\n+                column.initBuffer();\n+                return column;\n+              case DECIMAL:\n+                DecimalTypeInfo tInfo = (DecimalTypeInfo) primitiveTypeInfo;\n+                return new DecimalColumnVector(VectorizedRowBatch.DEFAULT_SIZE,\n+                    tInfo.precision(), tInfo.scale());\n+              default:\n+                throw new RuntimeException(\"Vectorizaton is not supported for datatype:\"\n+                    + primitiveTypeInfo.getPrimitiveCategory());\n+            }\n+          }\n+        default:\n+          throw new RuntimeException(\"Vectorization is not supported for datatype:\"\n+              + inspector.getCategory());\n+      }\n+    }\n+\n+    /**\n+     * Walk through the object inspector and add column vectors\n+     *\n+     * @param oi StructObjectInspector\n+     * @param cvList ColumnVectors are populated in this list\n+     */\n+    private void allocateColumnVector(StructObjectInspector oi,\n+        List<ColumnVector> cvList) {\n+      if (cvList == null) {\n+        throw new RuntimeException(\"Null columnvector list\");\n+      }\n+      if (oi == null) {\n+        return;\n+      }\n+      final List<? extends StructField> fields = oi.getAllStructFieldRefs();\n+      for(StructField field : fields) {\n+        ObjectInspector fieldObjectInspector = field.getFieldObjectInspector();\n+        cvList.add(createColumnVector(fieldObjectInspector));\n+      }\n+    }\n+\n+    /**\n+     * Create VectorizedRowBatch from ObjectInspector\n+     *\n+     * @param oi StructObjectInspector\n+     * @return VectorizedRowBatch\n+     */\n+    private VectorizedRowBatch constructVectorizedRowBatch(\n+        StructObjectInspector oi) {\n+      final List<ColumnVector> cvList = new LinkedList<ColumnVector>();\n+      allocateColumnVector(oi, cvList);\n+      final VectorizedRowBatch result = new VectorizedRowBatch(cvList.size());\n+      int i = 0;\n+      for(ColumnVector cv : cvList) {\n+        result.cols[i++] = cv;\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public boolean next(NullWritable key, VectorizedRowBatch value) throws IOException {",
    "line": 133
  }],
  "prId": 13775
}]