[{
  "comments": [{
    "author": {
      "login": "sujith71955"
    },
    "body": "pull up the flower bracket inline with finally",
    "commit": "51405b06be5cb120db0cc0b7cad8b87ab223a5a3",
    "createdAt": "2019-03-01T08:53:59Z",
    "diffHunk": "@@ -66,51 +66,58 @@ private[sql] class HiveSessionCatalog(\n       name: String,\n       clazz: Class[_],\n       input: Seq[Expression]): Expression = {\n-\n-    Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n-      var udfExpr: Option[Expression] = None\n-      try {\n-        // When we instantiate hive UDF wrapper class, we may throw exception if the input\n-        // expressions don't satisfy the hive UDF, such as type mismatch, input number\n-        // mismatch, etc. Here we catch the exception and throw AnalysisException instead.\n-        if (classOf[UDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveSimpleUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[AbstractGenericUDAFResolver].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[UDAF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(\n-            name,\n-            new HiveFunctionWrapper(clazz.getName),\n-            input,\n-            isUDAFBridgeRequired = true))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDTF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.asInstanceOf[HiveGenericUDTF].elementSchema // Force it to check data types.\n+    val originalClassLoader = Thread.currentThread().getContextClassLoader()\n+    Thread.currentThread().setContextClassLoader(clazz.getClassLoader)\n+    try {\n+      Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n+        var udfExpr: Option[Expression] = None\n+        try {\n+          // When we instantiate hive UDF wrapper class, we may throw exception if the input\n+          // expressions don't satisfy the hive UDF, such as type mismatch, input number\n+          // mismatch, etc. Here we catch the exception and throw AnalysisException instead.\n+          if (classOf[UDF].isAssignableFrom(clazz)) {\n+            udfExpr = Some(HiveSimpleUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n+            udfExpr.get.dataType // Force it to check input data types.\n+          } else if (classOf[GenericUDF].isAssignableFrom(clazz)) {\n+            udfExpr = Some(HiveGenericUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n+            udfExpr.get.dataType // Force it to check input data types.\n+          } else if (classOf[AbstractGenericUDAFResolver].isAssignableFrom(clazz)) {\n+            udfExpr = Some(HiveUDAFFunction(name, new HiveFunctionWrapper(clazz.getName), input))\n+            udfExpr.get.dataType // Force it to check input data types.\n+          } else if (classOf[UDAF].isAssignableFrom(clazz)) {\n+            udfExpr = Some(HiveUDAFFunction(\n+              name,\n+              new HiveFunctionWrapper(clazz.getName),\n+              input,\n+              isUDAFBridgeRequired = true))\n+            udfExpr.get.dataType // Force it to check input data types.\n+          } else if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n+            udfExpr = Some(HiveGenericUDTF(name, new HiveFunctionWrapper(clazz.getName), input))\n+            udfExpr.get.asInstanceOf[HiveGenericUDTF].elementSchema // Force it to check data types.\n+          }\n+        } catch {\n+          case NonFatal(e) =>\n+            val noHandlerMsg = s\"No handler for UDF/UDAF/UDTF '${clazz.getCanonicalName}': $e\"\n+            val errorMsg =\n+              if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n+                s\"$noHandlerMsg\\nPlease make sure your function overrides \" +\n+                  \"`public StructObjectInspector initialize(ObjectInspector[] args)`.\"\n+              } else {\n+                noHandlerMsg\n+              }\n+            val analysisException = new AnalysisException(errorMsg)\n+            analysisException.setStackTrace(e.getStackTrace)\n+            throw analysisException\n+        }\n+        udfExpr.getOrElse {\n+          throw new AnalysisException(s\"No handler for UDF/UDAF/UDTF '${clazz.getCanonicalName}'\")\n         }\n-      } catch {\n-        case NonFatal(e) =>\n-          val noHandlerMsg = s\"No handler for UDF/UDAF/UDTF '${clazz.getCanonicalName}': $e\"\n-          val errorMsg =\n-            if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n-              s\"$noHandlerMsg\\nPlease make sure your function overrides \" +\n-                \"`public StructObjectInspector initialize(ObjectInspector[] args)`.\"\n-            } else {\n-              noHandlerMsg\n-            }\n-          val analysisException = new AnalysisException(errorMsg)\n-          analysisException.setStackTrace(e.getStackTrace)\n-          throw analysisException\n-      }\n-      udfExpr.getOrElse {\n-        throw new AnalysisException(s\"No handler for UDF/UDAF/UDTF '${clazz.getCanonicalName}'\")\n       }\n     }\n+    finally\n+    {"
  }],
  "prId": 23921
}, {
  "comments": [{
    "author": {
      "login": "sujith71955"
    },
    "body": "is this try block is required now? please check once again",
    "commit": "51405b06be5cb120db0cc0b7cad8b87ab223a5a3",
    "createdAt": "2019-03-01T08:59:24Z",
    "diffHunk": "@@ -66,51 +66,58 @@ private[sql] class HiveSessionCatalog(\n       name: String,\n       clazz: Class[_],\n       input: Seq[Expression]): Expression = {\n-\n-    Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n-      var udfExpr: Option[Expression] = None\n-      try {\n-        // When we instantiate hive UDF wrapper class, we may throw exception if the input\n-        // expressions don't satisfy the hive UDF, such as type mismatch, input number\n-        // mismatch, etc. Here we catch the exception and throw AnalysisException instead.\n-        if (classOf[UDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveSimpleUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[AbstractGenericUDAFResolver].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[UDAF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(\n-            name,\n-            new HiveFunctionWrapper(clazz.getName),\n-            input,\n-            isUDAFBridgeRequired = true))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDTF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.asInstanceOf[HiveGenericUDTF].elementSchema // Force it to check data types.\n+    val originalClassLoader = Thread.currentThread().getContextClassLoader()\n+    Thread.currentThread().setContextClassLoader(clazz.getClassLoader)\n+    try {\n+      Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n+        var udfExpr: Option[Expression] = None\n+        try {"
  }, {
    "author": {
      "login": "nivo091"
    },
    "body": "we can remove this inside try and put the catch block to the outer try.\r\n",
    "commit": "51405b06be5cb120db0cc0b7cad8b87ab223a5a3",
    "createdAt": "2019-03-01T10:35:04Z",
    "diffHunk": "@@ -66,51 +66,58 @@ private[sql] class HiveSessionCatalog(\n       name: String,\n       clazz: Class[_],\n       input: Seq[Expression]): Expression = {\n-\n-    Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n-      var udfExpr: Option[Expression] = None\n-      try {\n-        // When we instantiate hive UDF wrapper class, we may throw exception if the input\n-        // expressions don't satisfy the hive UDF, such as type mismatch, input number\n-        // mismatch, etc. Here we catch the exception and throw AnalysisException instead.\n-        if (classOf[UDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveSimpleUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[AbstractGenericUDAFResolver].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[UDAF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveUDAFFunction(\n-            name,\n-            new HiveFunctionWrapper(clazz.getName),\n-            input,\n-            isUDAFBridgeRequired = true))\n-          udfExpr.get.dataType // Force it to check input data types.\n-        } else if (classOf[GenericUDTF].isAssignableFrom(clazz)) {\n-          udfExpr = Some(HiveGenericUDTF(name, new HiveFunctionWrapper(clazz.getName), input))\n-          udfExpr.get.asInstanceOf[HiveGenericUDTF].elementSchema // Force it to check data types.\n+    val originalClassLoader = Thread.currentThread().getContextClassLoader()\n+    Thread.currentThread().setContextClassLoader(clazz.getClassLoader)\n+    try {\n+      Try(super.makeFunctionExpression(name, clazz, input)).getOrElse {\n+        var udfExpr: Option[Expression] = None\n+        try {"
  }],
  "prId": 23921
}]