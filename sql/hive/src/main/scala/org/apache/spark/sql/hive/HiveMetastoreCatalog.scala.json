[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Can you add a comment to explain what we are doing at here?\n",
    "commit": "6f647468d48ceb3f74386a34b6da2c4874f43355",
    "createdAt": "2014-11-08T03:15:18Z",
    "diffHunk": "@@ -282,6 +282,9 @@ private[hive] class HiveMetastoreCatalog(hive: HiveContext) extends Catalog with\n \n       if (childOutputDataTypes == tableOutputDataTypes) {\n         p\n+      } else if (childOutputDataTypes.size == tableOutputDataTypes.size &&\n+        childOutputDataTypes.zip(tableOutputDataTypes).forall(equalsIgnoreNullability)) {\n+        InsertIntoHiveTable(p.table, p.partition, p.child, p.overwrite)"
  }],
  "prId": 3110
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Add a comment to explain the reason that we do not need to override `resolved`? Also, maybe some comments about this `InsertIntoHiveTable` class?\n",
    "commit": "6f647468d48ceb3f74386a34b6da2c4874f43355",
    "createdAt": "2014-11-08T03:16:32Z",
    "diffHunk": "@@ -312,6 +330,17 @@ private[hive] class HiveMetastoreCatalog(hive: HiveContext) extends Catalog with\n   override def unregisterAllTables() = {}\n }\n \n+private[hive] case class InsertIntoHiveTable(\n+    table: LogicalPlan,\n+    partition: Map[String, Option[String]],\n+    child: LogicalPlan,\n+    overwrite: Boolean)\n+  extends LogicalPlan {\n+\n+  override def children = child :: Nil\n+  override def output = child.output\n+}"
  }],
  "prId": 3110
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "I like this approach of having a separate equals function (In my experience overriding the standard `equals` to do loose equality is a recipe for disaster).  What do you think about moving this function into `DataType` though?  seems like it could be generally useful.\n",
    "commit": "6f647468d48ceb3f74386a34b6da2c4874f43355",
    "createdAt": "2014-11-11T00:07:11Z",
    "diffHunk": "@@ -313,6 +319,48 @@ private[hive] class HiveMetastoreCatalog(hive: HiveContext) extends Catalog with\n }\n \n /**\n+ * A logical plan representing insertion into Hive table.\n+ * This plan ignores nullability of ArrayType, MapType, StructType unlike InsertIntoTable\n+ * because Hive table doesn't have nullability for ARRAY, MAP, STRUCT types.\n+ */\n+private[hive] case class InsertIntoHiveTable(\n+    table: LogicalPlan,\n+    partition: Map[String, Option[String]],\n+    child: LogicalPlan,\n+    overwrite: Boolean)\n+  extends LogicalPlan {\n+\n+  override def children = child :: Nil\n+  override def output = child.output\n+\n+  override lazy val resolved = childrenResolved && child.output.zip(table.output).forall {\n+    case (childAttr, tableAttr) =>\n+      InsertIntoHiveType.equalsIgnoreNullability(childAttr.dataType, tableAttr.dataType)\n+  }\n+}\n+\n+private[hive] object InsertIntoHiveType {\n+\n+  /**\n+   * Compares two types, ignoring nullability of ArrayType, MapType, StructType.\n+   */\n+  def equalsIgnoreNullability(dataTypePair: (DataType, DataType)): Boolean = {"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "I think it's ok to move this function into `DataType`.\n",
    "commit": "6f647468d48ceb3f74386a34b6da2c4874f43355",
    "createdAt": "2014-11-11T07:18:50Z",
    "diffHunk": "@@ -313,6 +319,48 @@ private[hive] class HiveMetastoreCatalog(hive: HiveContext) extends Catalog with\n }\n \n /**\n+ * A logical plan representing insertion into Hive table.\n+ * This plan ignores nullability of ArrayType, MapType, StructType unlike InsertIntoTable\n+ * because Hive table doesn't have nullability for ARRAY, MAP, STRUCT types.\n+ */\n+private[hive] case class InsertIntoHiveTable(\n+    table: LogicalPlan,\n+    partition: Map[String, Option[String]],\n+    child: LogicalPlan,\n+    overwrite: Boolean)\n+  extends LogicalPlan {\n+\n+  override def children = child :: Nil\n+  override def output = child.output\n+\n+  override lazy val resolved = childrenResolved && child.output.zip(table.output).forall {\n+    case (childAttr, tableAttr) =>\n+      InsertIntoHiveType.equalsIgnoreNullability(childAttr.dataType, tableAttr.dataType)\n+  }\n+}\n+\n+private[hive] object InsertIntoHiveType {\n+\n+  /**\n+   * Compares two types, ignoring nullability of ArrayType, MapType, StructType.\n+   */\n+  def equalsIgnoreNullability(dataTypePair: (DataType, DataType)): Boolean = {"
  }],
  "prId": 3110
}]