[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "I think that this pr also suffers the same problem exposed in https://github.com/apache/spark/pull/9170. There was no test failure because we only set the mutable classloader when we actually do add jar (In #9170 we set the mutable classloader to `executionHive.state.getConf` whenever we need to use `withHiveState`).\n",
    "commit": "7951df1a91271826c8405f19d0ce12873faff21b",
    "createdAt": "2015-10-20T05:09:52Z",
    "diffHunk": "@@ -100,7 +99,7 @@ case class AddJar(path: String) extends RunnableCommand {\n     // returns the value of a thread local variable and its HiveConf may not be the HiveConf\n     // associated with `executionHive.state` (for example, HiveContext is created in one thread\n     // and then add jar is called from another thread).\n-    hiveContext.executionHive.state.getConf.setClassLoader(newClassLoader)\n+    hiveContext.executionHive.state.getConf.setClassLoader(hiveContext.libraryClassLoader)",
    "line": 20
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "I have changed the classloader to a non-closable mutable url class loader.\n",
    "commit": "7951df1a91271826c8405f19d0ce12873faff21b",
    "createdAt": "2015-10-23T17:16:38Z",
    "diffHunk": "@@ -100,7 +99,7 @@ case class AddJar(path: String) extends RunnableCommand {\n     // returns the value of a thread local variable and its HiveConf may not be the HiveConf\n     // associated with `executionHive.state` (for example, HiveContext is created in one thread\n     // and then add jar is called from another thread).\n-    hiveContext.executionHive.state.getConf.setClassLoader(newClassLoader)\n+    hiveContext.executionHive.state.getConf.setClassLoader(hiveContext.libraryClassLoader)",
    "line": 20
  }],
  "prId": 9171
}]