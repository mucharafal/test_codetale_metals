[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Can we get rid of these rules too?\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T20:23:37Z",
    "diffHunk": "@@ -183,19 +183,19 @@ private[hive] trait HiveStrategies {\n           table, partition, planLater(child), overwrite)(hiveContext) :: Nil\n       case logical.CreateTableAsSelect(\n              Some(database), tableName, child, allowExisting, Some(desc: CreateTableDesc)) =>\n-        execution.CreateTableAsSelect(\n+        ExecutedCommand(execution.CreateTableAsSelect(\n           database,\n           tableName,\n           child,\n           allowExisting,\n-          Some(desc)) :: Nil\n+          Some(desc))(hiveContext)) :: Nil\n       case logical.CreateTableAsSelect(Some(database), tableName, child, allowExisting, None) =>\n-        execution.CreateTableAsSelect(\n+        ExecutedCommand(execution.CreateTableAsSelect(\n           database,\n           tableName,\n           child,\n           allowExisting,\n-          None) :: Nil\n+          None)(hiveContext)) :: Nil"
  }],
  "prId": 3712
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Same, it would be good to remove these too if possible.\n",
    "commit": "51a82f2ae3fe9d28455940d953de7b76306f49b2",
    "createdAt": "2014-12-16T20:25:06Z",
    "diffHunk": "@@ -226,23 +226,27 @@ private[hive] trait HiveStrategies {\n \n   case class HiveCommandStrategy(context: HiveContext) extends Strategy {\n     def apply(plan: LogicalPlan): Seq[SparkPlan] = plan match {\n-      case logical.NativeCommand(sql) => NativeCommand(sql, plan.output)(context) :: Nil\n+      case hive.NativeCommand(sql) => ExecutedCommand(\n+        execution.NativeCommand(sql, plan.output)(context)) :: Nil\n \n-      case hive.DropTable(tableName, ifExists) => execution.DropTable(tableName, ifExists) :: Nil\n+      case hive.DropTable(tableName, ifExists) => ExecutedCommand(\n+        execution.DropTable(tableName, ifExists)(context)) :: Nil\n \n-      case hive.AddJar(path) => execution.AddJar(path) :: Nil\n+      case hive.AddJar(path) => ExecutedCommand(execution.AddJar(path)(context)) :: Nil\n \n-      case hive.AddFile(path) => execution.AddFile(path) :: Nil\n+      case hive.AddFile(path) => ExecutedCommand(execution.AddFile(path)(context)) :: Nil\n \n-      case hive.AnalyzeTable(tableName) => execution.AnalyzeTable(tableName) :: Nil\n+      case hive.AnalyzeTable(tableName) => ExecutedCommand(\n+        execution.AnalyzeTable(tableName)(context)) :: Nil\n \n       case describe: logical.DescribeCommand =>\n         val resolvedTable = context.executePlan(describe.table).analyzed\n         resolvedTable match {\n           case t: MetastoreRelation =>\n-            Seq(DescribeHiveTableCommand(t, describe.output, describe.isExtended)(context))\n+            ExecutedCommand(\n+              DescribeHiveTableCommand(t, describe.output, describe.isExtended)(context)) :: Nil\n           case o: LogicalPlan =>\n-            Seq(DescribeCommand(planLater(o), describe.output)(context))\n+            ExecutedCommand(DescribeCommand(planLater(o), describe.output)(context)) :: Nil"
  }],
  "prId": 3712
}]