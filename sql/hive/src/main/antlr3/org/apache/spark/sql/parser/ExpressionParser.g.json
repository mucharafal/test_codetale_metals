[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "@hvanhovell I made the change here.\n",
    "commit": "119a055c7c3749ca6014635d280e3a28324e3b45",
    "createdAt": "2016-01-06T16:38:42Z",
    "diffHunk": "@@ -0,0 +1,509 @@\n+/**\n+   Licensed to the Apache Software Foundation (ASF) under one or more \n+   contributor license agreements.  See the NOTICE file distributed with \n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with \n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+parser grammar ExpressionParser;\n+\n+options\n+{\n+output=AST;\n+ASTLabelType=CommonTree;\n+backtrack=false;\n+k=3;\n+}\n+\n+@members {\n+  @Override\n+  public Object recoverFromMismatchedSet(IntStream input,\n+      RecognitionException re, BitSet follow) throws RecognitionException {\n+    throw re;\n+  }\n+  @Override\n+  public void displayRecognitionError(String[] tokenNames,\n+      RecognitionException e) {\n+    gParent.errors.add(new ParseError(gParent, e, tokenNames));\n+  }\n+  protected boolean useSQL11ReservedKeywordsForIdentifier() {\n+    return gParent.useSQL11ReservedKeywordsForIdentifier();\n+  }\n+}\n+\n+@rulecatch {\n+catch (RecognitionException e) {\n+  throw e;\n+}\n+}\n+\n+//-----------------------------------------------------------------------------------\n+\n+constant\n+@init { gParent.pushMsg(\"constant\", state); }\n+@after { gParent.popMsg(state); }\n+    :\n+    Number\n+    | dateLiteral\n+    | timestampLiteral\n+    | intervalLiteral\n+    | StringLiteral\n+    | stringLiteralSequence\n+    | BigintLiteral\n+    | SmallintLiteral\n+    | TinyintLiteral\n+    | DecimalLiteral\n+    | charSetStringLiteral\n+    | booleanValue\n+    ;\n+\n+stringLiteralSequence\n+    :\n+    StringLiteral StringLiteral+ -> ^(TOK_STRINGLITERALSEQUENCE StringLiteral StringLiteral+)\n+    ;\n+\n+charSetStringLiteral\n+@init { gParent.pushMsg(\"character string literal\", state); }\n+@after { gParent.popMsg(state); }\n+    :\n+    csName=CharSetName csLiteral=CharSetLiteral -> ^(TOK_CHARSETLITERAL $csName $csLiteral)\n+    ;\n+\n+dateLiteral\n+    :\n+    KW_DATE StringLiteral ->\n+    {\n+      // Create DateLiteral token, but with the text of the string value\n+      // This makes the dateLiteral more consistent with the other type literals.\n+      adaptor.create(TOK_DATELITERAL, $StringLiteral.text)\n+    }\n+    |\n+    KW_CURRENT_DATE -> ^(TOK_FUNCTION KW_CURRENT_DATE)\n+    ;\n+\n+timestampLiteral\n+    :\n+    KW_TIMESTAMP StringLiteral ->\n+    {\n+      adaptor.create(TOK_TIMESTAMPLITERAL, $StringLiteral.text)\n+    }\n+    |\n+    KW_CURRENT_TIMESTAMP -> ^(TOK_FUNCTION KW_CURRENT_TIMESTAMP)\n+    ;\n+\n+intervalLiteral\n+    :\n+    KW_INTERVAL StringLiteral qualifiers=intervalQualifiers ->\n+    {\n+      adaptor.create($qualifiers.tree.token.getType(), $StringLiteral.text)\n+    }\n+    ;\n+\n+intervalQualifiers\n+    :\n+    KW_YEAR KW_TO KW_MONTH -> TOK_INTERVAL_YEAR_MONTH_LITERAL\n+    | KW_DAY KW_TO KW_SECOND -> TOK_INTERVAL_DAY_TIME_LITERAL\n+    | KW_YEAR -> TOK_INTERVAL_YEAR_LITERAL\n+    | KW_MONTH -> TOK_INTERVAL_MONTH_LITERAL\n+    | KW_DAY -> TOK_INTERVAL_DAY_LITERAL\n+    | KW_HOUR -> TOK_INTERVAL_HOUR_LITERAL\n+    | KW_MINUTE -> TOK_INTERVAL_MINUTE_LITERAL\n+    | KW_SECOND -> TOK_INTERVAL_SECOND_LITERAL\n+    ;\n+\n+expression\n+@init { gParent.pushMsg(\"expression specification\", state); }\n+@after { gParent.popMsg(state); }\n+    :\n+    precedenceOrExpression\n+    ;\n+\n+atomExpression\n+    :\n+    (KW_NULL) => KW_NULL -> TOK_NULL\n+    | (constant) => constant\n+    | castExpression\n+    | caseExpression\n+    | whenExpression\n+    | (functionName LPAREN) => function\n+    | tableOrColumn\n+    | LPAREN! expression RPAREN!\n+    ;\n+\n+\n+precedenceFieldExpression\n+    :\n+    atomExpression ((LSQUARE^ expression RSQUARE!) | (DOT^ identifier))*\n+    ;\n+\n+precedenceUnaryOperator\n+    :\n+    PLUS | MINUS | TILDE\n+    ;\n+\n+nullCondition\n+    :\n+    KW_NULL -> ^(TOK_ISNULL)\n+    | KW_NOT KW_NULL -> ^(TOK_ISNOTNULL)\n+    ;\n+\n+precedenceUnaryPrefixExpression\n+    :\n+    (precedenceUnaryOperator^)* precedenceFieldExpression\n+    ;\n+\n+precedenceUnarySuffixExpression\n+    :\n+    (\n+    (LPAREN precedenceUnaryPrefixExpression RPAREN) => LPAREN precedenceUnaryPrefixExpression (a=KW_IS nullCondition)? RPAREN\n+    |\n+    precedenceUnaryPrefixExpression (a=KW_IS nullCondition)?"
  }],
  "prId": 10620
}]