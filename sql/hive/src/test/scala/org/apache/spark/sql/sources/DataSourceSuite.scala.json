[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This has been tested in `OrcFilterSuite` and `ParquetFilterSuite`, right? What is the goal of this test case?",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T07:29:04Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`OrcFilterSuite` and `ParquetFilterSuite` does not test `stripe` level filtering in a single file. It only filters out the file-level filtering, doesn't it?\r\n\r\nThis test suite is designed to prove that PPD on ORC data source doesn't filter out wrongly. Since ORC does not filter row-by-row, this PR check the all values of the returned stripe. **All values in the stripe exist correctly in this test case**.\r\n\r\nIIRC, this is what you requested in [SPARK-21783 Turn on ORC filter push-down by default](https://github.com/apache/spark/pull/18991). If `OrcFilterSuite` has been complete, I'm wondering what is the reason to block turning on `ORC PPD` by default.",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T09:06:51Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I do not know why we did not turn it on by default. To me, to turn it on, we need to improve the coverage. \r\n\r\nSo far, the coverage of `OrcFilterSuite ` and `ParquetFilterSuite ` are not good. They only have very basic checks. Could you improve them?\r\n\r\nFor example, adding the boundary values for these predicate pushdown in both sides? We need to ensure whether the predicates are pushed down, executed in the underlying data sources, and the filters work properly (value comparison).\r\n\r\n",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T16:36:26Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I agree with you on improving the coverage, @gatorsmile . So, I've started this and have been trying to improve this in order to find a way what you want.\r\n\r\nGiven that all the situations are the same with Parquet and ORC, what I suggested on #18991 is to turn on ORC PPD by default at least before 2.3.0 release. How do you think about that?",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T16:52:27Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Parquet is the default format. It is being used by most our Spark users. We already got many related JIRA issues and then fixed/blocked them. You were also involved in some of these PRs. \r\n\r\nTo avoid repeating the same issue in ORC, we should improve the coverage before turning on ORC predicate pushdown by default. ",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T16:58:33Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "1. Every JIRA issue in Apache Spark should have a test case to be resolved. If then, we can focus on ORC test case parity for Parquet. Adding more test cases is beyond of that scope.\r\n    > We already got many related JIRA issues and then fixed/blocked them.\r\n\r\n2. Yes. ORC is not a default format. Even worse, although a user try to use '.orc(...)`, PPD is not used by default, too. We cannot find any issues on PPD. It doesn't form a virtuous cycle at all. To be honest with you, I trust the efforts on Apache ORC community.",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T17:14:57Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I have different philosophy. I worked for mission-critical enterprise software. I do not trust anybody's codes unless they can pass the corresponding tests. \r\n\r\nThe initial ORC PPD does not have enough test coverage. To enable it by default, we should improve the test coverage now. The new test case framework for PPD should cover all the sources. We can have source-speicific ones, if it is not applicable to the other sources. ",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T17:25:57Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. This PR is based on the following your guidelines and I wish that it will continue to evolve. :)\r\n- Handle all data sources (For value ranges, I tested on Spark min/max instead of data source min/max)\r\n- Use high-level end-to-end test case\r\n\r\nFor PPD, Parquet and ORC are the only ones supporting PPD, aren't they?",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T17:39:43Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "What we didn't agree is only **the corresponding tests**.",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T17:47:13Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "So far, Parquet and ORC are the only built-in sources that support PPD. From the viewpoints of software development, we should make the test framework easily extensible. \r\n\r\nSorry, I do not think it covers what we need. First, to verify whether the underlying data source works properly, we need to have the corresponding (boundary) data (which are inserted to the sources), the predicates (which are using boundary values), and also need to ensure these predicates are pushed down and not evaluated by Spark.",
    "commit": "fb72c89478149da99bd7ac402257ab7468156f9d",
    "createdAt": "2017-09-05T18:10:25Z",
    "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.sources\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.orc.OrcConf\n+\n+import org.apache.spark.sql.{Dataset, QueryTest, Row}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.test.SQLTestUtils\n+\n+/**\n+ * Data Source qualification as Apache Spark Data Sources.\n+ * - Apache Spark Data Type Value Limits: CSV, JSON, ORC, Parquet\n+ * - Predicate Push Down: ORC\n+ */\n+class DataSourceSuite\n+  extends QueryTest\n+  with SQLTestUtils\n+  with TestHiveSingleton {\n+\n+  import testImplicits._\n+\n+  var df: Dataset[Row] = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    spark.conf.set(\"spark.sql.session.timeZone\", \"GMT\")\n+\n+    df = ((\n+      false,\n+      true,\n+      Byte.MinValue,\n+      Byte.MaxValue,\n+      Short.MinValue,\n+      Short.MaxValue,\n+      Int.MinValue,\n+      Int.MaxValue,\n+      Long.MinValue,\n+      Long.MaxValue,\n+      Float.MinValue,\n+      Float.MaxValue,\n+      Double.MinValue,\n+      Double.MaxValue,\n+      Date.valueOf(\"0001-01-01\"),\n+      Date.valueOf(\"9999-12-31\"),\n+      new Timestamp(-62135769600000L), // 0001-01-01 00:00:00.000\n+      new Timestamp(253402300799999L)  // 9999-12-31 23:59:59.999\n+    ) :: Nil).toDF()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    try {\n+      spark.conf.unset(\"spark.sql.session.timeZone\")\n+    } finally {\n+      super.afterAll()\n+    }\n+  }\n+\n+  Seq(\"parquet\", \"orc\", \"json\", \"csv\").foreach { dataSource =>\n+    test(s\"$dataSource - data type value limit\") {\n+      withTempPath { dir =>\n+        df.write.format(dataSource).save(dir.getCanonicalPath)\n+\n+        // Use the same schema for saving/loading\n+        checkAnswer(\n+          spark.read.format(dataSource).schema(df.schema).load(dir.getCanonicalPath),\n+          df)\n+\n+        // Use schema inference, but skip text-based format due to its limitation\n+        if (Seq(\"parquet\", \"orc\").contains(dataSource)) {\n+          withTable(\"tab1\") {\n+            sql(s\"CREATE TABLE tab1 USING $dataSource LOCATION '${dir.toURI}'\")\n+            checkAnswer(sql(s\"SELECT ${df.schema.fieldNames.mkString(\",\")} FROM tab1\"), df)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  Seq(\"orc\").foreach { dataSource =>\n+    test(s\"$dataSource - predicate push down\") {\n+      withSQLConf(\n+        SQLConf.ORC_FILTER_PUSHDOWN_ENABLED.key -> \"true\",\n+        SQLConf.PARQUET_FILTER_PUSHDOWN_ENABLED.key -> \"true\") {\n+        withTempPath { dir =>\n+          // write 4000 rows with the integer and the string in a single orc file with stride 1000\n+          spark\n+            .range(4000)\n+            .map(i => (i, s\"$i\"))\n+            .toDF(\"i\", \"s\")\n+            .repartition(1)\n+            .write\n+            .option(OrcConf.ROW_INDEX_STRIDE.getAttribute, 1000)\n+            // TODO: Add Parquet option, too.\n+            .format(dataSource)\n+            .save(dir.getCanonicalPath)\n+\n+          val df = spark.read.format(dataSource).load(dir.getCanonicalPath)\n+            .where(s\"i BETWEEN 1500 AND 1999\")",
    "line": 117
  }],
  "prId": 19060
}]