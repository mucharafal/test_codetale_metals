[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "We also need to test whether Hive can still read the altered table schema by using \r\n```\r\nspark.sharedState.externalCatalog.asInstanceOf[HiveExternalCatalog].client.runSqlHive\r\n```",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-08T23:49:17Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "That's not easy to do here. The catalog being updated is not the same as the one the spark session is using. You can potentially run queries against the 2.1 catalog in the test, but how do you insert data into the table? (You could run a Hive query for that to, but then what's the point?)\r\n\r\nI'd argue this kind of test should be done in `HiveDDLSuite` if it doesn't do it now; and if it's desired to test against multiple Hive versions, that it needs to be re-worked so it can be run against multiple Hive versions. But `TestHiveSingleton` makes that really hard currently, and fixing that is way beyond the scope of this change.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-09T01:20:31Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "My only comment here is to ensure the altered table is still readable by Hive.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-09T07:26:10Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "I understand, but it's really hard to write that kind of test without a serious rewrite of the tests in the hive module, so that you can have multiple `SparkSession` instances.\r\n\r\nRight now, I think the best we can achieve is \"the metastore has accepted the table so the metadata looks ok\", and assume that the tests performed elsewhere (e.g. HiveDDLSuite), where a proper `SparkSession` exists, are enough to make sure Hive can read the data.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-09T17:20:57Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I checked the test case coverage. We do not have such a check. Could you add them in the following test cases? \r\nhttps://github.com/apache/spark/blob/master/sql/hive/src/test/scala/org/apache/spark/sql/hive/execution/HiveDDLSuite.scala#L1865-L1923\r\n\r\nI think this PR is also trying to make Hive readable after Spark adds columns.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-10T18:01:22Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "> I think this PR is also trying to make Hive readable after Spark adds columns.\r\n\r\nNo, that should be the case before already. This PR is just to make the existing feature work on Hive 2.1.\r\n\r\nI really would like to avoid turning this PR into \"let's fix all the Hive tests to make sure they make sense\". If you'd like I can open a bug to track that, but that is *not* what this change is about and I'd like to keep it focused.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-10T18:05:40Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "OK, we can do it in a separate PR.",
    "commit": "c41683a907cfd9dad9b16d462e7d8f6b5f78c200",
    "createdAt": "2017-08-10T18:08:00Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import scala.language.existentials\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach}\n+\n+import org.apache.spark.{SparkConf, SparkFunSuite}\n+import org.apache.spark.launcher.SparkLauncher\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.catalog._\n+import org.apache.spark.sql.hive.{HiveExternalCatalog, HiveUtils}\n+import org.apache.spark.sql.hive.test.TestHiveSingleton\n+import org.apache.spark.sql.internal.StaticSQLConf._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.tags.ExtendedHiveTest\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * A separate set of DDL tests that uses Hive 2.1 libraries, which behave a little differently\n+ * from the built-in ones.\n+ */\n+@ExtendedHiveTest\n+class Hive_2_1_DDLSuite extends SparkFunSuite with TestHiveSingleton with BeforeAndAfterEach\n+  with BeforeAndAfterAll {\n+\n+  // Create a custom HiveExternalCatalog instance with the desired configuration. We cannot\n+  // use SparkSession here since there's already an active on managed by the TestHive object.\n+  private var catalog = {\n+    val warehouse = Utils.createTempDir()\n+    val metastore = Utils.createTempDir()\n+    metastore.delete()\n+    val sparkConf = new SparkConf()\n+      .set(SparkLauncher.SPARK_MASTER, \"local\")\n+      .set(WAREHOUSE_PATH.key, warehouse.toURI().toString())\n+      .set(CATALOG_IMPLEMENTATION.key, \"hive\")\n+      .set(HiveUtils.HIVE_METASTORE_VERSION.key, \"2.1\")\n+      .set(HiveUtils.HIVE_METASTORE_JARS.key, \"maven\")\n+\n+    val hadoopConf = new Configuration()\n+    hadoopConf.set(\"hive.metastore.warehouse.dir\", warehouse.toURI().toString())\n+    hadoopConf.set(\"javax.jdo.option.ConnectionURL\",\n+      s\"jdbc:derby:;databaseName=${metastore.getAbsolutePath()};create=true\")\n+    // These options are needed since the defaults in Hive 2.1 cause exceptions with an\n+    // empty metastore db.\n+    hadoopConf.set(\"datanucleus.schema.autoCreateAll\", \"true\")\n+    hadoopConf.set(\"hive.metastore.schema.verification\", \"false\")\n+\n+    new HiveExternalCatalog(sparkConf, hadoopConf)\n+  }\n+\n+  override def afterEach: Unit = {\n+    catalog.listTables(\"default\").foreach { t =>\n+      catalog.dropTable(\"default\", t, true, false)\n+    }\n+    spark.sessionState.catalog.reset()\n+  }\n+\n+  override def afterAll(): Unit = {\n+    catalog = null\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for non-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING json\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))),\n+      hiveCompatible = false)\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive-compatible DataSource tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) USING parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE for Hive tables\") {\n+    testAlterTable(\n+      \"t1\",\n+      \"CREATE TABLE t1 (c1 int) STORED AS parquet\",\n+      StructType(Array(StructField(\"c1\", IntegerType), StructField(\"c2\", IntegerType))))\n+  }\n+\n+  test(\"SPARK-21617: ALTER TABLE with incompatible schema on Hive-compatible table\") {\n+    val exception = intercept[AnalysisException] {\n+      testAlterTable(\n+        \"t1\",\n+        \"CREATE TABLE t1 (c1 string) USING parquet\",\n+        StructType(Array(StructField(\"c2\", IntegerType))))\n+    }\n+    assert(exception.getMessage().contains(\"types incompatible with the existing columns\"))\n+  }\n+\n+  private def testAlterTable(\n+      tableName: String,\n+      createTableStmt: String,\n+      updatedSchema: StructType,\n+      hiveCompatible: Boolean = true): Unit = {\n+    spark.sql(createTableStmt)\n+    val oldTable = spark.sessionState.catalog.externalCatalog.getTable(\"default\", tableName)\n+    catalog.createTable(oldTable, true)\n+    catalog.alterTableSchema(\"default\", tableName, updatedSchema)\n+\n+    val updatedTable = catalog.getTable(\"default\", tableName)\n+    assert(updatedTable.schema.fieldNames === updatedSchema.fieldNames)\n+\n+    val rawTable = catalog.getRawTable(\"default\", tableName)\n+    val compatibility = rawTable.properties.get(HiveExternalCatalog.DATASOURCE_HIVE_COMPATIBLE)\n+      .map(_.toBoolean).getOrElse(true)\n+    assert(hiveCompatible === compatibility)"
  }],
  "prId": 18849
}]