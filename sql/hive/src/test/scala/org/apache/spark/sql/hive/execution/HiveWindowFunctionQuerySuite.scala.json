[{
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "not related to this PR. \nmaybe we should set kryo by default, otherwise there are many tests can not generate golden answer(i have tested it locally)\n",
    "commit": "76fe1c89d5bb95a9928fe77401985889c3876864",
    "createdAt": "2015-05-05T01:52:12Z",
    "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import java.io.File\n+import java.util.{Locale, TimeZone}\n+\n+import org.apache.spark.sql.hive.test.TestHive\n+import org.apache.spark.sql.hive.test.TestHive._\n+import org.apache.spark.util.Utils\n+import org.scalatest.BeforeAndAfter\n+\n+/**\n+ * The test suite for window functions. To actually compare results with Hive,\n+ * every test should be created by `createQueryTest`. Because we are reusing tables\n+ * for different tests and there are a few properties needed to let Hive generate golden\n+ * files, every `createQueryTest` calls should explicitly set `reset` to `false`.\n+ */\n+abstract class HiveWindowFunctionQueryBaseSuite extends HiveComparisonTest with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._\n+\n+  override def beforeAll() {\n+    TestHive.cacheTables = true\n+    // Timezone is fixed to America/Los_Angeles for those timezone sensitive tests (timestamp_*)\n+    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n+    // Add Locale setting\n+    Locale.setDefault(Locale.US)\n+\n+    // Create the table used in windowing.q\n+    sql(\"DROP TABLE IF EXISTS part\")\n+    sql(\n+      \"\"\"\n+        |CREATE TABLE part(\n+        |  p_partkey INT,\n+        |  p_name STRING,\n+        |  p_mfgr STRING,\n+        |  p_brand STRING,\n+        |  p_type STRING,\n+        |  p_size INT,\n+        |  p_container STRING,\n+        |  p_retailprice DOUBLE,\n+        |  p_comment STRING)\n+      \"\"\".stripMargin)\n+    val testData1 = TestHive.getHiveFile(\"data/files/part_tiny.txt\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData1' overwrite into table part\n+      \"\"\".stripMargin)\n+\n+    sql(\"DROP TABLE IF EXISTS over1k\")\n+    sql(\n+      \"\"\"\n+        |create table over1k(\n+        |  t tinyint,\n+        |  si smallint,\n+        |  i int,\n+        |  b bigint,\n+        |  f float,\n+        |  d double,\n+        |  bo boolean,\n+        |  s string,\n+        |  ts timestamp,\n+        |  dec decimal(4,2),\n+        |  bin binary)\n+        |row format delimited\n+        |fields terminated by '|'\n+      \"\"\".stripMargin)\n+    val testData2 = TestHive.getHiveFile(\"data/files/over1k\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData2' overwrite into table over1k\n+      \"\"\".stripMargin)\n+\n+    // The following settings are used for generating golden files with Hive.\n+    // We have to use kryo to correctly let Hive serialize plans with window functions.\n+    // This is used to generate golden files.\n+    sql(\"set hive.plan.serialization.format=kryo\")\n+    // Explicitly set fs to local fs.\n+    sql(s\"set fs.default.name=file://$testTempDir/\")\n+    // Ask Hive to run jobs in-process as a single map and reduce task.\n+    sql(\"set mapred.job.tracker=local\")\n+  }\n+\n+  override def afterAll() {\n+    TestHive.cacheTables = false\n+    TimeZone.setDefault(originalTimeZone)\n+    Locale.setDefault(originalLocale)\n+    TestHive.reset()\n+  }\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_multipartitioning.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by si) r,\n+      |sum(b) over (partition by s order by si) sum\n+      |from over1k\n+      |order by s, r, sum;\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* timestamp comparison issue with Hive?\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 2\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by dec desc) r,\n+      |sum(b) over (partition by s order by ts desc) as sum\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |order by s, r, sum;\n+     \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 3\",\n+    s\"\"\"\n+      |select s, sum(i) over (partition by s), sum(f) over (partition by si)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 4\",\n+    s\"\"\"\n+      |select s, rank() over (partition by s order by bo),\n+      |rank() over (partition by si order by bin desc) from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 5\",\n+    s\"\"\"\n+      |select s, sum(f) over (partition by i), row_number() over (order by f)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 6\",\n+    s\"\"\"\n+      |select s, rank() over w1,\n+      |rank() over w2\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |window\n+      |w1 as (partition by s order by dec),\n+      |w2 as (partition by si order by f) ;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_navfn.q\n+  // Results of the original query file are not deterministic.\n+  // Also, the original query of\n+  // select i, lead(s) over (partition by bin order by d,i desc) from over1k ;\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_navfn.q (deterministic)\",\n+    s\"\"\"\n+      |select s, row_number() over (partition by d order by dec) rn from over1k\n+      |order by s, rn desc;\n+      |select i, lead(s) over (partition by cast(bin as string) order by d,i desc) as l\n+      |from over1k\n+      |order by i desc, l;\n+      |select i, lag(dec) over (partition by i order by s,i,dec) l from over1k\n+      |order by i, l;\n+      |select s, last_value(t) over (partition by d order by f) l from over1k\n+      |order by s, l;\n+      |select s, first_value(s) over (partition by bo order by s) f from over1k\n+      |order by s, f;\n+      |select t, s, i, last_value(i) over (partition by t order by s)\n+      |from over1k where (s = 'oscar allen' or s = 'oscar carson') and t = 10;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_ntile.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_ntile.q (deterministic)\",\n+    s\"\"\"\n+      |select i, ntile(10) over (partition by s order by i) n from over1k\n+      |order by i, n;\n+      |select s, ntile(100) over (partition by i order by s) n from over1k\n+      |order by s, n;\n+      |select f, ntile(4) over (partition by d order by f) n from over1k\n+      |order by f, n;\n+      |select d, ntile(1000) over (partition by dec order by d) n from over1k\n+      |order by d, n;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_udaf.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_udaf.q (deterministic)\",\n+    s\"\"\"\n+      |select s, min(i) over (partition by s) m from over1k\n+      |order by s, m;\n+      |select s, avg(f) over (partition by si order by s) a from over1k\n+      |order by s, a;\n+      |select s, avg(i) over (partition by t, b order by s) a from over1k\n+      |order by s, a;\n+      |select max(i) over w m from over1k\n+      |order by m window w as (partition by f) ;\n+      |select s, avg(d) over (partition by t order by f) a from over1k\n+      |order by s, a;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_windowspec.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_windowspec.q (deterministic)\",\n+    s\"\"\"\n+      |select s, sum(b) over (partition by i order by s,b rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over (partition by d order by s,f rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over\n+      |(partition by ts order by f range between current row and unbounded following) as sum\n+      |from over1k order by s, sum;\n+      |select s, avg(f)\n+      |over (partition by ts order by s,f rows between current row and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, avg(d) over\n+      |(partition by t order by s,d desc rows between 5 preceding and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, sum(i) over(partition by ts order by s) sum from over1k\n+      |order by s, sum;\n+      |select f, sum(f) over\n+      |(partition by ts order by f range between unbounded preceding and current row) sum\n+      |from over1k order by f, sum;\n+      |select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) avg\n+      |from over1k order by s, i, avg;\n+      |select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) avg\n+      |from over1k\n+      |order by s, i, avg window w1 as (partition by s order by i);\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_rank.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_rank.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s, rank() over (partition by f order by t) r from over1k order by s, r;\n+      |select s, dense_rank() over (partition by ts order by i,s desc) as r from over1k\n+      |order by s desc, r desc;\n+      |select s, cume_dist() over (partition by bo order by b,s) cd from over1k\n+      |order by s, cd;\n+      |select s, percent_rank() over (partition by dec order by f) r from over1k\n+      |order by s desc, r desc;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 2\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk =  1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 3\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where dec = 89.5\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 4\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |             where other.t < 10\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk = 1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests from windowing.q\n+  // We port tests in windowing.q to here because this query file contains too\n+  // many tests and the syntax of test \"-- 7. testJoinWithWindowingAndPTF\"\n+  // is not supported right now.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing.q -- 1. testWindowing\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over\n+      |(distribute by p_mfgr sort by p_name rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 2. testGroupByWithPartitioning\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name)as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 3. testGroupByHavingWithSWQ\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 4. testCount\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 5. testCountWithWindowingUDAF\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 6. testCountInSubQ\",\n+    s\"\"\"\n+      |select sub1.r, sub1.dr, sub1.cd, sub1.s1, sub1.deltaSz\n+      |from (select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |) sub1\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 8. testMixedCaseAlias\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name, p_size desc) as R\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 9. testHavingWithWindowingNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row)  as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 10. testHavingWithWindowingCondRankNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 11. testFirstLast\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1  as f,\n+      |last_value(p_size, false) over w1  as l\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 12. testFirstLastWithWhere\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1 as f,\n+      |last_value(p_size, false) over w1 as l\n+      |from part\n+      |where p_mfgr = 'Manufacturer#3'\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 13. testSumWindow\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over (distribute by p_mfgr  sort by p_name\n+      |rows between current row and current row)  as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr  sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 14. testNoSortClause\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 15. testExpressions\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |percent_rank() over(distribute by p_mfgr sort by p_name) as pr,\n+      |ntile(3) over(distribute by p_mfgr sort by p_name) as nt,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |avg(p_size) over(distribute by p_mfgr sort by p_name) as avg,\n+      |stddev(p_size) over(distribute by p_mfgr sort by p_name) as st,\n+      |first_value(p_size % 5) over(distribute by p_mfgr sort by p_name) as fv,\n+      |last_value(p_size) over(distribute by p_mfgr sort by p_name) as lv,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 16. testMultipleWindows\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |range between unbounded preceding and current row) as s1,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 5 preceding and current row) as s2,\n+      |first_value(p_size) over w1  as fv1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+\n+  createQueryTest(\"windowing.q -- 17. testCountStar\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |count(*) over(distribute by p_mfgr sort by p_name ) as c,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 18. testUDAFs\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) over w1 as mi,\n+      |max(p_retailprice) over w1 as ma,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 19. testUDAFsWithGBY\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size, p_retailprice,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) as mi ,\n+      |max(p_retailprice) as ma ,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |group by p_mfgr,p_name, p_size, p_retailprice\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following);\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 20. testSTATs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |stddev(p_retailprice) over w1 as sdev,\n+      |stddev_pop(p_retailprice) over w1 as sdev_pop,\n+      |collect_set(p_size) over w1 as uniq_size,\n+      |variance(p_retailprice) over w1 as var,\n+      |corr(p_size, p_retailprice) over w1 as cor,\n+      |covar_pop(p_size, p_retailprice) over w1 as covarp\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 21. testDISTs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |histogram_numeric(p_retailprice, 5) over w1 as hist,\n+      |percentile(p_partkey, 0.5) over w1 as per,\n+      |row_number() over(distribute by p_mfgr sort by p_name) as rn\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 24. testLateralViews\",\n+    \"\"\"\n+      |select p_mfgr, p_name,\n+      |lv_col, p_size, sum(p_size) over w1   as s\n+      |from (select p_mfgr, p_name, p_size, array(1,2,3) arr from part) p\n+      |lateral view explode(arr) part_lv as lv_col\n+      |window w1 as (distribute by p_mfgr sort by p_size, lv_col\n+      |             rows between 2 preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 26. testGroupByHavingWithSWQAndAlias\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice) as mi,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 27. testMultipleRangeWindows\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 10 preceding and current row) as s2,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between current row and 10 following )  as s1\n+      |from part\n+      |window w1 as (rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 28. testPartOrderInUDAFInvoke\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over (partition by p_mfgr  order by p_name\n+      |rows between 2 preceding and 2 following) as s\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 29. testPartOrderInWdwDef\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (partition by p_mfgr  order by p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 30. testDefaultPartitioningSpecRules\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following),\n+      |       w2 as (partition by p_mfgr order by p_name)\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 31. testWindowCrossReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w1\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 32. testWindowInheritance\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as (w1 rows between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 33. testWindowForwardReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over w3 as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 34. testWindowDefinitionPropagation\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over (w3 rows between 2 preceding and 2 following)  as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* Seems Hive evaluate SELECT DISTINCT before window functions?\n+  createQueryTest(\"windowing.q -- 35. testDistinctWithWindowing\",\n+    \"\"\"\n+      |select DISTINCT p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing.q -- 36. testRankWithPartitioning\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over (partition by p_mfgr order by p_name )  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 37. testPartitioningVariousForms\",\n+    \"\"\"\n+      |select p_mfgr,\n+      |round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,\n+      |min(p_retailprice) over (partition by p_mfgr) as s2,\n+      |max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,\n+      |round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,\n+      |count(p_retailprice) over (cluster by p_mfgr ) as s5\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 38. testPartitioningVariousForms2\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (partition by p_mfgr, p_name order by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s1,\n+      |min(p_retailprice) over (distribute by p_mfgr, p_name sort by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s2,\n+      |max(p_retailprice) over (partition by p_mfgr, p_name order by p_name) as s3\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 39. testUDFOnOrderCols\",\n+    \"\"\"\n+      |select p_mfgr, p_type, substr(p_type, 2) as short_ptype,\n+      |rank() over (partition by p_mfgr order by substr(p_type, 2))  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 40. testNoBetweenForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 41. testNoBetweenForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size range unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 42. testUnboundedFollowingForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 43. testUnboundedFollowingForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size\n+      |range between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 44. testOverNoPartitionSingleAggregate\",\n+    \"\"\"\n+      |select p_name, p_retailprice,\n+      |round(avg(p_retailprice) over(),2)\n+      |from part\n+      |order by p_name\n+    \"\"\".stripMargin, reset = false)\n+}\n+\n+class HiveWindowFunctionQueryWithoutCodeGenSuite extends HiveWindowFunctionQueryBaseSuite {\n+  var originalCodegenEnabled: Boolean = _\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    originalCodegenEnabled = conf.codegenEnabled\n+    sql(\"set spark.sql.codegen=false\")\n+  }\n+\n+  override def afterAll(): Unit = {\n+    sql(s\"set spark.sql.codegen=$originalCodegenEnabled\")\n+    super.afterAll()\n+  }\n+}\n+\n+abstract class HiveWindowFunctionQueryFileBaseSuite\n+  extends HiveCompatibilitySuite with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._\n+\n+  override def beforeAll() {\n+    TestHive.cacheTables = true\n+    // Timezone is fixed to America/Los_Angeles for those timezone sensitive tests (timestamp_*)\n+    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n+    // Add Locale setting\n+    Locale.setDefault(Locale.US)\n+\n+    // The following settings are used for generating golden files with Hive.\n+    // We have to use kryo to correctly let Hive serialize plans with window functions.\n+    // This is used to generate golden files.\n+    sql(\"set hive.plan.serialization.format=kryo\")",
    "line": 95
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "I think if we use `javaXML`, developers do not need to download Hive jars published for Spark (those `0.13.1a` jars) and they can still use regular Hive distribution. \nBasically, if `javaXML` works, it does not require any extra setup. If we set it to kryo, developers have to follow the setup instructions in https://github.com/apache/spark/tree/master/sql.\n",
    "commit": "76fe1c89d5bb95a9928fe77401985889c3876864",
    "createdAt": "2015-05-05T17:35:13Z",
    "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import java.io.File\n+import java.util.{Locale, TimeZone}\n+\n+import org.apache.spark.sql.hive.test.TestHive\n+import org.apache.spark.sql.hive.test.TestHive._\n+import org.apache.spark.util.Utils\n+import org.scalatest.BeforeAndAfter\n+\n+/**\n+ * The test suite for window functions. To actually compare results with Hive,\n+ * every test should be created by `createQueryTest`. Because we are reusing tables\n+ * for different tests and there are a few properties needed to let Hive generate golden\n+ * files, every `createQueryTest` calls should explicitly set `reset` to `false`.\n+ */\n+abstract class HiveWindowFunctionQueryBaseSuite extends HiveComparisonTest with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._\n+\n+  override def beforeAll() {\n+    TestHive.cacheTables = true\n+    // Timezone is fixed to America/Los_Angeles for those timezone sensitive tests (timestamp_*)\n+    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n+    // Add Locale setting\n+    Locale.setDefault(Locale.US)\n+\n+    // Create the table used in windowing.q\n+    sql(\"DROP TABLE IF EXISTS part\")\n+    sql(\n+      \"\"\"\n+        |CREATE TABLE part(\n+        |  p_partkey INT,\n+        |  p_name STRING,\n+        |  p_mfgr STRING,\n+        |  p_brand STRING,\n+        |  p_type STRING,\n+        |  p_size INT,\n+        |  p_container STRING,\n+        |  p_retailprice DOUBLE,\n+        |  p_comment STRING)\n+      \"\"\".stripMargin)\n+    val testData1 = TestHive.getHiveFile(\"data/files/part_tiny.txt\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData1' overwrite into table part\n+      \"\"\".stripMargin)\n+\n+    sql(\"DROP TABLE IF EXISTS over1k\")\n+    sql(\n+      \"\"\"\n+        |create table over1k(\n+        |  t tinyint,\n+        |  si smallint,\n+        |  i int,\n+        |  b bigint,\n+        |  f float,\n+        |  d double,\n+        |  bo boolean,\n+        |  s string,\n+        |  ts timestamp,\n+        |  dec decimal(4,2),\n+        |  bin binary)\n+        |row format delimited\n+        |fields terminated by '|'\n+      \"\"\".stripMargin)\n+    val testData2 = TestHive.getHiveFile(\"data/files/over1k\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData2' overwrite into table over1k\n+      \"\"\".stripMargin)\n+\n+    // The following settings are used for generating golden files with Hive.\n+    // We have to use kryo to correctly let Hive serialize plans with window functions.\n+    // This is used to generate golden files.\n+    sql(\"set hive.plan.serialization.format=kryo\")\n+    // Explicitly set fs to local fs.\n+    sql(s\"set fs.default.name=file://$testTempDir/\")\n+    // Ask Hive to run jobs in-process as a single map and reduce task.\n+    sql(\"set mapred.job.tracker=local\")\n+  }\n+\n+  override def afterAll() {\n+    TestHive.cacheTables = false\n+    TimeZone.setDefault(originalTimeZone)\n+    Locale.setDefault(originalLocale)\n+    TestHive.reset()\n+  }\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_multipartitioning.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by si) r,\n+      |sum(b) over (partition by s order by si) sum\n+      |from over1k\n+      |order by s, r, sum;\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* timestamp comparison issue with Hive?\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 2\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by dec desc) r,\n+      |sum(b) over (partition by s order by ts desc) as sum\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |order by s, r, sum;\n+     \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 3\",\n+    s\"\"\"\n+      |select s, sum(i) over (partition by s), sum(f) over (partition by si)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 4\",\n+    s\"\"\"\n+      |select s, rank() over (partition by s order by bo),\n+      |rank() over (partition by si order by bin desc) from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 5\",\n+    s\"\"\"\n+      |select s, sum(f) over (partition by i), row_number() over (order by f)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 6\",\n+    s\"\"\"\n+      |select s, rank() over w1,\n+      |rank() over w2\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |window\n+      |w1 as (partition by s order by dec),\n+      |w2 as (partition by si order by f) ;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_navfn.q\n+  // Results of the original query file are not deterministic.\n+  // Also, the original query of\n+  // select i, lead(s) over (partition by bin order by d,i desc) from over1k ;\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_navfn.q (deterministic)\",\n+    s\"\"\"\n+      |select s, row_number() over (partition by d order by dec) rn from over1k\n+      |order by s, rn desc;\n+      |select i, lead(s) over (partition by cast(bin as string) order by d,i desc) as l\n+      |from over1k\n+      |order by i desc, l;\n+      |select i, lag(dec) over (partition by i order by s,i,dec) l from over1k\n+      |order by i, l;\n+      |select s, last_value(t) over (partition by d order by f) l from over1k\n+      |order by s, l;\n+      |select s, first_value(s) over (partition by bo order by s) f from over1k\n+      |order by s, f;\n+      |select t, s, i, last_value(i) over (partition by t order by s)\n+      |from over1k where (s = 'oscar allen' or s = 'oscar carson') and t = 10;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_ntile.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_ntile.q (deterministic)\",\n+    s\"\"\"\n+      |select i, ntile(10) over (partition by s order by i) n from over1k\n+      |order by i, n;\n+      |select s, ntile(100) over (partition by i order by s) n from over1k\n+      |order by s, n;\n+      |select f, ntile(4) over (partition by d order by f) n from over1k\n+      |order by f, n;\n+      |select d, ntile(1000) over (partition by dec order by d) n from over1k\n+      |order by d, n;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_udaf.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_udaf.q (deterministic)\",\n+    s\"\"\"\n+      |select s, min(i) over (partition by s) m from over1k\n+      |order by s, m;\n+      |select s, avg(f) over (partition by si order by s) a from over1k\n+      |order by s, a;\n+      |select s, avg(i) over (partition by t, b order by s) a from over1k\n+      |order by s, a;\n+      |select max(i) over w m from over1k\n+      |order by m window w as (partition by f) ;\n+      |select s, avg(d) over (partition by t order by f) a from over1k\n+      |order by s, a;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_windowspec.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_windowspec.q (deterministic)\",\n+    s\"\"\"\n+      |select s, sum(b) over (partition by i order by s,b rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over (partition by d order by s,f rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over\n+      |(partition by ts order by f range between current row and unbounded following) as sum\n+      |from over1k order by s, sum;\n+      |select s, avg(f)\n+      |over (partition by ts order by s,f rows between current row and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, avg(d) over\n+      |(partition by t order by s,d desc rows between 5 preceding and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, sum(i) over(partition by ts order by s) sum from over1k\n+      |order by s, sum;\n+      |select f, sum(f) over\n+      |(partition by ts order by f range between unbounded preceding and current row) sum\n+      |from over1k order by f, sum;\n+      |select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) avg\n+      |from over1k order by s, i, avg;\n+      |select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) avg\n+      |from over1k\n+      |order by s, i, avg window w1 as (partition by s order by i);\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_rank.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_rank.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s, rank() over (partition by f order by t) r from over1k order by s, r;\n+      |select s, dense_rank() over (partition by ts order by i,s desc) as r from over1k\n+      |order by s desc, r desc;\n+      |select s, cume_dist() over (partition by bo order by b,s) cd from over1k\n+      |order by s, cd;\n+      |select s, percent_rank() over (partition by dec order by f) r from over1k\n+      |order by s desc, r desc;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 2\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk =  1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 3\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where dec = 89.5\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 4\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |             where other.t < 10\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk = 1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests from windowing.q\n+  // We port tests in windowing.q to here because this query file contains too\n+  // many tests and the syntax of test \"-- 7. testJoinWithWindowingAndPTF\"\n+  // is not supported right now.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing.q -- 1. testWindowing\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over\n+      |(distribute by p_mfgr sort by p_name rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 2. testGroupByWithPartitioning\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name)as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 3. testGroupByHavingWithSWQ\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 4. testCount\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 5. testCountWithWindowingUDAF\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 6. testCountInSubQ\",\n+    s\"\"\"\n+      |select sub1.r, sub1.dr, sub1.cd, sub1.s1, sub1.deltaSz\n+      |from (select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |) sub1\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 8. testMixedCaseAlias\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name, p_size desc) as R\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 9. testHavingWithWindowingNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row)  as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 10. testHavingWithWindowingCondRankNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 11. testFirstLast\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1  as f,\n+      |last_value(p_size, false) over w1  as l\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 12. testFirstLastWithWhere\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1 as f,\n+      |last_value(p_size, false) over w1 as l\n+      |from part\n+      |where p_mfgr = 'Manufacturer#3'\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 13. testSumWindow\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over (distribute by p_mfgr  sort by p_name\n+      |rows between current row and current row)  as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr  sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 14. testNoSortClause\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 15. testExpressions\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |percent_rank() over(distribute by p_mfgr sort by p_name) as pr,\n+      |ntile(3) over(distribute by p_mfgr sort by p_name) as nt,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |avg(p_size) over(distribute by p_mfgr sort by p_name) as avg,\n+      |stddev(p_size) over(distribute by p_mfgr sort by p_name) as st,\n+      |first_value(p_size % 5) over(distribute by p_mfgr sort by p_name) as fv,\n+      |last_value(p_size) over(distribute by p_mfgr sort by p_name) as lv,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 16. testMultipleWindows\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |range between unbounded preceding and current row) as s1,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 5 preceding and current row) as s2,\n+      |first_value(p_size) over w1  as fv1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+\n+  createQueryTest(\"windowing.q -- 17. testCountStar\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |count(*) over(distribute by p_mfgr sort by p_name ) as c,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 18. testUDAFs\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) over w1 as mi,\n+      |max(p_retailprice) over w1 as ma,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 19. testUDAFsWithGBY\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size, p_retailprice,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) as mi ,\n+      |max(p_retailprice) as ma ,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |group by p_mfgr,p_name, p_size, p_retailprice\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following);\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 20. testSTATs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |stddev(p_retailprice) over w1 as sdev,\n+      |stddev_pop(p_retailprice) over w1 as sdev_pop,\n+      |collect_set(p_size) over w1 as uniq_size,\n+      |variance(p_retailprice) over w1 as var,\n+      |corr(p_size, p_retailprice) over w1 as cor,\n+      |covar_pop(p_size, p_retailprice) over w1 as covarp\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 21. testDISTs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |histogram_numeric(p_retailprice, 5) over w1 as hist,\n+      |percentile(p_partkey, 0.5) over w1 as per,\n+      |row_number() over(distribute by p_mfgr sort by p_name) as rn\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 24. testLateralViews\",\n+    \"\"\"\n+      |select p_mfgr, p_name,\n+      |lv_col, p_size, sum(p_size) over w1   as s\n+      |from (select p_mfgr, p_name, p_size, array(1,2,3) arr from part) p\n+      |lateral view explode(arr) part_lv as lv_col\n+      |window w1 as (distribute by p_mfgr sort by p_size, lv_col\n+      |             rows between 2 preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 26. testGroupByHavingWithSWQAndAlias\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice) as mi,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 27. testMultipleRangeWindows\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 10 preceding and current row) as s2,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between current row and 10 following )  as s1\n+      |from part\n+      |window w1 as (rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 28. testPartOrderInUDAFInvoke\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over (partition by p_mfgr  order by p_name\n+      |rows between 2 preceding and 2 following) as s\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 29. testPartOrderInWdwDef\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (partition by p_mfgr  order by p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 30. testDefaultPartitioningSpecRules\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following),\n+      |       w2 as (partition by p_mfgr order by p_name)\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 31. testWindowCrossReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w1\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 32. testWindowInheritance\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as (w1 rows between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 33. testWindowForwardReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over w3 as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 34. testWindowDefinitionPropagation\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over (w3 rows between 2 preceding and 2 following)  as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* Seems Hive evaluate SELECT DISTINCT before window functions?\n+  createQueryTest(\"windowing.q -- 35. testDistinctWithWindowing\",\n+    \"\"\"\n+      |select DISTINCT p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing.q -- 36. testRankWithPartitioning\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over (partition by p_mfgr order by p_name )  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 37. testPartitioningVariousForms\",\n+    \"\"\"\n+      |select p_mfgr,\n+      |round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,\n+      |min(p_retailprice) over (partition by p_mfgr) as s2,\n+      |max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,\n+      |round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,\n+      |count(p_retailprice) over (cluster by p_mfgr ) as s5\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 38. testPartitioningVariousForms2\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (partition by p_mfgr, p_name order by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s1,\n+      |min(p_retailprice) over (distribute by p_mfgr, p_name sort by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s2,\n+      |max(p_retailprice) over (partition by p_mfgr, p_name order by p_name) as s3\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 39. testUDFOnOrderCols\",\n+    \"\"\"\n+      |select p_mfgr, p_type, substr(p_type, 2) as short_ptype,\n+      |rank() over (partition by p_mfgr order by substr(p_type, 2))  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 40. testNoBetweenForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 41. testNoBetweenForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size range unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 42. testUnboundedFollowingForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 43. testUnboundedFollowingForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size\n+      |range between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 44. testOverNoPartitionSingleAggregate\",\n+    \"\"\"\n+      |select p_name, p_retailprice,\n+      |round(avg(p_retailprice) over(),2)\n+      |from part\n+      |order by p_name\n+    \"\"\".stripMargin, reset = false)\n+}\n+\n+class HiveWindowFunctionQueryWithoutCodeGenSuite extends HiveWindowFunctionQueryBaseSuite {\n+  var originalCodegenEnabled: Boolean = _\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    originalCodegenEnabled = conf.codegenEnabled\n+    sql(\"set spark.sql.codegen=false\")\n+  }\n+\n+  override def afterAll(): Unit = {\n+    sql(s\"set spark.sql.codegen=$originalCodegenEnabled\")\n+    super.afterAll()\n+  }\n+}\n+\n+abstract class HiveWindowFunctionQueryFileBaseSuite\n+  extends HiveCompatibilitySuite with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._\n+\n+  override def beforeAll() {\n+    TestHive.cacheTables = true\n+    // Timezone is fixed to America/Los_Angeles for those timezone sensitive tests (timestamp_*)\n+    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n+    // Add Locale setting\n+    Locale.setDefault(Locale.US)\n+\n+    // The following settings are used for generating golden files with Hive.\n+    // We have to use kryo to correctly let Hive serialize plans with window functions.\n+    // This is used to generate golden files.\n+    sql(\"set hive.plan.serialization.format=kryo\")",
    "line": 95
  }],
  "prId": 5604
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "do not need this implicit in this file\n",
    "commit": "76fe1c89d5bb95a9928fe77401985889c3876864",
    "createdAt": "2015-05-05T01:54:02Z",
    "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import java.io.File\n+import java.util.{Locale, TimeZone}\n+\n+import org.apache.spark.sql.hive.test.TestHive\n+import org.apache.spark.sql.hive.test.TestHive._\n+import org.apache.spark.util.Utils\n+import org.scalatest.BeforeAndAfter\n+\n+/**\n+ * The test suite for window functions. To actually compare results with Hive,\n+ * every test should be created by `createQueryTest`. Because we are reusing tables\n+ * for different tests and there are a few properties needed to let Hive generate golden\n+ * files, every `createQueryTest` calls should explicitly set `reset` to `false`.\n+ */\n+abstract class HiveWindowFunctionQueryBaseSuite extends HiveComparisonTest with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._\n+\n+  override def beforeAll() {\n+    TestHive.cacheTables = true\n+    // Timezone is fixed to America/Los_Angeles for those timezone sensitive tests (timestamp_*)\n+    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Los_Angeles\"))\n+    // Add Locale setting\n+    Locale.setDefault(Locale.US)\n+\n+    // Create the table used in windowing.q\n+    sql(\"DROP TABLE IF EXISTS part\")\n+    sql(\n+      \"\"\"\n+        |CREATE TABLE part(\n+        |  p_partkey INT,\n+        |  p_name STRING,\n+        |  p_mfgr STRING,\n+        |  p_brand STRING,\n+        |  p_type STRING,\n+        |  p_size INT,\n+        |  p_container STRING,\n+        |  p_retailprice DOUBLE,\n+        |  p_comment STRING)\n+      \"\"\".stripMargin)\n+    val testData1 = TestHive.getHiveFile(\"data/files/part_tiny.txt\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData1' overwrite into table part\n+      \"\"\".stripMargin)\n+\n+    sql(\"DROP TABLE IF EXISTS over1k\")\n+    sql(\n+      \"\"\"\n+        |create table over1k(\n+        |  t tinyint,\n+        |  si smallint,\n+        |  i int,\n+        |  b bigint,\n+        |  f float,\n+        |  d double,\n+        |  bo boolean,\n+        |  s string,\n+        |  ts timestamp,\n+        |  dec decimal(4,2),\n+        |  bin binary)\n+        |row format delimited\n+        |fields terminated by '|'\n+      \"\"\".stripMargin)\n+    val testData2 = TestHive.getHiveFile(\"data/files/over1k\").getCanonicalPath\n+    sql(\n+      s\"\"\"\n+        |LOAD DATA LOCAL INPATH '$testData2' overwrite into table over1k\n+      \"\"\".stripMargin)\n+\n+    // The following settings are used for generating golden files with Hive.\n+    // We have to use kryo to correctly let Hive serialize plans with window functions.\n+    // This is used to generate golden files.\n+    sql(\"set hive.plan.serialization.format=kryo\")\n+    // Explicitly set fs to local fs.\n+    sql(s\"set fs.default.name=file://$testTempDir/\")\n+    // Ask Hive to run jobs in-process as a single map and reduce task.\n+    sql(\"set mapred.job.tracker=local\")\n+  }\n+\n+  override def afterAll() {\n+    TestHive.cacheTables = false\n+    TimeZone.setDefault(originalTimeZone)\n+    Locale.setDefault(originalLocale)\n+    TestHive.reset()\n+  }\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_multipartitioning.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by si) r,\n+      |sum(b) over (partition by s order by si) sum\n+      |from over1k\n+      |order by s, r, sum;\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* timestamp comparison issue with Hive?\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 2\",\n+    s\"\"\"\n+      |select s,\n+      |rank() over (partition by s order by dec desc) r,\n+      |sum(b) over (partition by s order by ts desc) as sum\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |order by s, r, sum;\n+     \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 3\",\n+    s\"\"\"\n+      |select s, sum(i) over (partition by s), sum(f) over (partition by si)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 4\",\n+    s\"\"\"\n+      |select s, rank() over (partition by s order by bo),\n+      |rank() over (partition by si order by bin desc) from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 5\",\n+    s\"\"\"\n+      |select s, sum(f) over (partition by i), row_number() over (order by f)\n+      |from over1k where s = 'tom allen' or s = 'bob steinbeck';\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_multipartitioning.q (deterministic) 6\",\n+    s\"\"\"\n+      |select s, rank() over w1,\n+      |rank() over w2\n+      |from over1k\n+      |where s = 'tom allen' or s = 'bob steinbeck'\n+      |window\n+      |w1 as (partition by s order by dec),\n+      |w2 as (partition by si order by f) ;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_navfn.q\n+  // Results of the original query file are not deterministic.\n+  // Also, the original query of\n+  // select i, lead(s) over (partition by bin order by d,i desc) from over1k ;\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_navfn.q (deterministic)\",\n+    s\"\"\"\n+      |select s, row_number() over (partition by d order by dec) rn from over1k\n+      |order by s, rn desc;\n+      |select i, lead(s) over (partition by cast(bin as string) order by d,i desc) as l\n+      |from over1k\n+      |order by i desc, l;\n+      |select i, lag(dec) over (partition by i order by s,i,dec) l from over1k\n+      |order by i, l;\n+      |select s, last_value(t) over (partition by d order by f) l from over1k\n+      |order by s, l;\n+      |select s, first_value(s) over (partition by bo order by s) f from over1k\n+      |order by s, f;\n+      |select t, s, i, last_value(i) over (partition by t order by s)\n+      |from over1k where (s = 'oscar allen' or s = 'oscar carson') and t = 10;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_ntile.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_ntile.q (deterministic)\",\n+    s\"\"\"\n+      |select i, ntile(10) over (partition by s order by i) n from over1k\n+      |order by i, n;\n+      |select s, ntile(100) over (partition by i order by s) n from over1k\n+      |order by s, n;\n+      |select f, ntile(4) over (partition by d order by f) n from over1k\n+      |order by f, n;\n+      |select d, ntile(1000) over (partition by dec order by d) n from over1k\n+      |order by d, n;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_udaf.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_udaf.q (deterministic)\",\n+    s\"\"\"\n+      |select s, min(i) over (partition by s) m from over1k\n+      |order by s, m;\n+      |select s, avg(f) over (partition by si order by s) a from over1k\n+      |order by s, a;\n+      |select s, avg(i) over (partition by t, b order by s) a from over1k\n+      |order by s, a;\n+      |select max(i) over w m from over1k\n+      |order by m window w as (partition by f) ;\n+      |select s, avg(d) over (partition by t order by f) a from over1k\n+      |order by s, a;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_windowspec.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_windowspec.q (deterministic)\",\n+    s\"\"\"\n+      |select s, sum(b) over (partition by i order by s,b rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over (partition by d order by s,f rows unbounded preceding) as sum\n+      |from over1k order by s, sum;\n+      |select s, sum(f) over\n+      |(partition by ts order by f range between current row and unbounded following) as sum\n+      |from over1k order by s, sum;\n+      |select s, avg(f)\n+      |over (partition by ts order by s,f rows between current row and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, avg(d) over\n+      |(partition by t order by s,d desc rows between 5 preceding and 5 following) avg\n+      |from over1k order by s, avg;\n+      |select s, sum(i) over(partition by ts order by s) sum from over1k\n+      |order by s, sum;\n+      |select f, sum(f) over\n+      |(partition by ts order by f range between unbounded preceding and current row) sum\n+      |from over1k order by f, sum;\n+      |select s, i, round(avg(d) over (partition by s order by i) / 10.0 , 2) avg\n+      |from over1k order by s, i, avg;\n+      |select s, i, round((avg(d) over  w1 + 10.0) - (avg(d) over w1 - 10.0),2) avg\n+      |from over1k\n+      |order by s, i, avg window w1 as (partition by s order by i);\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests based on windowing_rank.q\n+  // Results of the original query file are not deterministic.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing_rank.q (deterministic) 1\",\n+    s\"\"\"\n+      |select s, rank() over (partition by f order by t) r from over1k order by s, r;\n+      |select s, dense_rank() over (partition by ts order by i,s desc) as r from over1k\n+      |order by s desc, r desc;\n+      |select s, cume_dist() over (partition by bo order by b,s) cd from over1k\n+      |order by s, cd;\n+      |select s, percent_rank() over (partition by dec order by f) r from over1k\n+      |order by s desc, r desc;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 2\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk =  1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 3\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |            ) joined\n+      |  ) ranked\n+      |where dec = 89.5\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing_rank.q (deterministic) 4\",\n+    s\"\"\"\n+      |select ts, dec, rnk\n+      |from\n+      |  (select ts, dec,\n+      |          rank() over (partition by ts order by dec)  as rnk\n+      |          from\n+      |            (select other.ts, other.dec\n+      |             from over1k other\n+      |             join over1k on (other.b = over1k.b)\n+      |             where other.t < 10\n+      |            ) joined\n+      |  ) ranked\n+      |where rnk = 1\n+      |order by ts, dec, rnk;\n+     \"\"\".stripMargin, reset = false)\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+  // Tests from windowing.q\n+  // We port tests in windowing.q to here because this query file contains too\n+  // many tests and the syntax of test \"-- 7. testJoinWithWindowingAndPTF\"\n+  // is not supported right now.\n+  /////////////////////////////////////////////////////////////////////////////\n+  createQueryTest(\"windowing.q -- 1. testWindowing\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over\n+      |(distribute by p_mfgr sort by p_name rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 2. testGroupByWithPartitioning\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name)as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 3. testGroupByHavingWithSWQ\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice),\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 4. testCount\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 5. testCountWithWindowingUDAF\",\n+    s\"\"\"\n+      |select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 6. testCountInSubQ\",\n+    s\"\"\"\n+      |select sub1.r, sub1.dr, sub1.cd, sub1.s1, sub1.deltaSz\n+      |from (select p_mfgr, p_name,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as cd,\n+      |p_retailprice, sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                                  rows between unbounded preceding and current row) as s1,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |) sub1\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 8. testMixedCaseAlias\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name, p_size desc) as R\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 9. testHavingWithWindowingNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row)  as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 10. testHavingWithWindowingCondRankNoGBY\",\n+    s\"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |                        rows between unbounded preceding and current row) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 11. testFirstLast\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1  as f,\n+      |last_value(p_size, false) over w1  as l\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 12. testFirstLastWithWhere\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and current row) as s2,\n+      |first_value(p_size) over w1 as f,\n+      |last_value(p_size, false) over w1 as l\n+      |from part\n+      |where p_mfgr = 'Manufacturer#3'\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 13. testSumWindow\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over (distribute by p_mfgr  sort by p_name\n+      |rows between current row and current row)  as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr  sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 14. testNoSortClause\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 15. testExpressions\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |percent_rank() over(distribute by p_mfgr sort by p_name) as pr,\n+      |ntile(3) over(distribute by p_mfgr sort by p_name) as nt,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |avg(p_size) over(distribute by p_mfgr sort by p_name) as avg,\n+      |stddev(p_size) over(distribute by p_mfgr sort by p_name) as st,\n+      |first_value(p_size % 5) over(distribute by p_mfgr sort by p_name) as fv,\n+      |last_value(p_size) over(distribute by p_mfgr sort by p_name) as lv,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 16. testMultipleWindows\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |cume_dist() over(distribute by p_mfgr sort by p_name) as cud,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_name\n+      |range between unbounded preceding and current row) as s1,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 5 preceding and current row) as s2,\n+      |first_value(p_size) over w1  as fv1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+\n+  createQueryTest(\"windowing.q -- 17. testCountStar\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |count(*) over(distribute by p_mfgr sort by p_name ) as c,\n+      |count(p_size) over(distribute by p_mfgr sort by p_name) as ca,\n+      |first_value(p_size) over w1  as fvW1\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 18. testUDAFs\",\n+    s\"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) over w1 as mi,\n+      |max(p_retailprice) over w1 as ma,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 19. testUDAFsWithGBY\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size, p_retailprice,\n+      |sum(p_retailprice) over w1 as s,\n+      |min(p_retailprice) as mi ,\n+      |max(p_retailprice) as ma ,\n+      |avg(p_retailprice) over w1 as ag\n+      |from part\n+      |group by p_mfgr,p_name, p_size, p_retailprice\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following);\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 20. testSTATs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |stddev(p_retailprice) over w1 as sdev,\n+      |stddev_pop(p_retailprice) over w1 as sdev_pop,\n+      |collect_set(p_size) over w1 as uniq_size,\n+      |variance(p_retailprice) over w1 as var,\n+      |corr(p_size, p_retailprice) over w1 as cor,\n+      |covar_pop(p_size, p_retailprice) over w1 as covarp\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 21. testDISTs\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |histogram_numeric(p_retailprice, 5) over w1 as hist,\n+      |percentile(p_partkey, 0.5) over w1 as per,\n+      |row_number() over(distribute by p_mfgr sort by p_name) as rn\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_mfgr, p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 24. testLateralViews\",\n+    \"\"\"\n+      |select p_mfgr, p_name,\n+      |lv_col, p_size, sum(p_size) over w1   as s\n+      |from (select p_mfgr, p_name, p_size, array(1,2,3) arr from part) p\n+      |lateral view explode(arr) part_lv as lv_col\n+      |window w1 as (distribute by p_mfgr sort by p_size, lv_col\n+      |             rows between 2 preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 26. testGroupByHavingWithSWQAndAlias\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size, min(p_retailprice) as mi,\n+      |rank() over(distribute by p_mfgr sort by p_name) as r,\n+      |dense_rank() over(distribute by p_mfgr sort by p_name) as dr,\n+      |p_size, p_size - lag(p_size,1,p_size) over(distribute by p_mfgr sort by p_name) as deltaSz\n+      |from part\n+      |group by p_mfgr, p_name, p_size\n+      |having p_size > 0\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 27. testMultipleRangeWindows\",\n+    \"\"\"\n+      |select  p_mfgr,p_name, p_size,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between 10 preceding and current row) as s2,\n+      |sum(p_size) over (distribute by p_mfgr sort by p_size\n+      |range between current row and 10 following )  as s1\n+      |from part\n+      |window w1 as (rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 28. testPartOrderInUDAFInvoke\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over (partition by p_mfgr  order by p_name\n+      |rows between 2 preceding and 2 following) as s\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 29. testPartOrderInWdwDef\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (partition by p_mfgr  order by p_name\n+      |             rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 30. testDefaultPartitioningSpecRules\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following),\n+      |       w2 as (partition by p_mfgr order by p_name)\n+    \"\"\".stripMargin, reset = false)\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 31. testWindowCrossReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w1\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 32. testWindowInheritance\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2\n+      |from part\n+      |window w1 as (partition by p_mfgr order by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as (w1 rows between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* p_name is not a numeric column. What is Hive's semantic?\n+  createQueryTest(\"windowing.q -- 33. testWindowForwardReference\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over w3 as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+  /*\n+  createQueryTest(\"windowing.q -- 34. testWindowDefinitionPropagation\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s1,\n+      |sum(p_size) over w2 as s2,\n+      |sum(p_size) over (w3 rows between 2 preceding and 2 following)  as s3\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name\n+      |             range between 2 preceding and 2 following),\n+      |       w2 as w3,\n+      |       w3 as (distribute by p_mfgr sort by p_name\n+      |             range between unbounded preceding and current row)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  /* Seems Hive evaluate SELECT DISTINCT before window functions?\n+  createQueryTest(\"windowing.q -- 35. testDistinctWithWindowing\",\n+    \"\"\"\n+      |select DISTINCT p_mfgr, p_name, p_size,\n+      |sum(p_size) over w1 as s\n+      |from part\n+      |window w1 as (distribute by p_mfgr sort by p_name rows between 2 preceding and 2 following)\n+    \"\"\".stripMargin, reset = false)\n+  */\n+\n+  createQueryTest(\"windowing.q -- 36. testRankWithPartitioning\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |rank() over (partition by p_mfgr order by p_name )  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 37. testPartitioningVariousForms\",\n+    \"\"\"\n+      |select p_mfgr,\n+      |round(sum(p_retailprice) over (partition by p_mfgr order by p_mfgr),2) as s1,\n+      |min(p_retailprice) over (partition by p_mfgr) as s2,\n+      |max(p_retailprice) over (distribute by p_mfgr sort by p_mfgr) as s3,\n+      |round(avg(p_retailprice) over (distribute by p_mfgr),2) as s4,\n+      |count(p_retailprice) over (cluster by p_mfgr ) as s5\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 38. testPartitioningVariousForms2\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (partition by p_mfgr, p_name order by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s1,\n+      |min(p_retailprice) over (distribute by p_mfgr, p_name sort by p_mfgr, p_name\n+      |rows between unbounded preceding and current row) as s2,\n+      |max(p_retailprice) over (partition by p_mfgr, p_name order by p_name) as s3\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 39. testUDFOnOrderCols\",\n+    \"\"\"\n+      |select p_mfgr, p_type, substr(p_type, 2) as short_ptype,\n+      |rank() over (partition by p_mfgr order by substr(p_type, 2))  as r\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 40. testNoBetweenForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name rows unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 41. testNoBetweenForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size range unbounded preceding) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 42. testUnboundedFollowingForRows\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_name\n+      |rows between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 43. testUnboundedFollowingForRange\",\n+    \"\"\"\n+      |select p_mfgr, p_name, p_size,\n+      |sum(p_retailprice) over (distribute by p_mfgr sort by p_size\n+      |range between current row and unbounded following) as s1\n+      |from part\n+    \"\"\".stripMargin, reset = false)\n+\n+  createQueryTest(\"windowing.q -- 44. testOverNoPartitionSingleAggregate\",\n+    \"\"\"\n+      |select p_name, p_retailprice,\n+      |round(avg(p_retailprice) over(),2)\n+      |from part\n+      |order by p_name\n+    \"\"\".stripMargin, reset = false)\n+}\n+\n+class HiveWindowFunctionQueryWithoutCodeGenSuite extends HiveWindowFunctionQueryBaseSuite {\n+  var originalCodegenEnabled: Boolean = _\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    originalCodegenEnabled = conf.codegenEnabled\n+    sql(\"set spark.sql.codegen=false\")\n+  }\n+\n+  override def afterAll(): Unit = {\n+    sql(s\"set spark.sql.codegen=$originalCodegenEnabled\")\n+    super.afterAll()\n+  }\n+}\n+\n+abstract class HiveWindowFunctionQueryFileBaseSuite\n+  extends HiveCompatibilitySuite with BeforeAndAfter {\n+  private val originalTimeZone = TimeZone.getDefault\n+  private val originalLocale = Locale.getDefault\n+  private val testTempDir = Utils.createTempDir()\n+\n+  import org.apache.spark.sql.hive.test.TestHive.implicits._"
  }],
  "prId": 5604
}, {
  "comments": [{
    "author": {
      "login": "scwf"
    },
    "body": "imports order\n",
    "commit": "76fe1c89d5bb95a9928fe77401985889c3876864",
    "createdAt": "2015-05-05T01:54:33Z",
    "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.hive.execution\n+\n+import java.io.File\n+import java.util.{Locale, TimeZone}\n+\n+import org.apache.spark.sql.hive.test.TestHive\n+import org.apache.spark.sql.hive.test.TestHive._\n+import org.apache.spark.util.Utils\n+import org.scalatest.BeforeAndAfter"
  }],
  "prId": 5604
}]