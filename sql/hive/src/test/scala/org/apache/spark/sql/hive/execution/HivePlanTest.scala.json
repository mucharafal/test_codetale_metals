[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Actually the trouble maker is [`PlanTest.comparePlans`](https://github.com/apache/spark/blob/master/sql/hive/src/test/scala/org/apache/spark/sql/catalyst/plans/PlanTest.scala#L50), because now `MetastoreRelation` also compares output attributes. But right now I don't have a clean solution for this. Thus, I replace the original metastore relation with a temporary relation to pass the test here.\n",
    "commit": "d0095acfb5c5e04bec0108e87b485e571aeeaf67",
    "createdAt": "2015-03-31T09:09:26Z",
    "diffHunk": "@@ -18,14 +18,18 @@\n package org.apache.spark.sql.hive.execution\n \n import org.apache.spark.sql.QueryTest\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n import org.apache.spark.sql.hive.test.TestHive\n \n class HivePlanTest extends QueryTest {\n   import TestHive._\n+  import TestHive.implicits._\n \n   test(\"udf constant folding\") {\n-    val optimized = sql(\"SELECT cos(null) FROM src\").queryExecution.optimizedPlan\n-    val correctAnswer = sql(\"SELECT cast(null as double) FROM src\").queryExecution.optimizedPlan\n+    Seq.empty[Tuple1[Int]].toDF(\"a\").registerTempTable(\"t\")\n+    val optimized = sql(\"SELECT cos(null) FROM t\").queryExecution.optimizedPlan\n+    val correctAnswer = sql(\"SELECT cast(null as double) FROM t\").queryExecution.optimizedPlan",
    "line": 11
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "I think thats actually reasonable.  Compare plans is mostly about checking plan structure.\n",
    "commit": "d0095acfb5c5e04bec0108e87b485e571aeeaf67",
    "createdAt": "2015-03-31T18:14:15Z",
    "diffHunk": "@@ -18,14 +18,18 @@\n package org.apache.spark.sql.hive.execution\n \n import org.apache.spark.sql.QueryTest\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n import org.apache.spark.sql.hive.test.TestHive\n \n class HivePlanTest extends QueryTest {\n   import TestHive._\n+  import TestHive.implicits._\n \n   test(\"udf constant folding\") {\n-    val optimized = sql(\"SELECT cos(null) FROM src\").queryExecution.optimizedPlan\n-    val correctAnswer = sql(\"SELECT cast(null as double) FROM src\").queryExecution.optimizedPlan\n+    Seq.empty[Tuple1[Int]].toDF(\"a\").registerTempTable(\"t\")\n+    val optimized = sql(\"SELECT cos(null) FROM t\").queryExecution.optimizedPlan\n+    val correctAnswer = sql(\"SELECT cast(null as double) FROM t\").queryExecution.optimizedPlan",
    "line": 11
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "I'd even be okay adding a special rule to compare plans that always replaces MetastoreRelations with LocalRelation\n",
    "commit": "d0095acfb5c5e04bec0108e87b485e571aeeaf67",
    "createdAt": "2015-03-31T18:14:52Z",
    "diffHunk": "@@ -18,14 +18,18 @@\n package org.apache.spark.sql.hive.execution\n \n import org.apache.spark.sql.QueryTest\n+import org.apache.spark.sql.catalyst.expressions.AttributeReference\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n import org.apache.spark.sql.hive.test.TestHive\n \n class HivePlanTest extends QueryTest {\n   import TestHive._\n+  import TestHive.implicits._\n \n   test(\"udf constant folding\") {\n-    val optimized = sql(\"SELECT cos(null) FROM src\").queryExecution.optimizedPlan\n-    val correctAnswer = sql(\"SELECT cast(null as double) FROM src\").queryExecution.optimizedPlan\n+    Seq.empty[Tuple1[Int]].toDF(\"a\").registerTempTable(\"t\")\n+    val optimized = sql(\"SELECT cos(null) FROM t\").queryExecution.optimizedPlan\n+    val correctAnswer = sql(\"SELECT cast(null as double) FROM t\").queryExecution.optimizedPlan",
    "line": 11
  }],
  "prId": 5289
}]