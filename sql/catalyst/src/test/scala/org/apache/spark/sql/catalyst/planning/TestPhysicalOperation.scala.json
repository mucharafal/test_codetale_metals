[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can you also show a full reproducer? How did you face such case when using exposed APIs? Catalyst is a set of private APIs.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-09-16T00:54:23Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+\n+  object InvokePhysicalOperation {\n+    def apply(plan: LogicalPlan): Seq[Expression] = plan match {\n+      case PhysicalOperation(projects, filters, _) =>\n+        filters\n+      case _ => Nil\n+    }\n+  }\n+\n+  test(\"verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReferences are same in alias map and filter condition\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField))\n+\n+    Assert.assertEquals(expectedFilters, actualFilters)\n+  }\n+\n+  test(\"SPARK-29029 verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReference's ExprId is same but qualifier is different\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField2.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField2))"
  }, {
    "author": {
      "login": "nikitagkonda"
    },
    "body": "@HyukjinKwon We have a case where we introduce a Custom logical operator for eg `CustomBarrier` in the spark logical plan merely to block some of the Spark optimization rules. However, as part of custom optimizations in `sessionState.experimentalMethods.extraOptimizations` (executed after all spark's optimization rules) we remove the custom logical operator `CustomBarrier` and after that we end up in this scenario. On digging further we found that the optimizer rule `PushDownPredicate` that handles this case was not getting triggered because of the `CustomBarrier`. Also `PushDownPredicate` is using `AttributeMap` instead of `Map[Attribute, Expression]` hence we do not see such case there and the alias is substituted properly in that case.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-09-16T18:53:29Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+\n+  object InvokePhysicalOperation {\n+    def apply(plan: LogicalPlan): Seq[Expression] = plan match {\n+      case PhysicalOperation(projects, filters, _) =>\n+        filters\n+      case _ => Nil\n+    }\n+  }\n+\n+  test(\"verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReferences are same in alias map and filter condition\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField))\n+\n+    Assert.assertEquals(expectedFilters, actualFilters)\n+  }\n+\n+  test(\"SPARK-29029 verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReference's ExprId is same but qualifier is different\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField2.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField2))"
  }, {
    "author": {
      "login": "nikitagkonda"
    },
    "body": "@HyukjinKwon I have added test suite `DataSourceStrategyWithCustomBarrierSuite` that reproduces the failing scenario. I had to keep the `CustomBarrier` in `Catalyst` package in order to demonstrate the failing scenario.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-09-18T01:43:03Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+\n+  object InvokePhysicalOperation {\n+    def apply(plan: LogicalPlan): Seq[Expression] = plan match {\n+      case PhysicalOperation(projects, filters, _) =>\n+        filters\n+      case _ => Nil\n+    }\n+  }\n+\n+  test(\"verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReferences are same in alias map and filter condition\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField))\n+\n+    Assert.assertEquals(expectedFilters, actualFilters)\n+  }\n+\n+  test(\"SPARK-29029 verify PhysicalOperation returns correct filters with substituted alias when\" +\n+    \" AttributeReference's ExprId is same but qualifier is different\") {\n+    val actualFilters = InvokePhysicalOperation(\n+      Filter(IsNotNull(longAliasField2.toAttribute),\n+        Project(Seq(longAliasField, textField),\n+          Filter(IsNotNull(dateField),\n+            testRelation))))\n+    val expectedFilters = Seq(IsNotNull(dateField), IsNotNull(longAliasField2))"
  }],
  "prId": 25761
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`PhysicalOperationSuite`",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T03:28:46Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {"
  }],
  "prId": 25761
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Can we simplify the test? I think a very obvious consequence of this bug is: we can't push down certain filters to data source. ",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T03:29:48Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+"
  }, {
    "author": {
      "login": "nikitagkonda"
    },
    "body": "@cloud-fan could you explain more on how we can simplify the test, I'm a bit unclear. Also the other two test files `DataSourceStrategyWithCustomBarrierSuite.scala` and `CustomBarrier.scala` were added only to show the full reproducer of the bug, I can remove them if they are not needed.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T04:49:46Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think he meant a test case that causes the similar failure to show it is indeed a bug within Apache Spark without external stuff.\r\n\r\nI think we should remove out such custom barriers - that's not what Apache Spark guarantees. Can we find a case where we can't push down certain filters to data source?",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T05:03:10Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ah I was wrong. Since optimizer always push filter through project, so we should never hit this bug.\r\n\r\nMaybe just remove all tests and treat it as a code cleanup.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T06:57:41Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+"
  }, {
    "author": {
      "login": "nikitagkonda"
    },
    "body": "Yes correct. Okay will remove all tests and update shortly.",
    "commit": "847c9ece22f6757162acac7b7a8981731f3573e5",
    "createdAt": "2019-11-19T15:29:03Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.junit.Assert\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Expression, ExprId, IsNotNull}\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LocalRelation, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{LongType, StringType, TimestampType}\n+\n+class TestPhysicalOperation extends SparkFunSuite {\n+  private val textField = AttributeReference(\"text1\", StringType, nullable = false)()\n+  private val dateField = AttributeReference(\"date1\", TimestampType)()\n+  private val longField = AttributeReference(\"long1\", LongType)()\n+  private val longAliasField = Alias(longField, \"long1\")(exprId = ExprId(100))\n+  private val longAliasField2 =\n+    Alias(longField, \"long1\")(exprId = ExprId(100), qualifier = Seq(\"tmp\"))\n+  private val testRelation = LocalRelation(textField, dateField, longField)\n+"
  }],
  "prId": 25761
}]