[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can we specify the byte order of `ByteBuffer` during test?",
    "commit": "53fb370d4988a4093ce3979b5dabcb0c7036a156",
    "createdAt": "2019-03-20T12:53:28Z",
    "diffHunk": "@@ -37,4 +39,47 @@ class NumberConverterSuite extends SparkFunSuite {\n     checkConv(\"11abc\", 10, 16, \"B\")\n   }\n \n+  test(\"byte to binary\") {\n+    checkToBinary(0.toByte)\n+    checkToBinary(1.toByte)\n+    checkToBinary(-1.toByte)\n+    checkToBinary(Byte.MaxValue)\n+    checkToBinary(Byte.MinValue)\n+  }\n+\n+  test(\"short to binary\") {\n+    checkToBinary(0.toShort)\n+    checkToBinary(1.toShort)\n+    checkToBinary(-1.toShort)\n+    checkToBinary(Short.MaxValue)\n+    checkToBinary(Short.MinValue)\n+  }\n+\n+  test(\"integer to binary\") {\n+    checkToBinary(0)\n+    checkToBinary(1)\n+    checkToBinary(-1)\n+    checkToBinary(Int.MaxValue)\n+    checkToBinary(Int.MinValue)\n+  }\n+\n+  test(\"long to binary\") {\n+    checkToBinary(0L)\n+    checkToBinary(1L)\n+    checkToBinary(-1L)\n+    checkToBinary(Long.MaxValue)\n+    checkToBinary(Long.MinValue)\n+  }\n+\n+  def checkToBinary[T](in: T): Unit = in match {\n+    case b: Byte =>\n+      assert(NumberConverter.toBinary(b) === ByteBuffer.allocate(1).put(b).array())"
  }],
  "prId": 24107
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "one question: Does the SQL standard say something about the endianness when casting integral to binary? What do other RDBMS do?",
    "commit": "53fb370d4988a4093ce3979b5dabcb0c7036a156",
    "createdAt": "2019-03-21T19:54:20Z",
    "diffHunk": "@@ -37,4 +40,47 @@ class NumberConverterSuite extends SparkFunSuite {\n     checkConv(\"11abc\", 10, 16, \"B\")\n   }\n \n+  test(\"byte to binary\") {\n+    checkToBinary(0.toByte)\n+    checkToBinary(1.toByte)\n+    checkToBinary(-1.toByte)\n+    checkToBinary(Byte.MaxValue)\n+    checkToBinary(Byte.MinValue)\n+  }\n+\n+  test(\"short to binary\") {\n+    checkToBinary(0.toShort)\n+    checkToBinary(1.toShort)\n+    checkToBinary(-1.toShort)\n+    checkToBinary(Short.MaxValue)\n+    checkToBinary(Short.MinValue)\n+  }\n+\n+  test(\"integer to binary\") {\n+    checkToBinary(0)\n+    checkToBinary(1)\n+    checkToBinary(-1)\n+    checkToBinary(Int.MaxValue)\n+    checkToBinary(Int.MinValue)\n+  }\n+\n+  test(\"long to binary\") {\n+    checkToBinary(0L)\n+    checkToBinary(1L)\n+    checkToBinary(-1L)\n+    checkToBinary(Long.MaxValue)\n+    checkToBinary(Long.MinValue)\n+  }\n+\n+  def checkToBinary[T](in: T): Unit = in match {\n+    case b: Byte =>\n+      assert(toBinary(b) === ByteBuffer.allocate(1).order(BIG_ENDIAN).put(b).array())",
    "line": 51
  }, {
    "author": {
      "login": "s1ck"
    },
    "body": "As mentioned above, casting to binary is not specified within the SQL standard. From the vendor docs, I couldn't figure out how it's being handled. Imho, going big endian here (Java and network standard) is ok for an unspecified feature.",
    "commit": "53fb370d4988a4093ce3979b5dabcb0c7036a156",
    "createdAt": "2019-03-22T10:40:02Z",
    "diffHunk": "@@ -37,4 +40,47 @@ class NumberConverterSuite extends SparkFunSuite {\n     checkConv(\"11abc\", 10, 16, \"B\")\n   }\n \n+  test(\"byte to binary\") {\n+    checkToBinary(0.toByte)\n+    checkToBinary(1.toByte)\n+    checkToBinary(-1.toByte)\n+    checkToBinary(Byte.MaxValue)\n+    checkToBinary(Byte.MinValue)\n+  }\n+\n+  test(\"short to binary\") {\n+    checkToBinary(0.toShort)\n+    checkToBinary(1.toShort)\n+    checkToBinary(-1.toShort)\n+    checkToBinary(Short.MaxValue)\n+    checkToBinary(Short.MinValue)\n+  }\n+\n+  test(\"integer to binary\") {\n+    checkToBinary(0)\n+    checkToBinary(1)\n+    checkToBinary(-1)\n+    checkToBinary(Int.MaxValue)\n+    checkToBinary(Int.MinValue)\n+  }\n+\n+  test(\"long to binary\") {\n+    checkToBinary(0L)\n+    checkToBinary(1L)\n+    checkToBinary(-1L)\n+    checkToBinary(Long.MaxValue)\n+    checkToBinary(Long.MinValue)\n+  }\n+\n+  def checkToBinary[T](in: T): Unit = in match {\n+    case b: Byte =>\n+      assert(toBinary(b) === ByteBuffer.allocate(1).order(BIG_ENDIAN).put(b).array())",
    "line": 51
  }],
  "prId": 24107
}]