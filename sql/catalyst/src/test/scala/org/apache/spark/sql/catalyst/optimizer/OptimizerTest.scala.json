[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Is there any reason to keep this class?\n",
    "commit": "227e89ef5b5c523a3a99e098ab5dec407f10e377",
    "createdAt": "2014-06-16T20:27:10Z",
    "diffHunk": "@@ -17,39 +17,10 @@\n \n package org.apache.spark.sql.catalyst.optimizer\n \n-import org.scalatest.FunSuite\n-\n-import org.apache.spark.sql.catalyst.expressions._\n-import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n-import org.apache.spark.sql.catalyst.util._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n \n /**\n  * Provides helper methods for comparing plans produced by optimization rules with the expected\n  * result\n  */\n-class OptimizerTest extends FunSuite {\n-\n-  /**\n-   * Since attribute references are given globally unique ids during analysis,\n-   * we must normalize them to check if two different queries are identical.\n-   */\n-  protected def normalizeExprIds(plan: LogicalPlan) = {\n-    val minId = plan.flatMap(_.expressions.flatMap(_.references).map(_.exprId.id)).min\n-    plan transformAllExpressions {\n-      case a: AttributeReference =>\n-        AttributeReference(a.name, a.dataType, a.nullable)(exprId = ExprId(a.exprId.id - minId))\n-    }\n-  }\n-\n-  /** Fails the test if the two plans do not match */\n-  protected def comparePlans(plan1: LogicalPlan, plan2: LogicalPlan) {\n-    val normalized1 = normalizeExprIds(plan1)\n-    val normalized2 = normalizeExprIds(plan2)\n-    if (normalized1 != normalized2)\n-      fail(\n-        s\"\"\"\n-          |== FAIL: Plans do not match ===\n-          |${sideBySide(normalized1.treeString, normalized2.treeString).mkString(\"\\n\")}\n-        \"\"\".stripMargin)\n-  }\n-}\n+class OptimizerTest extends PlanTest"
  }],
  "prId": 999
}]