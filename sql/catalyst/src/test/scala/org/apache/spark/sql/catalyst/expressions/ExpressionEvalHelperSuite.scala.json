[{
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "what happens if here you put `Map(3 -> 7, 6 -> -1)`?",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-13T13:23:24Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Here is an output. This is because the test correctly detects a failure even in codegen-off mode, too.\r\n\r\n```\r\n\"Incorrect evaluation (codegen off): mapincorrectdatatypeexpression(), actual: keys: [3,6], values: [7,null], expected: keys: [3,6], values: [7,-1]\" did not contain \"Incorrect evaluation in unsafe mode\"\r\nScalaTestFailureLocation: org.apache.spark.sql.catalyst.expressions.ExpressionEvalHelperSuite$$anonfun$4 at (ExpressionEvalHelperSuite.scala:44)\r\norg.scalatest.exceptions.TestFailedException: \"Incorrect evaluation (codegen off): mapincorrectdatatypeexpression(), actual: keys: [3,6], values: [7,null], expected: keys: [3,6], values: [7,-1]\" did not contain \"Incorrect evaluation in unsafe mode\"\r\n\tat org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:528)\r\n...\r\n```",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-13T16:38:10Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I see, so the example above passes in codegen off and fails with codegen on with this fix, while using `Map(3 -> 7, 6 -> -1)` passes codegen on and fails codegen off, am I right?\r\n\r\nWhat I am thinking about (but I have not yet found a working implementation) is: since the problem arise when we say we expect `null` in a non-nullable datatype, can we add such a check? I mean, instead of pretending the expected value to be nullable, can't we add a check in case it is not nullable for being sure that it does not contain `null`? I think it would be better, because we would be able to distinguish a failure caused by a bad test, ie. a test written wrongly, from a UT failure caused by a bug in what we are testing. What do you think?",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-13T18:52:13Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Here is summary.\r\n* `Map(3 -> 7, 6 -> null)` passes in codegen off and fails in codegen on with this fix\r\n* `Map(3 -> 7, 6 -> -1)` fails in codegen off and fails in codegen on \r\n\r\nWould it be possible to share examples of two cases that you think we would be able to distinguish?",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-17T14:14:26Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "yes, thanks for the summary, it states more clearly what I thought.\r\n\r\nMy point is that this fix works properly only when we test both codegen on and off, but it would fail to detect the error condition it claims to fix if only one of them (for any reason) is tested. So I am wondering if it is possible to perform a check on the expected value, instead of this fix. Something like:\r\n```\r\nassert(containsNull(expected) && isNullable(expression.dataType))\r\n```\r\nwhere `containsNull` and `isNullable` have to be defined properly. In this way we should fail properly independently from whether codegen is on or not. And we can also give a more clear hint in the error message about the problem being most likely a bad UT.",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-17T14:36:16Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Would it be possible to let us know how can this assertion distinguish the following two cases?\r\n* a failure caused by a bad test, ie. a test written wrongly\r\n* a UT failure caused by a bug in what we are testing",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-17T15:05:07Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Well, actually I was not clear about this, sorry for that. I meant we can separate from:\r\n - a failure caused by a wrong result returned;\r\n - a failure caused by a wrong result type returned (ie. the expected values contains NULL while the expression return data type is not nullable - this case can happen both in case the UT is bad and in case the return type of the expression is wrong);",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-18T09:33:18Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Sorry, I am confusing. I meant how your proposed assert can distinguish the two cases that you want to distinguish at [here](https://github.com/apache/spark/pull/22375#discussion_r217495874).\r\n1. a failure caused by a bad test, ie. a test written wrongly\r\n2. a UT failure caused by a bug in what we are testing\r\n\r\nAs you said [here](https://github.com/apache/spark/pull/22375#discussion_r218362156), the assert may detect both cases 1. and 2..\r\n",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-18T23:48:46Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Sorry, you're right, I have not been precise in my previous statements so they are confusing. I'll try to elaborate more clearly.\r\n\r\nIIUC what you are proposing now is for detecting the case when the output datatype of an expression is not nullable and the expected output instead contains a null. The way you're trying to achieve this is to make always nullable the expected output, so that we get a null as output both for codegen on and codegen off (while before this change for codegen on we would get as expected output a wrong value, which is the default value for that data type).\r\n\r\nThe problems I see on the approach above are:\r\n - if you test only codegen on or codegen off, you might still be missing to cover some cases (eg. see https://github.com/apache/spark/pull/22375#discussion_r218085246, with codegen off we can have null as output for a non-nullable expression...);\r\n - The failure you get is that the expected output is different from the the evaluated one, so this case is treated as any other failure in the expression evaluation.\r\n\r\nWith something like this:\r\n```\r\nassert(containsNull(expected) && isNullable(expression.dataType))\r\n```\r\nI think we could solve the 2 problems above as:\r\n - this check would fail in both modes;\r\n - we can differentiate between a test failing because of a wrong output and this new case which covers: a bad written UT; an expression returning wrongly a non-nullable datatype instead of a nullable one when returning null.\r\n\r\nHope now it is more clear. Thanks.",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-19T06:56:50Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "The your first is correct since this patch addresses only codegen-on case. We can add another code to address codegen-off case.\r\nRegarding the your second point, have we ever distingished a wrong output from a bad written UT when we defect the difference between `expression` and `expected`. I think that the distinguishment is nice to have, but not mandatory to have.\r\n\r\n\r\nI have one question about your approach:\r\n```\r\nassert(containsNull(expected) && isNullable(expression.dataType))\r\n```\r\nSince the above two conditions evaluates `expected` and `expression` independently, how this works for the following case? I think that the assertion would be passed\r\n```\r\nexpression:\r\ndataType = StructType(ArrayType(IntegerType, false), ArrayType(IntegerType, true))\r\nStruct(Array(0, null), Array(1, 0))\r\n\r\nexpected:\r\nStruct(Array(0, 0), Array(1, null))\r\n```\r\n\r\n",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T06:45:22Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Yes, you're right, my suggestion doesn't work in a case like that, sorry. We would need to make it checking recursively. But I think you got the idea of what I am proposing here. Thanks.",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T07:31:08Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Even if we make it checking recursively, I think that this case cannot be detected. This is because the mismatch occurs in the different recursive path.\r\n\r\nWould it be possible to share the case where we distingished a wrong output from a bad written UT in other places, as you proposed?",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T09:13:01Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Yes, I said that the suggestion above is wrong and needs to be rewritten in a recursive way. Sorry for the bad suggestion, I just meant to show my idea. So it should be something like:\r\n\r\n```\r\nassert(!containsNullWhereNotNullable(expected, expression.dataType))\r\n```",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T09:21:11Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I may not still understand your motivation correctly. What is the motivation to introduce this assertion?",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T10:09:56Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "The motivations are the 2 mentioned above. Basically, I am proposing the same suggestion @cloud-fan has just commented [here](https://github.com/apache/spark/pull/22375#discussion_r219452615)",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-21T10:36:53Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "With some hints from @ueshin, this PR implemented the check of `null` value with nullable bit in `checkResult()`.",
    "commit": "5f84e80e83d38e6332d6a30d600396c880d5dd2a",
    "createdAt": "2018-09-28T09:31:36Z",
    "diffHunk": "@@ -35,6 +36,13 @@ class ExpressionEvalHelperSuite extends SparkFunSuite with ExpressionEvalHelper\n     val e = intercept[RuntimeException] { checkEvaluation(BadCodegenExpression(), 10) }\n     assert(e.getMessage.contains(\"some_variable\"))\n   }\n+\n+  test(\"SPARK-25388: checkEvaluation should fail if nullable in DataType is incorrect\") {\n+    val e = intercept[RuntimeException] {\n+      checkEvaluation(MapIncorrectDataTypeExpression(), Map(3 -> 7, 6 -> null))",
    "line": 20
  }],
  "prId": 22375
}]