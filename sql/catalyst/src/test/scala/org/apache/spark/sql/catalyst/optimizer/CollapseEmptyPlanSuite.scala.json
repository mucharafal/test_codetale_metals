[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "you should test something that shouldn't have been converted too\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-28T06:03:39Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans.{LeftAnti, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ur, any other scenario except the existing followings?\n- test(\"one non-empty local relation\")\n- test(\"one non-empty and one empty local relations\")\n- test(\"aggregating expressions on empty plan\")\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-28T06:06:42Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans.{LeftAnti, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I'll update to have more.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-28T06:30:51Z",
    "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans.{LeftAnti, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Remove \"(or Higher)\".\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:43:37Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))\n+\n+  test(\"Binary(or Higher) Logical Plans - Collapse empty union\") {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. I removed.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:48:31Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))\n+\n+  test(\"Binary(or Higher) Logical Plans - Collapse empty union\") {"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "This test is too verbose... Can you try to simplify it? We don't need to cover all cases but some typical ones\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T13:54:17Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {\n+    val query = testRelation1\n+      .where(false)\n+      .union(testRelation2.where(false))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Binary Logical Plans - Collapse joins\") {"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Well, I guess the verbosity is necessary since it guarantees that we don't do wrong empty relation propagation for certain types of joins (e.g. outer join with only one empty child).\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T14:21:13Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {\n+    val query = testRelation1\n+      .where(false)\n+      .union(testRelation2.where(false))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Binary Logical Plans - Collapse joins\") {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ok then it's fine\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T14:23:55Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {\n+    val query = testRelation1\n+      .where(false)\n+      .union(testRelation2.where(false))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Binary Logical Plans - Collapse joins\") {"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "seems this is never used?\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T14:24:23Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. I'll remove this.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T17:14:50Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class CollapseEmptyPlanSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        CollapseEmptyPlan) :: Nil\n+  }\n+\n+  object OptimizeWithoutCollapseEmptyPlan extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"CollapseEmptyPlan\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+  val testRelation3 = LocalRelation.fromExternalRows(Seq('c.int), data = Seq(Row(1)))"
  }],
  "prId": 13906
}]