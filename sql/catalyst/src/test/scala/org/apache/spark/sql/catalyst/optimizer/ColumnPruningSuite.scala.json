[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Maybe we can also have a test for `val input = LocalRelation('a.int, 'b.array(StringType))`. Basically, we test turning `join` to false and then we add a project as the child of `Generate`.\n",
    "commit": "6e4c6c8a22276231a7a5ea4cb54f71ddaf22a3a9",
    "createdAt": "2015-08-19T22:02:36Z",
    "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.Explode\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.catalyst.plans.logical.{Project, LocalRelation, Generate, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.types.StringType\n+\n+class ColumnPruningSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Column pruning\", FixedPoint(100),\n+      ColumnPruning) :: Nil\n+  }\n+\n+  test(\"Column pruning for Generate when Generate.join = false\") {\n+    val input = LocalRelation('a.int, 'b.array(StringType))\n+\n+    val query = Generate(Explode('b), false, false, None, 's.string :: Nil, input).analyze\n+    val optimized = Optimize.execute(query)\n+\n+    val correctAnswer =\n+      Generate(Explode('b), false, false, None, 's.string :: Nil,\n+        Project('b.attr :: Nil, input)).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Column pruning for Generate when Generate.join = true\") {\n+    val input = LocalRelation('a.int, 'b.int, 'c.array(StringType))\n+\n+    val query =\n+      Project(Seq('a, 's),\n+        Generate(Explode('c), true, false, None, 's.string :: Nil,\n+          input)).analyze\n+    val optimized = Optimize.execute(query)\n+\n+    val correctAnswer =\n+      Project(Seq('a, 's),\n+        Generate(Explode('c), true, false, None, 's.string :: Nil,\n+          Project(Seq('a, 'c),\n+            input))).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Turn Generate.join to false if possible\") {\n+    val input = LocalRelation('b.array(StringType))\n+\n+    val query =\n+      Project(('s + 1).as(\"s+1\") :: Nil,\n+        Generate(Explode('b), true, false, None, 's.string :: Nil,\n+          input)).analyze\n+    val optimized = Optimize.execute(query)\n+\n+    val correctAnswer =\n+      Project(('s + 1).as(\"s+1\") :: Nil,\n+        Generate(Explode('b), false, false, None, 's.string :: Nil,\n+          input)).analyze\n+\n+    comparePlans(optimized, correctAnswer)",
    "line": 80
  }],
  "prId": 8268
}]