[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Could you add a NotFound case?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-06T09:46:39Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.types.{IntegerType, StringType}\n+\n+/**\n+ * Test suite for [[JavaMethodReflect]] and its companion object.\n+ */\n+class JavaMethodReflectSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  import JavaMethodReflect._\n+\n+  private val staticClassName = ReflectStaticClass.getClass.getName\n+  private val dynamicClassName = classOf[ReflectClass].getName\n+\n+  test(\"findMethod via reflection for static methods\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      assert(findMethod(className, \"method1\", Seq.empty).exists(_.getName == \"method1\"))\n+      assert(findMethod(className, \"method2\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method3\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method4\", Seq(IntegerType, StringType)).isDefined)"
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Here again. `Invalid class name test`?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-06T09:48:33Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.types.{IntegerType, StringType}\n+\n+/**\n+ * Test suite for [[JavaMethodReflect]] and its companion object.\n+ */\n+class JavaMethodReflectSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  import JavaMethodReflect._\n+\n+  private val staticClassName = ReflectStaticClass.getClass.getName\n+  private val dynamicClassName = classOf[ReflectClass].getName\n+\n+  test(\"findMethod via reflection for static methods\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      assert(findMethod(className, \"method1\", Seq.empty).exists(_.getName == \"method1\"))\n+      assert(findMethod(className, \"method2\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method3\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method4\", Seq(IntegerType, StringType)).isDefined)\n+    }\n+  }\n+\n+  test(\"instantiate class via reflection\") {\n+    // Should succeed since the following two should have no-arg ctor.\n+    assert(instantiate(dynamicClassName).isDefined)\n+    assert(instantiate(staticClassName).isDefined)\n+\n+    // Should fail since there is no no-arg ctor.\n+    assert(instantiate(classOf[ReflectClass1].getName).isEmpty)"
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Could you add two testcase (success/fail) for `dynamicClassName`, too?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-06T09:52:37Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.types.{IntegerType, StringType}\n+\n+/**\n+ * Test suite for [[JavaMethodReflect]] and its companion object.\n+ */\n+class JavaMethodReflectSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  import JavaMethodReflect._\n+\n+  private val staticClassName = ReflectStaticClass.getClass.getName\n+  private val dynamicClassName = classOf[ReflectClass].getName\n+\n+  test(\"findMethod via reflection for static methods\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      assert(findMethod(className, \"method1\", Seq.empty).exists(_.getName == \"method1\"))\n+      assert(findMethod(className, \"method2\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method3\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method4\", Seq(IntegerType, StringType)).isDefined)\n+    }\n+  }\n+\n+  test(\"instantiate class via reflection\") {\n+    // Should succeed since the following two should have no-arg ctor.\n+    assert(instantiate(dynamicClassName).isDefined)\n+    assert(instantiate(staticClassName).isDefined)\n+\n+    // Should fail since there is no no-arg ctor.\n+    assert(instantiate(classOf[ReflectClass1].getName).isEmpty)\n+  }\n+\n+  test(\"findMethod for a JDK library\") {\n+    assert(findMethod(classOf[java.util.UUID].getName, \"randomUUID\", Seq.empty).isDefined)\n+  }\n+\n+  test(\"type checking\") {\n+    assert(JavaMethodReflect(Seq.empty).checkInputDataTypes().isFailure)\n+    assert(JavaMethodReflect(Seq(Literal(staticClassName))).checkInputDataTypes().isFailure)\n+    assert(\n+      JavaMethodReflect(Seq(Literal(staticClassName), Literal(1))).checkInputDataTypes().isFailure)\n+\n+    assert(reflectExpr(staticClassName, \"method1\").checkInputDataTypes().isSuccess)"
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Minor, but could you remove `: JavaMethodReflect` here?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-06T09:58:42Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.types.{IntegerType, StringType}\n+\n+/**\n+ * Test suite for [[JavaMethodReflect]] and its companion object.\n+ */\n+class JavaMethodReflectSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  import JavaMethodReflect._\n+\n+  private val staticClassName = ReflectStaticClass.getClass.getName\n+  private val dynamicClassName = classOf[ReflectClass].getName\n+\n+  test(\"findMethod via reflection for static methods\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      assert(findMethod(className, \"method1\", Seq.empty).exists(_.getName == \"method1\"))\n+      assert(findMethod(className, \"method2\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method3\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method4\", Seq(IntegerType, StringType)).isDefined)\n+    }\n+  }\n+\n+  test(\"instantiate class via reflection\") {\n+    // Should succeed since the following two should have no-arg ctor.\n+    assert(instantiate(dynamicClassName).isDefined)\n+    assert(instantiate(staticClassName).isDefined)\n+\n+    // Should fail since there is no no-arg ctor.\n+    assert(instantiate(classOf[ReflectClass1].getName).isEmpty)\n+  }\n+\n+  test(\"findMethod for a JDK library\") {\n+    assert(findMethod(classOf[java.util.UUID].getName, \"randomUUID\", Seq.empty).isDefined)\n+  }\n+\n+  test(\"type checking\") {\n+    assert(JavaMethodReflect(Seq.empty).checkInputDataTypes().isFailure)\n+    assert(JavaMethodReflect(Seq(Literal(staticClassName))).checkInputDataTypes().isFailure)\n+    assert(\n+      JavaMethodReflect(Seq(Literal(staticClassName), Literal(1))).checkInputDataTypes().isFailure)\n+\n+    assert(reflectExpr(staticClassName, \"method1\").checkInputDataTypes().isSuccess)\n+  }\n+\n+  test(\"invoking methods using acceptable types\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      checkEvaluation(reflectExpr(className, \"method1\"), \"m1\")\n+      checkEvaluation(reflectExpr(className, \"method2\", 2), \"m2\")\n+      checkEvaluation(reflectExpr(className, \"method3\", 3), \"m3\")\n+      checkEvaluation(reflectExpr(className, \"method4\", 4, \"four\"), \"m4four\")\n+    }\n+  }\n+\n+  private def reflectExpr(className: String, methodName: String, args: Any*): JavaMethodReflect = {"
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "Why?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-07T06:26:54Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.types.{IntegerType, StringType}\n+\n+/**\n+ * Test suite for [[JavaMethodReflect]] and its companion object.\n+ */\n+class JavaMethodReflectSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  import JavaMethodReflect._\n+\n+  private val staticClassName = ReflectStaticClass.getClass.getName\n+  private val dynamicClassName = classOf[ReflectClass].getName\n+\n+  test(\"findMethod via reflection for static methods\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      assert(findMethod(className, \"method1\", Seq.empty).exists(_.getName == \"method1\"))\n+      assert(findMethod(className, \"method2\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method3\", Seq(IntegerType)).isDefined)\n+      assert(findMethod(className, \"method4\", Seq(IntegerType, StringType)).isDefined)\n+    }\n+  }\n+\n+  test(\"instantiate class via reflection\") {\n+    // Should succeed since the following two should have no-arg ctor.\n+    assert(instantiate(dynamicClassName).isDefined)\n+    assert(instantiate(staticClassName).isDefined)\n+\n+    // Should fail since there is no no-arg ctor.\n+    assert(instantiate(classOf[ReflectClass1].getName).isEmpty)\n+  }\n+\n+  test(\"findMethod for a JDK library\") {\n+    assert(findMethod(classOf[java.util.UUID].getName, \"randomUUID\", Seq.empty).isDefined)\n+  }\n+\n+  test(\"type checking\") {\n+    assert(JavaMethodReflect(Seq.empty).checkInputDataTypes().isFailure)\n+    assert(JavaMethodReflect(Seq(Literal(staticClassName))).checkInputDataTypes().isFailure)\n+    assert(\n+      JavaMethodReflect(Seq(Literal(staticClassName), Literal(1))).checkInputDataTypes().isFailure)\n+\n+    assert(reflectExpr(staticClassName, \"method1\").checkInputDataTypes().isSuccess)\n+  }\n+\n+  test(\"invoking methods using acceptable types\") {\n+    for (className <- Seq(staticClassName, dynamicClassName)) {\n+      checkEvaluation(reflectExpr(className, \"method1\"), \"m1\")\n+      checkEvaluation(reflectExpr(className, \"method2\", 2), \"m2\")\n+      checkEvaluation(reflectExpr(className, \"method3\", 3), \"m3\")\n+      checkEvaluation(reflectExpr(className, \"method4\", 4, \"four\"), \"m4four\")\n+    }\n+  }\n+\n+  private def reflectExpr(className: String, methodName: String, args: Any*): JavaMethodReflect = {"
  }],
  "prId": 13969
}]