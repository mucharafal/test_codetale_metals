[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can you also update the test names? like `propagate empty relation through Union`\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T23:13:45Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class PropagateEmptyRelationSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"PropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        PropagateEmptyRelation) :: Nil\n+  }\n+\n+  object OptimizeWithoutPropagateEmptyRelation extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"OptimizeWithoutPropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "No problem!\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T23:26:22Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class PropagateEmptyRelationSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"PropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        PropagateEmptyRelation) :: Nil\n+  }\n+\n+  object OptimizeWithoutPropagateEmptyRelation extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"OptimizeWithoutPropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about `Don't propagate empty relation through Aggregate with aggregate function`\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T23:14:25Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class PropagateEmptyRelationSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"PropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        PropagateEmptyRelation) :: Nil\n+  }\n+\n+  object OptimizeWithoutPropagateEmptyRelation extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"OptimizeWithoutPropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {\n+    val query = testRelation1\n+      .where(false)\n+      .union(testRelation2.where(false))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Binary Logical Plans - Collapse joins\") {\n+    // Testcases are tuples of (left predicate, right predicate, joinType, correct answer)\n+    // Note that `None` is used to compare with OptimizeWithoutPropagateEmptyRelation.\n+    val testcases = Seq(\n+      (true, true, Inner, None),\n+      (true, true, LeftOuter, None),\n+      (true, true, RightOuter, None),\n+      (true, true, FullOuter, None),\n+      (true, true, LeftAnti, None),\n+      (true, true, LeftSemi, None),\n+\n+      (true, false, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (true, false, LeftOuter, None),\n+      (true, false, RightOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (true, false, FullOuter, None),\n+      (true, false, LeftAnti, None),\n+      (true, false, LeftSemi, None),\n+\n+      (false, true, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (false, true, LeftOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, true, RightOuter, None),\n+      (false, true, FullOuter, None),\n+      (false, true, LeftAnti, Some(LocalRelation('a.int))),\n+      (false, true, LeftSemi, Some(LocalRelation('a.int))),\n+\n+      (false, false, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, LeftOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, RightOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, FullOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, LeftAnti, Some(LocalRelation('a.int))),\n+      (false, false, LeftSemi, Some(LocalRelation('a.int)))\n+    )\n+\n+    testcases.foreach { case (left, right, jt, answer) =>\n+      val query = testRelation1\n+        .where(left)\n+        .join(testRelation2.where(right), joinType = jt, condition = Some('a.attr == 'b.attr))\n+      val optimized = Optimize.execute(query.analyze)\n+      val correctAnswer =\n+        answer.getOrElse(OptimizeWithoutPropagateEmptyRelation.execute(query.analyze))\n+      comparePlans(optimized, correctAnswer)\n+    }\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse one empty local relation\") {\n+    val query = testRelation1\n+      .where(false)\n+      .select('a)\n+      .groupBy('a)('a)\n+      .where('a > 1)\n+      .orderBy('a.asc)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Don't collapse one non-empty local relation\") {\n+    val query = testRelation1\n+      .where(true)\n+      .groupBy('a)('a)\n+      .where('a > 1)\n+      .orderBy('a.asc)\n+      .select('a)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = testRelation1\n+      .where('a > 1)\n+      .groupBy('a)('a)\n+      .orderBy('a.asc)\n+      .select('a)\n+\n+    comparePlans(optimized, correctAnswer.analyze)\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse non-aggregating expressions on empty plan\") {\n+    val query = testRelation1\n+      .where(false)\n+      .groupBy('a)('a)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse non-aggregating complex expressions on empty plan\") {\n+    val query = testRelation1\n+      .where(false)\n+      .groupBy('a)('a, ('a + 1).as('x))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int, 'x.int).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Don't collapse aggregating expressions on empty plan\") {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Sounds good!\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T23:31:11Z",
    "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+\n+class PropagateEmptyRelationSuite extends PlanTest {\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"PropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters,\n+        PropagateEmptyRelation) :: Nil\n+  }\n+\n+  object OptimizeWithoutPropagateEmptyRelation extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"OptimizeWithoutPropagateEmptyRelation\", Once,\n+        CombineUnions,\n+        ReplaceDistinctWithAggregate,\n+        ReplaceExceptWithAntiJoin,\n+        ReplaceIntersectWithSemiJoin,\n+        PushDownPredicate,\n+        PruneFilters) :: Nil\n+  }\n+\n+  val testRelation1 = LocalRelation.fromExternalRows(Seq('a.int), data = Seq(Row(1)))\n+  val testRelation2 = LocalRelation.fromExternalRows(Seq('b.int), data = Seq(Row(1)))\n+\n+  test(\"Binary Logical Plans - Collapse empty union\") {\n+    val query = testRelation1\n+      .where(false)\n+      .union(testRelation2.where(false))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Binary Logical Plans - Collapse joins\") {\n+    // Testcases are tuples of (left predicate, right predicate, joinType, correct answer)\n+    // Note that `None` is used to compare with OptimizeWithoutPropagateEmptyRelation.\n+    val testcases = Seq(\n+      (true, true, Inner, None),\n+      (true, true, LeftOuter, None),\n+      (true, true, RightOuter, None),\n+      (true, true, FullOuter, None),\n+      (true, true, LeftAnti, None),\n+      (true, true, LeftSemi, None),\n+\n+      (true, false, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (true, false, LeftOuter, None),\n+      (true, false, RightOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (true, false, FullOuter, None),\n+      (true, false, LeftAnti, None),\n+      (true, false, LeftSemi, None),\n+\n+      (false, true, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (false, true, LeftOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, true, RightOuter, None),\n+      (false, true, FullOuter, None),\n+      (false, true, LeftAnti, Some(LocalRelation('a.int))),\n+      (false, true, LeftSemi, Some(LocalRelation('a.int))),\n+\n+      (false, false, Inner, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, LeftOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, RightOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, FullOuter, Some(LocalRelation('a.int, 'b.int))),\n+      (false, false, LeftAnti, Some(LocalRelation('a.int))),\n+      (false, false, LeftSemi, Some(LocalRelation('a.int)))\n+    )\n+\n+    testcases.foreach { case (left, right, jt, answer) =>\n+      val query = testRelation1\n+        .where(left)\n+        .join(testRelation2.where(right), joinType = jt, condition = Some('a.attr == 'b.attr))\n+      val optimized = Optimize.execute(query.analyze)\n+      val correctAnswer =\n+        answer.getOrElse(OptimizeWithoutPropagateEmptyRelation.execute(query.analyze))\n+      comparePlans(optimized, correctAnswer)\n+    }\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse one empty local relation\") {\n+    val query = testRelation1\n+      .where(false)\n+      .select('a)\n+      .groupBy('a)('a)\n+      .where('a > 1)\n+      .orderBy('a.asc)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int)\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Don't collapse one non-empty local relation\") {\n+    val query = testRelation1\n+      .where(true)\n+      .groupBy('a)('a)\n+      .where('a > 1)\n+      .orderBy('a.asc)\n+      .select('a)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = testRelation1\n+      .where('a > 1)\n+      .groupBy('a)('a)\n+      .orderBy('a.asc)\n+      .select('a)\n+\n+    comparePlans(optimized, correctAnswer.analyze)\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse non-aggregating expressions on empty plan\") {\n+    val query = testRelation1\n+      .where(false)\n+      .groupBy('a)('a)\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Collapse non-aggregating complex expressions on empty plan\") {\n+    val query = testRelation1\n+      .where(false)\n+      .groupBy('a)('a, ('a + 1).as('x))\n+\n+    val optimized = Optimize.execute(query.analyze)\n+    val correctAnswer = LocalRelation('a.int, 'x.int).analyze\n+\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"Unary Logical Plans - Don't collapse aggregating expressions on empty plan\") {"
  }],
  "prId": 13906
}]