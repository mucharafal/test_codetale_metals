[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I have a question here. According to the Javadoc of `Row`, a user should use and only use `Row` for `StructType` field. It's ok to support `Product` too, but do we have a reason for this? Is it needed for the UDT stuff? Sorry I'm not familiar with UDT handling, it will be good if you can explain it in detail, thanks!\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-14T16:19:53Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Actually I found this problem when working on ScalaUDF. ScalaUDF will use `schemaFor` to obtain catalyst type for UDF input and output. The catalyst type returned by `schemaFor` for a `Product` is `StructType`. It is reasonable as we don't have other type to represent `Product` as I see.\n\nSo for a `StructType` field in an external `Row`, both `Row` and `Product` are possible values. When we call `extractorsFor` on the external `Row`, `externalDataTypeFor` will return `ObjectType(classOf[Row])` for this field. But the `get` accessor on the inputObject (i.e., the `Row`) will possibly return a `Product` for the ScalaUDF case and an exception will be thrown.\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-15T05:03:19Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "If one of the input parameter is `Tuple2`, then we need to use the encoder to decode a catalyst value to external value, i.e. decode an `InternalRow` object to `Tuple2` object. I think this is hard for a `RowEncoder`(your change only makes it possible to encode a `Product` into `InternalRow`, but not vice versa), we should use `ProductEncoder` for this case.\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-15T13:42:33Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "If we have an input parameter mapping to a `StructType` field in an `InternalRow`, we will use `Row` as its input type. E.g., `sqlContext.udf.register(\"udfFunc\", (ns: Row) => { (ns.getInt(0), ns.getString(1)) })`. But we can't use `Row` as output type for an UDF. Because we can still get the input schema of `ScalaUDF`'s children expressions later if we can't infer input types correctly by using `schemaFor`. However, the output types of the UDF can be only inferred by `schemaFor`.\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-15T15:26:43Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Ah I see. We need the type tag to infer the return type of UDF, and if a `Row` is returned, there is no type information we can get. How about we use `ProductEncoder` or `FlatEncoder` for the return value?\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-16T01:34:12Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Hmm, as I tried, I found a problem is we may not always be able to get the type `T` needed to construct `ProductEncoder` and `FlatEncoder`. Even we can get it, we can't keep it in ScalaUDF due to serialization issue. So I think using RowEncoder is more reasonable.\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-16T09:50:15Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }, {
    "author": {
      "login": "davies"
    },
    "body": "I think the reason we still support Product for StructType is for backward-compatibility, we did not enforce the inbound type before, someone may reply one it (because it's easier than Row in Scala).\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-11-16T16:57:04Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {\n+    val schema = new StructType()\n+      .add(\"arrayOfUDT\", arrayOfUDT)\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row(Seq(new ExamplePoint(0.1, 0.2), new ExamplePoint(0.3, 0.4)))\n+    val row = encoder.toRow(input)\n+    val convertedBack = encoder.fromRow(row)\n+    assert(input.getSeq[ExamplePoint](0) == convertedBack.getSeq[ExamplePoint](0))\n+  }\n+\n+  test(s\"encode/decode: Product\") {\n+    val schema = new StructType()\n+      .add(\"structAsProduct\",\n+        new StructType()\n+          .add(\"int\", IntegerType)\n+          .add(\"string\", StringType)\n+          .add(\"double\", DoubleType))\n+\n+    val encoder = RowEncoder(schema)\n+\n+    val input: Row = Row((100, \"test\", 0.123))",
    "line": 103
  }],
  "prId": 9712
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "any reason why we put this test here instead of adding `arrayOfUDT` type in `encodeDecodeTest` like `structOfUDT`?\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-12-31T03:29:54Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {",
    "line": 81
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "No. I moved it in #10538.\n",
    "commit": "a5fdbcec468926134e32ea7c35d9bfc7a28debfa",
    "createdAt": "2015-12-31T04:05:13Z",
    "diffHunk": "@@ -68,7 +117,36 @@ class RowEncoderSuite extends SparkFunSuite {\n       .add(\"structOfArray\", new StructType().add(\"array\", arrayOfString))\n       .add(\"structOfMap\", new StructType().add(\"map\", mapOfString))\n       .add(\"structOfArrayAndMap\",\n-        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString)))\n+        new StructType().add(\"array\", arrayOfString).add(\"map\", mapOfString))\n+      .add(\"structOfUDT\", structOfUDT))\n+\n+  test(s\"encode/decode: arrayOfUDT\") {",
    "line": 81
  }],
  "prId": 9712
}]