[{
  "comments": [{
    "author": {
      "login": "wzhfy"
    },
    "body": "add some comment to indicate it's a table not in a star schema?",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T06:52:41Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1"
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@wzhfy I will update the comment.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T16:52:12Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1"
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "wzhfy"
    },
    "body": "It's an integer attribute, if its value range is [1, 50], ndv can't be larger than 50.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T06:53:46Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Same for some other attributes.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T07:02:13Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),"
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@wzhfy I will change the max values. \r\n\r\nTo control the layout of the join plans, I intentionally kept certain stats constant (e.g. size on the non-fact tables) and only varied the rowcount and the number of distinct values. ",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T17:33:20Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),"
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "wzhfy"
    },
    "body": "Can you also add a test for multi-star?",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T06:57:13Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(3), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(3), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }\n+    //\n+    // Number of generated plans: 11 (vs. 20 w/o filter)\n+    val query =\n+      f1.join(t1).join(t2).join(d1).join(d2)\n+        .where((nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t2, Inner, Some(nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")))\n+        .join(t1, Inner, Some(nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 2: Star with a linear branch\") {\n+    //\n+    //  t1   d1 - t2 - t3\n+    //   \\  /\n+    //    f1\n+    //    |\n+    //    d2\n+    //\n+    // star: {d1, f1, d2}\n+    // non-star: {t2, t1, t3}\n+    //\n+    // level 0: (f1 ), (d2 ), (t3 ), (d1 ), (t1 ), (t2 )\n+    // level 1: {t3 t2 }, {f1 d2 }, {f1 d1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t1 d1 f1 d2 }, {t2 d1 f1 d2 }\n+    // level 4: {d1 t2 f1 t1 d2 }, {d1 t3 t2 f1 d2 }\n+    // level 5: {d1 t3 t2 f1 t1 d2 }\n+    //\n+    // Number of generated plans: 15 (vs 24)\n+    val query =\n+      d1.join(t1).join(t2).join(f1).join(d2).join(t3)\n+        .where((nameToAttr(\"d1_pk\") === nameToAttr(\"f1_fk1\")) &&\n+          (nameToAttr(\"t1_c1\") === nameToAttr(\"f1_c1\")) &&\n+          (nameToAttr(\"d2_pk\") === nameToAttr(\"f1_fk2\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"d1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"t2_c2\") === nameToAttr(\"t3_c1\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t3.join(t2, Inner, Some(nameToAttr(\"t2_c2\") === nameToAttr(\"t3_c1\"))), Inner,\n+          Some(nameToAttr(\"d1_c2\") === nameToAttr(\"t2_c1\")))\n+        .join(t1, Inner, Some(nameToAttr(\"t1_c1\") === nameToAttr(\"f1_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 3: Star with derived branches\") {\n+    //         t3   t2\n+    //         |    |\n+    //    d1 - t4 - t1\n+    //    |\n+    //    f1\n+    //    |\n+    //    d2\n+    //\n+    // star:  (d1 f1 d2 )\n+    // non-star: (t4 t1 t2 t3 )\n+    //\n+    // level 0: (t1 ), (t3 ), (f1 ), (d1 ), (t2 ), (d2 ), (t4 )\n+    // level 1: {f1 d2 }, {t1 t4 }, {t1 t2 }, {f1 d1 }, {t3 t4 }\n+    // level 2: {d1 f1 d2 }, {t2 t1 t4 }, {t1 t3 t4 }\n+    // level 3: {t4 d1 f1 d2 }, {t3 t4 t1 t2 }\n+    // level 4: {d1 f1 t4 d2 t3 }, {d1 f1 t4 d2 t1 }\n+    // level 5: {d1 f1 t4 d2 t1 t2 }, {d1 f1 t4 d2 t1 t3 }\n+    // level 6: {d1 f1 t4 d2 t1 t2 t3 }\n+    //\n+    // Number of generated plans: 22 (vs. 34)\n+    val query =\n+      d1.join(t1).join(t2).join(t3).join(t4).join(f1).join(d2)\n+        .where((nameToAttr(\"t1_c1\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\")) &&\n+          (nameToAttr(\"t1_c2\") === nameToAttr(\"t4_c2\")) &&\n+          (nameToAttr(\"d1_c2\") === nameToAttr(\"t4_c3\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t3.join(t4, Inner, Some(nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\"))), Inner,\n+          Some(nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\")))\n+        .join(t1.join(t2, Inner, Some(nameToAttr(\"t1_c1\") === nameToAttr(\"t2_c1\"))), Inner,\n+          Some(nameToAttr(\"t1_c2\") === nameToAttr(\"t4_c2\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 4: Star with several branches\") {\n+    //\n+    //    d1 - t3 - t4\n+    //    |\n+    //    f1 - d3 - t1 - t2\n+    //    |\n+    //    d2 - t5 - t6\n+    //\n+    // star: {d1 f1 d2 d3 }\n+    // non-star: {t5 t3 t6 t2 t4 t1}\n+    //\n+    // level 0: (t4 ), (d2 ), (t5 ), (d3 ), (d1 ), (f1 ), (t2 ), (t6 ), (t1 ), (t3 )\n+    // level 1: {t5 t6 }, {t4 t3 }, {d3 f1 }, {t2 t1 }, {d2 f1 }, {d1 f1 }\n+    // level 2: {d2 d1 f1 }, {d2 d3 f1 }, {d3 d1 f1 }\n+    // level 3: {d2 d1 d3 f1 }\n+    // level 4: {d1 t3 d3 f1 d2 }, {d1 d3 f1 t1 d2 }, {d1 t5 d3 f1 d2 }\n+    // level 5: {d1 t5 d3 f1 t1 d2 }, {d1 t3 t4 d3 f1 d2 }, {d1 t5 t6 d3 f1 d2 },\n+    //          {d1 t5 t3 d3 f1 d2 }, {d1 t3 d3 f1 t1 d2 }, {d1 t2 d3 f1 t1 d2 }\n+    // level 6: {d1 t5 t3 t4 d3 f1 d2 }, {d1 t3 t2 d3 f1 t1 d2 }, {d1 t5 t6 d3 f1 t1 d2 },\n+    //          {d1 t5 t3 d3 f1 t1 d2 }, {d1 t5 t2 d3 f1 t1 d2 }, ...\n+    // ...\n+    // level 9: {d1 t5 t3 t6 t2 t4 d3 f1 t1 d2 }\n+    //\n+    // Number of generated plans: 46 (vs. 82)\n+    val query =\n+      d1.join(t3).join(t4).join(f1).join(d2).join(t5).join(t6).join(d3).join(t1).join(t2)\n+        .where((nameToAttr(\"d1_c2\") === nameToAttr(\"t3_c1\")) &&\n+          (nameToAttr(\"t3_c2\") === nameToAttr(\"t4_c2\")) &&\n+          (nameToAttr(\"d1_pk\") === nameToAttr(\"f1_fk1\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"d2_c2\") === nameToAttr(\"t5_c1\")) &&\n+          (nameToAttr(\"t5_c2\") === nameToAttr(\"t6_c2\")) &&\n+          (nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")) &&\n+          (nameToAttr(\"d3_c2\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"t1_c2\") === nameToAttr(\"t2_c2\")))\n+\n+    val expected =\n+      f1.join(d3, Inner, Some(nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(t4.join(t3, Inner, Some(nameToAttr(\"t3_c2\") === nameToAttr(\"t4_c2\"))), Inner,\n+          Some(nameToAttr(\"d1_c2\") === nameToAttr(\"t3_c1\")))\n+        .join(t2.join(t1, Inner, Some(nameToAttr(\"t1_c2\") === nameToAttr(\"t2_c2\"))), Inner,\n+          Some(nameToAttr(\"d3_c2\") === nameToAttr(\"t1_c1\")))\n+        .join(t5.join(t6, Inner, Some(nameToAttr(\"t5_c2\") === nameToAttr(\"t6_c2\"))), Inner,\n+          Some(nameToAttr(\"d2_c2\") === nameToAttr(\"t5_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 5: RI star only\") {\n+    //    d1\n+    //    |\n+    //    f1\n+    //   /  \\\n+    // d2    d3\n+    //\n+    // star: {f1, d1, d2, d3}\n+    // non-star: {}\n+    // level 0: (d1), (f1), (d2), (d3)\n+    // level 1: {f1 d3 }, {f1 d2 }, {d1 f1 }\n+    // level 2: {d1 f1 d2 }, {d2 f1 d3 }, {d1 f1 d3 }\n+    // level 3: {d1 d2 f1 d3 }\n+    // Number of generated plans: 11 (= 11)\n+    val query =\n+      d1.join(d2).join(f1).join(d3)\n+        .where((nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+\n+    val expected =\n+      f1.join(d3, Inner, Some(nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+        .join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 6: No RI star\") {",
    "line": 396
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@wzhfy Star detection algorithm returns the star-join for the largest fact table. I will generalize the algorithm in a follow up PR and add corresponding test cases.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-06T16:51:23Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(3), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(3), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(3), max = Some(3),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }\n+    //\n+    // Number of generated plans: 11 (vs. 20 w/o filter)\n+    val query =\n+      f1.join(t1).join(t2).join(d1).join(d2)\n+        .where((nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t2, Inner, Some(nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")))\n+        .join(t1, Inner, Some(nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 2: Star with a linear branch\") {\n+    //\n+    //  t1   d1 - t2 - t3\n+    //   \\  /\n+    //    f1\n+    //    |\n+    //    d2\n+    //\n+    // star: {d1, f1, d2}\n+    // non-star: {t2, t1, t3}\n+    //\n+    // level 0: (f1 ), (d2 ), (t3 ), (d1 ), (t1 ), (t2 )\n+    // level 1: {t3 t2 }, {f1 d2 }, {f1 d1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t1 d1 f1 d2 }, {t2 d1 f1 d2 }\n+    // level 4: {d1 t2 f1 t1 d2 }, {d1 t3 t2 f1 d2 }\n+    // level 5: {d1 t3 t2 f1 t1 d2 }\n+    //\n+    // Number of generated plans: 15 (vs 24)\n+    val query =\n+      d1.join(t1).join(t2).join(f1).join(d2).join(t3)\n+        .where((nameToAttr(\"d1_pk\") === nameToAttr(\"f1_fk1\")) &&\n+          (nameToAttr(\"t1_c1\") === nameToAttr(\"f1_c1\")) &&\n+          (nameToAttr(\"d2_pk\") === nameToAttr(\"f1_fk2\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"d1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"t2_c2\") === nameToAttr(\"t3_c1\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t3.join(t2, Inner, Some(nameToAttr(\"t2_c2\") === nameToAttr(\"t3_c1\"))), Inner,\n+          Some(nameToAttr(\"d1_c2\") === nameToAttr(\"t2_c1\")))\n+        .join(t1, Inner, Some(nameToAttr(\"t1_c1\") === nameToAttr(\"f1_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 3: Star with derived branches\") {\n+    //         t3   t2\n+    //         |    |\n+    //    d1 - t4 - t1\n+    //    |\n+    //    f1\n+    //    |\n+    //    d2\n+    //\n+    // star:  (d1 f1 d2 )\n+    // non-star: (t4 t1 t2 t3 )\n+    //\n+    // level 0: (t1 ), (t3 ), (f1 ), (d1 ), (t2 ), (d2 ), (t4 )\n+    // level 1: {f1 d2 }, {t1 t4 }, {t1 t2 }, {f1 d1 }, {t3 t4 }\n+    // level 2: {d1 f1 d2 }, {t2 t1 t4 }, {t1 t3 t4 }\n+    // level 3: {t4 d1 f1 d2 }, {t3 t4 t1 t2 }\n+    // level 4: {d1 f1 t4 d2 t3 }, {d1 f1 t4 d2 t1 }\n+    // level 5: {d1 f1 t4 d2 t1 t2 }, {d1 f1 t4 d2 t1 t3 }\n+    // level 6: {d1 f1 t4 d2 t1 t2 t3 }\n+    //\n+    // Number of generated plans: 22 (vs. 34)\n+    val query =\n+      d1.join(t1).join(t2).join(t3).join(t4).join(f1).join(d2)\n+        .where((nameToAttr(\"t1_c1\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\")) &&\n+          (nameToAttr(\"t1_c2\") === nameToAttr(\"t4_c2\")) &&\n+          (nameToAttr(\"d1_c2\") === nameToAttr(\"t4_c3\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =\n+      f1.join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(t3.join(t4, Inner, Some(nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\"))), Inner,\n+          Some(nameToAttr(\"t3_c1\") === nameToAttr(\"t4_c1\")))\n+        .join(t1.join(t2, Inner, Some(nameToAttr(\"t1_c1\") === nameToAttr(\"t2_c1\"))), Inner,\n+          Some(nameToAttr(\"t1_c2\") === nameToAttr(\"t4_c2\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 4: Star with several branches\") {\n+    //\n+    //    d1 - t3 - t4\n+    //    |\n+    //    f1 - d3 - t1 - t2\n+    //    |\n+    //    d2 - t5 - t6\n+    //\n+    // star: {d1 f1 d2 d3 }\n+    // non-star: {t5 t3 t6 t2 t4 t1}\n+    //\n+    // level 0: (t4 ), (d2 ), (t5 ), (d3 ), (d1 ), (f1 ), (t2 ), (t6 ), (t1 ), (t3 )\n+    // level 1: {t5 t6 }, {t4 t3 }, {d3 f1 }, {t2 t1 }, {d2 f1 }, {d1 f1 }\n+    // level 2: {d2 d1 f1 }, {d2 d3 f1 }, {d3 d1 f1 }\n+    // level 3: {d2 d1 d3 f1 }\n+    // level 4: {d1 t3 d3 f1 d2 }, {d1 d3 f1 t1 d2 }, {d1 t5 d3 f1 d2 }\n+    // level 5: {d1 t5 d3 f1 t1 d2 }, {d1 t3 t4 d3 f1 d2 }, {d1 t5 t6 d3 f1 d2 },\n+    //          {d1 t5 t3 d3 f1 d2 }, {d1 t3 d3 f1 t1 d2 }, {d1 t2 d3 f1 t1 d2 }\n+    // level 6: {d1 t5 t3 t4 d3 f1 d2 }, {d1 t3 t2 d3 f1 t1 d2 }, {d1 t5 t6 d3 f1 t1 d2 },\n+    //          {d1 t5 t3 d3 f1 t1 d2 }, {d1 t5 t2 d3 f1 t1 d2 }, ...\n+    // ...\n+    // level 9: {d1 t5 t3 t6 t2 t4 d3 f1 t1 d2 }\n+    //\n+    // Number of generated plans: 46 (vs. 82)\n+    val query =\n+      d1.join(t3).join(t4).join(f1).join(d2).join(t5).join(t6).join(d3).join(t1).join(t2)\n+        .where((nameToAttr(\"d1_c2\") === nameToAttr(\"t3_c1\")) &&\n+          (nameToAttr(\"t3_c2\") === nameToAttr(\"t4_c2\")) &&\n+          (nameToAttr(\"d1_pk\") === nameToAttr(\"f1_fk1\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"d2_c2\") === nameToAttr(\"t5_c1\")) &&\n+          (nameToAttr(\"t5_c2\") === nameToAttr(\"t6_c2\")) &&\n+          (nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")) &&\n+          (nameToAttr(\"d3_c2\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"t1_c2\") === nameToAttr(\"t2_c2\")))\n+\n+    val expected =\n+      f1.join(d3, Inner, Some(nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+        .join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(t4.join(t3, Inner, Some(nameToAttr(\"t3_c2\") === nameToAttr(\"t4_c2\"))), Inner,\n+          Some(nameToAttr(\"d1_c2\") === nameToAttr(\"t3_c1\")))\n+        .join(t2.join(t1, Inner, Some(nameToAttr(\"t1_c2\") === nameToAttr(\"t2_c2\"))), Inner,\n+          Some(nameToAttr(\"d3_c2\") === nameToAttr(\"t1_c1\")))\n+        .join(t5.join(t6, Inner, Some(nameToAttr(\"t5_c2\") === nameToAttr(\"t6_c2\"))), Inner,\n+          Some(nameToAttr(\"d2_c2\") === nameToAttr(\"t5_c1\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 5: RI star only\") {\n+    //    d1\n+    //    |\n+    //    f1\n+    //   /  \\\n+    // d2    d3\n+    //\n+    // star: {f1, d1, d2, d3}\n+    // non-star: {}\n+    // level 0: (d1), (f1), (d2), (d3)\n+    // level 1: {f1 d3 }, {f1 d2 }, {d1 f1 }\n+    // level 2: {d1 f1 d2 }, {d2 f1 d3 }, {d1 f1 d3 }\n+    // level 3: {d1 d2 f1 d3 }\n+    // Number of generated plans: 11 (= 11)\n+    val query =\n+      d1.join(d2).join(f1).join(d3)\n+        .where((nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")) &&\n+          (nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+\n+    val expected =\n+      f1.join(d3, Inner, Some(nameToAttr(\"f1_fk3\") === nameToAttr(\"d3_pk\")))\n+        .join(d2, Inner, Some(nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+        .join(d1, Inner, Some(nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")))\n+\n+    assertEqualPlans(query, expected)\n+  }\n+\n+  test(\"Test 6: No RI star\") {",
    "line": 396
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": " Can we have another optimizer without this filter and see the difference between two optimized plans from two optimizers?",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-07T03:02:07Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1 (regular table i.e. outside star)\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2 (regular table)\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3 (regular table)\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4 (regular table)\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5 (regular table)\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6 (regular table)\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  // To control the layout of the join plans, keep the size for the non-fact tables constant\n+  // and vary the rowcount and the number of distinct values of the join columns.\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }\n+    //\n+    // Number of generated plans: 11 (vs. 20 w/o filter)\n+    val query =\n+      f1.join(t1).join(t2).join(d1).join(d2)\n+        .where((nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =",
    "line": 230
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@wzhfy We have the results presented in SPARK-17791. I didn't run TPC-DS with CBO enabled, but it is on my to-do list.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-07T04:29:19Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1 (regular table i.e. outside star)\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2 (regular table)\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3 (regular table)\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4 (regular table)\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5 (regular table)\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6 (regular table)\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  // To control the layout of the join plans, keep the size for the non-fact tables constant\n+  // and vary the rowcount and the number of distinct values of the join columns.\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }\n+    //\n+    // Number of generated plans: 11 (vs. 20 w/o filter)\n+    val query =\n+      f1.join(t1).join(t2).join(d1).join(d2)\n+        .where((nameToAttr(\"f1_c1\") === nameToAttr(\"t1_c1\")) &&\n+          (nameToAttr(\"f1_c2\") === nameToAttr(\"t2_c1\")) &&\n+          (nameToAttr(\"f1_fk1\") === nameToAttr(\"d1_pk\")) &&\n+          (nameToAttr(\"f1_fk2\") === nameToAttr(\"d2_pk\")))\n+\n+    val expected =",
    "line": 230
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Does the order of items in this representation matter? If so, `{f1 t1 t2 d1 d2 }` is confusing because it looks like `f1` will join with `t1`, `t2` first.\r\n",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-07T03:06:02Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1 (regular table i.e. outside star)\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2 (regular table)\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3 (regular table)\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4 (regular table)\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5 (regular table)\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6 (regular table)\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  // To control the layout of the join plans, keep the size for the non-fact tables constant\n+  // and vary the rowcount and the number of distinct values of the join columns.\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }",
    "line": 220
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@viirya No, it doesn't matter. It does not reflect the order in which the tables are joined. It only shows the set of tables that will be joined together. To find out the actual order, you can look at the order of the joins in the \"expected\" query. ",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-07T04:34:16Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,\n+    CBO_ENABLED -> true,\n+    JOIN_REORDER_ENABLED -> true,\n+    STARSCHEMA_DETECTION -> true,\n+    JOIN_REORDER_DP_STAR_FILTER -> true)\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Operator Optimizations\", FixedPoint(100),\n+        CombineFilters,\n+        PushDownPredicate,\n+        ReorderJoin(conf),\n+        PushPredicateThroughJoin,\n+        ColumnPruning,\n+        CollapseProject) ::\n+        Batch(\"Join Reorder\", Once,\n+          CostBasedJoinReorder(conf)) :: Nil\n+  }\n+\n+  private val columnInfo: AttributeMap[ColumnStat] = AttributeMap(Seq(\n+    // F1 (fact table)\n+    attr(\"f1_fk1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_fk3\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c1\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"f1_c2\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D1 (dimension)\n+    attr(\"d1_pk\") -> ColumnStat(distinctCount = 100, min = Some(1), max = Some(100),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c2\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d1_c3\") -> ColumnStat(distinctCount = 50, min = Some(1), max = Some(50),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D2 (dimension)\n+    attr(\"d2_pk\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d2_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // D3 (dimension)\n+    attr(\"d3_pk\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+    attr(\"d3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 0, avgLen = 4, maxLen = 4),\n+\n+    // T1 (regular table i.e. outside star)\n+    attr(\"t1_c1\") -> ColumnStat(distinctCount = 20, min = Some(1), max = Some(20),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c2\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t1_c3\") -> ColumnStat(distinctCount = 10, min = Some(1), max = Some(10),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T2 (regular table)\n+    attr(\"t2_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t2_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T3 (regular table)\n+    attr(\"t3_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t3_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T4 (regular table)\n+    attr(\"t4_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t4_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T5 (regular table)\n+    attr(\"t5_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t5_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+\n+    // T6 (regular table)\n+    attr(\"t6_c1\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c2\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4),\n+    attr(\"t6_c3\") -> ColumnStat(distinctCount = 5, min = Some(1), max = Some(5),\n+      nullCount = 1, avgLen = 4, maxLen = 4)\n+\n+  ))\n+\n+  private val nameToAttr: Map[String, Attribute] = columnInfo.map(kv => kv._1.name -> kv._1)\n+  private val nameToColInfo: Map[String, (Attribute, ColumnStat)] =\n+    columnInfo.map(kv => kv._1.name -> kv)\n+\n+  private val f1 = StatsTestPlan(\n+    outputList = Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\").map(nameToAttr),\n+    rowCount = 1000,\n+    size = Some(1000 * (8 + 4 * 5)),\n+    attributeStats = AttributeMap(Seq(\"f1_fk1\", \"f1_fk2\", \"f1_fk3\", \"f1_c1\", \"f1_c2\")\n+      .map(nameToColInfo)))\n+\n+  // To control the layout of the join plans, keep the size for the non-fact tables constant\n+  // and vary the rowcount and the number of distinct values of the join columns.\n+  private val d1 = StatsTestPlan(\n+    outputList = Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToAttr),\n+    rowCount = 100,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d1_pk\", \"d1_c2\", \"d1_c3\").map(nameToColInfo)))\n+\n+  private val d2 = StatsTestPlan(\n+    outputList = Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToAttr),\n+    rowCount = 20,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d2_pk\", \"d2_c2\", \"d2_c3\").map(nameToColInfo)))\n+\n+  private val d3 = StatsTestPlan(\n+    outputList = Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"d3_pk\", \"d3_c2\", \"d3_c3\").map(nameToColInfo)))\n+\n+  private val t1 = StatsTestPlan(\n+    outputList = Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToAttr),\n+    rowCount = 50,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t1_c1\", \"t1_c2\", \"t1_c3\").map(nameToColInfo)))\n+\n+  private val t2 = StatsTestPlan(\n+    outputList = Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t2_c1\", \"t2_c2\", \"t2_c3\").map(nameToColInfo)))\n+\n+  private val t3 = StatsTestPlan(\n+    outputList = Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t3_c1\", \"t3_c2\", \"t3_c3\").map(nameToColInfo)))\n+\n+  private val t4 = StatsTestPlan(\n+    outputList = Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t4_c1\", \"t4_c2\", \"t4_c3\").map(nameToColInfo)))\n+\n+  private val t5 = StatsTestPlan(\n+    outputList = Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t5_c1\", \"t5_c2\", \"t5_c3\").map(nameToColInfo)))\n+\n+  private val t6 = StatsTestPlan(\n+    outputList = Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToAttr),\n+    rowCount = 10,\n+    size = Some(3000),\n+    attributeStats = AttributeMap(Seq(\"t6_c1\", \"t6_c2\", \"t6_c3\").map(nameToColInfo)))\n+\n+  test(\"Test 1: Star query with two dimensions and two regular tables\") {\n+\n+    // d1     t1\n+    //   \\   /\n+    //    f1\n+    //   /  \\\n+    // d2    t2\n+    //\n+    // star: {f1, d1, d2}\n+    // non-star: {t1, t2}\n+    //\n+    // level 0: (t2 ), (d2 ), (f1 ), (d1 ), (t1 )\n+    // level 1: {f1 d1 }, {d2 f1 }\n+    // level 2: {d2 f1 d1 }\n+    // level 3: {t2 d1 d2 f1 }, {t1 d1 d2 f1 }\n+    // level 4: {f1 t1 t2 d1 d2 }",
    "line": 220
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "wzhfy"
    },
    "body": "unnecessary?",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-11T07:13:21Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,"
  }, {
    "author": {
      "login": "ioana-delaney"
    },
    "body": "@wzhfy Removed.",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-11T19:02:38Z",
    "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(\n+    CASE_SENSITIVE -> true,"
  }],
  "prId": 17546
}, {
  "comments": [{
    "author": {
      "login": "ioana-delaney"
    },
    "body": "Removed star-filter dependency on the ```STARSCHEMA_DETECTION``` conf. When star-schema is called from CBO, it is under the control of ```JOIN_REORDER_DP_STAR_FILTER```. When called from ```ReorderJoin```, it is under the control of the ```STARSCHEMA_DETECTION``` conf.\r\n",
    "commit": "c9ec7c9378fd6522da1a8e2bf134c877366cf41d",
    "createdAt": "2017-04-11T19:13:24Z",
    "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeMap}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{ColumnStat, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.catalyst.statsEstimation.{StatsEstimationTestBase, StatsTestPlan}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf._\n+\n+\n+class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBase {\n+\n+  override val conf = new SQLConf().copy(",
    "line": 33
  }],
  "prId": 17546
}]