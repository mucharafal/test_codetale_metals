[{
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "Why not use the plugin system to instantiate these catalogs?",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T00:00:20Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "It depends on if this test should also be exercising the code path that does said loading, or if we want a separate unit test to verify that behavior in isolation. I'm usually a proponent of each test covering a specific feature and that feature only, so as long as we have another unit test that exercises plugin loading then I think this is fine.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T00:08:13Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap"
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "To be clear I think we should be avoiding plugin loading in these tests.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T00:09:01Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "+1, good call.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-18T17:13:25Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap"
  }],
  "prId": 23848
}, {
  "comments": [{
    "author": {
      "login": "mccheah"
    },
    "body": "Nit: Don't think we want the whitespace here.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T00:23:14Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+"
  }, {
    "author": {
      "login": "jzhuge"
    },
    "body": "Fixed the 2 white spaces after resolveOperators",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T05:28:53Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+"
  }],
  "prId": 23848
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "This uses a lot of temporary classes to simulate future rules that match multi-part identifiers. I think I would rather include an update that adds new `UnresolvedRelation` nodes and uses them instead of test plan nodes, but I'd be interested to hear whether @cloud-fan agrees.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T00:40:56Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap\n+\n+  private def lookupCatalog(catalog: String): CatalogPlugin =\n+    catalogs.getOrElse(catalog, throw new CatalogNotFoundException(\"Not found\"))\n+\n+  private def makeAnalyzer(caseSensitive: Boolean) = {\n+    val conf = new SQLConf().copy(SQLConf.CASE_SENSITIVE -> caseSensitive)\n+    new Analyzer(Some(lookupCatalog _), null, conf) {\n+      override val extendedResolutionRules =\n+        EliminateSubqueryAliases :: TestMultipartAnalysis(this) :: Nil"
  }, {
    "author": {
      "login": "jzhuge"
    },
    "body": "OK either way. I have already converted SELECT/INSERT/DROP code paths to support multi-catalog in my private 2.3 branch. Pretty straightforward. Converting CREATE would be a lot easier with Ryan's PR 24029.",
    "commit": "3bb448503f35e9e035480401261702bcc3114e7a",
    "createdAt": "2019-03-16T05:33:57Z",
    "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.catalog.v2\n+\n+import org.apache.spark.sql.catalog.v2.{CatalogNotFoundException, CatalogPlugin}\n+import org.apache.spark.sql.catalyst.CatalogIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, Analyzer, EliminateSubqueryAliases, NamedRelation}\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.{LeafNode, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+private case class TestUnresolvedMultipartRelation(parts: Seq[String])\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestUnresolvedMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = false\n+}\n+\n+private case class TestMultipartRelation(catalog: Option[CatalogPlugin], ident: CatalogIdentifier)\n+    extends LeafNode with NamedRelation {\n+\n+  override def name: String = \"TestMultipartRelation\"\n+\n+  override def output: Seq[Attribute] = Nil\n+\n+  override lazy val resolved = true\n+}\n+\n+private case class TestMultipartAnalysis(analyzer: Analyzer) extends Rule[LogicalPlan] {\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators  {\n+\n+    case TestUnresolvedMultipartRelation(analyzer.CatalogRef(catalog, ident)) =>\n+      TestMultipartRelation(catalog, ident)\n+  }\n+}\n+\n+private class TestCatalogPlugin(override val name: String) extends CatalogPlugin {\n+\n+  override def initialize(name: String, options: CaseInsensitiveStringMap): Unit = Unit\n+}\n+\n+class ResolveMultipartRelationSuite extends AnalysisTest {\n+  import CatalystSqlParser._\n+\n+  private val analyzer = makeAnalyzer(caseSensitive = false)\n+\n+  private val catalogs = Seq(\"prod\", \"test\").map(name => name -> new TestCatalogPlugin(name)).toMap\n+\n+  private def lookupCatalog(catalog: String): CatalogPlugin =\n+    catalogs.getOrElse(catalog, throw new CatalogNotFoundException(\"Not found\"))\n+\n+  private def makeAnalyzer(caseSensitive: Boolean) = {\n+    val conf = new SQLConf().copy(SQLConf.CASE_SENSITIVE -> caseSensitive)\n+    new Analyzer(Some(lookupCatalog _), null, conf) {\n+      override val extendedResolutionRules =\n+        EliminateSubqueryAliases :: TestMultipartAnalysis(this) :: Nil"
  }],
  "prId": 23848
}]