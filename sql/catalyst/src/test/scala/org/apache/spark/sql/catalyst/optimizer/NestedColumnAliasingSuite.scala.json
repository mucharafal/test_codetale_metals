[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Is this `name` used in `testSingleFieldPushDown`?",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-14T09:53:50Z",
    "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown(\"limit\", (input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown(\"repartition\", (input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown(\"sample\", (input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact.select('name))\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Pushing a single nested field projection through filters - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.where('name.isNotNull),\n+      (input: LogicalPlan) => input.where($\"name.middle\".isNotNull)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact)\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Do not optimize when parent field is used\") {\n+    val query = contact\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Do not optimize when all fields are used\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val middle = GetStructField('name, 1, Some(\"middle\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, middle, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, middle, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  private def testSingleFieldPushDown(name: String, op: LogicalPlan => LogicalPlan): Unit = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. Removed!",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-14T16:33:34Z",
    "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown(\"limit\", (input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown(\"repartition\", (input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown(\"sample\", (input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact.select('name))\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Pushing a single nested field projection through filters - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.where('name.isNotNull),\n+      (input: LogicalPlan) => input.where($\"name.middle\".isNotNull)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact)\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Do not optimize when parent field is used\") {\n+    val query = contact\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Do not optimize when all fields are used\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val middle = GetStructField('name, 1, Some(\"middle\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, middle, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, middle, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  private def testSingleFieldPushDown(name: String, op: LogicalPlan => LogicalPlan): Unit = {"
  }],
  "prId": 23964
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about moving this test func inside the `test(\"Pushing a single nested field projection\")` test?",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-18T01:55:33Z",
    "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown((input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown((input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown((input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val aliases = collectGeneratedAliases(optimized)\n+\n+    val expected = contact\n+      .select('id, first.as(aliases(0)), last.as(aliases(1)))\n+      .limit(5)\n+      .select(\n+        'id,\n+        ConcatWs(Seq($\"${aliases(0)}\", $\"${aliases(1)}\")).as(\"concat_ws(name.first, name.last)\"))\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact.select('name))\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Pushing a single nested field projection through filters - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.where('name.isNotNull),\n+      (input: LogicalPlan) => input.where($\"name.middle\".isNotNull)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact)\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Do not optimize when parent field is used\") {\n+    val query = contact\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, 'name)\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Some nested column means the whole structure\") {\n+    val nestedRelation = LocalRelation('a.struct('b.struct('c.int, 'd.int, 'e.int)))\n+\n+    val query = nestedRelation\n+      .limit(5)\n+      .select(GetStructField('a, 0, Some(\"b\")))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = nestedRelation\n+      .select(GetStructField('a, 0, Some(\"b\")))\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  private def testSingleFieldPushDown(op: LogicalPlan => LogicalPlan): Unit = {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Sure!",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-18T05:05:46Z",
    "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown((input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown((input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown((input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val aliases = collectGeneratedAliases(optimized)\n+\n+    val expected = contact\n+      .select('id, first.as(aliases(0)), last.as(aliases(1)))\n+      .limit(5)\n+      .select(\n+        'id,\n+        ConcatWs(Seq($\"${aliases(0)}\", $\"${aliases(1)}\")).as(\"concat_ws(name.first, name.last)\"))\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact.select('name))\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Pushing a single nested field projection through filters - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.where('name.isNotNull),\n+      (input: LogicalPlan) => input.where($\"name.middle\".isNotNull)\n+    )\n+\n+    val queries = ops.map { op =>\n+      op(contact)\n+        .select(GetStructField('name, 1, Some(\"middle\")))\n+        .analyze\n+    }\n+\n+    val optimizedQueries = queries.map(Optimize.execute)\n+    val expectedQueries = queries\n+\n+    optimizedQueries.zip(expectedQueries).foreach { case (optimized, expected) =>\n+      comparePlans(optimized, expected)\n+    }\n+  }\n+\n+  test(\"Do not optimize when parent field is used\") {\n+    val query = contact\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, 'name)\n+      .limit(5)\n+      .select('id, GetStructField('name, 0, Some(\"first\")), 'name)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Some nested column means the whole structure\") {\n+    val nestedRelation = LocalRelation('a.struct('b.struct('c.int, 'd.int, 'e.int)))\n+\n+    val query = nestedRelation\n+      .limit(5)\n+      .select(GetStructField('a, 0, Some(\"b\")))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = nestedRelation\n+      .select(GetStructField('a, 0, Some(\"b\")))\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  private def testSingleFieldPushDown(op: LogicalPlan => LogicalPlan): Unit = {"
  }],
  "prId": 23964
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "In feature, we could extend this nested -column pruning optimization for these negative cases? If so, could you leave TODO comments in https://github.com/apache/spark/pull/23964/files#diff-43334bab9616cc53e8797b9afa9fc7aaR79?",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-18T01:57:38Z",
    "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown((input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown((input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown((input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val aliases = collectGeneratedAliases(optimized)\n+\n+    val expected = contact\n+      .select('id, first.as(aliases(0)), last.as(aliases(1)))\n+      .limit(5)\n+      .select(\n+        'id,\n+        ConcatWs(Seq($\"${aliases(0)}\", $\"${aliases(1)}\")).as(\"concat_ws(name.first, name.last)\"))\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)",
    "line": 150
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yes. It's possible. Actually, I hope we extend this for `GroupBy`,`SortBy`/`OrderBy`/`Union` in the near future because the performance gain is huge in the deeply nested cases. @dbtsai and I'm working under the umbrella JIRA issue, https://issues.apache.org/jira/browse/SPARK-25603 . We will file sub-JIRA issues one-by-one when we are ready. For now, I think this is a complete PR. The negative cases are not a scope of this PR nor a TODO item. It will be ugly when we file several JIRA issues ID there.",
    "commit": "3711312af5c443e861929e1a2bdde18c05728856",
    "createdAt": "2019-03-18T05:13:58Z",
    "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.catalyst.SchemaPruningTest\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, _}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{StringType, StructType}\n+\n+class NestedColumnAliasingSuite extends SchemaPruningTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"Nested column pruning\", FixedPoint(100),\n+      ColumnPruning,\n+      CollapseProject,\n+      RemoveNoopOperators) :: Nil\n+  }\n+\n+  private val name = StructType.fromDDL(\"first string, middle string, last string\")\n+  private val employer = StructType.fromDDL(\"id int, company struct<name:string, address:string>\")\n+  private val contact = LocalRelation(\n+    'id.int,\n+    'name.struct(name),\n+    'address.string,\n+    'friends.array(name),\n+    'relatives.map(StringType, name),\n+    'employer.struct(employer))\n+\n+  test(\"Pushing a single nested field projection\") {\n+    testSingleFieldPushDown((input: LogicalPlan) => input.limit(5))\n+    testSingleFieldPushDown((input: LogicalPlan) => input.repartition(1))\n+    testSingleFieldPushDown((input: LogicalPlan) => Sample(0.0, 0.6, false, 11L, input))\n+  }\n+\n+  test(\"Pushing multiple nested field projection\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first, last)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first, last)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"function with nested field inputs\") {\n+    val first = GetStructField('name, 0, Some(\"first\"))\n+    val last = GetStructField('name, 2, Some(\"last\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, ConcatWs(Seq(first, last)))\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val aliases = collectGeneratedAliases(optimized)\n+\n+    val expected = contact\n+      .select('id, first.as(aliases(0)), last.as(aliases(1)))\n+      .limit(5)\n+      .select(\n+        'id,\n+        ConcatWs(Seq($\"${aliases(0)}\", $\"${aliases(1)}\")).as(\"concat_ws(name.first, name.last)\"))\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"multi-level nested field\") {\n+    val field1 = GetStructField(GetStructField('employer, 1, Some(\"company\")), 0, Some(\"name\"))\n+    val field2 = GetStructField('employer, 0, Some(\"id\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select(field1, field2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select(field1, field2)\n+      .limit(5)\n+      .analyze\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Push original case-sensitive names\") {\n+    val first1 = GetStructField('name, 0, Some(\"first\"))\n+    val first2 = GetStructField('name, 1, Some(\"FIRST\"))\n+\n+    val query = contact\n+      .limit(5)\n+      .select('id, first1, first2)\n+      .analyze\n+\n+    val optimized = Optimize.execute(query)\n+\n+    val expected = contact\n+      .select('id, first1, first2)\n+      .limit(5)\n+      .analyze\n+\n+    comparePlans(optimized, expected)\n+  }\n+\n+  test(\"Pushing a single nested field projection - negative\") {\n+    val ops = Array(\n+      (input: LogicalPlan) => input.distribute('name)(1),\n+      (input: LogicalPlan) => input.distribute($\"name.middle\")(1),\n+      (input: LogicalPlan) => input.orderBy('name.asc),\n+      (input: LogicalPlan) => input.orderBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.sortBy('name.asc),\n+      (input: LogicalPlan) => input.sortBy($\"name.middle\".asc),\n+      (input: LogicalPlan) => input.union(input)",
    "line": 150
  }],
  "prId": 23964
}]