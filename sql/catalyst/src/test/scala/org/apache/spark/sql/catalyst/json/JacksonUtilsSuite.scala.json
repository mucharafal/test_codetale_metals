[{
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "@viirya, would you mind if I ask to leave a simple e2e test alone for this PR? This one looks quite a simple fix to me and I think this won't require such many tests alone for this issue. I want to backport this but only leave strictly related changes here.\r\n\r\nI think we could do something like `SELECT to_json(struct(map(interval 1 second, 'a')))` or `SELECT to_json(struct(map('a', interval 1 second)))`.",
    "commit": "fbf8a88ba76e03602d82060b982038ddb53b43df",
    "createdAt": "2017-09-08T09:22:51Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.json\n+\n+import java.io.CharArrayWriter\n+import java.util.TimeZone\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.RandomDataGenerator\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+\n+class JacksonUtilsSuite extends SparkFunSuite {\n+\n+  test(\"verifySchema\") {"
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "OK, I am fine with those test coverage improvement too together. Up to you.",
    "commit": "fbf8a88ba76e03602d82060b982038ddb53b43df",
    "createdAt": "2017-09-08T09:37:08Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.json\n+\n+import java.io.CharArrayWriter\n+import java.util.TimeZone\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.RandomDataGenerator\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+\n+class JacksonUtilsSuite extends SparkFunSuite {\n+\n+  test(\"verifySchema\") {"
  }],
  "prId": 19167
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I'd do this as below:\r\n\r\n```scala\r\nval atomicMapTypes = for {\r\n  keyType <- atomicTypes\r\n  valueType <- atomicTypes\r\n} yield MapType(keyType, valueType, false)\r\n```",
    "commit": "fbf8a88ba76e03602d82060b982038ddb53b43df",
    "createdAt": "2017-09-08T09:35:42Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.json\n+\n+import java.io.CharArrayWriter\n+import java.util.TimeZone\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.RandomDataGenerator\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+\n+class JacksonUtilsSuite extends SparkFunSuite {\n+\n+  test(\"verifySchema\") {\n+    def verfifyJSONGenerate(schema: StructType): Unit = {\n+      val convertToInternalRow = CatalystTypeConverters.createToCatalystConverter(schema)\n+      val maybeDataGen = RandomDataGenerator.forType(schema, nullable = false)\n+      val dataGen = maybeDataGen.getOrElse(\n+        fail(s\"Failed to create data generator for type $schema\"))\n+      val row = convertToInternalRow(dataGen.apply()).asInstanceOf[InternalRow]\n+      val gen = new JacksonGenerator(\n+        schema, new CharArrayWriter(), new JSONOptions(Map.empty, TimeZone.getDefault.getID))\n+      gen.write(row)\n+    }\n+\n+    // The valid schema\n+    val atomicTypes = DataTypeTestUtils.atomicTypes\n+    val atomicArrayTypes = atomicTypes.map(ArrayType(_, containsNull = false))\n+    val atomicMapTypes = for (keyType <- atomicTypes;\n+      valueType <- atomicTypes) yield MapType(keyType, valueType, false)"
  }],
  "prId": 19167
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Would it be possible to move these supported cases into 45L so we loop twice, one for the vaild and one for invalid one?",
    "commit": "fbf8a88ba76e03602d82060b982038ddb53b43df",
    "createdAt": "2017-09-08T09:47:01Z",
    "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.json\n+\n+import java.io.CharArrayWriter\n+import java.util.TimeZone\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.RandomDataGenerator\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+\n+class JacksonUtilsSuite extends SparkFunSuite {\n+\n+  test(\"verifySchema\") {\n+    def verfifyJSONGenerate(schema: StructType): Unit = {\n+      val convertToInternalRow = CatalystTypeConverters.createToCatalystConverter(schema)\n+      val maybeDataGen = RandomDataGenerator.forType(schema, nullable = false)\n+      val dataGen = maybeDataGen.getOrElse(\n+        fail(s\"Failed to create data generator for type $schema\"))\n+      val row = convertToInternalRow(dataGen.apply()).asInstanceOf[InternalRow]\n+      val gen = new JacksonGenerator(\n+        schema, new CharArrayWriter(), new JSONOptions(Map.empty, TimeZone.getDefault.getID))\n+      gen.write(row)\n+    }\n+\n+    // The valid schema\n+    val atomicTypes = DataTypeTestUtils.atomicTypes\n+    val atomicArrayTypes = atomicTypes.map(ArrayType(_, containsNull = false))\n+    val atomicMapTypes = for (keyType <- atomicTypes;\n+      valueType <- atomicTypes) yield MapType(keyType, valueType, false)\n+\n+    (atomicTypes ++ atomicArrayTypes ++ atomicMapTypes).foreach { dataType =>\n+      val schema = StructType(StructField(\"a\", dataType, nullable = false) :: Nil)\n+      JacksonUtils.verifySchema(schema)\n+      verfifyJSONGenerate(schema)\n+    }\n+\n+    val invalidTypes = Seq(CalendarIntervalType)\n+\n+    // For MapType, its keys are treated as a string basically when generating JSON, so we only\n+    // care if the values are valid for JSON.\n+    val alsoValidMapTypes = for (keyType <- atomicTypes ++ invalidTypes;"
  }],
  "prId": 19167
}]