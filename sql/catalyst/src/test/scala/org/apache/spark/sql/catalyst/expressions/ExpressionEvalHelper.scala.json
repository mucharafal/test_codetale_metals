[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Doesn't this line do the same what `CatalystTypeConverters.convertToCatalyst` does?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T02:00:33Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "`CatalystTypeConverters.convertToCatalyst` tries to match with `Array[Any]`. This code tries to match with `Array[_]`. These two matches work differently.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T05:02:50Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think they are the same here, isn't?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T05:21:55Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I think that you are right. This workaround was for previous versions.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T07:16:53Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@viirya This code is for the change of `ComplexTypeSuite.CreateArray`. While seq is passed in the original version, array is passed now.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T13:16:11Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I don't see `convertToCatalyst` do special case for `BinaryType` before. Why we need to do that now?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T02:01:12Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "good catch. It also seems to be old workaround. Removed.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-11T10:05:42Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData for array expect Binarytype\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This is still looks weird to me.\n\nActually you need this because you replace `Seq` with `Array` in `test(\"CreateArray\")` at `ComplexTypeSuite.scala`.\n\nCan we not change `Seq` to `Array` in `ComplexTypeSuite`?  We actually can convert `Seq` to `Array` for unsafe version only in `convertToCatalystUnsafe` if we move `convertToCatalystUnsafe` to `ExpressionEvalHelper.scala`.\n\nNo other place uses this `convertToCatalystUnsafe`, I think.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-12T02:52:08Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "As I added a comment, this change intends to give a primitive array to pass `Array(_, containsNull = true)` as a type to generate better code by using `UnsafeArrayData.fromPrimitiveArray`.\nI agree to move `convertToCatalystUnsafe` to `ExpressionEvalHelper.scala`.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-13T19:08:57Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@viirya do they make sense?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-14T10:01:05Z",
    "diffHunk": "@@ -43,11 +43,38 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n \n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This might be a little dangerous. Because if an expression can't support codegen, i.e., it is `CodegenFallback`, it may return `GenericArrayData` anyway.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-16T03:27:02Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))\n+      case _ => CatalystTypeConverters.convertToCatalyst(expected)\n+    }\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueUnsafe = expected match {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Even if `GenericArrayData` is return, it may work except a case of a primitive array.\nI changed the name `catalystValueUnsafe` to `catalystValueForCodegen`.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-17T10:43:31Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))\n+      case _ => CatalystTypeConverters.convertToCatalyst(expected)\n+    }\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueUnsafe = expected match {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yeah, only primitive array would cause problem here. Currently looks like no tests use it. I'd suggest to change this to check if the expression is codegen supported.\n\nAt lease leave a comment for this.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T02:23:47Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))\n+      case _ => CatalystTypeConverters.convertToCatalyst(expected)\n+    }\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueUnsafe = expected match {"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "In `CatalystTypeConverters.convertToCatalyst`, we have `case arr: Array[Any] => new GenericArrayData(arr.map(convertToCatalyst))`.\n\nActually it looks weird to me. Because most Array will not match this pattern and `convertToCatalyst` will return the original Array as it is. Looks it is not correct.\n\nCan you try to change that pattern to `Array[_]`, and remove this line here? And we can see if it passes all tests.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-16T03:39:01Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I have just changed `Array[Any]` to `Array[_]` in `CatalystTypeConverters.convertToCatalyst` and remove line 63 in `ExpressionEvalHelper.scala`. Then, I ran some test cases.\n\nI realized `LiteralExpressionSuite.\"binary literals\" is failed. Here is a part of the log.\n\n``` java\nIncorrect evaluation (codegen off): [], actual: [], expected: [B@3ef41c66\nScalaTestFailureLocation: org.apache.spark.sql.catalyst.expressions.ExpressionEvalHelper$class at (ExpressionEvalHelper.scala:153)\norg.scalatest.exceptions.TestFailedException: Incorrect evaluation (codegen off): [], actual: [], expected: [B@3ef41c66\n    at org.scalatest.Assertions$class.newAssertionFailedException(Assertions.scala:495)\n    at org.scalatest.FunSuite.newAssertionFailedException(FunSuite.scala:1555)\n    at org.scalatest.Assertions$class.fail(Assertions.scala:1328)\n    at org.scalatest.FunSuite.fail(FunSuite.scala:1555)\n    at org.apache.spark.sql.catalyst.expressions.ExpressionEvalHelper$class.checkEvaluationWithoutCodegen(ExpressionEvalHelper.scala:153)\n    at org.apache.spark.sql.catalyst.expressions.LiteralExpressionSuite.checkEvaluationWithoutCodegen(LiteralExpressionSuite.scala:30)\n...\n```\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-17T10:42:49Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "oh. got it. You might change line 62 to `case arr: Array[Byte] => arr`. It should pass this test.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T02:26:10Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I applied the following three changes. However, `LiteralExpressionSuite.\"binary literals\" still produces the same exception.\n- changed `Array[Any]` to `Array[_]` in CatalystTypeConverters.convertToCatalyst \n- remove line 63 in `ExpressionEvalHelper.scala`\n- changed line 62 `ExpressionEvalHelper.scala` to `case arr: Array[Byte] => arr`\n\nThe set of these changes also creates another exception at `ExpressionToSQLSuite.string function`\n\n``` java\njava.lang.ClassCastException: org.apache.spark.sql.catalyst.util.GenericArrayData cannot be cast to [B\n    at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIterator.processNext(generated.java:31)\n    at org.apache.spark.sql.execution.BufferedRowIterator.hasNext(BufferedRowIterator.java:43)\n    at org.apache.spark.sql.execution.WholeStageCodegenExec$$anonfun$8$$anon$1.hasNext(WholeStageCodegenExec.scala:377)\n    at org.apache.spark.sql.execution.SparkPlan$$anonfun$2.apply(SparkPlan.scala:231)\n    at org.apache.spark.sql.execution.SparkPlan$$anonfun$2.apply(SparkPlan.scala:225)\n...\n```\n\n@viirya  What do you think?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T09:15:45Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "@kiszk Thanks for trying it! Currently I don't look into it in details. I may try it later to see if we can simplify it.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T15:26:32Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {\n+      case arr: Array[Byte] if expression.dataType == BinaryType => arr\n+      case arr: Array[_] => new GenericArrayData(arr.map(CatalystTypeConverters.convertToCatalyst))"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Can we just ask the caller side to pass in catalyst array? We can create some helper functions at the caller side to create catalyst array easily.\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T11:40:42Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@cloud-fan I would like to handle this at callee side (i.e. `ExpressionEvalHelper.scala`). If we ask the caller side to pass catalyst array, to change implementation in runtime or code generation requires changes at caller sites. This is because catalyst array (e.g. `GenericArrayData` or `UnsafeArrayData` depend on the implementation of runtime or code generation.\n\n `expected` is referred to two places. One is for non-codegen result. The other is for codegen result. Since these two parts may require different catalyst arrays (e.g.  `GenericArrayData` or `UnsafeArrayData`), it is not easy for a caller site to pass one catalyst array.\n\nWhat do you think?\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-18T14:42:40Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "At the callee side, we can do type aware comparison so that the caller side can just pass in a generic array data, e.g. https://github.com/apache/spark/pull/15645/files#diff-41747ec3f56901eb7bfb95d2a217e94dR69",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-21T08:09:43Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think we already have simplified non-codegen expected result with the new commit https://github.com/apache/spark/pull/13909/commits/64ec0818ca94bb13cb013e79e7de8a4651a68fac.\r\n\r\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T09:55:22Z",
    "diffHunk": "@@ -42,15 +42,55 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n-    val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // No codegen version expects GenericArrayData\n+    val catalystValue = expected match {"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Do we need this actually? I doubt that we have use case of expecting Array[Byte] but the data type is not BinaryType.\r\n",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T10:07:30Z",
    "diffHunk": "@@ -42,15 +42,51 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = expected match {\n+       case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "We need this line. Without this line, some tests fail. For example, `LiteralExpressionSuite.\"binary `literals\".",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T10:12:39Z",
    "diffHunk": "@@ -42,15 +42,51 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = expected match {\n+       case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Or, do you want to replace this line with `case arr: Array[Byte] => arr`? In this case, five favorite suites succeeded. ",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T10:20:58Z",
    "diffHunk": "@@ -42,15 +42,51 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = expected match {\n+       case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yeah, as `convertToCatalyst` now takes care of Array[Byte]. We don't need this line if we remove `case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)` too.",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T10:37:22Z",
    "diffHunk": "@@ -42,15 +42,51 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = expected match {\n+       case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "As I pointed out, `case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)` is required. I will move this into `convertToCatalystUnsafe()`.",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-11-22T10:49:25Z",
    "diffHunk": "@@ -42,15 +42,51 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Byte] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = expected match {\n+       case arr: Array[Byte] if expression.dataType == BinaryType => arr"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "if we use encoder here to convert the value to catalyst format, we don't need to change the `CatalystTypeConverters` right?",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-12-02T04:46:57Z",
    "diffHunk": "@@ -42,15 +42,48 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Byte] => arr\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "> Codegen version expects UnsafeArrayData\r\n\r\nThis is wrong, e.g. even the codegen version of `Cast` will produce safe format array.\r\nMy proposal is, we improve the checkResult to do type-aware comparison on complex types.",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-12-02T04:50:03Z",
    "diffHunk": "@@ -42,15 +42,48 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n     InternalRow.fromSeq(values.map(CatalystTypeConverters.convertToCatalyst))\n   }\n \n+  protected def convertToCatalystUnsafe(a: Any): Any = a match {\n+    case arr: Array[Byte] => arr\n+    case arr: Array[Boolean] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Short] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Int] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Long] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Float] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case arr: Array[Double] => UnsafeArrayData.fromPrimitiveArray(arr)\n+    case other => CatalystTypeConverters.convertToCatalyst(other)\n+  }\n+\n   protected def checkEvaluation(\n       expression: => Expression, expected: Any, inputRow: InternalRow = EmptyRow): Unit = {\n     val serializer = new JavaSerializer(new SparkConf()).newInstance\n     val expr: Expression = serializer.deserialize(serializer.serialize(expression))\n+    // No codegen version expects GenericArrayData\n     val catalystValue = CatalystTypeConverters.convertToCatalyst(expected)\n+    // Codegen version expects UnsafeArrayData for array expect Array(Binarytype)\n+    val catalystValueForCodegen = convertToCatalystUnsafe(expected)"
  }],
  "prId": 13909
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about we change this file like this? https://github.com/apache/spark/pull/15645/files#diff-41747ec3f56901eb7bfb95d2a217e94dR59",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-12-06T02:41:11Z",
    "diffHunk": "@@ -59,12 +59,36 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n    * Check the equality between result of expression and expected value, it will handle\n    * Array[Byte], Spread[Double], and MapData.\n    */\n-  protected def checkResult(result: Any, expected: Any): Boolean = {\n+  protected def checkResult(result: Any, expected: Any, expr: Any = null): Boolean = {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Ok, done",
    "commit": "cfe2e3d9defd7c04e921e886dc129725ce06fc67",
    "createdAt": "2016-12-06T09:32:47Z",
    "diffHunk": "@@ -59,12 +59,36 @@ trait ExpressionEvalHelper extends GeneratorDrivenPropertyChecks {\n    * Check the equality between result of expression and expected value, it will handle\n    * Array[Byte], Spread[Double], and MapData.\n    */\n-  protected def checkResult(result: Any, expected: Any): Boolean = {\n+  protected def checkResult(result: Any, expected: Any, expr: Any = null): Boolean = {"
  }],
  "prId": 13909
}]