[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why these changes? i.e. adding `.create`",
    "commit": "c2b71a0a66c4de749cbd2958c4469636e5c45887",
    "createdAt": "2017-07-06T11:36:06Z",
    "diffHunk": "@@ -35,7 +35,8 @@ class PredicateSuite extends SparkFunSuite with ExpressionEvalHelper {\n     test(s\"3VL $name\") {\n       truthTable.foreach {\n         case (l, r, answer) =>\n-          val expr = op(NonFoldableLiteral(l, BooleanType), NonFoldableLiteral(r, BooleanType))\n+          val expr = op(NonFoldableLiteral.create(l, BooleanType),",
    "line": 5
  }, {
    "author": {
      "login": "bogdanrdc"
    },
    "body": "The problem is that `NonFoldableLiteral(java.math.BigDecimal, DecimalType)` is keeping the java value while `NonFoldableLiteral.create(value,type)` does Literal.create which transforms `java.math.BigDecimal` to `Decimal` (catalyst type).\r\nIt's a bit of weird code. Literal has the same problem. `Literal(value,type)` is not the same as `Literal.create(value,type)`. So, one should always use `.create` and never the 2 parameter constructor.\r\nOtherwise you get java values in the execution, which in my case was failing because there is no ordering for non catalyst types. \r\n",
    "commit": "c2b71a0a66c4de749cbd2958c4469636e5c45887",
    "createdAt": "2017-07-06T11:48:58Z",
    "diffHunk": "@@ -35,7 +35,8 @@ class PredicateSuite extends SparkFunSuite with ExpressionEvalHelper {\n     test(s\"3VL $name\") {\n       truthTable.foreach {\n         case (l, r, answer) =>\n-          val expr = op(NonFoldableLiteral(l, BooleanType), NonFoldableLiteral(r, BooleanType))\n+          val expr = op(NonFoldableLiteral.create(l, BooleanType),",
    "line": 5
  }],
  "prId": 18455
}]