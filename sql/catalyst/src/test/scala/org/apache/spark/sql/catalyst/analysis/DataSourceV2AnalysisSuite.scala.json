[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit:\r\n```\r\nimport org.apache.spark.sql.catalyst.dsl.expressions._\r\nimport org.apache.spark.sql.catalyst.dsl.plans._\r\n\r\nval table = TestRelation(Seq('x.float, 'y.float))\r\nval requiredTable = TestRelation(Seq('x.float.notNull, 'y.float.notNull))\r\n...\r\n```",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T10:50:15Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)",
    "line": 33
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Symbols are rarely used in Scala, so I think it is better to use the StructType and convert. It matches what users do more closely.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:36:26Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)",
    "line": 33
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "this test is by name.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:31:49Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {",
    "line": 52
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Yes, this is testing that the query that would work when matching by position fails when matching by name.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T16:09:02Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {",
    "line": 52
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "it's clearer to specify the `caseSensitive` parameter of `assertAnalysisError`",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:32:53Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(",
    "line": 60
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Updated.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:28:22Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(",
    "line": 60
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "query.output.last",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:34:23Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Fixed.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:33:05Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)"
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can't we just call `query.output.head`?",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:34:24Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Fixed.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:33:02Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)"
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "where do we lowercase the attribute name in `ResolveOutputRelation`?",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:37:54Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),",
    "line": 90
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I don't know, but this is required for tests to pass. Other parts of the code also assume that case may not match (like in [PruneFileSourcePartitions](https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/PruneFileSourcePartitions.scala#L42-L50)) so I didn't investigate further.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T16:15:29Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),",
    "line": 90
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is there really a difference between missing required columns and missing optional columns?",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:45:59Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Missing optional columns may be allowed in the future. We've already had a team request this feature (enabled by a flag) to support schema evolution. The use case is that you don't want to fail existing jobs when you add a column to the table. Iceberg supports this, so Spark should too.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T16:17:51Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {"
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "this test is identical to \"Append.byName: missing columns are identified by name\"",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:46:42Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {",
    "line": 147
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I probably intended to update it for byPosition. I'll fix it.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T16:18:50Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {",
    "line": 147
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Removed. Looks like it was from when I split out the tests for required/optional.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:33:36Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {",
    "line": 147
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we need this test? In \"Append.byPosition: basic behavior\" we proved that we can do append even the column names are different.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:49:55Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: fail canWrite check\") {\n+    val parsedPlan = AppendData.byName(table, widerTable)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"'y'\", \"DoubleType to FloatType\"))\n+  }\n+\n+  test(\"Append.byName: insert safe cast\") {\n+    val x = table.output.toIndexedSeq(0)\n+    val y = table.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(widerTable, table)\n+    val expectedPlan = AppendData.byName(widerTable,\n+      Project(Seq(\n+        Alias(Cast(x, DoubleType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, DoubleType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        table))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail extra data fields\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType),\n+      StructField(\"y\", FloatType),\n+      StructField(\"z\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\", \"too many data columns\",\n+      \"Table columns: 'x', 'y'\",\n+      \"Data columns: 'x', 'y', 'z'\"))\n+  }\n+\n+  test(\"Append.byName: multiple field errors are reported\") {\n+    val xRequiredTable = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"y\", DoubleType))).toAttributes)\n+\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", DoubleType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(xRequiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"DoubleType to FloatType\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\",\n+      \"Cannot find data for output column\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byPosition: basic behavior\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val a = query.output.toIndexedSeq(0)\n+    val b = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byPosition(table, query)\n+    val expectedPlan = AppendData.byPosition(table,\n+      Project(Seq(\n+        Alias(Cast(a, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(b, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byPosition: case does not fail column resolution\") {"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I can remove it. I was including most test cases for both byName and byPosition to validate the different behaviors.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T16:25:14Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: fail canWrite check\") {\n+    val parsedPlan = AppendData.byName(table, widerTable)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"'y'\", \"DoubleType to FloatType\"))\n+  }\n+\n+  test(\"Append.byName: insert safe cast\") {\n+    val x = table.output.toIndexedSeq(0)\n+    val y = table.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(widerTable, table)\n+    val expectedPlan = AppendData.byName(widerTable,\n+      Project(Seq(\n+        Alias(Cast(x, DoubleType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, DoubleType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        table))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail extra data fields\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType),\n+      StructField(\"y\", FloatType),\n+      StructField(\"z\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\", \"too many data columns\",\n+      \"Table columns: 'x', 'y'\",\n+      \"Data columns: 'x', 'y', 'z'\"))\n+  }\n+\n+  test(\"Append.byName: multiple field errors are reported\") {\n+    val xRequiredTable = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"y\", DoubleType))).toAttributes)\n+\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", DoubleType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(xRequiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"DoubleType to FloatType\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\",\n+      \"Cannot find data for output column\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byPosition: basic behavior\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val a = query.output.toIndexedSeq(0)\n+    val b = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byPosition(table, query)\n+    val expectedPlan = AppendData.byPosition(table,\n+      Project(Seq(\n+        Alias(Cast(a, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(b, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byPosition: case does not fail column resolution\") {"
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Removed.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T17:34:13Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: fail canWrite check\") {\n+    val parsedPlan = AppendData.byName(table, widerTable)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"'y'\", \"DoubleType to FloatType\"))\n+  }\n+\n+  test(\"Append.byName: insert safe cast\") {\n+    val x = table.output.toIndexedSeq(0)\n+    val y = table.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(widerTable, table)\n+    val expectedPlan = AppendData.byName(widerTable,\n+      Project(Seq(\n+        Alias(Cast(x, DoubleType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, DoubleType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        table))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail extra data fields\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType),\n+      StructField(\"y\", FloatType),\n+      StructField(\"z\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\", \"too many data columns\",\n+      \"Table columns: 'x', 'y'\",\n+      \"Data columns: 'x', 'y', 'z'\"))\n+  }\n+\n+  test(\"Append.byName: multiple field errors are reported\") {\n+    val xRequiredTable = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"y\", DoubleType))).toAttributes)\n+\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", DoubleType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(xRequiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"DoubleType to FloatType\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\",\n+      \"Cannot find data for output column\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byPosition: basic behavior\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val a = query.output.toIndexedSeq(0)\n+    val b = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byPosition(table, query)\n+    val expectedPlan = AppendData.byPosition(table,\n+      Project(Seq(\n+        Alias(Cast(a, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(b, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byPosition: case does not fail column resolution\") {"
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can't we just call `query.output.head`?",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:50:23Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)"
  }],
  "prId": 22043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we need this test? In \"Append.byPosition: basic behavior\" we proved that we can do append even the column names are different.",
    "commit": "765c5b4fb7dd8f90a1a0e71d43ee4f2312c39552",
    "createdAt": "2018-08-09T11:50:41Z",
    "diffHunk": "@@ -0,0 +1,411 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import java.util.Locale\n+\n+import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference, Cast, UpCast}\n+import org.apache.spark.sql.catalyst.plans.logical.{AppendData, LeafNode, LogicalPlan, Project}\n+import org.apache.spark.sql.types.{DoubleType, FloatType, StructField, StructType}\n+\n+case class TestRelation(output: Seq[AttributeReference]) extends LeafNode with NamedRelation {\n+  override def name: String = \"table-name\"\n+}\n+\n+class DataSourceV2AnalysisSuite extends AnalysisTest {\n+  val table = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType),\n+    StructField(\"y\", FloatType))).toAttributes)\n+\n+  val requiredTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", FloatType, nullable = false),\n+    StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+  val widerTable = TestRelation(StructType(Seq(\n+    StructField(\"x\", DoubleType),\n+    StructField(\"y\", DoubleType))).toAttributes)\n+\n+  test(\"Append.byName: basic behavior\") {\n+    val query = TestRelation(table.schema.toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    checkAnalysis(parsedPlan, parsedPlan)\n+    assertResolved(parsedPlan)\n+  }\n+\n+  test(\"Append.byName: does not match by position\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: case sensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: case insensitive column resolution\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"X\", FloatType), // doesn't match case!\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val X = query.output.toIndexedSeq(0)\n+    val y = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(toLower(X), FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: data columns are reordered by name\") {\n+    // out of order\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType),\n+      StructField(\"x\", FloatType))).toAttributes)\n+\n+    val y = query.output.toIndexedSeq(0)\n+    val x = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+    val expectedPlan = AppendData.byName(table,\n+      Project(Seq(\n+        Alias(Cast(x, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail nullable data written to required columns\") {\n+    val parsedPlan = AppendData.byName(requiredTable, table)\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byName: allow required data written to nullable columns\") {\n+    val parsedPlan = AppendData.byName(table, requiredTable)\n+    assertResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, parsedPlan)\n+  }\n+\n+  test(\"Append.byName: missing columns are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing required columns cause failure and are identified by name\") {\n+    // missing required field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType, nullable = false))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(requiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: missing optional columns cause failure and are identified by name\") {\n+    // missing optional field x\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"y\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot find data for output column\", \"'x'\"))\n+  }\n+\n+  test(\"Append.byName: fail canWrite check\") {\n+    val parsedPlan = AppendData.byName(table, widerTable)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"'y'\", \"DoubleType to FloatType\"))\n+  }\n+\n+  test(\"Append.byName: insert safe cast\") {\n+    val x = table.output.toIndexedSeq(0)\n+    val y = table.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byName(widerTable, table)\n+    val expectedPlan = AppendData.byName(widerTable,\n+      Project(Seq(\n+        Alias(Cast(x, DoubleType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(y, DoubleType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        table))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byName: fail extra data fields\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType),\n+      StructField(\"y\", FloatType),\n+      StructField(\"z\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(table, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write\", \"'table-name'\", \"too many data columns\",\n+      \"Table columns: 'x', 'y'\",\n+      \"Data columns: 'x', 'y', 'z'\"))\n+  }\n+\n+  test(\"Append.byName: multiple field errors are reported\") {\n+    val xRequiredTable = TestRelation(StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"y\", DoubleType))).toAttributes)\n+\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"x\", DoubleType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val parsedPlan = AppendData.byName(xRequiredTable, query)\n+\n+    assertNotResolved(parsedPlan)\n+    assertAnalysisError(parsedPlan, Seq(\n+      \"Cannot write incompatible data to table\", \"'table-name'\",\n+      \"Cannot safely cast\", \"'x'\", \"DoubleType to FloatType\",\n+      \"Cannot write nullable values to non-null column\", \"'x'\",\n+      \"Cannot find data for output column\", \"'y'\"))\n+  }\n+\n+  test(\"Append.byPosition: basic behavior\") {\n+    val query = TestRelation(StructType(Seq(\n+      StructField(\"a\", FloatType),\n+      StructField(\"b\", FloatType))).toAttributes)\n+\n+    val a = query.output.toIndexedSeq(0)\n+    val b = query.output.toIndexedSeq(1)\n+\n+    val parsedPlan = AppendData.byPosition(table, query)\n+    val expectedPlan = AppendData.byPosition(table,\n+      Project(Seq(\n+        Alias(Cast(a, FloatType, Some(conf.sessionLocalTimeZone)), \"x\")(),\n+        Alias(Cast(b, FloatType, Some(conf.sessionLocalTimeZone)), \"y\")()),\n+        query))\n+\n+    assertNotResolved(parsedPlan)\n+    checkAnalysis(parsedPlan, expectedPlan, caseSensitive = false)\n+    assertResolved(expectedPlan)\n+  }\n+\n+  test(\"Append.byPosition: case does not fail column resolution\") {"
  }],
  "prId": 22043
}]