[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Could you change the test case names based on the goal of these tests? The reviewers and the future coders/readers can easily find out whether these tests cover all the data types and scenarios.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-05-21T04:23:41Z",
    "diffHunk": "@@ -0,0 +1,432 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)\n+\n+  test(\"should not match an attribute reference\") {\n+    assertResult(None)(unapplySelect(\"col1\"))\n+    assertResult(None)(unapplySelect(\"col1 as foo\"))\n+    assertResult(None)(unapplySelect(\"col2\"))\n+  }\n+\n+  test(\"col2.field2, col2.field2[0] as foo\") {"
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "I'll work on making these test names more readable.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-05-24T07:54:14Z",
    "diffHunk": "@@ -0,0 +1,432 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)\n+\n+  test(\"should not match an attribute reference\") {\n+    assertResult(None)(unapplySelect(\"col1\"))\n+    assertResult(None)(unapplySelect(\"col1 as foo\"))\n+    assertResult(None)(unapplySelect(\"col2\"))\n+  }\n+\n+  test(\"col2.field2, col2.field2[0] as foo\") {"
  }],
  "prId": 21320
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would like to suggest to separate this schema in possible for each test. Hard to read frankly .. ",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-20T04:08:44Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema ="
  }],
  "prId": 21320
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we just stick to string interpolation without `+`?",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-20T04:10:00Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)\n+\n+  test(\"SelectedField should not match an attribute reference\") {\n+    assertResult(None)(unapplySelect(\"col1\"))\n+    assertResult(None)(unapplySelect(\"col1 as foo\"))\n+    assertResult(None)(unapplySelect(\"col2\"))\n+  }\n+\n+  info(\"For a relation with schema\\n\" + indent(schema.treeString))\n+\n+  testSelect(\"col2.field2\", \"col2.field2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field9\", \"col2.field9['foo'] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield3\", \"col2.field3[0].subfield3 as foo\",\n+      \"col2.field3.subfield3[0] as foo\", \"col2.field3[0].subfield3[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col3.field1.subfield1\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col3.field2['foo'] as foo\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field2['bar'] as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col5[0]['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false)))\n+  }\n+\n+  testSelect(\"col6['foo'][0].field1.subfield1 as foo\") {\n+    StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), containsNull = false)))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1.subsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield2.subsubfield1.subsubsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield2\", StructType(\n+          StructField(\"subsubfield1\", StructType(\n+            StructField(\"subsubsubfield1\", StringType) :: Nil)) :: Nil)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield2 as foo\", \"col2.field4['foo'].subfield2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field8['foo'][0].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field1\", IntegerType) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) ::\n+        StructField(\"subfield2\", StringType) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field7.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field7\", StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col7.field1\", \"col7[0].field1 as foo\", \"col7.field1[0] as foo\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field1\", IntegerType, nullable = false) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field2.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field2\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field3.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil)))\n+  }\n+\n+  testSelect(\"col8.field1\", \"col8[0].field1 as foo\", \"col8.field1[0] as foo\", \"col8[0].field1[0] as foo\") {\n+    StructField(\"col8\", ArrayType(StructType(\n+      StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil)))\n+  }\n+\n+  def assertResult(expected: StructField)(actual: StructField)(selectExpr: String): Unit = {\n+    try {\n+      super.assertResult(expected)(actual)\n+    } catch {\n+      case ex: TestFailedException =>\n+        // Print some helpful diagnostics in the case of failure\n+        alert(\"Expected SELECT \\\"\" + selectExpr + \"\\\" to select the schema\\n\" +\n+          indent(StructType(expected :: Nil).treeString) +\n+          indent(\"but it actually selected\\n\") +\n+          indent(StructType(actual :: Nil).treeString) +\n+          indent(\"Note that expected.dataType.sameType(actual.dataType) = \" +\n+          expected.dataType.sameType(actual.dataType)))\n+        throw ex\n+    }\n+  }\n+\n+  // Test that the given SELECT expressions prune the test schema to the single-column schema\n+  // defined by the given field\n+  private def testSelect(selectExpr: String, otherSelectExprs: String*)(expected: StructField) {\n+    val selectExprs = selectExpr +: otherSelectExprs\n+    test(s\"SELECT \" + selectExprs.map(s => s\"\"\"\"$s\"\"\"\").mkString(\", \") + \" should select the schema\\n\" +"
  }],
  "prId": 21320
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Is it for add 4 spaces? I think we can remove this and just use 4 spaces. Virtually the code lengths are same.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-20T04:11:02Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)\n+\n+  test(\"SelectedField should not match an attribute reference\") {\n+    assertResult(None)(unapplySelect(\"col1\"))\n+    assertResult(None)(unapplySelect(\"col1 as foo\"))\n+    assertResult(None)(unapplySelect(\"col2\"))\n+  }\n+\n+  info(\"For a relation with schema\\n\" + indent(schema.treeString))\n+\n+  testSelect(\"col2.field2\", \"col2.field2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field9\", \"col2.field9['foo'] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield3\", \"col2.field3[0].subfield3 as foo\",\n+      \"col2.field3.subfield3[0] as foo\", \"col2.field3[0].subfield3[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col3.field1.subfield1\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col3.field2['foo'] as foo\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field2['bar'] as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col5[0]['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false)))\n+  }\n+\n+  testSelect(\"col6['foo'][0].field1.subfield1 as foo\") {\n+    StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), containsNull = false)))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1.subsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield2.subsubfield1.subsubsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield2\", StructType(\n+          StructField(\"subsubfield1\", StructType(\n+            StructField(\"subsubsubfield1\", StringType) :: Nil)) :: Nil)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield2 as foo\", \"col2.field4['foo'].subfield2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field8['foo'][0].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field1\", IntegerType) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) ::\n+        StructField(\"subfield2\", StringType) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field7.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field7\", StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col7.field1\", \"col7[0].field1 as foo\", \"col7.field1[0] as foo\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field1\", IntegerType, nullable = false) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field2.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field2\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field3.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil)))\n+  }\n+\n+  testSelect(\"col8.field1\", \"col8[0].field1 as foo\", \"col8.field1[0] as foo\", \"col8[0].field1[0] as foo\") {\n+    StructField(\"col8\", ArrayType(StructType(\n+      StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil)))\n+  }\n+\n+  def assertResult(expected: StructField)(actual: StructField)(selectExpr: String): Unit = {\n+    try {\n+      super.assertResult(expected)(actual)\n+    } catch {\n+      case ex: TestFailedException =>\n+        // Print some helpful diagnostics in the case of failure\n+        alert(\"Expected SELECT \\\"\" + selectExpr + \"\\\" to select the schema\\n\" +\n+          indent(StructType(expected :: Nil).treeString) +\n+          indent(\"but it actually selected\\n\") +\n+          indent(StructType(actual :: Nil).treeString) +\n+          indent(\"Note that expected.dataType.sameType(actual.dataType) = \" +\n+          expected.dataType.sameType(actual.dataType)))\n+        throw ex\n+    }\n+  }\n+\n+  // Test that the given SELECT expressions prune the test schema to the single-column schema\n+  // defined by the given field\n+  private def testSelect(selectExpr: String, otherSelectExprs: String*)(expected: StructField) {\n+    val selectExprs = selectExpr +: otherSelectExprs\n+    test(s\"SELECT \" + selectExprs.map(s => s\"\"\"\"$s\"\"\"\").mkString(\", \") + \" should select the schema\\n\" +\n+        indent(StructType(expected :: Nil).treeString)) {\n+      for (selectExpr <- selectExprs) {\n+        assertSelect(selectExpr, expected)\n+      }\n+    }\n+  }\n+\n+  private def assertSelect(expr: String, expected: StructField) = {\n+    unapplySelect(expr) match {\n+      case Some(field) =>\n+        assertResult(expected)(field)(expr)\n+      case None =>\n+        val failureMessage =\n+          \"Failed to select a field from \" + expr + \". \" +\n+          \"Expected:\\n\" +\n+          StructType(expected :: Nil).treeString\n+        fail(failureMessage)\n+    }\n+  }\n+\n+  private def unapplySelect(expr: String) = {\n+    val parsedExpr =\n+      CatalystSqlParser.parseExpression(expr) match {\n+        case namedExpr: NamedExpression => namedExpr\n+      }\n+    val select = testRelation.select(parsedExpr)\n+    val analyzed = select.analyze\n+    SelectedField.unapply(analyzed.expressions.head)\n+  }\n+\n+  private def indent(string: String) = string.replaceAll(\"(?m)^\", \"   \")"
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "This method indents every line in a string by four spaces. For example, https://regex101.com/r/teuQcA/1.\r\n\r\nI'll add an explanatory comment in my next push.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-21T11:11:36Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)\n+\n+  test(\"SelectedField should not match an attribute reference\") {\n+    assertResult(None)(unapplySelect(\"col1\"))\n+    assertResult(None)(unapplySelect(\"col1 as foo\"))\n+    assertResult(None)(unapplySelect(\"col2\"))\n+  }\n+\n+  info(\"For a relation with schema\\n\" + indent(schema.treeString))\n+\n+  testSelect(\"col2.field2\", \"col2.field2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field9\", \"col2.field9['foo'] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield3\", \"col2.field3[0].subfield3 as foo\",\n+      \"col2.field3.subfield3[0] as foo\", \"col2.field3[0].subfield3[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field3.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col3.field1.subfield1\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col3.field2['foo'] as foo\") {\n+    StructField(\"col3\", ArrayType(StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col4['foo'].field2['bar'] as foo\") {\n+    StructField(\"col4\", MapType(StringType, StructType(\n+      StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false)\n+  }\n+\n+  testSelect(\"col5[0]['foo'].field1.subfield1 as foo\") {\n+    StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false)))\n+  }\n+\n+  testSelect(\"col6['foo'][0].field1.subfield1 as foo\") {\n+    StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+      StructField(\"field1\", StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)) :: Nil), containsNull = false)))\n+  }\n+\n+  testSelect(\"col2.field5.subfield1.subsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) :: Nil), nullable = false) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field5.subfield2.subsubfield1.subsubsubfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field5\", ArrayType(StructType(\n+        StructField(\"subfield2\", StructType(\n+          StructField(\"subsubfield1\", StructType(\n+            StructField(\"subsubsubfield1\", StringType) :: Nil)) :: Nil)) :: Nil)), nullable = false) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field4['foo'].subfield2 as foo\", \"col2.field4['foo'].subfield2[0] as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field4\", MapType(StringType, StructType(\n+        StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field8['foo'][0].subfield1 as foo\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType) :: Nil)), valueContainsNull = false)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field1\", IntegerType) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) ::\n+        StructField(\"subfield2\", StringType) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field7.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field7\", StructType(\n+        StructField(\"subfield1\", StructType(\n+          StructField(\"subsubfield1\", IntegerType) ::\n+          StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col2.field6.subfield1\") {\n+    StructField(\"col2\", StructType(\n+      StructField(\"field6\", StructType(\n+        StructField(\"subfield1\", StringType, nullable = false) :: Nil)) :: Nil))\n+  }\n+\n+  testSelect(\"col7.field1\", \"col7[0].field1 as foo\", \"col7.field1[0] as foo\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field1\", IntegerType, nullable = false) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field2.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field2\", StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) :: Nil)))\n+  }\n+\n+  testSelect(\"col7.field3.subfield1\") {\n+    StructField(\"col7\", ArrayType(StructType(\n+      StructField(\"field3\", ArrayType(StructType(\n+        StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil)))\n+  }\n+\n+  testSelect(\"col8.field1\", \"col8[0].field1 as foo\", \"col8.field1[0] as foo\", \"col8[0].field1[0] as foo\") {\n+    StructField(\"col8\", ArrayType(StructType(\n+      StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil)))\n+  }\n+\n+  def assertResult(expected: StructField)(actual: StructField)(selectExpr: String): Unit = {\n+    try {\n+      super.assertResult(expected)(actual)\n+    } catch {\n+      case ex: TestFailedException =>\n+        // Print some helpful diagnostics in the case of failure\n+        alert(\"Expected SELECT \\\"\" + selectExpr + \"\\\" to select the schema\\n\" +\n+          indent(StructType(expected :: Nil).treeString) +\n+          indent(\"but it actually selected\\n\") +\n+          indent(StructType(actual :: Nil).treeString) +\n+          indent(\"Note that expected.dataType.sameType(actual.dataType) = \" +\n+          expected.dataType.sameType(actual.dataType)))\n+        throw ex\n+    }\n+  }\n+\n+  // Test that the given SELECT expressions prune the test schema to the single-column schema\n+  // defined by the given field\n+  private def testSelect(selectExpr: String, otherSelectExprs: String*)(expected: StructField) {\n+    val selectExprs = selectExpr +: otherSelectExprs\n+    test(s\"SELECT \" + selectExprs.map(s => s\"\"\"\"$s\"\"\"\").mkString(\", \") + \" should select the schema\\n\" +\n+        indent(StructType(expected :: Nil).treeString)) {\n+      for (selectExpr <- selectExprs) {\n+        assertSelect(selectExpr, expected)\n+      }\n+    }\n+  }\n+\n+  private def assertSelect(expr: String, expected: StructField) = {\n+    unapplySelect(expr) match {\n+      case Some(field) =>\n+        assertResult(expected)(field)(expr)\n+      case None =>\n+        val failureMessage =\n+          \"Failed to select a field from \" + expr + \". \" +\n+          \"Expected:\\n\" +\n+          StructType(expected :: Nil).treeString\n+        fail(failureMessage)\n+    }\n+  }\n+\n+  private def unapplySelect(expr: String) = {\n+    val parsedExpr =\n+      CatalystSqlParser.parseExpression(expr) match {\n+        case namedExpr: NamedExpression => namedExpr\n+      }\n+    val select = testRelation.select(parsedExpr)\n+    val analyzed = select.analyze\n+    SelectedField.unapply(analyzed.expressions.head)\n+  }\n+\n+  private def indent(string: String) = string.replaceAll(\"(?m)^\", \"   \")"
  }],
  "prId": 21320
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "tiny nit: I think we don't really have to disable the length limit.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-23T05:58:15Z",
    "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit"
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "No comment.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-25T08:24:06Z",
    "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit"
  }],
  "prId": 21320
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Per https://github.com/apache/spark/pull/21320#discussion_r203933423\r\n\r\nCan we make multiple relations with separate smaller schemas to make it more readable?",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-24T02:28:51Z",
    "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)"
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "No comment.",
    "commit": "e6baf681e06e229d740af120491d1bf0f426af99",
    "createdAt": "2018-07-25T08:28:08Z",
    "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.planning\n+\n+import org.scalatest.BeforeAndAfterAll\n+import org.scalatest.exceptions.TestFailedException\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.NamedExpression\n+import org.apache.spark.sql.catalyst.parser.CatalystSqlParser\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.types._\n+\n+// scalastyle:off line.size.limit\n+class SelectedFieldSuite extends SparkFunSuite with BeforeAndAfterAll {\n+  // The test schema as a tree string, i.e. `schema.treeString`\n+  // root\n+  //  |-- col1: string (nullable = false)\n+  //  |-- col2: struct (nullable = true)\n+  //  |    |-- field1: integer (nullable = true)\n+  //  |    |-- field2: array (nullable = true)\n+  //  |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field3: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield3: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = true)\n+  //  |    |-- field4: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field5: array (nullable = false)\n+  //  |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |-- subfield1: struct (nullable = false)\n+  //  |    |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |    |    |-- subfield2: struct (nullable = true)\n+  //  |    |    |    |    |-- subsubfield1: struct (nullable = true)\n+  //  |    |    |    |    |    |-- subsubsubfield1: string (nullable = true)\n+  //  |    |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field6: struct (nullable = true)\n+  //  |    |    |-- subfield1: string (nullable = false)\n+  //  |    |    |-- subfield2: string (nullable = true)\n+  //  |    |-- field7: struct (nullable = true)\n+  //  |    |    |-- subfield1: struct (nullable = true)\n+  //  |    |    |    |-- subsubfield1: integer (nullable = true)\n+  //  |    |    |    |-- subsubfield2: integer (nullable = true)\n+  //  |    |-- field8: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: array (valueContainsNull = false)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: array (nullable = true)\n+  //  |    |    |    |    |    |-- element: integer (containsNull = false)\n+  //  |    |-- field9: map (nullable = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col3: array (nullable = false)\n+  //  |    |-- element: struct (containsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col4: map (nullable = false)\n+  //  |    |-- key: string\n+  //  |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |    |    |-- field2: map (nullable = true)\n+  //  |    |    |    |-- key: string\n+  //  |    |    |    |-- value: integer (valueContainsNull = false)\n+  //  |-- col5: array (nullable = true)\n+  //  |    |-- element: map (containsNull = true)\n+  //  |    |    |-- key: string\n+  //  |    |    |-- value: struct (valueContainsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col6: map (nullable = true)\n+  //  |    |-- key: string\n+  //  |    |-- value: array (valueContainsNull = true)\n+  //  |    |    |-- element: struct (containsNull = false)\n+  //  |    |    |    |-- field1: struct (nullable = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = true)\n+  //  |    |    |    |    |-- subfield2: integer (nullable = true)\n+  //  |-- col7: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: integer (nullable = false)\n+  //  |    |    |-- field2: struct (nullable = true)\n+  //  |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |    |    |-- field3: array (nullable = true)\n+  //  |    |    |    |-- element: struct (containsNull = true)\n+  //  |    |    |    |    |-- subfield1: integer (nullable = false)\n+  //  |-- col8: array (nullable = true)\n+  //  |    |-- element: struct (containsNull = true)\n+  //  |    |    |-- field1: array (nullable = false)\n+  //  |    |    |    |-- element: integer (containsNull = false)\n+  private val schema =\n+    StructType(\n+      StructField(\"col1\", StringType, nullable = false) ::\n+      StructField(\"col2\", StructType(\n+        StructField(\"field1\", IntegerType) ::\n+        StructField(\"field2\", ArrayType(IntegerType, containsNull = false)) ::\n+        StructField(\"field3\", ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", IntegerType) ::\n+          StructField(\"subfield3\", ArrayType(IntegerType)) :: Nil)), nullable = false) ::\n+        StructField(\"field4\", MapType(StringType, StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil), valueContainsNull = false)) ::\n+        StructField(\"field5\", ArrayType(StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil), nullable = false) ::\n+          StructField(\"subfield2\", StructType(\n+            StructField(\"subsubfield1\", StructType(\n+              StructField(\"subsubsubfield1\", StringType) :: Nil)) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)), nullable = false) ::\n+        StructField(\"field6\", StructType(\n+          StructField(\"subfield1\", StringType, nullable = false) ::\n+          StructField(\"subfield2\", StringType) :: Nil)) ::\n+        StructField(\"field7\", StructType(\n+          StructField(\"subfield1\", StructType(\n+            StructField(\"subsubfield1\", IntegerType) ::\n+            StructField(\"subsubfield2\", IntegerType) :: Nil)) :: Nil)) ::\n+        StructField(\"field8\", MapType(StringType, ArrayType(StructType(\n+          StructField(\"subfield1\", IntegerType) ::\n+          StructField(\"subfield2\", ArrayType(IntegerType, containsNull = false)) :: Nil)), valueContainsNull = false)) ::\n+        StructField(\"field9\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil)) ::\n+     StructField(\"col3\", ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), containsNull = false), nullable = false) ::\n+     StructField(\"col4\", MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) ::\n+       StructField(\"field2\", MapType(StringType, IntegerType, valueContainsNull = false)) :: Nil), valueContainsNull = false), nullable = false) ::\n+     StructField(\"col5\", ArrayType(MapType(StringType, StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), valueContainsNull = false))) ::\n+     StructField(\"col6\", MapType(StringType, ArrayType(StructType(\n+       StructField(\"field1\", StructType(\n+         StructField(\"subfield1\", IntegerType) ::\n+         StructField(\"subfield2\", IntegerType) :: Nil)) :: Nil), containsNull = false))) ::\n+     StructField(\"col7\", ArrayType(StructType(\n+       StructField(\"field1\", IntegerType, nullable = false) ::\n+       StructField(\"field2\", StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil)) ::\n+       StructField(\"field3\", ArrayType(StructType(\n+         StructField(\"subfield1\", IntegerType, nullable = false) :: Nil))) :: Nil))) ::\n+     StructField(\"col8\", ArrayType(StructType(\n+       StructField(\"field1\", ArrayType(IntegerType, containsNull = false), nullable = false) :: Nil))) :: Nil)\n+\n+  private val testRelation = LocalRelation(schema.toAttributes)"
  }],
  "prId": 21320
}]