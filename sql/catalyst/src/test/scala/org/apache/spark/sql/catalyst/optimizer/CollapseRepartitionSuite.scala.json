[{
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "hmm, I can see the argument.\r\nbut there are 2 adjacent coalesces like this shouldn't it take the smaller number? (since coalesce can't increase partition numbers)\r\nwhereas if there are 2 adjacent repartition it could take the last number",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-15T08:01:14Z",
    "diffHunk": "@@ -32,6 +32,18 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    val query = testRelation\n+      .coalesce(10)\n+      .coalesce(20)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I think it would be better to respect the later input number, which is specified by users, for avoiding any surprise to users.",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-15T18:04:01Z",
    "diffHunk": "@@ -32,6 +32,18 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    val query = testRelation\n+      .coalesce(10)\n+      .coalesce(20)"
  }, {
    "author": {
      "login": "felixcheung"
    },
    "body": "ok, agreed.",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-15T18:42:56Z",
    "diffHunk": "@@ -32,6 +32,18 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    val query = testRelation\n+      .coalesce(10)\n+      .coalesce(20)"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "that might be the plan but the end result should be numPartitions == 5 correct? is there another suite we could add tests for repartition/coalesce like this?",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-15T08:03:40Z",
    "diffHunk": "@@ -43,15 +55,44 @@ class CollapseRepartitionSuite extends PlanTest {\n     comparePlans(optimized, correctAnswer)\n   }\n \n+  test(\"collapse one coalesce and one repartition into one\") {\n+    val query1 = testRelation\n+      .coalesce(20)\n+      .repartition(5)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(5).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(5)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.repartition(5).coalesce(20).analyze"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Yeah. We can get rid of `coalesce` if the number of partitions is smaller than the child `repartition`\r\n\r\nActually, I can add some simple end-to-end test cases like what you did in the R side. ",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-15T18:24:15Z",
    "diffHunk": "@@ -43,15 +55,44 @@ class CollapseRepartitionSuite extends PlanTest {\n     comparePlans(optimized, correctAnswer)\n   }\n \n+  test(\"collapse one coalesce and one repartition into one\") {\n+    val query1 = testRelation\n+      .coalesce(20)\n+      .repartition(5)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(5).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(5)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.repartition(5).coalesce(20).analyze"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "For improving this rule, we need to clean up the resolution of RepartitionByExpression at first. See the PR https://github.com/apache/spark/pull/16988",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-02-19T07:58:52Z",
    "diffHunk": "@@ -43,15 +55,44 @@ class CollapseRepartitionSuite extends PlanTest {\n     comparePlans(optimized, correctAnswer)\n   }\n \n+  test(\"collapse one coalesce and one repartition into one\") {\n+    val query1 = testRelation\n+      .coalesce(20)\n+      .repartition(5)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(5).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(5)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.repartition(5).coalesce(20).analyze"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "this is same as `correctAnswer1`",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T20:37:18Z",
    "diffHunk": "@@ -32,47 +32,180 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n       .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n       .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(20).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I not quite sure about this. Shall we optimize to `relation.repartition(10)`?",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T20:40:17Z",
    "diffHunk": "@@ -32,47 +32,180 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n       .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n       .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(20).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized2, correctAnswer2)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation\n       .distribute('a)(20)\n       .repartition(10)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(10).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(10).analyze"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Here, I just followed what we did before. After more code reading, I think we can do it, since `RoundRobinPartitioning ` looks cheaper. \r\n\r\n```Scala\r\n      case logical.Repartition(numPartitions, shuffle, child) =>\r\n        if (shuffle) {\r\n          ShuffleExchange(RoundRobinPartitioning(numPartitions), planLater(child)) :: Nil\r\n        } else {\r\n          execution.CoalesceExec(numPartitions, planLater(child)) :: Nil\r\n        }\r\n      case logical.RepartitionByExpression(expressions, child, numPartitions) =>\r\n        exchange.ShuffleExchange(HashPartitioning(\r\n          expressions, numPartitions), planLater(child)) :: Nil\r\n```\r\n\r\n",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T21:40:13Z",
    "diffHunk": "@@ -32,47 +32,180 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n       .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n       .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(20).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized2, correctAnswer2)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation\n       .distribute('a)(20)\n       .repartition(10)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(10).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(10).analyze"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "My concern is, optimization should not change the result. `relation.distributeBy('a, 10).repartition(10)` should have same result of `relation.repartition(10)`, instead of `relation.distributeBy('a, 10)`. It's not about which one is cheaper, we should not surprise users.",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T21:42:45Z",
    "diffHunk": "@@ -32,47 +32,180 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n       .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n       .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(20).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized2, correctAnswer2)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation\n       .distribute('a)(20)\n       .repartition(10)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(10).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(10).analyze"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I'd like to make `query2` as\r\n```\r\ntestRelation\r\n  .coalesce(30)\r\n  .distribute('a)(20)\r\n```\r\ni.e. the numPartitions of `coalesce` is bigger than `distribute`",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T22:31:14Z",
    "diffHunk": "@@ -32,47 +32,175 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n       .repartition(10)\n       .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we can add a comment: `// Always respects the top repartition amd removes useless distribute below repartition`",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T22:32:16Z",
    "diffHunk": "@@ -32,47 +32,175 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n       .repartition(10)\n       .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we can still pick the same numPartition pairs: `10, 20` and `30, 20`",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T22:33:10Z",
    "diffHunk": "@@ -32,47 +32,175 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n       .repartition(10)\n       .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation\n       .distribute('a)(20)\n       .repartition(10)"
  }],
  "prId": 16933
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "it's same with `correctAnswer1`",
    "commit": "d69c5a1f8d508f605f15a68f2b5adc6dbda60855",
    "createdAt": "2017-03-07T22:33:50Z",
    "diffHunk": "@@ -32,47 +32,175 @@ class CollapseRepartitionSuite extends PlanTest {\n \n   val testRelation = LocalRelation('a.int, 'b.int)\n \n+\n+  test(\"collapse two adjacent coalesces into one\") {\n+    // Always respects the top coalesces amd removes useless coalesce below coalesce\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .coalesce(20)\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+\n+    val correctAnswer = testRelation.coalesce(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n   test(\"collapse two adjacent repartitions into one\") {\n-    val query = testRelation\n+    // Always respects the top repartition amd removes useless repartition below repartition\n+    val query1 = testRelation\n       .repartition(10)\n       .repartition(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .repartition(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.repartition(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartition and repartitionBy into one\") {\n-    val query = testRelation\n+  test(\"coalesce above repartition\") {\n+    // Remove useless coalesce above repartition\n+    val query1 = testRelation\n+      .repartition(10)\n+      .coalesce(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    // No change in this case\n+    val query2 = testRelation\n+      .repartition(30)\n+      .coalesce(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = query2.analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above coalesce\") {\n+    // Always respects the top repartition amd removes useless coalesce below repartition\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .repartition(20)\n+    // Remove useless coalesce above repartition\n+    val query2 = testRelation\n+      .coalesce(30)\n+      .repartition(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer = testRelation.repartition(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n+  }\n+\n+  test(\"repartitionBy above repartition\") {\n+    val query1 = testRelation\n       .repartition(10)\n       .distribute('a)(20)\n+    val query2 = testRelation\n+      .repartition(30)\n+      .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val optimized2 = Optimize.execute(query2.analyze)\n     val correctAnswer = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized1, correctAnswer)\n+    comparePlans(optimized2, correctAnswer)\n   }\n \n-  test(\"collapse repartitionBy and repartition into one\") {\n-    val query = testRelation\n+  test(\"repartitionBy above coalesce\") {\n+    val query1 = testRelation\n+      .coalesce(10)\n+      .distribute('a)(20)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .coalesce(20)\n+      .distribute('a)(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"repartition above repartitionBy\") {\n+    val query1 = testRelation\n       .distribute('a)(20)\n       .repartition(10)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(10).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.repartition(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .distribute('a)(20)\n+      .repartition(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.repartition(30).analyze\n+\n+    comparePlans(optimized2, correctAnswer2)\n+  }\n+\n+  test(\"coalesce above repartitionBy\") {\n+    val query1 = testRelation\n+      .distribute('a)(20)\n+      .coalesce(10)\n+\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).coalesce(10).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .distribute('a)(20)\n+      .coalesce(30)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze\n \n-    comparePlans(optimized, correctAnswer)\n+    comparePlans(optimized2, correctAnswer2)\n   }\n \n   test(\"collapse two adjacent repartitionBys into one\") {\n-    val query = testRelation\n+    val query1 = testRelation\n       .distribute('b)(10)\n       .distribute('a)(20)\n \n-    val optimized = Optimize.execute(query.analyze)\n-    val correctAnswer = testRelation.distribute('a)(20).analyze\n+    val optimized1 = Optimize.execute(query1.analyze)\n+    val correctAnswer1 = testRelation.distribute('a)(20).analyze\n+\n+    comparePlans(optimized1, correctAnswer1)\n+\n+    val query2 = testRelation\n+      .distribute('b)(30)\n+      .distribute('a)(20)\n+\n+    val optimized2 = Optimize.execute(query2.analyze)\n+    val correctAnswer2 = testRelation.distribute('a)(20).analyze"
  }],
  "prId": 16933
}]