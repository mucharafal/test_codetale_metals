[{
  "comments": [{
    "author": {
      "login": "nongli"
    },
    "body": "you haven't done anything with a === 1 right? There's still no logic that a === 1 has a not nullable\n",
    "commit": "31b17007d8c6b2883d8f8b2f3bd4c0576fe0ed00",
    "createdAt": "2016-03-04T04:59:40Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+class NullFilteringSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"NullFiltering\", Once, NullFiltering) ::\n+      Batch(\"CombineFilters\", Once, CombineFilters) :: Nil\n+  }\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int)\n+\n+  test(\"filter: filter out nulls in condition\") {\n+    val originalQuery = testRelation.where('a === 1)\n+    val correctAnswer = testRelation.where(IsNotNull('a) && 'a === 1).analyze"
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "We can do that in a follow up pr \n",
    "commit": "31b17007d8c6b2883d8f8b2f3bd4c0576fe0ed00",
    "createdAt": "2016-03-04T05:00:47Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+class NullFilteringSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"NullFiltering\", Once, NullFiltering) ::\n+      Batch(\"CombineFilters\", Once, CombineFilters) :: Nil\n+  }\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int)\n+\n+  test(\"filter: filter out nulls in condition\") {\n+    val originalQuery = testRelation.where('a === 1)\n+    val correctAnswer = testRelation.where(IsNotNull('a) && 'a === 1).analyze"
  }],
  "prId": 11372
}, {
  "comments": [{
    "author": {
      "login": "nongli"
    },
    "body": "I had a few more test cases when i tried to this. Can you see if any of them should be added?\n\nhttps://github.com/nongli/spark/commit/ea0edd46e080cd0a1c6a1d41374563c149a030f7\n\nWe should also have outer join tests to make sure they don't add the is not null filter.\n",
    "commit": "31b17007d8c6b2883d8f8b2f3bd4c0576fe0ed00",
    "createdAt": "2016-03-04T05:02:44Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+class NullFilteringSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"NullFiltering\", Once, NullFiltering) ::\n+      Batch(\"CombineFilters\", Once, CombineFilters) :: Nil\n+  }\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int)\n+\n+  test(\"filter: filter out nulls in condition\") {\n+    val originalQuery = testRelation.where('a === 1)\n+    val correctAnswer = testRelation.where(IsNotNull('a) && 'a === 1).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"join: filter out nulls on either side\") {\n+    val x = testRelation.subquery('x)\n+    val y = testRelation.subquery('y)\n+    val originalQuery = x.join(y,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr && \"x.b\".attr === 1 && \"y.c\".attr > 5))\n+    val left = x.where(IsNotNull('a) && IsNotNull('b))\n+    val right = y.where(IsNotNull('a) && IsNotNull('c))\n+    val correctAnswer = left.join(right,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr && \"x.b\".attr === 1 && \"y.c\".attr > 5)).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"join with pre-existing filters: filter out nulls on either side\") {\n+    val x = testRelation.subquery('x)\n+    val y = testRelation.subquery('y)\n+    val originalQuery = x.where('b > 5).join(y.where('c === 10),\n+      condition = Some(\"x.a\".attr === \"y.a\".attr))\n+    val left = x.where(IsNotNull('a) && IsNotNull('b) && 'b > 5)\n+    val right = y.where(IsNotNull('a) && IsNotNull('c) && 'c === 10)\n+    val correctAnswer = left.join(right,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr)).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }"
  }, {
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Added a modified version of multi-join test based on your patch and a new test for outer join.\n\nAs discussed offline, there is an additional test for non-equal keys (`t1.a !== t2.b`) that requires generating isNotNull constraints for these expressions; I'll make that change in a small followup PR  and add new tests.\n",
    "commit": "31b17007d8c6b2883d8f8b2f3bd4c0576fe0ed00",
    "createdAt": "2016-03-04T23:34:13Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+class NullFilteringSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches = Batch(\"NullFiltering\", Once, NullFiltering) ::\n+      Batch(\"CombineFilters\", Once, CombineFilters) :: Nil\n+  }\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int)\n+\n+  test(\"filter: filter out nulls in condition\") {\n+    val originalQuery = testRelation.where('a === 1)\n+    val correctAnswer = testRelation.where(IsNotNull('a) && 'a === 1).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"join: filter out nulls on either side\") {\n+    val x = testRelation.subquery('x)\n+    val y = testRelation.subquery('y)\n+    val originalQuery = x.join(y,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr && \"x.b\".attr === 1 && \"y.c\".attr > 5))\n+    val left = x.where(IsNotNull('a) && IsNotNull('b))\n+    val right = y.where(IsNotNull('a) && IsNotNull('c))\n+    val correctAnswer = left.join(right,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr && \"x.b\".attr === 1 && \"y.c\".attr > 5)).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }\n+\n+  test(\"join with pre-existing filters: filter out nulls on either side\") {\n+    val x = testRelation.subquery('x)\n+    val y = testRelation.subquery('y)\n+    val originalQuery = x.where('b > 5).join(y.where('c === 10),\n+      condition = Some(\"x.a\".attr === \"y.a\".attr))\n+    val left = x.where(IsNotNull('a) && IsNotNull('b) && 'b > 5)\n+    val right = y.where(IsNotNull('a) && IsNotNull('c) && 'c === 10)\n+    val correctAnswer = left.join(right,\n+      condition = Some(\"x.a\".attr === \"y.a\".attr)).analyze\n+    val optimized = Optimize.execute(originalQuery.analyze)\n+    comparePlans(optimized, correctAnswer)\n+  }"
  }],
  "prId": 11372
}]