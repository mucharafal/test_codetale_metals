[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Have a test to call update using a null input and then check the answer?\n",
    "commit": "8b442debd33f6e985aa4ca536e2e8607db3ba477",
    "createdAt": "2016-10-05T01:16:17Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{AttributeReference, Literal}\n+import org.apache.spark.sql.types.IntegerType\n+\n+class LastTestSuite extends SparkFunSuite {\n+  val input = AttributeReference(\"input\", IntegerType, nullable = true)()\n+  val evaluator = DeclarativeAggregateEvaluator(Last(input, Literal(false)), Seq(input))\n+  val evaluatorIgnoreNulls = DeclarativeAggregateEvaluator(Last(input, Literal(true)), Seq(input))\n+\n+  test(\"empty buffer\") {\n+    assert(evaluator.initialize() === InternalRow(null, false))\n+  }\n+\n+  test(\"update\") {\n+    val result = evaluator.update(\n+      InternalRow(1),\n+      InternalRow(9),\n+      InternalRow(-1))\n+    assert(result === InternalRow(-1, true))\n+  }\n+\n+  test(\"update - ignore nulls\") {\n+    val result1 = evaluatorIgnoreNulls.update(\n+      InternalRow(null),\n+      InternalRow(9),\n+      InternalRow(null))\n+    assert(result1 === InternalRow(9, true))\n+\n+    val result2 = evaluatorIgnoreNulls.update(\n+      InternalRow(null),\n+      InternalRow(null))\n+    assert(result2 === InternalRow(null, false))\n+  }\n+\n+  test(\"merge\") {\n+    // Empty merge\n+    val p0 = evaluator.initialize()\n+    assert(evaluator.merge(p0) === InternalRow(null, false))\n+\n+    // Single merge\n+    val p1 = evaluator.update(InternalRow(1), InternalRow(-99))\n+    assert(evaluator.merge(p1) === p1)\n+\n+    // Multiple merges.\n+    val p2 = evaluator.update(InternalRow(2), InternalRow(10))\n+    assert(evaluator.merge(p1, p2) === p2)\n+\n+    // Empty partitions (p0 is empty)\n+    assert(evaluator.merge(p1, p0, p2) === p2)\n+    assert(evaluator.merge(p2, p1, p0) === p1)\n+  }\n+\n+  test(\"merge - ignore nulls\") {\n+    // Multi merges\n+    val p1 = evaluatorIgnoreNulls.update(InternalRow(1), InternalRow(null))\n+    val p2 = evaluatorIgnoreNulls.update(InternalRow(null), InternalRow(null))\n+    assert(evaluatorIgnoreNulls.merge(p1, p2) === p1)\n+  }\n+\n+  test(\"eval\") {\n+    // Empty Eval\n+    val p0 = evaluator.initialize()\n+    assert(evaluator.eval(p0) === InternalRow(null))\n+\n+    // Update - Eval\n+    val p1 = evaluator.update(InternalRow(1), InternalRow(-99))\n+    assert(evaluator.eval(p1) === InternalRow(-99))\n+\n+    // Update - Merge - Eval\n+    val p2 = evaluator.update(InternalRow(2), InternalRow(10))\n+    val m1 = evaluator.merge(p1, p0, p2)\n+    assert(evaluator.eval(m1) === InternalRow(10))\n+\n+    // Update - Merge - Eval (empty partition at the end)\n+    val m2 = evaluator.merge(p2, p1, p0)\n+    assert(evaluator.eval(m2) === InternalRow(-99))\n+  }",
    "line": 100
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done.\n",
    "commit": "8b442debd33f6e985aa4ca536e2e8607db3ba477",
    "createdAt": "2016-10-05T01:31:39Z",
    "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{AttributeReference, Literal}\n+import org.apache.spark.sql.types.IntegerType\n+\n+class LastTestSuite extends SparkFunSuite {\n+  val input = AttributeReference(\"input\", IntegerType, nullable = true)()\n+  val evaluator = DeclarativeAggregateEvaluator(Last(input, Literal(false)), Seq(input))\n+  val evaluatorIgnoreNulls = DeclarativeAggregateEvaluator(Last(input, Literal(true)), Seq(input))\n+\n+  test(\"empty buffer\") {\n+    assert(evaluator.initialize() === InternalRow(null, false))\n+  }\n+\n+  test(\"update\") {\n+    val result = evaluator.update(\n+      InternalRow(1),\n+      InternalRow(9),\n+      InternalRow(-1))\n+    assert(result === InternalRow(-1, true))\n+  }\n+\n+  test(\"update - ignore nulls\") {\n+    val result1 = evaluatorIgnoreNulls.update(\n+      InternalRow(null),\n+      InternalRow(9),\n+      InternalRow(null))\n+    assert(result1 === InternalRow(9, true))\n+\n+    val result2 = evaluatorIgnoreNulls.update(\n+      InternalRow(null),\n+      InternalRow(null))\n+    assert(result2 === InternalRow(null, false))\n+  }\n+\n+  test(\"merge\") {\n+    // Empty merge\n+    val p0 = evaluator.initialize()\n+    assert(evaluator.merge(p0) === InternalRow(null, false))\n+\n+    // Single merge\n+    val p1 = evaluator.update(InternalRow(1), InternalRow(-99))\n+    assert(evaluator.merge(p1) === p1)\n+\n+    // Multiple merges.\n+    val p2 = evaluator.update(InternalRow(2), InternalRow(10))\n+    assert(evaluator.merge(p1, p2) === p2)\n+\n+    // Empty partitions (p0 is empty)\n+    assert(evaluator.merge(p1, p0, p2) === p2)\n+    assert(evaluator.merge(p2, p1, p0) === p1)\n+  }\n+\n+  test(\"merge - ignore nulls\") {\n+    // Multi merges\n+    val p1 = evaluatorIgnoreNulls.update(InternalRow(1), InternalRow(null))\n+    val p2 = evaluatorIgnoreNulls.update(InternalRow(null), InternalRow(null))\n+    assert(evaluatorIgnoreNulls.merge(p1, p2) === p1)\n+  }\n+\n+  test(\"eval\") {\n+    // Empty Eval\n+    val p0 = evaluator.initialize()\n+    assert(evaluator.eval(p0) === InternalRow(null))\n+\n+    // Update - Eval\n+    val p1 = evaluator.update(InternalRow(1), InternalRow(-99))\n+    assert(evaluator.eval(p1) === InternalRow(-99))\n+\n+    // Update - Merge - Eval\n+    val p2 = evaluator.update(InternalRow(2), InternalRow(10))\n+    val m1 = evaluator.merge(p1, p0, p2)\n+    assert(evaluator.eval(m1) === InternalRow(10))\n+\n+    // Update - Merge - Eval (empty partition at the end)\n+    val m2 = evaluator.merge(p2, p1, p0)\n+    assert(evaluator.eval(m2) === InternalRow(-99))\n+  }",
    "line": 100
  }],
  "prId": 15348
}]