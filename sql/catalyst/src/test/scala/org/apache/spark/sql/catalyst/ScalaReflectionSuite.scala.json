[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Can you add a descriptive test name?",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-18T15:20:12Z",
    "diffHunk": "@@ -362,4 +392,11 @@ class ScalaReflectionSuite extends SparkFunSuite {\n     assert(numberOfCheckedArguments(deserializerFor[(java.lang.Double, Int)]) == 1)\n     assert(numberOfCheckedArguments(deserializerFor[(java.lang.Integer, java.lang.Integer)]) == 0)\n   }\n+\n+  test(\"SPARK-8288\") {"
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "why qualify as `_root_.scala.` here?",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T00:40:49Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)"
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think this is more readable as one liner",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T00:41:08Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply("
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Import this, unless this is somehow to avoid scala's Serializable",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T00:41:52Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+\n+  trait Proxy extends ScroogeLikeExample {\n+    protected def _underlying_ScroogeLikeExample: ScroogeLikeExample\n+    override def x: Int = _underlying_ScroogeLikeExample.x\n+  }\n+}\n+\n+trait ScroogeLikeExample\n+  extends _root_.scala.Product1[Int]\n+  with java.io.Serializable"
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "override?",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T00:42:08Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+\n+  trait Proxy extends ScroogeLikeExample {\n+    protected def _underlying_ScroogeLikeExample: ScroogeLikeExample\n+    override def x: Int = _underlying_ScroogeLikeExample.x\n+  }\n+}\n+\n+trait ScroogeLikeExample\n+  extends _root_.scala.Product1[Int]\n+  with java.io.Serializable\n+{\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  def _1: Int = x",
    "line": 18
  }, {
    "author": {
      "login": "drewrobb"
    },
    "body": "sure, i can't figure out if it is strictly necessary though",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T01:44:55Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+\n+  trait Proxy extends ScroogeLikeExample {\n+    protected def _underlying_ScroogeLikeExample: ScroogeLikeExample\n+    override def x: Int = _underlying_ScroogeLikeExample.x\n+  }\n+}\n+\n+trait ScroogeLikeExample\n+  extends _root_.scala.Product1[Int]\n+  with java.io.Serializable\n+{\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  def _1: Int = x",
    "line": 18
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Does it really need to extend Product1 for the test? quite possibly, just didn't see it.",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T00:42:25Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+\n+  trait Proxy extends ScroogeLikeExample {\n+    protected def _underlying_ScroogeLikeExample: ScroogeLikeExample\n+    override def x: Int = _underlying_ScroogeLikeExample.x\n+  }\n+}\n+\n+trait ScroogeLikeExample\n+  extends _root_.scala.Product1[Int]"
  }, {
    "author": {
      "login": "drewrobb"
    },
    "body": "It provides `productArity` used in `equals` used below. ",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T01:44:58Z",
    "diffHunk": "@@ -109,6 +109,64 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(\n+    x: Int\n+  ): ScroogeLikeExample =\n+    new Immutable(\n+      x\n+    )\n+\n+  def unapply(_item: ScroogeLikeExample): _root_.scala.Option[Int] = _root_.scala.Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+\n+  trait Proxy extends ScroogeLikeExample {\n+    protected def _underlying_ScroogeLikeExample: ScroogeLikeExample\n+    override def x: Int = _underlying_ScroogeLikeExample.x\n+  }\n+}\n+\n+trait ScroogeLikeExample\n+  extends _root_.scala.Product1[Int]"
  }],
  "prId": 23062
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Sure, but you've already established it's a `ScroogeLikeExample` here. Why must it be Product1 just to check whether it's also Product1? seems like it's not adding anything. In fact, why not just compare the one element that this trait knows about? to the extent it can implement equals() meaningfully, that's all it is doing already.",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T02:01:00Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }, {
    "author": {
      "login": "drewrobb"
    },
    "body": "My previous answer was not complete. `Product1` is also necessary so that the implicit `Encoders.product[T <: Product : TypeTag]` will work with this class, if omitted the DatasetSuite test will not compile: \r\n```\r\n[error] /home/drew/spark/sql/core/src/test/scala/org/apache/spark/sql/DatasetSuite.scala:1577: value toDS is not a member of Seq[org.apache.spark.sql.catalyst.ScroogeLikeExample]\r\n[error]     val ds = data.toDS\r\n```\r\nI could add some new encoder, but I think that might be worse as the goal of this PR is for Scrooge classes to work with the provided implicit encoders.",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T02:48:49Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Just use SparkSession.createDataset?",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T03:26:18Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Hm, actually that probably won't work any more or less. OK, it's because there is an Encoder for Product. You can still simplify the equals() and so on I think, but looks like that's easier than a new Encoder. Or is it sufficient to test a Seq of a concrete subtype of ScroogeLikeExample?",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T03:34:03Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }, {
    "author": {
      "login": "drewrobb"
    },
    "body": "I'm worried about changing the tests to use a concrete subtype, because the reflection calls might behave differently in that case either now or later on. I simplified a little more. `canEqual` is necessary to implement product. `equals` is necessary or tests will not pass (it will check object pointer equality), and `hashCode` is needed for scalastyle to pass since `equals` is necessary.",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T03:51:38Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "That's OK, leave in Product, if it's actually testing the case you have in mind. Yes I know equals() is needed. The new implementation looks good.",
    "commit": "04a34c4ee7c43120721659713fb8024e90282a0c",
    "createdAt": "2018-11-20T03:54:35Z",
    "diffHunk": "@@ -109,6 +109,35 @@ object TestingUDT {\n   }\n }\n \n+/** An example derived from Twitter/Scrooge codegen for thrift  */\n+object ScroogeLikeExample {\n+  def apply(x: Int): ScroogeLikeExample = new Immutable(x)\n+\n+  def unapply(_item: ScroogeLikeExample): Option[Int] = Some(_item.x)\n+\n+  class Immutable(val x: Int) extends ScroogeLikeExample\n+}\n+\n+trait ScroogeLikeExample extends Product1[Int] with Serializable {\n+  import ScroogeLikeExample._\n+\n+  def x: Int\n+\n+  override def _1: Int = x\n+\n+  def copy(x: Int = this.x): ScroogeLikeExample = new Immutable(x)\n+\n+  override def canEqual(other: Any): Boolean = other.isInstanceOf[ScroogeLikeExample]\n+\n+  private def _equals(x: ScroogeLikeExample, y: ScroogeLikeExample): Boolean =\n+      x.productArity == y.productArity &&"
  }],
  "prId": 23062
}]