[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "better to have one more test case that has both input rows and input variables.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-12T13:22:13Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class ExpressionCodegenSuite extends SparkFunSuite {\n+\n+  test(\"Returns eliminated subexpressions for expression\") {\n+    val ctx = new CodegenContext()\n+    val subExpr = Add(Literal(1), Literal(2))\n+    val exprs = Seq(Add(subExpr, Literal(3)), Add(subExpr, Literal(4)))\n+\n+    ctx.generateExpressions(exprs, doSubexpressionElimination = true)\n+    val subexpressions = ExpressionCodegen.getSubExprInChildren(ctx, exprs(0))\n+    assert(subexpressions.length == 1 && subexpressions(0) == subExpr)\n+  }\n+\n+  test(\"Gets parameters for subexpressions\") {\n+    val ctx = new CodegenContext()\n+    val subExprs = Seq(\n+      Add(Literal(1), AttributeReference(\"a\", IntegerType, nullable = false)()), // non-nullable\n+      Add(Literal(2), AttributeReference(\"b\", IntegerType, nullable = true)()))  // nullable\n+\n+    ctx.subExprEliminationExprs.put(subExprs(0), SubExprEliminationState(\"false\", \"value1\"))\n+    ctx.subExprEliminationExprs.put(subExprs(1), SubExprEliminationState(\"isNull2\", \"value2\"))\n+\n+    val subExprCodes = ExpressionCodegen.getSubExprCodes(ctx, subExprs)\n+    val subVars = subExprs.zip(subExprCodes).map { case (expr, exprCode) =>\n+      ExprInputVar(exprCode, expr.dataType, expr.nullable)\n+    }\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, subVars)\n+    assert(params.length == 3)\n+    assert(params(0) == Tuple2(\"value1\", \"int value1\"))\n+    assert(params(1) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(2) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input variables for expression: current variables\") {\n+    val ctx = new CodegenContext()\n+    val currentVars = Seq(\n+      ExprCode(\"\", isNull = \"false\", value = \"value1\"),             // evaluated\n+      ExprCode(\"\", isNull = \"isNull2\", value = \"value2\"),           // evaluated\n+      ExprCode(\"fake code;\", isNull = \"isNull3\", value = \"value3\")) // not evaluated\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = If(Literal(false),\n+      Add(BoundReference(0, IntegerType, nullable = false),\n+          BoundReference(1, IntegerType, nullable = true)),\n+        BoundReference(2, IntegerType, nullable = true))\n+\n+    val inputVars = ExpressionCodegen.getInputVarsForChildren(ctx, expr)\n+    // Only two evaluated variables included.\n+    assert(inputVars.length == 2)\n+    assert(inputVars(0).dataType == IntegerType && inputVars(0).nullable == false)\n+    assert(inputVars(1).dataType == IntegerType && inputVars(1).nullable == true)\n+    assert(inputVars(0).exprCode == currentVars(0))\n+    assert(inputVars(1).exprCode == currentVars(1))\n+\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, inputVars)\n+    assert(params.length == 3)\n+    assert(params(0) == Tuple2(\"value1\", \"int value1\"))\n+    assert(params(1) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(2) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input variables for expression: deferred variables\") {\n+    val ctx = new CodegenContext()\n+\n+    // The referred column is not evaluated yet. But it depends on an evaluated column from\n+    // other operator.\n+    val currentVars = Seq(ExprCode(\"fake code;\", isNull = \"isNull1\", value = \"value1\"))\n+\n+    // currentVars(0) depends on this evaluated column.\n+    currentVars(0).inputVars = Seq(ExprInputVar(ExprCode(\"\", isNull = \"isNull2\", value = \"value2\"),\n+      dataType = IntegerType, nullable = true))\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = Add(Literal(1), BoundReference(0, IntegerType, nullable = false))\n+    val inputVars = ExpressionCodegen.getInputVarsForChildren(ctx, expr)\n+    assert(inputVars.length == 1)\n+    assert(inputVars(0).dataType == IntegerType && inputVars(0).nullable == true)\n+\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, inputVars)\n+    assert(params.length == 2)\n+    assert(params(0) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(1) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input rows for expression\") {\n+    val ctx = new CodegenContext()\n+    ctx.currentVars = null\n+    ctx.INPUT_ROW = \"i\"\n+\n+    val expr = Add(BoundReference(0, IntegerType, nullable = false),\n+      BoundReference(1, IntegerType, nullable = true))\n+    val inputRows = ExpressionCodegen.getInputRowsForChildren(ctx, expr)\n+    assert(inputRows.length == 1)\n+    assert(inputRows(0) == \"i\")\n+  }\n+\n+  test(\"Returns input rows for expression: deferred expression\") {\n+    val ctx = new CodegenContext()\n+\n+    // The referred column is not evaluated yet. But it depends on an input row from\n+    // other operator.\n+    val currentVars = Seq(ExprCode(\"fake code;\", isNull = \"isNull1\", value = \"value1\"))\n+    currentVars(0).inputRow = \"inputadaptor_row1\"\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = Add(Literal(1), BoundReference(0, IntegerType, nullable = false))\n+    val inputRows = ExpressionCodegen.getInputRowsForChildren(ctx, expr)\n+    assert(inputRows.length == 1)\n+    assert(inputRows(0) == \"inputadaptor_row1\")\n+  }\n+",
    "line": 136
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yea, added one more test.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-12T14:04:32Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class ExpressionCodegenSuite extends SparkFunSuite {\n+\n+  test(\"Returns eliminated subexpressions for expression\") {\n+    val ctx = new CodegenContext()\n+    val subExpr = Add(Literal(1), Literal(2))\n+    val exprs = Seq(Add(subExpr, Literal(3)), Add(subExpr, Literal(4)))\n+\n+    ctx.generateExpressions(exprs, doSubexpressionElimination = true)\n+    val subexpressions = ExpressionCodegen.getSubExprInChildren(ctx, exprs(0))\n+    assert(subexpressions.length == 1 && subexpressions(0) == subExpr)\n+  }\n+\n+  test(\"Gets parameters for subexpressions\") {\n+    val ctx = new CodegenContext()\n+    val subExprs = Seq(\n+      Add(Literal(1), AttributeReference(\"a\", IntegerType, nullable = false)()), // non-nullable\n+      Add(Literal(2), AttributeReference(\"b\", IntegerType, nullable = true)()))  // nullable\n+\n+    ctx.subExprEliminationExprs.put(subExprs(0), SubExprEliminationState(\"false\", \"value1\"))\n+    ctx.subExprEliminationExprs.put(subExprs(1), SubExprEliminationState(\"isNull2\", \"value2\"))\n+\n+    val subExprCodes = ExpressionCodegen.getSubExprCodes(ctx, subExprs)\n+    val subVars = subExprs.zip(subExprCodes).map { case (expr, exprCode) =>\n+      ExprInputVar(exprCode, expr.dataType, expr.nullable)\n+    }\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, subVars)\n+    assert(params.length == 3)\n+    assert(params(0) == Tuple2(\"value1\", \"int value1\"))\n+    assert(params(1) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(2) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input variables for expression: current variables\") {\n+    val ctx = new CodegenContext()\n+    val currentVars = Seq(\n+      ExprCode(\"\", isNull = \"false\", value = \"value1\"),             // evaluated\n+      ExprCode(\"\", isNull = \"isNull2\", value = \"value2\"),           // evaluated\n+      ExprCode(\"fake code;\", isNull = \"isNull3\", value = \"value3\")) // not evaluated\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = If(Literal(false),\n+      Add(BoundReference(0, IntegerType, nullable = false),\n+          BoundReference(1, IntegerType, nullable = true)),\n+        BoundReference(2, IntegerType, nullable = true))\n+\n+    val inputVars = ExpressionCodegen.getInputVarsForChildren(ctx, expr)\n+    // Only two evaluated variables included.\n+    assert(inputVars.length == 2)\n+    assert(inputVars(0).dataType == IntegerType && inputVars(0).nullable == false)\n+    assert(inputVars(1).dataType == IntegerType && inputVars(1).nullable == true)\n+    assert(inputVars(0).exprCode == currentVars(0))\n+    assert(inputVars(1).exprCode == currentVars(1))\n+\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, inputVars)\n+    assert(params.length == 3)\n+    assert(params(0) == Tuple2(\"value1\", \"int value1\"))\n+    assert(params(1) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(2) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input variables for expression: deferred variables\") {\n+    val ctx = new CodegenContext()\n+\n+    // The referred column is not evaluated yet. But it depends on an evaluated column from\n+    // other operator.\n+    val currentVars = Seq(ExprCode(\"fake code;\", isNull = \"isNull1\", value = \"value1\"))\n+\n+    // currentVars(0) depends on this evaluated column.\n+    currentVars(0).inputVars = Seq(ExprInputVar(ExprCode(\"\", isNull = \"isNull2\", value = \"value2\"),\n+      dataType = IntegerType, nullable = true))\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = Add(Literal(1), BoundReference(0, IntegerType, nullable = false))\n+    val inputVars = ExpressionCodegen.getInputVarsForChildren(ctx, expr)\n+    assert(inputVars.length == 1)\n+    assert(inputVars(0).dataType == IntegerType && inputVars(0).nullable == true)\n+\n+    val params = ExpressionCodegen.prepareFunctionParams(ctx, inputVars)\n+    assert(params.length == 2)\n+    assert(params(0) == Tuple2(\"value2\", \"int value2\"))\n+    assert(params(1) == Tuple2(\"isNull2\", \"boolean isNull2\"))\n+  }\n+\n+  test(\"Returns input rows for expression\") {\n+    val ctx = new CodegenContext()\n+    ctx.currentVars = null\n+    ctx.INPUT_ROW = \"i\"\n+\n+    val expr = Add(BoundReference(0, IntegerType, nullable = false),\n+      BoundReference(1, IntegerType, nullable = true))\n+    val inputRows = ExpressionCodegen.getInputRowsForChildren(ctx, expr)\n+    assert(inputRows.length == 1)\n+    assert(inputRows(0) == \"i\")\n+  }\n+\n+  test(\"Returns input rows for expression: deferred expression\") {\n+    val ctx = new CodegenContext()\n+\n+    // The referred column is not evaluated yet. But it depends on an input row from\n+    // other operator.\n+    val currentVars = Seq(ExprCode(\"fake code;\", isNull = \"isNull1\", value = \"value1\"))\n+    currentVars(0).inputRow = \"inputadaptor_row1\"\n+    ctx.currentVars = currentVars\n+    ctx.INPUT_ROW = null\n+\n+    val expr = Add(Literal(1), BoundReference(0, IntegerType, nullable = false))\n+    val inputRows = ExpressionCodegen.getInputRowsForChildren(ctx, expr)\n+    assert(inputRows.length == 1)\n+    assert(inputRows(0) == \"inputadaptor_row1\")\n+  }\n+",
    "line": 136
  }],
  "prId": 19813
}]