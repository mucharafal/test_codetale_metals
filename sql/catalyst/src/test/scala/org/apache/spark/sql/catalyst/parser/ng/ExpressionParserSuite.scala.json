[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "when will we have a prefix for function?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T03:37:18Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())",
    "line": 196
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "When referencing a function defined in another database? (Not quite sure about this.)\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:30:09Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())",
    "line": 196
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Do you mean `function(Symbol(\"foo.bar\"))`?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:33:49Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())",
    "line": 196
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Ah... now I see. HiveQl allows us to have function dot separated function names. So I am just making sure this works. I am not sure how much sense this makes further down the line.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T17:26:03Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())",
    "line": 196
  }],
  "prId": 11557
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why does the `*` parsed to `1`?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T03:37:50Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "That is currently normal behavior (also in the current parser) for count. I currently implemented this for all functions, and this should be for count only; I'll change this. \n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:38:10Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))"
  }],
  "prId": 11557
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is it standard? Previously we only treat `struct(a, b)` as row constructor\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T03:43:16Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))\n+    assertEqual(\"foo(a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(all a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(distinct a, b)\", 'foo.distinctFunction('a, 'b))\n+    assertEqual(\"grouping(distinct a, b)\", 'grouping.distinctFunction('a, 'b))\n+    assertEqual(\"`select`(all a, b)\", 'select.function('a, 'b))\n+  }\n+\n+  test(\"window function expressions\") {\n+    val func = 'foo.function(1)\n+    def windowed(\n+        partitioning: Seq[Expression] = Seq.empty,\n+        ordering: Seq[SortOrder] = Seq.empty,\n+        frame: WindowFrame = UnspecifiedFrame): Expression = {\n+      WindowExpression(func, WindowSpecDefinition(partitioning, ordering, frame))\n+    }\n+\n+    // Basic window testing.\n+    assertEqual(\"foo(*) over w1\", UnresolvedWindowExpression(func, WindowSpecReference(\"w1\")))\n+    assertEqual(\"foo(*) over ()\", windowed())\n+    assertEqual(\"foo(*) over (partition by a, b)\", windowed(Seq('a, 'b)))\n+    assertEqual(\"foo(*) over (order by a desc, b asc)\", windowed(Seq.empty, Seq('a.desc, 'b.asc )))\n+    assertEqual(\"foo(*) over (partition by a, b order by c)\", windowed(Seq('a, 'b), Seq('c.asc)))\n+\n+    // Test use of expressions in window functions.\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product) + (1)) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product / 2) + 1) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product / 2 + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+\n+    // Range/Row\n+    val frameTypes = Seq((\"rows\", RowFrame), (\"range\", RangeFrame))\n+    val boundaries = Seq(\n+      (\"10 preceding\", ValuePreceding(10), CurrentRow),\n+      (\"3 + 1 following\", ValueFollowing(4), CurrentRow), // Will fail during analysis\n+      (\"unbounded preceding\", UnboundedPreceding, CurrentRow),\n+      (\"unbounded following\", UnboundedFollowing, CurrentRow), // Will fail during analysis\n+      (\"between unbounded preceding and current row\", UnboundedPreceding, CurrentRow),\n+      (\"between unbounded preceding and unbounded following\",\n+        UnboundedPreceding, UnboundedFollowing),\n+      (\"between 10 preceding and current row\", ValuePreceding(10), CurrentRow),\n+      (\"between current row and 5 following\", CurrentRow, ValueFollowing(5)),\n+      (\"between 10 preceding and 5 following\", ValuePreceding(10), ValueFollowing(5))\n+    )\n+    frameTypes.foreach {\n+      case (frameTypeSql, frameType) =>\n+        boundaries.foreach {\n+          case (boundarySql, begin, end) =>\n+            val query = s\"foo(*) over (partition by a order by b $frameTypeSql $boundarySql)\"\n+            val expr = windowed(Seq('a), Seq('b.asc), SpecifiedWindowFrame(frameType, begin, end))\n+            assertEqual(query, expr)\n+        }\n+    }\n+\n+    // We cannot use non integer constants.\n+    intercept(\"foo(*) over (partition by a order by b rows 10.0 preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot use an arbitrary expression.\n+    intercept(\"foo(*) over (partition by a order by b rows exp(b) preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot have a frame without an order by clause.\n+    intercept(\"foo(*) over (partition by a rows 10 preceding)\", \"mismatched input 'rows'\")\n+  }\n+\n+  test(\"row constructor\") {\n+    // Note that '(a)' will be interpreted as a nested expression.\n+    assertEqual(\"(a, b)\", CreateStruct(Seq('a, 'b)))",
    "line": 271
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "This is to support rows in virtual tables (inline tables), and I kinda like it.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:40:42Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))\n+    assertEqual(\"foo(a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(all a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(distinct a, b)\", 'foo.distinctFunction('a, 'b))\n+    assertEqual(\"grouping(distinct a, b)\", 'grouping.distinctFunction('a, 'b))\n+    assertEqual(\"`select`(all a, b)\", 'select.function('a, 'b))\n+  }\n+\n+  test(\"window function expressions\") {\n+    val func = 'foo.function(1)\n+    def windowed(\n+        partitioning: Seq[Expression] = Seq.empty,\n+        ordering: Seq[SortOrder] = Seq.empty,\n+        frame: WindowFrame = UnspecifiedFrame): Expression = {\n+      WindowExpression(func, WindowSpecDefinition(partitioning, ordering, frame))\n+    }\n+\n+    // Basic window testing.\n+    assertEqual(\"foo(*) over w1\", UnresolvedWindowExpression(func, WindowSpecReference(\"w1\")))\n+    assertEqual(\"foo(*) over ()\", windowed())\n+    assertEqual(\"foo(*) over (partition by a, b)\", windowed(Seq('a, 'b)))\n+    assertEqual(\"foo(*) over (order by a desc, b asc)\", windowed(Seq.empty, Seq('a.desc, 'b.asc )))\n+    assertEqual(\"foo(*) over (partition by a, b order by c)\", windowed(Seq('a, 'b), Seq('c.asc)))\n+\n+    // Test use of expressions in window functions.\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product) + (1)) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product / 2) + 1) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product / 2 + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+\n+    // Range/Row\n+    val frameTypes = Seq((\"rows\", RowFrame), (\"range\", RangeFrame))\n+    val boundaries = Seq(\n+      (\"10 preceding\", ValuePreceding(10), CurrentRow),\n+      (\"3 + 1 following\", ValueFollowing(4), CurrentRow), // Will fail during analysis\n+      (\"unbounded preceding\", UnboundedPreceding, CurrentRow),\n+      (\"unbounded following\", UnboundedFollowing, CurrentRow), // Will fail during analysis\n+      (\"between unbounded preceding and current row\", UnboundedPreceding, CurrentRow),\n+      (\"between unbounded preceding and unbounded following\",\n+        UnboundedPreceding, UnboundedFollowing),\n+      (\"between 10 preceding and current row\", ValuePreceding(10), CurrentRow),\n+      (\"between current row and 5 following\", CurrentRow, ValueFollowing(5)),\n+      (\"between 10 preceding and 5 following\", ValuePreceding(10), ValueFollowing(5))\n+    )\n+    frameTypes.foreach {\n+      case (frameTypeSql, frameType) =>\n+        boundaries.foreach {\n+          case (boundarySql, begin, end) =>\n+            val query = s\"foo(*) over (partition by a order by b $frameTypeSql $boundarySql)\"\n+            val expr = windowed(Seq('a), Seq('b.asc), SpecifiedWindowFrame(frameType, begin, end))\n+            assertEqual(query, expr)\n+        }\n+    }\n+\n+    // We cannot use non integer constants.\n+    intercept(\"foo(*) over (partition by a order by b rows 10.0 preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot use an arbitrary expression.\n+    intercept(\"foo(*) over (partition by a order by b rows exp(b) preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot have a frame without an order by clause.\n+    intercept(\"foo(*) over (partition by a rows 10 preceding)\", \"mismatched input 'rows'\")\n+  }\n+\n+  test(\"row constructor\") {\n+    // Note that '(a)' will be interpreted as a nested expression.\n+    assertEqual(\"(a, b)\", CreateStruct(Seq('a, 'b)))",
    "line": 271
  }],
  "prId": 11557
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about the day-time intervals?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T03:50:29Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))\n+    assertEqual(\"foo(a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(all a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(distinct a, b)\", 'foo.distinctFunction('a, 'b))\n+    assertEqual(\"grouping(distinct a, b)\", 'grouping.distinctFunction('a, 'b))\n+    assertEqual(\"`select`(all a, b)\", 'select.function('a, 'b))\n+  }\n+\n+  test(\"window function expressions\") {\n+    val func = 'foo.function(1)\n+    def windowed(\n+        partitioning: Seq[Expression] = Seq.empty,\n+        ordering: Seq[SortOrder] = Seq.empty,\n+        frame: WindowFrame = UnspecifiedFrame): Expression = {\n+      WindowExpression(func, WindowSpecDefinition(partitioning, ordering, frame))\n+    }\n+\n+    // Basic window testing.\n+    assertEqual(\"foo(*) over w1\", UnresolvedWindowExpression(func, WindowSpecReference(\"w1\")))\n+    assertEqual(\"foo(*) over ()\", windowed())\n+    assertEqual(\"foo(*) over (partition by a, b)\", windowed(Seq('a, 'b)))\n+    assertEqual(\"foo(*) over (order by a desc, b asc)\", windowed(Seq.empty, Seq('a.desc, 'b.asc )))\n+    assertEqual(\"foo(*) over (partition by a, b order by c)\", windowed(Seq('a, 'b), Seq('c.asc)))\n+\n+    // Test use of expressions in window functions.\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product) + (1)) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product / 2) + 1) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product / 2 + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+\n+    // Range/Row\n+    val frameTypes = Seq((\"rows\", RowFrame), (\"range\", RangeFrame))\n+    val boundaries = Seq(\n+      (\"10 preceding\", ValuePreceding(10), CurrentRow),\n+      (\"3 + 1 following\", ValueFollowing(4), CurrentRow), // Will fail during analysis\n+      (\"unbounded preceding\", UnboundedPreceding, CurrentRow),\n+      (\"unbounded following\", UnboundedFollowing, CurrentRow), // Will fail during analysis\n+      (\"between unbounded preceding and current row\", UnboundedPreceding, CurrentRow),\n+      (\"between unbounded preceding and unbounded following\",\n+        UnboundedPreceding, UnboundedFollowing),\n+      (\"between 10 preceding and current row\", ValuePreceding(10), CurrentRow),\n+      (\"between current row and 5 following\", CurrentRow, ValueFollowing(5)),\n+      (\"between 10 preceding and 5 following\", ValuePreceding(10), ValueFollowing(5))\n+    )\n+    frameTypes.foreach {\n+      case (frameTypeSql, frameType) =>\n+        boundaries.foreach {\n+          case (boundarySql, begin, end) =>\n+            val query = s\"foo(*) over (partition by a order by b $frameTypeSql $boundarySql)\"\n+            val expr = windowed(Seq('a), Seq('b.asc), SpecifiedWindowFrame(frameType, begin, end))\n+            assertEqual(query, expr)\n+        }\n+    }\n+\n+    // We cannot use non integer constants.\n+    intercept(\"foo(*) over (partition by a order by b rows 10.0 preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot use an arbitrary expression.\n+    intercept(\"foo(*) over (partition by a order by b rows exp(b) preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot have a frame without an order by clause.\n+    intercept(\"foo(*) over (partition by a rows 10 preceding)\", \"mismatched input 'rows'\")\n+  }\n+\n+  test(\"row constructor\") {\n+    // Note that '(a)' will be interpreted as a nested expression.\n+    assertEqual(\"(a, b)\", CreateStruct(Seq('a, 'b)))\n+    assertEqual(\"(a, b, c)\", CreateStruct(Seq('a, 'b, 'c)))\n+  }\n+\n+  test(\"scalar sub-query\") {\n+    assertEqual(\n+      \"(select max(val) from tbl) > current\",\n+      ScalarSubquery(table(\"tbl\").select('max.function('val))) > 'current)\n+    assertEqual(\n+      \"a = (select b from s)\",\n+      'a === ScalarSubquery(table(\"s\").select('b)))\n+  }\n+\n+  test(\"case when\") {\n+    assertEqual(\"case a when 1 then b when 2 then c else d end\",\n+      CaseKeyWhen('a, Seq(1, 'b, 2, 'c, 'd)))\n+    assertEqual(\"case when a = 1 then b when a = 2 then c else d end\",\n+      CaseWhen(Seq(('a === 1, 'b.expr), ('a === 2, 'c.expr)), 'd))\n+  }\n+\n+  test(\"dereference\") {\n+    assertEqual(\"a.b\", UnresolvedAttribute(\"a.b\"))\n+    assertEqual(\"`select`.b\", UnresolvedAttribute(\"select.b\"))\n+    assertEqual(\"(a + b).b\", ('a + 'b).getField(\"b\")) // This will fail analysis.\n+    assertEqual(\"struct(a, b).b\", 'struct.function('a, 'b).getField(\"b\"))\n+  }\n+\n+  test(\"reference\") {\n+    // Regular\n+    assertEqual(\"a\", 'a)\n+\n+    // Starting with a digit.\n+    assertEqual(\"1a\", Symbol(\"1a\"))\n+\n+    // Quoted using a keyword.\n+    assertEqual(\"`select`\", 'select)\n+\n+    // Unquoted using an unreserved keyword.\n+    assertEqual(\"columns\", 'columns)\n+  }\n+\n+  test(\"subscript\") {\n+    assertEqual(\"a[b]\", 'a.getItem('b))\n+    assertEqual(\"a[1 + 1]\", 'a.getItem(Literal(1) + 1))\n+    assertEqual(\"`c`.a[b]\", UnresolvedAttribute(\"c.a\").getItem('b))\n+  }\n+\n+  test(\"parenthesis\") {\n+    assertEqual(\"(a)\", 'a)\n+    assertEqual(\"r * (a + b)\", 'r * ('a + 'b))\n+  }\n+\n+  test(\"type constructors\") {\n+    // Dates.\n+    assertEqual(\"dAte '2016-03-11'\", Literal(Date.valueOf(\"2016-03-11\")))\n+    intercept[IllegalArgumentException] {\n+      parseExpression(\"DAtE 'mar 11 2016'\")\n+    }\n+\n+    // Timestamps.\n+    assertEqual(\"tImEstAmp '2016-03-11 20:54:00.000'\",\n+      Literal(Timestamp.valueOf(\"2016-03-11 20:54:00.000\")))\n+    intercept[IllegalArgumentException] {\n+      parseExpression(\"timestamP '2016-33-11 20:54:00.000'\")\n+    }\n+\n+    // Unsupported datatype.\n+    intercept(\"GEO '(10,-6)'\", \"Literals of type 'GEO' are currently not supported.\")\n+  }\n+\n+  test(\"literals\") {\n+    // NULL\n+    assertEqual(\"null\", Literal(null))\n+\n+    // Boolean\n+    assertEqual(\"trUe\", Literal(true))\n+    assertEqual(\"False\", Literal(false))\n+\n+    // Integral should have the narrowest possible type\n+    assertEqual(\"787324\", Literal(787324))\n+    assertEqual(\"7873247234798249234\", Literal(7873247234798249234L))\n+    assertEqual(\"78732472347982492793712334\",\n+      Literal(BigDecimal(\"78732472347982492793712334\").underlying()))\n+\n+    // Decimal\n+    assertEqual(\"7873247234798249279371.2334\",\n+      Literal(BigDecimal(\"7873247234798249279371.2334\").underlying()))\n+\n+    // Scientific Decimal\n+    assertEqual(\"9.0e1\", 90d)\n+    assertEqual(\".9e+2\", 90d)\n+    assertEqual(\"0.9e+2\", 90d)\n+    assertEqual(\"900e-1\", 90d)\n+    assertEqual(\"900.0E-1\", 90d)\n+    assertEqual(\"9.e+1\", 90d)\n+    intercept(\".e3\")\n+\n+    // Tiny Int Literal\n+    assertEqual(\"10Y\", Literal(10.toByte))\n+    intercept(\"-1000Y\")\n+\n+    // Small Int Literal\n+    assertEqual(\"10S\", Literal(10.toShort))\n+    intercept(\"40000S\")\n+\n+    // Long Int Literal\n+    assertEqual(\"10L\", Literal(10L))\n+    intercept(\"78732472347982492793712334L\")\n+\n+    // Double Literal\n+    assertEqual(\"10.0D\", Literal(10.0D))\n+    // TODO we need to figure out if we should throw an exception here!\n+    assertEqual(\"1E309\", Literal(Double.PositiveInfinity))\n+  }\n+\n+  test(\"strings\") {\n+    // Single Strings.\n+    assertEqual(\"\\\"hello\\\"\", \"hello\")\n+    assertEqual(\"'hello'\", \"hello\")\n+\n+    // Multi-Strings.\n+    assertEqual(\"\\\"hello\\\" 'world'\", \"helloworld\")\n+    assertEqual(\"'hello' \\\" \\\" 'world'\", \"hello world\")\n+\n+    // 'LIKE' string literals. Notice that an escaped '%' is the same as an escaped '\\' and a\n+    // regular '%'; to get the correct result you need to add another escaped '\\'.\n+    // TODO figure out if we shouldn't change the ParseUtils.unescapeSQLString method?\n+    assertEqual(\"'pattern%'\", \"pattern%\")\n+    assertEqual(\"'no-pattern\\\\%'\", \"no-pattern\\\\%\")\n+    assertEqual(\"'pattern\\\\\\\\%'\", \"pattern\\\\%\")\n+    assertEqual(\"'pattern\\\\\\\\\\\\%'\", \"pattern\\\\\\\\%\")\n+\n+    // Escaped characters.\n+    // See: http://dev.mysql.com/doc/refman/5.7/en/string-literals.html\n+    assertEqual(\"'\\\\0'\", \"\\u0000\") // ASCII NUL (X'00')\n+    assertEqual(\"'\\\\''\", \"\\'\")     // Single quote\n+    assertEqual(\"'\\\\\\\"'\", \"\\\"\")    // Double quote\n+    assertEqual(\"'\\\\b'\", \"\\b\")     // Backspace\n+    assertEqual(\"'\\\\n'\", \"\\n\")     // Newline\n+    assertEqual(\"'\\\\r'\", \"\\r\")     // Carriage return\n+    assertEqual(\"'\\\\t'\", \"\\t\")     // Tab character\n+    assertEqual(\"'\\\\Z'\", \"\\u001A\") // ASCII 26 - CTRL + Z (EOF on windows)\n+\n+    // Octals\n+    assertEqual(\"'\\\\110\\\\145\\\\154\\\\154\\\\157\\\\041'\", \"Hello!\")\n+\n+    // Unicode\n+    assertEqual(\"'\\\\u0087\\\\u0111\\\\u0114\\\\u0108\\\\u0100\\\\u0032\\\\u0058\\\\u0041'\", \"World :)\")\n+  }\n+\n+  test(\"intervals\") {\n+    def intervalLiteral(u: String, s: String): Literal = {\n+      Literal(CalendarInterval.fromSingleUnitString(u, s))\n+    }\n+\n+    // Empty interval statement\n+    intercept(\"interval\", \"at least one time unit should be given for interval literal\")\n+\n+    // Single Intervals.\n+    val units = Seq(\n+      \"year\",\n+      \"month\",\n+      \"week\",\n+      \"day\",\n+      \"hour\",\n+      \"minute\",\n+      \"second\",\n+      \"millisecond\",\n+      \"microsecond\")\n+    val forms = Seq(\"\", \"s\")\n+    val values = Seq(\"0\", \"10\", \"-7\", \"21\")\n+    units.foreach { unit =>\n+      forms.foreach { form =>\n+         values.foreach { value =>\n+           val expected = intervalLiteral(unit, value)\n+           assertEqual(s\"interval $value $unit$form\", expected)\n+           assertEqual(s\"interval '$value' $unit$form\", expected)\n+         }\n+      }\n+    }\n+\n+    // Hive nanosecond notation.\n+    assertEqual(\"interval 13.123456789 seconds\", intervalLiteral(\"second\", \"13.123456789\"))\n+    assertEqual(\"interval -13.123456789 second\", intervalLiteral(\"second\", \"-13.123456789\"))\n+\n+    // Non Existing unit\n+    intercept(\"interval 10 nanoseconds\", \"No interval can be constructed\")\n+\n+    // Year-Month intervals.\n+    val yearMonthValues = Seq(\"123-10\", \"496-0\", \"-2-3\", \"-123-0\")\n+    yearMonthValues.foreach { value =>\n+      val result = Literal(CalendarInterval.fromYearMonthString(value))\n+      assertEqual(s\"interval '$value' year to month\", result)\n+    }\n+\n+    // Year-Month intervals."
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "We do after line 463. I added the wrong comment.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:41:10Z",
    "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import java.sql.{Date, Timestamp}\n+\n+import org.apache.spark.sql.catalyst.TableIdentifier\n+import org.apache.spark.sql.catalyst.analysis.{UnresolvedAttribute, _}\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.PlanTest\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+/**\n+ * Test basic expression parsing. If a type of expression is supported it should be tested here.\n+ *\n+ * Please note that some of the expressions test don't have to be sound expressions, only their\n+ * structure needs to be valid. Unsound expressions should be caught by the Analyzer or\n+ * CheckAnalysis classes.\n+ */\n+class ExpressionParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, e: Expression): Unit = {\n+    compareExpressions(parseExpression(sqlCommand), e)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parseExpression(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"star expressions\") {\n+    // Global Star\n+    assertEqual(\"*\", UnresolvedStar(None))\n+\n+    // Targeted Star\n+    assertEqual(\"a.b.*\", UnresolvedStar(Option(Seq(\"a\", \"b\"))))\n+  }\n+\n+  // NamedExpression (Alias/Multialias)\n+  test(\"named expressions\") {\n+    // No Alias\n+    val r0 = 'a\n+    assertEqual(\"a\", r0)\n+\n+    // Single Alias.\n+    val r1 = 'a as \"b\"\n+    assertEqual(\"a as b\", r1)\n+    assertEqual(\"a b\", r1)\n+\n+    // Multi-Alias\n+    assertEqual(\"a as (b, c)\", MultiAlias('a, Seq(\"b\", \"c\")))\n+    assertEqual(\"a() (b, c)\", MultiAlias('a.function(), Seq(\"b\", \"c\")))\n+\n+    // Numeric literals without a space between the literal qualifier and the alias, should not be\n+    // interpreted as such. An unresolved reference should be returned instead.\n+    // TODO add the JIRA-ticket number.\n+    assertEqual(\"1SL\", Symbol(\"1SL\"))\n+\n+    // Aliased star is allowed.\n+    assertEqual(\"a.* b\", UnresolvedStar(Option(Seq(\"a\"))) as 'b)\n+  }\n+\n+  test(\"binary logical expressions\") {\n+    // And\n+    assertEqual(\"a and b\", 'a && 'b)\n+\n+    // Or\n+    assertEqual(\"a or b\", 'a || 'b)\n+\n+    // Combination And/Or check precedence\n+    assertEqual(\"a and b or c and d\", ('a && 'b) || ('c && 'd))\n+    assertEqual(\"a or b or c and d\", 'a || 'b || ('c && 'd))\n+\n+    // Multiple AND/OR get converted into a balanced tree\n+    assertEqual(\"a or b or c or d or e or f\", (('a || 'b) || 'c) || (('d || 'e) || 'f))\n+    assertEqual(\"a and b and c and d and e and f\", (('a && 'b) && 'c) && (('d && 'e) && 'f))\n+  }\n+\n+  test(\"long binary logical expressions\") {\n+    def testVeryBinaryExpression(op: String, clazz: Class[_]): Unit = {\n+      val sql = (1 to 1000).map(x => s\"$x == $x\").mkString(op)\n+      val e = parseExpression(sql)\n+      assert(e.collect { case _: EqualTo => true }.size === 1000)\n+      assert(e.collect { case x if clazz.isInstance(x) => true }.size === 999)\n+    }\n+    testVeryBinaryExpression(\" AND \", classOf[And])\n+    testVeryBinaryExpression(\" OR \", classOf[Or])\n+  }\n+\n+  test(\"not expressions\") {\n+    assertEqual(\"not a\", !'a)\n+    assertEqual(\"!a\", !'a)\n+    assertEqual(\"not true > true\", Not(GreaterThan(true, true)))\n+  }\n+\n+  test(\"exists expression\") {\n+    intercept(\"exists (select 1 from b where b.x = a.x)\", \"EXISTS clauses are not supported\")\n+  }\n+\n+  test(\"comparison expressions\") {\n+    assertEqual(\"a = b\", 'a === 'b)\n+    assertEqual(\"a == b\", 'a === 'b)\n+    assertEqual(\"a <=> b\", 'a <=> 'b)\n+    assertEqual(\"a <> b\", 'a =!= 'b)\n+    assertEqual(\"a != b\", 'a =!= 'b)\n+    assertEqual(\"a < b\", 'a < 'b)\n+    assertEqual(\"a <= b\", 'a <= 'b)\n+    assertEqual(\"a > b\", 'a > 'b)\n+    assertEqual(\"a >= b\", 'a >= 'b)\n+  }\n+\n+  test(\"between expressions\") {\n+    assertEqual(\"a between b and c\", 'a >= 'b && 'a <= 'c)\n+    assertEqual(\"a not between b and c\", !('a >= 'b && 'a <= 'c))\n+  }\n+\n+  test(\"in expressions\") {\n+    assertEqual(\"a in (b, c, d)\", 'a in ('b, 'c, 'd))\n+    assertEqual(\"a not in (b, c, d)\", !('a in ('b, 'c, 'd)))\n+  }\n+\n+  test(\"in sub-query\") {\n+    intercept(\"a in (select b from c)\", \"IN with a Sub-query is currently not supported\")\n+  }\n+\n+  test(\"like expressions\") {\n+    assertEqual(\"a like 'pattern%'\", 'a like \"pattern%\")\n+    assertEqual(\"a not like 'pattern%'\", !('a like \"pattern%\"))\n+    assertEqual(\"a rlike 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not rlike 'pattern%'\", !('a rlike \"pattern%\"))\n+    assertEqual(\"a regexp 'pattern%'\", 'a rlike \"pattern%\")\n+    assertEqual(\"a not regexp 'pattern%'\", !('a rlike \"pattern%\"))\n+  }\n+\n+  test(\"is null expressions\") {\n+    assertEqual(\"a is null\", 'a.isNull)\n+    assertEqual(\"a is not null\", 'a.isNotNull)\n+  }\n+\n+  test(\"binary arithmetic expressions\") {\n+    // Simple operations\n+    assertEqual(\"a * b\", 'a * 'b)\n+    assertEqual(\"a / b\", 'a / 'b)\n+    assertEqual(\"a DIV b\", ('a / 'b).cast(LongType))\n+    assertEqual(\"a % b\", 'a % 'b)\n+    assertEqual(\"a + b\", 'a + 'b)\n+    assertEqual(\"a - b\", 'a - 'b)\n+    assertEqual(\"a & b\", 'a & 'b)\n+    assertEqual(\"a ^ b\", 'a ^ 'b)\n+    assertEqual(\"a | b\", 'a | 'b)\n+\n+    // Check precedences\n+    assertEqual(\n+      \"a * t | b ^ c & d - e + f % g DIV h / i * k\",\n+      'a * 't | ('b ^ ('c & ('d - 'e + (('f % 'g / 'h).cast(LongType) / 'i * 'k)))))\n+  }\n+\n+  test(\"unary arithmetic expressions\") {\n+    assertEqual(\"+a\", 'a)\n+    assertEqual(\"-a\", -'a)\n+    assertEqual(\"~a\", ~'a)\n+    assertEqual(\"-+~~a\", -(~(~'a)))\n+  }\n+\n+  test(\"cast expressions\") {\n+    // Note that DataType parsing is tested elsewhere.\n+    assertEqual(\"cast(a as int)\", 'a.cast(IntegerType))\n+    assertEqual(\"cast(a as timestamp)\", 'a.cast(TimestampType))\n+    assertEqual(\"cast(a as array<int>)\", 'a.cast(ArrayType(IntegerType)))\n+    assertEqual(\"cast(cast(a as int) as long)\", 'a.cast(IntegerType).cast(LongType))\n+  }\n+\n+  test(\"function expressions\") {\n+    assertEqual(\"foo()\", 'foo.function())\n+    assertEqual(\"foo.bar()\", Symbol(\"foo.bar\").function())\n+    assertEqual(\"foo(*)\", 'foo.function(1))\n+    assertEqual(\"foo(a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(all a, b)\", 'foo.function('a, 'b))\n+    assertEqual(\"foo(distinct a, b)\", 'foo.distinctFunction('a, 'b))\n+    assertEqual(\"grouping(distinct a, b)\", 'grouping.distinctFunction('a, 'b))\n+    assertEqual(\"`select`(all a, b)\", 'select.function('a, 'b))\n+  }\n+\n+  test(\"window function expressions\") {\n+    val func = 'foo.function(1)\n+    def windowed(\n+        partitioning: Seq[Expression] = Seq.empty,\n+        ordering: Seq[SortOrder] = Seq.empty,\n+        frame: WindowFrame = UnspecifiedFrame): Expression = {\n+      WindowExpression(func, WindowSpecDefinition(partitioning, ordering, frame))\n+    }\n+\n+    // Basic window testing.\n+    assertEqual(\"foo(*) over w1\", UnresolvedWindowExpression(func, WindowSpecReference(\"w1\")))\n+    assertEqual(\"foo(*) over ()\", windowed())\n+    assertEqual(\"foo(*) over (partition by a, b)\", windowed(Seq('a, 'b)))\n+    assertEqual(\"foo(*) over (order by a desc, b asc)\", windowed(Seq.empty, Seq('a.desc, 'b.asc )))\n+    assertEqual(\"foo(*) over (partition by a, b order by c)\", windowed(Seq('a, 'b), Seq('c.asc)))\n+\n+    // Test use of expressions in window functions.\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product) + (1)) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+    assertEqual(\n+      \"sum(product + 1) over (partition by ((product / 2) + 1) order by 2)\",\n+      WindowExpression('sum.function('product + 1),\n+        WindowSpecDefinition(Seq('product / 2 + 1), Seq(Literal(2).asc), UnspecifiedFrame)))\n+\n+    // Range/Row\n+    val frameTypes = Seq((\"rows\", RowFrame), (\"range\", RangeFrame))\n+    val boundaries = Seq(\n+      (\"10 preceding\", ValuePreceding(10), CurrentRow),\n+      (\"3 + 1 following\", ValueFollowing(4), CurrentRow), // Will fail during analysis\n+      (\"unbounded preceding\", UnboundedPreceding, CurrentRow),\n+      (\"unbounded following\", UnboundedFollowing, CurrentRow), // Will fail during analysis\n+      (\"between unbounded preceding and current row\", UnboundedPreceding, CurrentRow),\n+      (\"between unbounded preceding and unbounded following\",\n+        UnboundedPreceding, UnboundedFollowing),\n+      (\"between 10 preceding and current row\", ValuePreceding(10), CurrentRow),\n+      (\"between current row and 5 following\", CurrentRow, ValueFollowing(5)),\n+      (\"between 10 preceding and 5 following\", ValuePreceding(10), ValueFollowing(5))\n+    )\n+    frameTypes.foreach {\n+      case (frameTypeSql, frameType) =>\n+        boundaries.foreach {\n+          case (boundarySql, begin, end) =>\n+            val query = s\"foo(*) over (partition by a order by b $frameTypeSql $boundarySql)\"\n+            val expr = windowed(Seq('a), Seq('b.asc), SpecifiedWindowFrame(frameType, begin, end))\n+            assertEqual(query, expr)\n+        }\n+    }\n+\n+    // We cannot use non integer constants.\n+    intercept(\"foo(*) over (partition by a order by b rows 10.0 preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot use an arbitrary expression.\n+    intercept(\"foo(*) over (partition by a order by b rows exp(b) preceding)\",\n+      \"Frame bound value must be a constant integer.\")\n+\n+    // We cannot have a frame without an order by clause.\n+    intercept(\"foo(*) over (partition by a rows 10 preceding)\", \"mismatched input 'rows'\")\n+  }\n+\n+  test(\"row constructor\") {\n+    // Note that '(a)' will be interpreted as a nested expression.\n+    assertEqual(\"(a, b)\", CreateStruct(Seq('a, 'b)))\n+    assertEqual(\"(a, b, c)\", CreateStruct(Seq('a, 'b, 'c)))\n+  }\n+\n+  test(\"scalar sub-query\") {\n+    assertEqual(\n+      \"(select max(val) from tbl) > current\",\n+      ScalarSubquery(table(\"tbl\").select('max.function('val))) > 'current)\n+    assertEqual(\n+      \"a = (select b from s)\",\n+      'a === ScalarSubquery(table(\"s\").select('b)))\n+  }\n+\n+  test(\"case when\") {\n+    assertEqual(\"case a when 1 then b when 2 then c else d end\",\n+      CaseKeyWhen('a, Seq(1, 'b, 2, 'c, 'd)))\n+    assertEqual(\"case when a = 1 then b when a = 2 then c else d end\",\n+      CaseWhen(Seq(('a === 1, 'b.expr), ('a === 2, 'c.expr)), 'd))\n+  }\n+\n+  test(\"dereference\") {\n+    assertEqual(\"a.b\", UnresolvedAttribute(\"a.b\"))\n+    assertEqual(\"`select`.b\", UnresolvedAttribute(\"select.b\"))\n+    assertEqual(\"(a + b).b\", ('a + 'b).getField(\"b\")) // This will fail analysis.\n+    assertEqual(\"struct(a, b).b\", 'struct.function('a, 'b).getField(\"b\"))\n+  }\n+\n+  test(\"reference\") {\n+    // Regular\n+    assertEqual(\"a\", 'a)\n+\n+    // Starting with a digit.\n+    assertEqual(\"1a\", Symbol(\"1a\"))\n+\n+    // Quoted using a keyword.\n+    assertEqual(\"`select`\", 'select)\n+\n+    // Unquoted using an unreserved keyword.\n+    assertEqual(\"columns\", 'columns)\n+  }\n+\n+  test(\"subscript\") {\n+    assertEqual(\"a[b]\", 'a.getItem('b))\n+    assertEqual(\"a[1 + 1]\", 'a.getItem(Literal(1) + 1))\n+    assertEqual(\"`c`.a[b]\", UnresolvedAttribute(\"c.a\").getItem('b))\n+  }\n+\n+  test(\"parenthesis\") {\n+    assertEqual(\"(a)\", 'a)\n+    assertEqual(\"r * (a + b)\", 'r * ('a + 'b))\n+  }\n+\n+  test(\"type constructors\") {\n+    // Dates.\n+    assertEqual(\"dAte '2016-03-11'\", Literal(Date.valueOf(\"2016-03-11\")))\n+    intercept[IllegalArgumentException] {\n+      parseExpression(\"DAtE 'mar 11 2016'\")\n+    }\n+\n+    // Timestamps.\n+    assertEqual(\"tImEstAmp '2016-03-11 20:54:00.000'\",\n+      Literal(Timestamp.valueOf(\"2016-03-11 20:54:00.000\")))\n+    intercept[IllegalArgumentException] {\n+      parseExpression(\"timestamP '2016-33-11 20:54:00.000'\")\n+    }\n+\n+    // Unsupported datatype.\n+    intercept(\"GEO '(10,-6)'\", \"Literals of type 'GEO' are currently not supported.\")\n+  }\n+\n+  test(\"literals\") {\n+    // NULL\n+    assertEqual(\"null\", Literal(null))\n+\n+    // Boolean\n+    assertEqual(\"trUe\", Literal(true))\n+    assertEqual(\"False\", Literal(false))\n+\n+    // Integral should have the narrowest possible type\n+    assertEqual(\"787324\", Literal(787324))\n+    assertEqual(\"7873247234798249234\", Literal(7873247234798249234L))\n+    assertEqual(\"78732472347982492793712334\",\n+      Literal(BigDecimal(\"78732472347982492793712334\").underlying()))\n+\n+    // Decimal\n+    assertEqual(\"7873247234798249279371.2334\",\n+      Literal(BigDecimal(\"7873247234798249279371.2334\").underlying()))\n+\n+    // Scientific Decimal\n+    assertEqual(\"9.0e1\", 90d)\n+    assertEqual(\".9e+2\", 90d)\n+    assertEqual(\"0.9e+2\", 90d)\n+    assertEqual(\"900e-1\", 90d)\n+    assertEqual(\"900.0E-1\", 90d)\n+    assertEqual(\"9.e+1\", 90d)\n+    intercept(\".e3\")\n+\n+    // Tiny Int Literal\n+    assertEqual(\"10Y\", Literal(10.toByte))\n+    intercept(\"-1000Y\")\n+\n+    // Small Int Literal\n+    assertEqual(\"10S\", Literal(10.toShort))\n+    intercept(\"40000S\")\n+\n+    // Long Int Literal\n+    assertEqual(\"10L\", Literal(10L))\n+    intercept(\"78732472347982492793712334L\")\n+\n+    // Double Literal\n+    assertEqual(\"10.0D\", Literal(10.0D))\n+    // TODO we need to figure out if we should throw an exception here!\n+    assertEqual(\"1E309\", Literal(Double.PositiveInfinity))\n+  }\n+\n+  test(\"strings\") {\n+    // Single Strings.\n+    assertEqual(\"\\\"hello\\\"\", \"hello\")\n+    assertEqual(\"'hello'\", \"hello\")\n+\n+    // Multi-Strings.\n+    assertEqual(\"\\\"hello\\\" 'world'\", \"helloworld\")\n+    assertEqual(\"'hello' \\\" \\\" 'world'\", \"hello world\")\n+\n+    // 'LIKE' string literals. Notice that an escaped '%' is the same as an escaped '\\' and a\n+    // regular '%'; to get the correct result you need to add another escaped '\\'.\n+    // TODO figure out if we shouldn't change the ParseUtils.unescapeSQLString method?\n+    assertEqual(\"'pattern%'\", \"pattern%\")\n+    assertEqual(\"'no-pattern\\\\%'\", \"no-pattern\\\\%\")\n+    assertEqual(\"'pattern\\\\\\\\%'\", \"pattern\\\\%\")\n+    assertEqual(\"'pattern\\\\\\\\\\\\%'\", \"pattern\\\\\\\\%\")\n+\n+    // Escaped characters.\n+    // See: http://dev.mysql.com/doc/refman/5.7/en/string-literals.html\n+    assertEqual(\"'\\\\0'\", \"\\u0000\") // ASCII NUL (X'00')\n+    assertEqual(\"'\\\\''\", \"\\'\")     // Single quote\n+    assertEqual(\"'\\\\\\\"'\", \"\\\"\")    // Double quote\n+    assertEqual(\"'\\\\b'\", \"\\b\")     // Backspace\n+    assertEqual(\"'\\\\n'\", \"\\n\")     // Newline\n+    assertEqual(\"'\\\\r'\", \"\\r\")     // Carriage return\n+    assertEqual(\"'\\\\t'\", \"\\t\")     // Tab character\n+    assertEqual(\"'\\\\Z'\", \"\\u001A\") // ASCII 26 - CTRL + Z (EOF on windows)\n+\n+    // Octals\n+    assertEqual(\"'\\\\110\\\\145\\\\154\\\\154\\\\157\\\\041'\", \"Hello!\")\n+\n+    // Unicode\n+    assertEqual(\"'\\\\u0087\\\\u0111\\\\u0114\\\\u0108\\\\u0100\\\\u0032\\\\u0058\\\\u0041'\", \"World :)\")\n+  }\n+\n+  test(\"intervals\") {\n+    def intervalLiteral(u: String, s: String): Literal = {\n+      Literal(CalendarInterval.fromSingleUnitString(u, s))\n+    }\n+\n+    // Empty interval statement\n+    intercept(\"interval\", \"at least one time unit should be given for interval literal\")\n+\n+    // Single Intervals.\n+    val units = Seq(\n+      \"year\",\n+      \"month\",\n+      \"week\",\n+      \"day\",\n+      \"hour\",\n+      \"minute\",\n+      \"second\",\n+      \"millisecond\",\n+      \"microsecond\")\n+    val forms = Seq(\"\", \"s\")\n+    val values = Seq(\"0\", \"10\", \"-7\", \"21\")\n+    units.foreach { unit =>\n+      forms.foreach { form =>\n+         values.foreach { value =>\n+           val expected = intervalLiteral(unit, value)\n+           assertEqual(s\"interval $value $unit$form\", expected)\n+           assertEqual(s\"interval '$value' $unit$form\", expected)\n+         }\n+      }\n+    }\n+\n+    // Hive nanosecond notation.\n+    assertEqual(\"interval 13.123456789 seconds\", intervalLiteral(\"second\", \"13.123456789\"))\n+    assertEqual(\"interval -13.123456789 second\", intervalLiteral(\"second\", \"-13.123456789\"))\n+\n+    // Non Existing unit\n+    intercept(\"interval 10 nanoseconds\", \"No interval can be constructed\")\n+\n+    // Year-Month intervals.\n+    val yearMonthValues = Seq(\"123-10\", \"496-0\", \"-2-3\", \"-123-0\")\n+    yearMonthValues.foreach { value =>\n+      val result = Literal(CalendarInterval.fromYearMonthString(value))\n+      assertEqual(s\"interval '$value' year to month\", result)\n+    }\n+\n+    // Year-Month intervals."
  }],
  "prId": 11557
}]