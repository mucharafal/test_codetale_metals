[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Is this allowed? I tried it on PostgreSQL, it throws exception.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T02:57:10Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "This currently works in our parser. I first tied a `HAVING` to a `GROUP BY` clause, but then the following query failed: `SELECT COUNT(*), SUM(A) FROM tbl HAVING COUNT(*) > 1`\n\nI have also added this to show that some of the syntax is a bit weird.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:31:03Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Agree. There should be at least one aggregate function being `SELECT`-ed.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:32:11Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Oh I see, so although the parser accepts this syntax, we must detect this case in analyzer.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:34:57Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "So this syntax should be allowed, but we need to fail analysis. However, we will convert both `WHERE` and `HAVING` to `Filter`, it's a bit hard to distinguish them during analysis.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:41:07Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Throwing an exception during analysis would actually be a regression. I am pretty sure that we support this in HiveQl for 1.6.\n\nI am also not sure if we should be that struct. HAVING only means (IMHO) that a filter is applied after a potential aggregation.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T07:13:42Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "It's not a big deal, we can keep it to make life easier :)\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T07:25:09Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))"
  }],
  "prId": 11557
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Is it allowed to use multi-select without the `insert`?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T03:58:13Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))\n+    assertEqual(\"select distinct a, b from db.c\", Distinct(table(\"db\", \"c\").select('a, 'b)))\n+    assertEqual(\"select all a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+  }\n+\n+  test(\"transform query spec\") {\n+    val p = ScriptTransformation(Seq('a, 'b), \"func\", Seq.empty, table(\"e\"), null)\n+    assertEqual(\"select transform(a, b) using 'func' from e where f < 10\",\n+      p.copy(child = p.child.where('f < 10)))\n+    assertEqual(\"map(a, b) using 'func' as c, d from e\",\n+      p.copy(output = Seq('c.string, 'd.string)))\n+    assertEqual(\"reduce(a, b) using 'func' as (c: int, d decimal(10, 0)) from e\",\n+      p.copy(output = Seq('c.int, 'd.decimal(10, 0))))\n+  }\n+\n+  test(\"multi select query\") {\n+    assertEqual(\n+      \"from a select * select * where s < 10\",",
    "line": 137
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "It is but it does not make much sense. Hive supports this (It returned multiple result sets).\n\nA multi-insert will then revert to a union all; so the queries should all have the same number of ouputs and similar output types.\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:45:38Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))\n+    assertEqual(\"select distinct a, b from db.c\", Distinct(table(\"db\", \"c\").select('a, 'b)))\n+    assertEqual(\"select all a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+  }\n+\n+  test(\"transform query spec\") {\n+    val p = ScriptTransformation(Seq('a, 'b), \"func\", Seq.empty, table(\"e\"), null)\n+    assertEqual(\"select transform(a, b) using 'func' from e where f < 10\",\n+      p.copy(child = p.child.where('f < 10)))\n+    assertEqual(\"map(a, b) using 'func' as c, d from e\",\n+      p.copy(output = Seq('c.string, 'd.string)))\n+    assertEqual(\"reduce(a, b) using 'func' as (c: int, d decimal(10, 0)) from e\",\n+      p.copy(output = Seq('c.int, 'd.decimal(10, 0))))\n+  }\n+\n+  test(\"multi select query\") {\n+    assertEqual(\n+      \"from a select * select * where s < 10\",",
    "line": 137
  }],
  "prId": 11557
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "This is interesting, do you have a complete example for this syntax?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T04:03:56Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))\n+    assertEqual(\"select distinct a, b from db.c\", Distinct(table(\"db\", \"c\").select('a, 'b)))\n+    assertEqual(\"select all a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+  }\n+\n+  test(\"transform query spec\") {\n+    val p = ScriptTransformation(Seq('a, 'b), \"func\", Seq.empty, table(\"e\"), null)\n+    assertEqual(\"select transform(a, b) using 'func' from e where f < 10\",\n+      p.copy(child = p.child.where('f < 10)))\n+    assertEqual(\"map(a, b) using 'func' as c, d from e\",\n+      p.copy(output = Seq('c.string, 'd.string)))\n+    assertEqual(\"reduce(a, b) using 'func' as (c: int, d decimal(10, 0)) from e\",\n+      p.copy(output = Seq('c.int, 'd.decimal(10, 0))))\n+  }\n+\n+  test(\"multi select query\") {\n+    assertEqual(\n+      \"from a select * select * where s < 10\",\n+      table(\"a\").select(star()).unionAll(table(\"a\").where('s < 10).select(star())))\n+    intercept(\n+      \"from a select * select * from x where a.s < 10\",\n+      \"Multi-Insert queries cannot have a FROM clause in their individual SELECT statements\")\n+    assertEqual(\n+      \"from a insert into tbl1 select * insert into tbl2 select * where s < 10\",\n+      table(\"a\").select(star()).insertInto(\"tbl1\").unionAll(\n+        table(\"a\").where('s < 10).select(star()).insertInto(\"tbl2\")))\n+  }\n+\n+  test(\"query organization\") {\n+    // Test all valid combinations of order by/sort by/distribute by/cluster by/limit/windows\n+    val baseSql = \"select * from t\"\n+    val basePlan = table(\"t\").select(star())\n+\n+    val ws = Map(\"w1\" -> WindowSpecDefinition(Seq.empty, Seq.empty, UnspecifiedFrame))\n+    val limitWindowClauses = Seq(\n+      (\"\", (p: LogicalPlan) => p),\n+      (\" limit 10\", (p: LogicalPlan) => p.limit(10)),\n+      (\" window w1 as ()\", (p: LogicalPlan) => WithWindowDefinition(ws, p)),\n+      (\" window w1 as () limit 10\", (p: LogicalPlan) => WithWindowDefinition(ws, p).limit(10))\n+    )\n+\n+    val orderSortDistrClusterClauses = Seq(\n+      (\"\", basePlan),\n+      (\" order by a, b desc\", basePlan.orderBy('a.asc, 'b.desc)),\n+      (\" sort by a, b desc\", basePlan.sortBy('a.asc, 'b.desc)),\n+      (\" distribute by a, b\", basePlan.distribute('a, 'b)),\n+      (\" distribute by a sort by b\", basePlan.distribute('a).sortBy('b.asc)),\n+      (\" cluster by a, b\", basePlan.distribute('a, 'b).sortBy('a.asc, 'b.asc))\n+    )\n+\n+    orderSortDistrClusterClauses.foreach {\n+      case (s1, p1) =>\n+        limitWindowClauses.foreach {\n+          case (s2, pf2) =>\n+            assertEqual(baseSql + s1 + s2, pf2(p1))\n+        }\n+    }\n+\n+    val msg = \"Combination of ORDER BY/SORT BY/DISTRIBUTE BY/CLUSTER BY is not supported\"\n+    intercept(s\"$baseSql order by a sort by a\", msg)\n+    intercept(s\"$baseSql cluster by a distribute by a\", msg)\n+    intercept(s\"$baseSql order by a cluster by a\", msg)\n+    intercept(s\"$baseSql order by a distribute by a\", msg)\n+  }\n+\n+  test(\"insert into\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    def insert(\n+        partition: Map[String, Option[String]],\n+        overwrite: Boolean = false,\n+        ifNotExists: Boolean = false): LogicalPlan =\n+      InsertIntoTable(table(\"s\"), partition, plan, overwrite, ifNotExists)\n+\n+    // Single inserts\n+    assertEqual(s\"insert overwrite table s $sql\",\n+      insert(Map.empty, overwrite = true))\n+    assertEqual(s\"insert overwrite table s if not exists $sql\",\n+      insert(Map.empty, overwrite = true, ifNotExists = true))\n+    assertEqual(s\"insert into s $sql\",\n+      insert(Map.empty))\n+    assertEqual(s\"insert into table s partition (c = 'd', e = 1) $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"e\" -> Option(\"1\"))))\n+    assertEqual(s\"insert overwrite table s partition (c = 'd', x) if not exists $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"x\" -> None), overwrite = true, ifNotExists = true))\n+\n+    // Multi insert\n+    val plan2 = table(\"t\").where('x > 5).select(star())\n+    assertEqual(\"from t insert into s select * limit 1 insert into u select * where x > 5\",\n+      InsertIntoTable(\n+        table(\"s\"), Map.empty, plan.limit(1), overwrite = false, ifNotExists = false).unionAll(\n+        InsertIntoTable(\n+          table(\"u\"), Map.empty, plan2, overwrite = false, ifNotExists = false)))\n+  }\n+\n+  test(\"aggregation\") {\n+    val sql = \"select a, b, sum(c) as c from d group by a, b\"\n+\n+    // Normal\n+    assertEqual(sql, table(\"d\").groupBy('a, 'b)('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Cube\n+    assertEqual(s\"$sql with cube\",\n+      table(\"d\").groupBy(Cube(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Rollup\n+    assertEqual(s\"$sql with rollup\",\n+      table(\"d\").groupBy(Rollup(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Grouping Sets\n+    assertEqual(s\"$sql grouping sets((a, b), (a), ())\",\n+      GroupingSets(Seq(0, 1, 3), Seq('a, 'b), table(\"d\"), Seq('a, 'b, 'sum.function('c).as(\"c\"))))\n+    intercept(s\"$sql grouping sets((a, b), (c), ())\",\n+      \"c doesn't show up in the GROUP BY list\")\n+  }\n+\n+  test(\"limit\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    assertEqual(s\"$sql limit 10\", plan.limit(10))\n+    assertEqual(s\"$sql limit cast(9 / 4 as int)\", plan.limit(Cast(Literal(9) / 4, IntegerType)))\n+  }\n+\n+  test(\"window spec\") {\n+    // Note that WindowSpecs are testing in the ExpressionParserSuite\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    val spec = WindowSpecDefinition(Seq('a, 'b), Seq('c.asc),\n+      SpecifiedWindowFrame(RowFrame, ValuePreceding(1), ValueFollowing(1)))\n+\n+    // Test window resolution.\n+    val ws1 = Map(\"w1\" -> spec, \"w2\" -> spec, \"w3\" -> spec)\n+    assertEqual(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w1\"\"\".stripMargin,\n+      WithWindowDefinition(ws1, plan))\n+\n+    // Fail with no reference.\n+    intercept(s\"$sql window w2 as w1\", \"Cannot resolve window reference 'w1'\")\n+\n+    // Fail when resolved reference is not a window spec.\n+    intercept(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w2\"\"\".stripMargin,\n+      \"Window reference 'w2' is not a window specification\"\n+    )\n+  }\n+\n+  test(\"lateral view\") {\n+    // Single lateral view\n+    assertEqual(\n+      \"select * from t lateral view explode(x) expl as x\",\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .select(star()))\n+\n+    // Multiple lateral views\n+    assertEqual(\n+      \"\"\"select *\n+        |from t\n+        |lateral view explode(x) expl as x\n+        |lateral view outer json_tuple(x, y) jtup q, z\"\"\".stripMargin,\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = true, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star()))\n+\n+    // Multi-Insert lateral views.\n+    val from = table(\"t1\").generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+    assertEqual(\n+      \"\"\"from t1\n+        |lateral view explode(x) expl as x\n+        |insert into t2\n+        |select *\n+        |lateral view json_tuple(x, y) jtup q, z\n+        |insert into t3\n+        |select *\n+        |where s < 10\n+      \"\"\".stripMargin,\n+      Union(from\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = false, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star())\n+        .insertInto(\"t2\"),\n+        from.where('s < 10).select(star()).insertInto(\"t3\")))\n+\n+    // Unsupported generator.\n+    intercept(\n+      \"select * from t lateral view posexplode(x) posexpl as x, y\",\n+      \"Generator function 'posexplode' is not supported\")\n+  }\n+\n+  test(\"joins\") {\n+    val testUnconditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t as tt $sql u\",\n+        table(\"t\").as(\"tt\").join(table(\"u\"), jt, None).select(star()))\n+    }\n+    val testConditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u as uu on a = b\",\n+        table(\"t\").join(table(\"u\").as(\"uu\"), jt, Option('a === 'b)).select(star()))\n+    }\n+    val testNaturalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t tt natural $sql u as uu\",\n+        table(\"t\").as(\"tt\").join(table(\"u\").as(\"uu\"), NaturalJoin(jt), None).select(star()))\n+    }\n+    val testUsingJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u using(a, b)\",\n+        table(\"t\").join(table(\"u\"), UsingJoin(jt, Seq('a.attr, 'b.attr)), None).select(star()))\n+    }\n+    val testAll = Seq(testUnconditionalJoin, testConditionalJoin, testNaturalJoin, testUsingJoin)\n+\n+    def test(sql: String, jt: JoinType, tests: Seq[(String, JoinType) => Unit]): Unit = {\n+      tests.foreach(_(sql, jt))\n+    }\n+    test(\"cross join\", Inner, Seq(testUnconditionalJoin))\n+    test(\",\", Inner, Seq(testUnconditionalJoin))\n+    test(\"join\", Inner, testAll)\n+    test(\"inner join\", Inner, testAll)\n+    test(\"left join\", LeftOuter, testAll)\n+    test(\"left outer join\", LeftOuter, testAll)\n+    test(\"right join\", RightOuter, testAll)\n+    test(\"right outer join\", RightOuter, testAll)\n+    test(\"full join\", FullOuter, testAll)\n+    test(\"full outer join\", FullOuter, testAll)\n+  }\n+\n+  test(\"sampled relations\") {\n+    val sql = \"select * from t\"\n+    assertEqual(s\"$sql tablesample(100 rows)\",\n+      table(\"t\").limit(100).select(star()))\n+    assertEqual(s\"$sql as x tablesample(43 percent)\",\n+      Sample(0, .43d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    assertEqual(s\"$sql as x tablesample(bucket 4 out of 10)\",\n+      Sample(0, .4d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    intercept(s\"$sql as x tablesample(bucket 4 out of 10 on x)\",\n+      \"TABLESAMPLE(BUCKET x OUT OF y ON id) is not supported\")\n+    intercept(s\"$sql as x tablesample(bucket 11 out of 10)\",\n+      s\"Sampling fraction (${11.0/10.0}) must be on interval [0, 1]\")\n+  }\n+\n+  test(\"sub-query\") {\n+    val plan = table(\"t0\").select('id)\n+    assertEqual(\"select id from (t0)\", plan)\n+    assertEqual(\"select id from ((((((t0))))))\", plan)\n+    assertEqual(\n+      \"(select * from t1) union distinct (select * from t2)\",\n+      Distinct(table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))))\n+    assertEqual(\n+      \"select * from ((select * from t1) union (select * from t2)) t\",\n+      Distinct(\n+        table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))).as(\"t\").select(star()))\n+    assertEqual(\n+      \"\"\"select  id\n+        |from (((select id from t0)\n+        |       union all\n+        |       (select  id from t0))\n+        |      union all\n+        |      (select id from t0)) as u_1\n+      \"\"\".stripMargin,\n+      plan.unionAll(plan).unionAll(plan).as(\"u_1\").select('id))\n+  }\n+\n+  test(\"scalar sub-query\") {\n+    assertEqual(\n+      \"select (select max(b) from s) ss from t\",\n+      table(\"t\").select(ScalarSubquery(table(\"s\").select('max.function('b))).as(\"ss\")))\n+    assertEqual(\n+      \"select * from t where a = (select b from s)\",\n+      table(\"t\").where('a === ScalarSubquery(table(\"s\").select('b))).select(star()))\n+    assertEqual(\n+      \"select g from t group by g having a > (select b from s)\",\n+      table(\"t\").groupBy('g)('g).where('a > ScalarSubquery(table(\"s\").select('b))))\n+  }\n+\n+  test(\"table reference\") {\n+    assertEqual(\"table t\", table(\"t\"))\n+    assertEqual(\"table d.t\", table(\"d\", \"t\"))\n+  }\n+\n+  test(\"inline table\") {\n+    assertEqual(\"values 1, 2, 3, 4\", LocalRelation.fromExternalRows(",
    "line": 415
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "This PostgreSQL doc page might be helpful: http://www.postgresql.org/docs/9.5/static/sql-values.html\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:28:48Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))\n+    assertEqual(\"select distinct a, b from db.c\", Distinct(table(\"db\", \"c\").select('a, 'b)))\n+    assertEqual(\"select all a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+  }\n+\n+  test(\"transform query spec\") {\n+    val p = ScriptTransformation(Seq('a, 'b), \"func\", Seq.empty, table(\"e\"), null)\n+    assertEqual(\"select transform(a, b) using 'func' from e where f < 10\",\n+      p.copy(child = p.child.where('f < 10)))\n+    assertEqual(\"map(a, b) using 'func' as c, d from e\",\n+      p.copy(output = Seq('c.string, 'd.string)))\n+    assertEqual(\"reduce(a, b) using 'func' as (c: int, d decimal(10, 0)) from e\",\n+      p.copy(output = Seq('c.int, 'd.decimal(10, 0))))\n+  }\n+\n+  test(\"multi select query\") {\n+    assertEqual(\n+      \"from a select * select * where s < 10\",\n+      table(\"a\").select(star()).unionAll(table(\"a\").where('s < 10).select(star())))\n+    intercept(\n+      \"from a select * select * from x where a.s < 10\",\n+      \"Multi-Insert queries cannot have a FROM clause in their individual SELECT statements\")\n+    assertEqual(\n+      \"from a insert into tbl1 select * insert into tbl2 select * where s < 10\",\n+      table(\"a\").select(star()).insertInto(\"tbl1\").unionAll(\n+        table(\"a\").where('s < 10).select(star()).insertInto(\"tbl2\")))\n+  }\n+\n+  test(\"query organization\") {\n+    // Test all valid combinations of order by/sort by/distribute by/cluster by/limit/windows\n+    val baseSql = \"select * from t\"\n+    val basePlan = table(\"t\").select(star())\n+\n+    val ws = Map(\"w1\" -> WindowSpecDefinition(Seq.empty, Seq.empty, UnspecifiedFrame))\n+    val limitWindowClauses = Seq(\n+      (\"\", (p: LogicalPlan) => p),\n+      (\" limit 10\", (p: LogicalPlan) => p.limit(10)),\n+      (\" window w1 as ()\", (p: LogicalPlan) => WithWindowDefinition(ws, p)),\n+      (\" window w1 as () limit 10\", (p: LogicalPlan) => WithWindowDefinition(ws, p).limit(10))\n+    )\n+\n+    val orderSortDistrClusterClauses = Seq(\n+      (\"\", basePlan),\n+      (\" order by a, b desc\", basePlan.orderBy('a.asc, 'b.desc)),\n+      (\" sort by a, b desc\", basePlan.sortBy('a.asc, 'b.desc)),\n+      (\" distribute by a, b\", basePlan.distribute('a, 'b)),\n+      (\" distribute by a sort by b\", basePlan.distribute('a).sortBy('b.asc)),\n+      (\" cluster by a, b\", basePlan.distribute('a, 'b).sortBy('a.asc, 'b.asc))\n+    )\n+\n+    orderSortDistrClusterClauses.foreach {\n+      case (s1, p1) =>\n+        limitWindowClauses.foreach {\n+          case (s2, pf2) =>\n+            assertEqual(baseSql + s1 + s2, pf2(p1))\n+        }\n+    }\n+\n+    val msg = \"Combination of ORDER BY/SORT BY/DISTRIBUTE BY/CLUSTER BY is not supported\"\n+    intercept(s\"$baseSql order by a sort by a\", msg)\n+    intercept(s\"$baseSql cluster by a distribute by a\", msg)\n+    intercept(s\"$baseSql order by a cluster by a\", msg)\n+    intercept(s\"$baseSql order by a distribute by a\", msg)\n+  }\n+\n+  test(\"insert into\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    def insert(\n+        partition: Map[String, Option[String]],\n+        overwrite: Boolean = false,\n+        ifNotExists: Boolean = false): LogicalPlan =\n+      InsertIntoTable(table(\"s\"), partition, plan, overwrite, ifNotExists)\n+\n+    // Single inserts\n+    assertEqual(s\"insert overwrite table s $sql\",\n+      insert(Map.empty, overwrite = true))\n+    assertEqual(s\"insert overwrite table s if not exists $sql\",\n+      insert(Map.empty, overwrite = true, ifNotExists = true))\n+    assertEqual(s\"insert into s $sql\",\n+      insert(Map.empty))\n+    assertEqual(s\"insert into table s partition (c = 'd', e = 1) $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"e\" -> Option(\"1\"))))\n+    assertEqual(s\"insert overwrite table s partition (c = 'd', x) if not exists $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"x\" -> None), overwrite = true, ifNotExists = true))\n+\n+    // Multi insert\n+    val plan2 = table(\"t\").where('x > 5).select(star())\n+    assertEqual(\"from t insert into s select * limit 1 insert into u select * where x > 5\",\n+      InsertIntoTable(\n+        table(\"s\"), Map.empty, plan.limit(1), overwrite = false, ifNotExists = false).unionAll(\n+        InsertIntoTable(\n+          table(\"u\"), Map.empty, plan2, overwrite = false, ifNotExists = false)))\n+  }\n+\n+  test(\"aggregation\") {\n+    val sql = \"select a, b, sum(c) as c from d group by a, b\"\n+\n+    // Normal\n+    assertEqual(sql, table(\"d\").groupBy('a, 'b)('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Cube\n+    assertEqual(s\"$sql with cube\",\n+      table(\"d\").groupBy(Cube(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Rollup\n+    assertEqual(s\"$sql with rollup\",\n+      table(\"d\").groupBy(Rollup(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Grouping Sets\n+    assertEqual(s\"$sql grouping sets((a, b), (a), ())\",\n+      GroupingSets(Seq(0, 1, 3), Seq('a, 'b), table(\"d\"), Seq('a, 'b, 'sum.function('c).as(\"c\"))))\n+    intercept(s\"$sql grouping sets((a, b), (c), ())\",\n+      \"c doesn't show up in the GROUP BY list\")\n+  }\n+\n+  test(\"limit\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    assertEqual(s\"$sql limit 10\", plan.limit(10))\n+    assertEqual(s\"$sql limit cast(9 / 4 as int)\", plan.limit(Cast(Literal(9) / 4, IntegerType)))\n+  }\n+\n+  test(\"window spec\") {\n+    // Note that WindowSpecs are testing in the ExpressionParserSuite\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    val spec = WindowSpecDefinition(Seq('a, 'b), Seq('c.asc),\n+      SpecifiedWindowFrame(RowFrame, ValuePreceding(1), ValueFollowing(1)))\n+\n+    // Test window resolution.\n+    val ws1 = Map(\"w1\" -> spec, \"w2\" -> spec, \"w3\" -> spec)\n+    assertEqual(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w1\"\"\".stripMargin,\n+      WithWindowDefinition(ws1, plan))\n+\n+    // Fail with no reference.\n+    intercept(s\"$sql window w2 as w1\", \"Cannot resolve window reference 'w1'\")\n+\n+    // Fail when resolved reference is not a window spec.\n+    intercept(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w2\"\"\".stripMargin,\n+      \"Window reference 'w2' is not a window specification\"\n+    )\n+  }\n+\n+  test(\"lateral view\") {\n+    // Single lateral view\n+    assertEqual(\n+      \"select * from t lateral view explode(x) expl as x\",\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .select(star()))\n+\n+    // Multiple lateral views\n+    assertEqual(\n+      \"\"\"select *\n+        |from t\n+        |lateral view explode(x) expl as x\n+        |lateral view outer json_tuple(x, y) jtup q, z\"\"\".stripMargin,\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = true, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star()))\n+\n+    // Multi-Insert lateral views.\n+    val from = table(\"t1\").generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+    assertEqual(\n+      \"\"\"from t1\n+        |lateral view explode(x) expl as x\n+        |insert into t2\n+        |select *\n+        |lateral view json_tuple(x, y) jtup q, z\n+        |insert into t3\n+        |select *\n+        |where s < 10\n+      \"\"\".stripMargin,\n+      Union(from\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = false, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star())\n+        .insertInto(\"t2\"),\n+        from.where('s < 10).select(star()).insertInto(\"t3\")))\n+\n+    // Unsupported generator.\n+    intercept(\n+      \"select * from t lateral view posexplode(x) posexpl as x, y\",\n+      \"Generator function 'posexplode' is not supported\")\n+  }\n+\n+  test(\"joins\") {\n+    val testUnconditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t as tt $sql u\",\n+        table(\"t\").as(\"tt\").join(table(\"u\"), jt, None).select(star()))\n+    }\n+    val testConditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u as uu on a = b\",\n+        table(\"t\").join(table(\"u\").as(\"uu\"), jt, Option('a === 'b)).select(star()))\n+    }\n+    val testNaturalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t tt natural $sql u as uu\",\n+        table(\"t\").as(\"tt\").join(table(\"u\").as(\"uu\"), NaturalJoin(jt), None).select(star()))\n+    }\n+    val testUsingJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u using(a, b)\",\n+        table(\"t\").join(table(\"u\"), UsingJoin(jt, Seq('a.attr, 'b.attr)), None).select(star()))\n+    }\n+    val testAll = Seq(testUnconditionalJoin, testConditionalJoin, testNaturalJoin, testUsingJoin)\n+\n+    def test(sql: String, jt: JoinType, tests: Seq[(String, JoinType) => Unit]): Unit = {\n+      tests.foreach(_(sql, jt))\n+    }\n+    test(\"cross join\", Inner, Seq(testUnconditionalJoin))\n+    test(\",\", Inner, Seq(testUnconditionalJoin))\n+    test(\"join\", Inner, testAll)\n+    test(\"inner join\", Inner, testAll)\n+    test(\"left join\", LeftOuter, testAll)\n+    test(\"left outer join\", LeftOuter, testAll)\n+    test(\"right join\", RightOuter, testAll)\n+    test(\"right outer join\", RightOuter, testAll)\n+    test(\"full join\", FullOuter, testAll)\n+    test(\"full outer join\", FullOuter, testAll)\n+  }\n+\n+  test(\"sampled relations\") {\n+    val sql = \"select * from t\"\n+    assertEqual(s\"$sql tablesample(100 rows)\",\n+      table(\"t\").limit(100).select(star()))\n+    assertEqual(s\"$sql as x tablesample(43 percent)\",\n+      Sample(0, .43d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    assertEqual(s\"$sql as x tablesample(bucket 4 out of 10)\",\n+      Sample(0, .4d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    intercept(s\"$sql as x tablesample(bucket 4 out of 10 on x)\",\n+      \"TABLESAMPLE(BUCKET x OUT OF y ON id) is not supported\")\n+    intercept(s\"$sql as x tablesample(bucket 11 out of 10)\",\n+      s\"Sampling fraction (${11.0/10.0}) must be on interval [0, 1]\")\n+  }\n+\n+  test(\"sub-query\") {\n+    val plan = table(\"t0\").select('id)\n+    assertEqual(\"select id from (t0)\", plan)\n+    assertEqual(\"select id from ((((((t0))))))\", plan)\n+    assertEqual(\n+      \"(select * from t1) union distinct (select * from t2)\",\n+      Distinct(table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))))\n+    assertEqual(\n+      \"select * from ((select * from t1) union (select * from t2)) t\",\n+      Distinct(\n+        table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))).as(\"t\").select(star()))\n+    assertEqual(\n+      \"\"\"select  id\n+        |from (((select id from t0)\n+        |       union all\n+        |       (select  id from t0))\n+        |      union all\n+        |      (select id from t0)) as u_1\n+      \"\"\".stripMargin,\n+      plan.unionAll(plan).unionAll(plan).as(\"u_1\").select('id))\n+  }\n+\n+  test(\"scalar sub-query\") {\n+    assertEqual(\n+      \"select (select max(b) from s) ss from t\",\n+      table(\"t\").select(ScalarSubquery(table(\"s\").select('max.function('b))).as(\"ss\")))\n+    assertEqual(\n+      \"select * from t where a = (select b from s)\",\n+      table(\"t\").where('a === ScalarSubquery(table(\"s\").select('b))).select(star()))\n+    assertEqual(\n+      \"select g from t group by g having a > (select b from s)\",\n+      table(\"t\").groupBy('g)('g).where('a > ScalarSubquery(table(\"s\").select('b))))\n+  }\n+\n+  test(\"table reference\") {\n+    assertEqual(\"table t\", table(\"t\"))\n+    assertEqual(\"table d.t\", table(\"d\", \"t\"))\n+  }\n+\n+  test(\"inline table\") {\n+    assertEqual(\"values 1, 2, 3, 4\", LocalRelation.fromExternalRows(",
    "line": 415
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "```\ninsert into temp_tbl\nvalues (1, 'a'), (2, 'b'), (3, 'c') as x(a, b)\n```\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-24T06:49:43Z",
    "diffHunk": "@@ -0,0 +1,408 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.parser.ng\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.types.IntegerType\n+\n+class PlanParserSuite extends PlanTest {\n+  import CatalystSqlParser._\n+  import org.apache.spark.sql.catalyst.dsl.expressions._\n+  import org.apache.spark.sql.catalyst.dsl.plans._\n+\n+  def assertEqual(sqlCommand: String, plan: LogicalPlan): Unit = {\n+    comparePlans(parsePlan(sqlCommand), plan)\n+  }\n+\n+  def intercept(sqlCommand: String, messages: String*): Unit = {\n+    val e = intercept[ParseException](parsePlan(sqlCommand))\n+    messages.foreach { message =>\n+      assert(e.message.contains(message))\n+    }\n+  }\n+\n+  test(\"case insensitive\") {\n+    val plan = table(\"a\").select(star())\n+    assertEqual(\"sELEct * FroM a\", plan)\n+    assertEqual(\"select * fRoM a\", plan)\n+    assertEqual(\"SELECT * FROM a\", plan)\n+  }\n+\n+  test(\"show functions\") {\n+    assertEqual(\"show functions\", ShowFunctions(None, None))\n+    assertEqual(\"show functions foo\", ShowFunctions(None, Some(\"foo\")))\n+    assertEqual(\"show functions foo.bar\", ShowFunctions(Some(\"foo\"), Some(\"bar\")))\n+    assertEqual(\"show functions 'foo\\\\\\\\.*'\", ShowFunctions(None, Some(\"foo\\\\.*\")))\n+    intercept(\"show functions foo.bar.baz\", \"SHOW FUNCTIONS unsupported name\")\n+  }\n+\n+  test(\"describe function\") {\n+    assertEqual(\"describe function bar\", DescribeFunction(\"bar\", isExtended = false))\n+    assertEqual(\"describe function extended bar\", DescribeFunction(\"bar\", isExtended = true))\n+    assertEqual(\"describe function foo.bar\", DescribeFunction(\"foo.bar\", isExtended = false))\n+    assertEqual(\"describe function extended f.bar\", DescribeFunction(\"f.bar\", isExtended = true))\n+  }\n+\n+  test(\"set operations\") {\n+    val a = table(\"a\").select(star())\n+    val b = table(\"b\").select(star())\n+\n+    assertEqual(\"select * from a union select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union distinct select * from b\", Distinct(a.unionAll(b)))\n+    assertEqual(\"select * from a union all select * from b\", a.unionAll(b))\n+    assertEqual(\"select * from a except select * from b\", a.except(b))\n+    intercept(\"select * from a except all select * from b\", \"EXCEPT ALL is not supported.\")\n+    assertEqual(\"select * from a except distinct select * from b\", a.except(b))\n+    assertEqual(\"select * from a intersect select * from b\", a.intersect(b))\n+    intercept(\"select * from a intersect all select * from b\", \"INTERSECT ALL is not supported.\")\n+    assertEqual(\"select * from a intersect distinct select * from b\", a.intersect(b))\n+  }\n+\n+  test(\"common table expressions\") {\n+    def cte(plan: LogicalPlan, namedPlans: (String, LogicalPlan)*): With = {\n+      val ctes = namedPlans.map {\n+        case (name, cte) =>\n+          name -> SubqueryAlias(name, cte)\n+      }.toMap\n+      With(plan, ctes)\n+    }\n+    assertEqual(\n+      \"with cte1 as (select * from a) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> table(\"a\").select(star())))\n+    assertEqual(\n+      \"with cte1 (select 1) select * from cte1\",\n+      cte(table(\"cte1\").select(star()), \"cte1\" -> OneRowRelation.select(1)))\n+    assertEqual(\n+      \"with cte1 (select 1), cte2 as (select * from cte1) select * from cte2\",\n+      cte(table(\"cte2\").select(star()),\n+        \"cte1\" -> OneRowRelation.select(1),\n+        \"cte2\" -> table(\"cte1\").select(star())))\n+    intercept(\n+      \"with cte1 (select 1), cte1 as (select 1 from cte1) select * from cte1\",\n+      \"Name 'cte1' is used for multiple common table expressions\")\n+  }\n+\n+  test(\"simple select query\") {\n+    assertEqual(\"select 1\", OneRowRelation.select(1))\n+    assertEqual(\"select a, b\", OneRowRelation.select('a, 'b))\n+    assertEqual(\"select a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+    assertEqual(\"select a, b from db.c where x < 1\", table(\"db\", \"c\").where('x < 1).select('a, 'b))\n+    assertEqual(\"select a, b from db.c having x < 1\", table(\"db\", \"c\").select('a, 'b).where('x < 1))\n+    assertEqual(\"select distinct a, b from db.c\", Distinct(table(\"db\", \"c\").select('a, 'b)))\n+    assertEqual(\"select all a, b from db.c\", table(\"db\", \"c\").select('a, 'b))\n+  }\n+\n+  test(\"transform query spec\") {\n+    val p = ScriptTransformation(Seq('a, 'b), \"func\", Seq.empty, table(\"e\"), null)\n+    assertEqual(\"select transform(a, b) using 'func' from e where f < 10\",\n+      p.copy(child = p.child.where('f < 10)))\n+    assertEqual(\"map(a, b) using 'func' as c, d from e\",\n+      p.copy(output = Seq('c.string, 'd.string)))\n+    assertEqual(\"reduce(a, b) using 'func' as (c: int, d decimal(10, 0)) from e\",\n+      p.copy(output = Seq('c.int, 'd.decimal(10, 0))))\n+  }\n+\n+  test(\"multi select query\") {\n+    assertEqual(\n+      \"from a select * select * where s < 10\",\n+      table(\"a\").select(star()).unionAll(table(\"a\").where('s < 10).select(star())))\n+    intercept(\n+      \"from a select * select * from x where a.s < 10\",\n+      \"Multi-Insert queries cannot have a FROM clause in their individual SELECT statements\")\n+    assertEqual(\n+      \"from a insert into tbl1 select * insert into tbl2 select * where s < 10\",\n+      table(\"a\").select(star()).insertInto(\"tbl1\").unionAll(\n+        table(\"a\").where('s < 10).select(star()).insertInto(\"tbl2\")))\n+  }\n+\n+  test(\"query organization\") {\n+    // Test all valid combinations of order by/sort by/distribute by/cluster by/limit/windows\n+    val baseSql = \"select * from t\"\n+    val basePlan = table(\"t\").select(star())\n+\n+    val ws = Map(\"w1\" -> WindowSpecDefinition(Seq.empty, Seq.empty, UnspecifiedFrame))\n+    val limitWindowClauses = Seq(\n+      (\"\", (p: LogicalPlan) => p),\n+      (\" limit 10\", (p: LogicalPlan) => p.limit(10)),\n+      (\" window w1 as ()\", (p: LogicalPlan) => WithWindowDefinition(ws, p)),\n+      (\" window w1 as () limit 10\", (p: LogicalPlan) => WithWindowDefinition(ws, p).limit(10))\n+    )\n+\n+    val orderSortDistrClusterClauses = Seq(\n+      (\"\", basePlan),\n+      (\" order by a, b desc\", basePlan.orderBy('a.asc, 'b.desc)),\n+      (\" sort by a, b desc\", basePlan.sortBy('a.asc, 'b.desc)),\n+      (\" distribute by a, b\", basePlan.distribute('a, 'b)),\n+      (\" distribute by a sort by b\", basePlan.distribute('a).sortBy('b.asc)),\n+      (\" cluster by a, b\", basePlan.distribute('a, 'b).sortBy('a.asc, 'b.asc))\n+    )\n+\n+    orderSortDistrClusterClauses.foreach {\n+      case (s1, p1) =>\n+        limitWindowClauses.foreach {\n+          case (s2, pf2) =>\n+            assertEqual(baseSql + s1 + s2, pf2(p1))\n+        }\n+    }\n+\n+    val msg = \"Combination of ORDER BY/SORT BY/DISTRIBUTE BY/CLUSTER BY is not supported\"\n+    intercept(s\"$baseSql order by a sort by a\", msg)\n+    intercept(s\"$baseSql cluster by a distribute by a\", msg)\n+    intercept(s\"$baseSql order by a cluster by a\", msg)\n+    intercept(s\"$baseSql order by a distribute by a\", msg)\n+  }\n+\n+  test(\"insert into\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    def insert(\n+        partition: Map[String, Option[String]],\n+        overwrite: Boolean = false,\n+        ifNotExists: Boolean = false): LogicalPlan =\n+      InsertIntoTable(table(\"s\"), partition, plan, overwrite, ifNotExists)\n+\n+    // Single inserts\n+    assertEqual(s\"insert overwrite table s $sql\",\n+      insert(Map.empty, overwrite = true))\n+    assertEqual(s\"insert overwrite table s if not exists $sql\",\n+      insert(Map.empty, overwrite = true, ifNotExists = true))\n+    assertEqual(s\"insert into s $sql\",\n+      insert(Map.empty))\n+    assertEqual(s\"insert into table s partition (c = 'd', e = 1) $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"e\" -> Option(\"1\"))))\n+    assertEqual(s\"insert overwrite table s partition (c = 'd', x) if not exists $sql\",\n+      insert(Map(\"c\" -> Option(\"d\"), \"x\" -> None), overwrite = true, ifNotExists = true))\n+\n+    // Multi insert\n+    val plan2 = table(\"t\").where('x > 5).select(star())\n+    assertEqual(\"from t insert into s select * limit 1 insert into u select * where x > 5\",\n+      InsertIntoTable(\n+        table(\"s\"), Map.empty, plan.limit(1), overwrite = false, ifNotExists = false).unionAll(\n+        InsertIntoTable(\n+          table(\"u\"), Map.empty, plan2, overwrite = false, ifNotExists = false)))\n+  }\n+\n+  test(\"aggregation\") {\n+    val sql = \"select a, b, sum(c) as c from d group by a, b\"\n+\n+    // Normal\n+    assertEqual(sql, table(\"d\").groupBy('a, 'b)('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Cube\n+    assertEqual(s\"$sql with cube\",\n+      table(\"d\").groupBy(Cube(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Rollup\n+    assertEqual(s\"$sql with rollup\",\n+      table(\"d\").groupBy(Rollup(Seq('a, 'b)))('a, 'b, 'sum.function('c).as(\"c\")))\n+\n+    // Grouping Sets\n+    assertEqual(s\"$sql grouping sets((a, b), (a), ())\",\n+      GroupingSets(Seq(0, 1, 3), Seq('a, 'b), table(\"d\"), Seq('a, 'b, 'sum.function('c).as(\"c\"))))\n+    intercept(s\"$sql grouping sets((a, b), (c), ())\",\n+      \"c doesn't show up in the GROUP BY list\")\n+  }\n+\n+  test(\"limit\") {\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    assertEqual(s\"$sql limit 10\", plan.limit(10))\n+    assertEqual(s\"$sql limit cast(9 / 4 as int)\", plan.limit(Cast(Literal(9) / 4, IntegerType)))\n+  }\n+\n+  test(\"window spec\") {\n+    // Note that WindowSpecs are testing in the ExpressionParserSuite\n+    val sql = \"select * from t\"\n+    val plan = table(\"t\").select(star())\n+    val spec = WindowSpecDefinition(Seq('a, 'b), Seq('c.asc),\n+      SpecifiedWindowFrame(RowFrame, ValuePreceding(1), ValueFollowing(1)))\n+\n+    // Test window resolution.\n+    val ws1 = Map(\"w1\" -> spec, \"w2\" -> spec, \"w3\" -> spec)\n+    assertEqual(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w1\"\"\".stripMargin,\n+      WithWindowDefinition(ws1, plan))\n+\n+    // Fail with no reference.\n+    intercept(s\"$sql window w2 as w1\", \"Cannot resolve window reference 'w1'\")\n+\n+    // Fail when resolved reference is not a window spec.\n+    intercept(\n+      s\"\"\"$sql\n+         |window w1 as (partition by a, b order by c rows between 1 preceding and 1 following),\n+         |       w2 as w1,\n+         |       w3 as w2\"\"\".stripMargin,\n+      \"Window reference 'w2' is not a window specification\"\n+    )\n+  }\n+\n+  test(\"lateral view\") {\n+    // Single lateral view\n+    assertEqual(\n+      \"select * from t lateral view explode(x) expl as x\",\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .select(star()))\n+\n+    // Multiple lateral views\n+    assertEqual(\n+      \"\"\"select *\n+        |from t\n+        |lateral view explode(x) expl as x\n+        |lateral view outer json_tuple(x, y) jtup q, z\"\"\".stripMargin,\n+      table(\"t\")\n+        .generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = true, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star()))\n+\n+    // Multi-Insert lateral views.\n+    val from = table(\"t1\").generate(Explode('x), join = true, outer = false, Some(\"expl\"), Seq(\"x\"))\n+    assertEqual(\n+      \"\"\"from t1\n+        |lateral view explode(x) expl as x\n+        |insert into t2\n+        |select *\n+        |lateral view json_tuple(x, y) jtup q, z\n+        |insert into t3\n+        |select *\n+        |where s < 10\n+      \"\"\".stripMargin,\n+      Union(from\n+        .generate(JsonTuple(Seq('x, 'y)), join = true, outer = false, Some(\"jtup\"), Seq(\"q\", \"z\"))\n+        .select(star())\n+        .insertInto(\"t2\"),\n+        from.where('s < 10).select(star()).insertInto(\"t3\")))\n+\n+    // Unsupported generator.\n+    intercept(\n+      \"select * from t lateral view posexplode(x) posexpl as x, y\",\n+      \"Generator function 'posexplode' is not supported\")\n+  }\n+\n+  test(\"joins\") {\n+    val testUnconditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t as tt $sql u\",\n+        table(\"t\").as(\"tt\").join(table(\"u\"), jt, None).select(star()))\n+    }\n+    val testConditionalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u as uu on a = b\",\n+        table(\"t\").join(table(\"u\").as(\"uu\"), jt, Option('a === 'b)).select(star()))\n+    }\n+    val testNaturalJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t tt natural $sql u as uu\",\n+        table(\"t\").as(\"tt\").join(table(\"u\").as(\"uu\"), NaturalJoin(jt), None).select(star()))\n+    }\n+    val testUsingJoin = (sql: String, jt: JoinType) => {\n+      assertEqual(\n+        s\"select * from t $sql u using(a, b)\",\n+        table(\"t\").join(table(\"u\"), UsingJoin(jt, Seq('a.attr, 'b.attr)), None).select(star()))\n+    }\n+    val testAll = Seq(testUnconditionalJoin, testConditionalJoin, testNaturalJoin, testUsingJoin)\n+\n+    def test(sql: String, jt: JoinType, tests: Seq[(String, JoinType) => Unit]): Unit = {\n+      tests.foreach(_(sql, jt))\n+    }\n+    test(\"cross join\", Inner, Seq(testUnconditionalJoin))\n+    test(\",\", Inner, Seq(testUnconditionalJoin))\n+    test(\"join\", Inner, testAll)\n+    test(\"inner join\", Inner, testAll)\n+    test(\"left join\", LeftOuter, testAll)\n+    test(\"left outer join\", LeftOuter, testAll)\n+    test(\"right join\", RightOuter, testAll)\n+    test(\"right outer join\", RightOuter, testAll)\n+    test(\"full join\", FullOuter, testAll)\n+    test(\"full outer join\", FullOuter, testAll)\n+  }\n+\n+  test(\"sampled relations\") {\n+    val sql = \"select * from t\"\n+    assertEqual(s\"$sql tablesample(100 rows)\",\n+      table(\"t\").limit(100).select(star()))\n+    assertEqual(s\"$sql as x tablesample(43 percent)\",\n+      Sample(0, .43d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    assertEqual(s\"$sql as x tablesample(bucket 4 out of 10)\",\n+      Sample(0, .4d, withReplacement = false, 10L, table(\"t\").as(\"x\"))(true).select(star()))\n+    intercept(s\"$sql as x tablesample(bucket 4 out of 10 on x)\",\n+      \"TABLESAMPLE(BUCKET x OUT OF y ON id) is not supported\")\n+    intercept(s\"$sql as x tablesample(bucket 11 out of 10)\",\n+      s\"Sampling fraction (${11.0/10.0}) must be on interval [0, 1]\")\n+  }\n+\n+  test(\"sub-query\") {\n+    val plan = table(\"t0\").select('id)\n+    assertEqual(\"select id from (t0)\", plan)\n+    assertEqual(\"select id from ((((((t0))))))\", plan)\n+    assertEqual(\n+      \"(select * from t1) union distinct (select * from t2)\",\n+      Distinct(table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))))\n+    assertEqual(\n+      \"select * from ((select * from t1) union (select * from t2)) t\",\n+      Distinct(\n+        table(\"t1\").select(star()).unionAll(table(\"t2\").select(star()))).as(\"t\").select(star()))\n+    assertEqual(\n+      \"\"\"select  id\n+        |from (((select id from t0)\n+        |       union all\n+        |       (select  id from t0))\n+        |      union all\n+        |      (select id from t0)) as u_1\n+      \"\"\".stripMargin,\n+      plan.unionAll(plan).unionAll(plan).as(\"u_1\").select('id))\n+  }\n+\n+  test(\"scalar sub-query\") {\n+    assertEqual(\n+      \"select (select max(b) from s) ss from t\",\n+      table(\"t\").select(ScalarSubquery(table(\"s\").select('max.function('b))).as(\"ss\")))\n+    assertEqual(\n+      \"select * from t where a = (select b from s)\",\n+      table(\"t\").where('a === ScalarSubquery(table(\"s\").select('b))).select(star()))\n+    assertEqual(\n+      \"select g from t group by g having a > (select b from s)\",\n+      table(\"t\").groupBy('g)('g).where('a > ScalarSubquery(table(\"s\").select('b))))\n+  }\n+\n+  test(\"table reference\") {\n+    assertEqual(\"table t\", table(\"t\"))\n+    assertEqual(\"table d.t\", table(\"d\", \"t\"))\n+  }\n+\n+  test(\"inline table\") {\n+    assertEqual(\"values 1, 2, 3, 4\", LocalRelation.fromExternalRows(",
    "line": 415
  }],
  "prId": 11557
}]