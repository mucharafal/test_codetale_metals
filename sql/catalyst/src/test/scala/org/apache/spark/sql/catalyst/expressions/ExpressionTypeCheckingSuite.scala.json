[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe -- assertSuccess?\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T05:46:29Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation('a.int, 'b.string, 'c.boolean, 'd.array(StringType))\n+\n+  def checkError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      checkAnalysis(expr)\n+    }\n+    assert(e.getMessage.contains(s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def checkAnalysis(expr: Expression): Unit = {"
  }],
  "prId": 6405
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "assertError?\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T05:46:33Z",
    "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation('a.int, 'b.string, 'c.boolean, 'd.array(StringType))\n+\n+  def checkError(expr: Expression, errorMessage: String): Unit = {"
  }],
  "prId": 6405
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "don't the two need to have the same type?\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T05:54:08Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation('a.int, 'b.string, 'c.boolean, 'd.array(StringType))\n+\n+  def checkError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      checkAnalysis(expr)\n+    }\n+    assert(e.getMessage.contains(\n+      s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def checkAnalysis(expr: Expression): Unit = {\n+    val analyzed = testRelation.select(expr.as(\"_c\")).analyze\n+    SimpleAnalyzer.checkAnalysis(analyzed)\n+  }\n+\n+  test(\"check types for unary arithmetic\") {\n+    checkError(UnaryMinus('b), \"operator - requires numeric type\")\n+    checkAnalysis(Sqrt('b)) // We will cast String to Double for sqrt\n+    checkError(Sqrt('c), \"function sqrt requires numeric type\")\n+    checkError(Abs('b), \"function abs requires numeric type\")\n+    checkError(BitwiseNot('b), \"operator ~ requires integral type\")\n+  }\n+\n+  test(\"check types for binary arithmetic\") {\n+    // We will cast String to Double for binary arithmetic\n+    checkAnalysis(Add('a, 'b))\n+    checkAnalysis(Subtract('a, 'b))\n+    checkAnalysis(Multiply('a, 'b))\n+    checkAnalysis(Divide('a, 'b))\n+    checkAnalysis(Remainder('a, 'b))\n+    // checkAnalysis(BitwiseAnd('a, 'b))\n+\n+    val msg = \"differing types in BinaryArithmetic, IntegerType != BooleanType\"\n+    checkError(Add('a, 'c), msg)\n+    checkError(Subtract('a, 'c), msg)\n+    checkError(Multiply('a, 'c), msg)\n+    checkError(Divide('a, 'c), msg)\n+    checkError(Remainder('a, 'c), msg)\n+    checkError(BitwiseAnd('a, 'c), msg)\n+    checkError(BitwiseOr('a, 'c), msg)\n+    checkError(BitwiseXor('a, 'c), msg)\n+    checkError(MaxOf('a, 'c), msg)\n+    checkError(MinOf('a, 'c), msg)\n+\n+    checkError(Add('c, 'c), \"operator + requires numeric type\")\n+    checkError(Subtract('c, 'c), \"operator - requires numeric type\")\n+    checkError(Multiply('c, 'c), \"operator * requires numeric type\")\n+    checkError(Divide('c, 'c), \"operator / requires numeric type\")\n+    checkError(Remainder('c, 'c), \"operator % requires numeric type\")\n+\n+    checkError(BitwiseAnd('c, 'c), \"operator & requires integral type\")\n+    checkError(BitwiseOr('c, 'c), \"operator | requires integral type\")\n+    checkError(BitwiseXor('c, 'c), \"operator ^ requires integral type\")\n+\n+    checkError(MaxOf('d, 'd), \"function maxOf requires atomic type\")\n+    checkError(MinOf('d, 'd), \"function minOf requires atomic type\")\n+  }\n+\n+  test(\"check types for predicates\") {\n+    // EqualTo don't have type constraint\n+    checkAnalysis(EqualTo('a, 'c))"
  }],
  "prId": 6405
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "to make the test cases more clear, i think you should replace the field names to include type names.\n\ne.g.\n\na -> intField\nb -> strField\nc -> boolField\nd -> strField\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T05:54:47Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation('a.int, 'b.string, 'c.boolean, 'd.array(StringType))"
  }],
  "prId": 6405
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "It's weird that we only cast string to double for `Sqrt`, not all unary arithmetics. \n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T08:17:55Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation(\n+    'intField.int,\n+    'stringField.string,\n+    'booleanField.boolean,\n+    'complexField.array(StringType))\n+\n+  def assertError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      assertSuccess(expr)\n+    }\n+    assert(e.getMessage.contains(\n+      s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def assertSuccess(expr: Expression): Unit = {\n+    val analyzed = testRelation.select(expr.as(\"c\")).analyze\n+    SimpleAnalyzer.checkAnalysis(analyzed)\n+  }\n+\n+  def assertErrorForDifferingTypes(expr: Expression): Unit = {\n+    assertError(expr,\n+      s\"differing types in ${expr.getClass.getSimpleName} (IntegerType and BooleanType).\")\n+  }\n+\n+  test(\"check types for unary arithmetic\") {\n+    assertError(UnaryMinus('stringField), \"operator - accepts numeric type\")\n+    assertSuccess(Sqrt('stringField)) // We will cast String to Double for sqrt",
    "line": 57
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "We should check to see why Hive does.\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-31T22:00:51Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation(\n+    'intField.int,\n+    'stringField.string,\n+    'booleanField.boolean,\n+    'complexField.array(StringType))\n+\n+  def assertError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      assertSuccess(expr)\n+    }\n+    assert(e.getMessage.contains(\n+      s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def assertSuccess(expr: Expression): Unit = {\n+    val analyzed = testRelation.select(expr.as(\"c\")).analyze\n+    SimpleAnalyzer.checkAnalysis(analyzed)\n+  }\n+\n+  def assertErrorForDifferingTypes(expr: Expression): Unit = {\n+    assertError(expr,\n+      s\"differing types in ${expr.getClass.getSimpleName} (IntegerType and BooleanType).\")\n+  }\n+\n+  test(\"check types for unary arithmetic\") {\n+    assertError(UnaryMinus('stringField), \"operator - accepts numeric type\")\n+    assertSuccess(Sqrt('stringField)) // We will cast String to Double for sqrt",
    "line": 57
  }],
  "prId": 6405
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "There may be a bug here: first we cast string to double in `PromoteStrings`, then we cast int to double in `WidenTypes`, finally we fail to evaluate it as `Bitwise` only accepts integral types, not double.\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T08:20:13Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation(\n+    'intField.int,\n+    'stringField.string,\n+    'booleanField.boolean,\n+    'complexField.array(StringType))\n+\n+  def assertError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      assertSuccess(expr)\n+    }\n+    assert(e.getMessage.contains(\n+      s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def assertSuccess(expr: Expression): Unit = {\n+    val analyzed = testRelation.select(expr.as(\"c\")).analyze\n+    SimpleAnalyzer.checkAnalysis(analyzed)\n+  }\n+\n+  def assertErrorForDifferingTypes(expr: Expression): Unit = {\n+    assertError(expr,\n+      s\"differing types in ${expr.getClass.getSimpleName} (IntegerType and BooleanType).\")\n+  }\n+\n+  test(\"check types for unary arithmetic\") {\n+    assertError(UnaryMinus('stringField), \"operator - accepts numeric type\")\n+    assertSuccess(Sqrt('stringField)) // We will cast String to Double for sqrt\n+    assertError(Sqrt('booleanField), \"function sqrt accepts numeric type\")\n+    assertError(Abs('stringField), \"function abs accepts numeric type\")\n+    assertError(BitwiseNot('stringField), \"operator ~ accepts integral type\")\n+  }\n+\n+  test(\"check types for binary arithmetic\") {\n+    // We will cast String to Double for binary arithmetic\n+    assertSuccess(Add('intField, 'stringField))\n+    assertSuccess(Subtract('intField, 'stringField))\n+    assertSuccess(Multiply('intField, 'stringField))\n+    assertSuccess(Divide('intField, 'stringField))\n+    assertSuccess(Remainder('intField, 'stringField))\n+    // checkAnalysis(BitwiseAnd('intField, 'stringField))",
    "line": 70
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Seems you want a rule in `PromoteStrings` to handle `Bitwise`?\n",
    "commit": "b5ff31b0dde66ed24634dc8773dfafb11b95ee50",
    "createdAt": "2015-05-29T23:01:05Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.plans.logical.LocalRelation\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.types.{BooleanType, StringType}\n+import org.scalatest.FunSuite\n+\n+\n+class ExpressionTypeCheckingSuite extends FunSuite {\n+\n+  val testRelation = LocalRelation(\n+    'intField.int,\n+    'stringField.string,\n+    'booleanField.boolean,\n+    'complexField.array(StringType))\n+\n+  def assertError(expr: Expression, errorMessage: String): Unit = {\n+    val e = intercept[AnalysisException] {\n+      assertSuccess(expr)\n+    }\n+    assert(e.getMessage.contains(\n+      s\"cannot resolve '${expr.prettyString}' due to data type mismatch:\"))\n+    assert(e.getMessage.contains(errorMessage))\n+  }\n+\n+  def assertSuccess(expr: Expression): Unit = {\n+    val analyzed = testRelation.select(expr.as(\"c\")).analyze\n+    SimpleAnalyzer.checkAnalysis(analyzed)\n+  }\n+\n+  def assertErrorForDifferingTypes(expr: Expression): Unit = {\n+    assertError(expr,\n+      s\"differing types in ${expr.getClass.getSimpleName} (IntegerType and BooleanType).\")\n+  }\n+\n+  test(\"check types for unary arithmetic\") {\n+    assertError(UnaryMinus('stringField), \"operator - accepts numeric type\")\n+    assertSuccess(Sqrt('stringField)) // We will cast String to Double for sqrt\n+    assertError(Sqrt('booleanField), \"function sqrt accepts numeric type\")\n+    assertError(Abs('stringField), \"function abs accepts numeric type\")\n+    assertError(BitwiseNot('stringField), \"operator ~ accepts integral type\")\n+  }\n+\n+  test(\"check types for binary arithmetic\") {\n+    // We will cast String to Double for binary arithmetic\n+    assertSuccess(Add('intField, 'stringField))\n+    assertSuccess(Subtract('intField, 'stringField))\n+    assertSuccess(Multiply('intField, 'stringField))\n+    assertSuccess(Divide('intField, 'stringField))\n+    assertSuccess(Remainder('intField, 'stringField))\n+    // checkAnalysis(BitwiseAnd('intField, 'stringField))",
    "line": 70
  }],
  "prId": 6405
}]