[{
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "We should have a binary type key test as well?",
    "commit": "72c771e691ae1071742bde5a612593d38f147ff5",
    "createdAt": "2018-11-28T06:57:34Z",
    "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.util\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{UnsafeArrayData, UnsafeRow}\n+import org.apache.spark.sql.types.{ArrayType, IntegerType, StructType}\n+import org.apache.spark.unsafe.Platform\n+\n+class ArrayBasedMapBuilderSuite extends SparkFunSuite {\n+\n+  test(\"basic\") {\n+    val builder = new ArrayBasedMapBuilder(IntegerType, IntegerType)\n+    builder.put(1, 1)\n+    builder.put(InternalRow(2, 2))\n+    builder.putAll(new GenericArrayData(Seq(3)), new GenericArrayData(Seq(3)))\n+    val map = builder.build()\n+    assert(map.numElements() == 3)\n+    assert(ArrayBasedMapData.toScalaMap(map) == Map(1 -> 1, 2 -> 2, 3 -> 3))\n+  }\n+\n+  test(\"fail with null key\") {\n+    val builder = new ArrayBasedMapBuilder(IntegerType, IntegerType)\n+    builder.put(1, null) // null value is OK\n+    val e = intercept[RuntimeException](builder.put(null, 1))\n+    assert(e.getMessage.contains(\"Cannot use null as map key\"))\n+  }\n+\n+  test(\"remove duplicated keys with last wins policy\") {\n+    val builder = new ArrayBasedMapBuilder(IntegerType, IntegerType)\n+    builder.put(1, 1)\n+    builder.put(2, 2)\n+    builder.put(1, 2)\n+    val map = builder.build()\n+    assert(map.numElements() == 2)\n+    assert(ArrayBasedMapData.toScalaMap(map) == Map(1 -> 2, 2 -> 2))\n+  }\n+\n+  test(\"struct type key\") {\n+    val builder = new ArrayBasedMapBuilder(new StructType().add(\"i\", \"int\"), IntegerType)\n+    builder.put(InternalRow(1), 1)\n+    builder.put(InternalRow(2), 2)\n+    val unsafeRow = {\n+      val row = new UnsafeRow(1)\n+      val bytes = new Array[Byte](16)\n+      row.pointTo(bytes, 16)\n+      row.setInt(0, 1)\n+      row\n+    }\n+    builder.put(unsafeRow, 3)\n+    val map = builder.build()\n+    assert(map.numElements() == 2)\n+    assert(ArrayBasedMapData.toScalaMap(map) == Map(InternalRow(1) -> 3, InternalRow(2) -> 2))\n+  }\n+\n+  test(\"array type key\") {\n+    val builder = new ArrayBasedMapBuilder(ArrayType(IntegerType), IntegerType)\n+    builder.put(new GenericArrayData(Seq(1, 1)), 1)\n+    builder.put(new GenericArrayData(Seq(2, 2)), 2)\n+    val unsafeArray = {\n+      val array = new UnsafeArrayData()\n+      val bytes = new Array[Byte](24)\n+      Platform.putLong(bytes, Platform.BYTE_ARRAY_OFFSET, 2)\n+      array.pointTo(bytes, Platform.BYTE_ARRAY_OFFSET, 24)\n+      array.setInt(0, 1)\n+      array.setInt(1, 1)\n+      array\n+    }\n+    builder.put(unsafeArray, 3)\n+    val map = builder.build()\n+    assert(map.numElements() == 2)\n+    assert(ArrayBasedMapData.toScalaMap(map) ==\n+      Map(new GenericArrayData(Seq(1, 1)) -> 3, new GenericArrayData(Seq(2, 2)) -> 2))\n+  }",
    "line": 104
  }],
  "prId": 23124
}]