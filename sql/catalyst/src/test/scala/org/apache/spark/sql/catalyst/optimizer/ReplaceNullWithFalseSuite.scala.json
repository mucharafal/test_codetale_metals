[{
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "remove extra line.",
    "commit": "5499651485c70beff67c7a9f83ca49da626ee49b",
    "createdAt": "2018-10-28T08:28:50Z",
    "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{And, CaseWhen, Expression, GreaterThan, If, Literal, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.{FalseLiteral, TrueLiteral}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{BooleanType, IntegerType}\n+\n+class ReplaceNullWithFalseSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Replace null literals\", FixedPoint(10),\n+        NullPropagation,\n+        ConstantFolding,\n+        BooleanSimplification,\n+        SimplifyConditionals,\n+        ReplaceNullWithFalse) :: Nil\n+  }\n+\n+  private val testRelation = LocalRelation('i.int, 'b.boolean)\n+  private val anotherTestRelation = LocalRelation('d.int)\n+\n+  test(\"successful replacement of null literals in filter and join conditions (1)\") {\n+    testFilter(originalCond = Literal(null), expectedCond = FalseLiteral)\n+    testJoin(originalCond = Literal(null), expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (2)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      FalseLiteral,\n+      Literal(null, BooleanType))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (3)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      TrueLiteral && Literal(null, BooleanType),\n+      UnresolvedAttribute(\"b\") && Literal(null, BooleanType))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (4)\") {\n+    val branches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> FalseLiteral)\n+    val originalCond = CaseWhen(branches, Literal(null, BooleanType))\n+    val expectedCond = CaseWhen(branches, FalseLiteral)\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (5)\") {\n+    val branches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> Literal(null, BooleanType),\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> FalseLiteral)\n+    val originalCond = CaseWhen(branches, Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (6)\") {\n+    val originalBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) ->\n+        If(UnresolvedAttribute(\"i\") < Literal(20), Literal(null, BooleanType), FalseLiteral),\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> TrueLiteral)\n+    val originalCond = CaseWhen(originalBranches)\n+\n+    val expectedBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> FalseLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> TrueLiteral)\n+    val expectedCond = CaseWhen(expectedBranches)\n+\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (7)\") {\n+    val originalBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (Literal(6) <= Literal(1)) -> FalseLiteral,\n+      (Literal(4) === Literal(5)) -> FalseLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(10)) -> Literal(null, BooleanType),\n+      (Literal(4) === Literal(4)) -> TrueLiteral)\n+    val originalCond = CaseWhen(originalBranches)\n+\n+    val expectedBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(10)) -> FalseLiteral,\n+      TrueLiteral -> TrueLiteral)\n+    val expectedCond = CaseWhen(expectedBranches)\n+\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (8)\") {\n+    val originalCond = Or(UnresolvedAttribute(\"b\"), Literal(null))\n+    val expectedCond = UnresolvedAttribute(\"b\")\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (9)\") {\n+    val originalCond = And(UnresolvedAttribute(\"b\"), Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (10)\") {\n+    val originalCond = And(\n+      And(UnresolvedAttribute(\"b\"), Literal(null)),\n+      Or(Literal(null), And(Literal(null), And(UnresolvedAttribute(\"b\"), Literal(null)))))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (11)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      FalseLiteral,\n+      And(UnresolvedAttribute(\"b\"), Literal(null, BooleanType)))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (12)\") {\n+    val originalCond = And(\n+      UnresolvedAttribute(\"b\"),\n+      If(\n+        UnresolvedAttribute(\"i\") > Literal(10),\n+        Literal(null),\n+        And(FalseLiteral, UnresolvedAttribute(\"b\"))))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (13)\") {\n+    val originalCond = If(\n+      If(UnresolvedAttribute(\"b\"), Literal(null), FalseLiteral),\n+      TrueLiteral,\n+      Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (14)\") {\n+    val nestedCaseWhen = CaseWhen(Seq(UnresolvedAttribute(\"b\") -> FalseLiteral), Literal(null))\n+    val originalCond = CaseWhen(Seq(nestedCaseWhen -> TrueLiteral), Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"inability to replace null literals in filter and join conditions (1)\") {\n+    val condition = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      Literal(5) > If(\n+        UnresolvedAttribute(\"i\") === Literal(15),\n+        Literal(null, IntegerType),\n+        Literal(3)),\n+      FalseLiteral)\n+    testFilter(originalCond = condition, expectedCond = condition)\n+    testJoin(originalCond = condition, expectedCond = condition)\n+  }\n+\n+  test(\"inability to replace null literals in filter and join conditions (2)\") {\n+    val nestedCaseWhen = CaseWhen(\n+      Seq((UnresolvedAttribute(\"i\") > Literal(20)) -> Literal(2)),\n+      Literal(null, IntegerType))\n+    val branchValue = If(\n+      Literal(2) === nestedCaseWhen,\n+      TrueLiteral,\n+      FalseLiteral)\n+    val branches = Seq((UnresolvedAttribute(\"i\") > Literal(10)) -> branchValue)\n+    val condition = CaseWhen(branches)\n+    testFilter(originalCond = condition, expectedCond = condition)\n+    testJoin(originalCond = condition, expectedCond = condition)\n+  }\n+\n+  test(\"inability to replace null literals in filter and join conditions (3)\") {\n+    val condition = If(\n+      Literal(5) > If(\n+        UnresolvedAttribute(\"i\") === Literal(15),\n+        Literal(null, IntegerType),\n+        Literal(3)),\n+      TrueLiteral,\n+      FalseLiteral)\n+    testFilter(originalCond = condition, expectedCond = condition)\n+    testJoin(originalCond = condition, expectedCond = condition)\n+  }\n+\n+  test(\"successful replacement of null literals in join conditions (1)\") {\n+    // this test is only for joins as the condition involves columns from different relations\n+    val originalCond = If(\n+      UnresolvedAttribute(\"d\") > UnresolvedAttribute(\"i\"),\n+      Literal(null),\n+      FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in join conditions (2)\") {\n+    // this test is only for joins as the condition involves columns from different relations\n+    val originalBranches = Seq(\n+      (UnresolvedAttribute(\"d\") > UnresolvedAttribute(\"i\")) -> Literal(null),\n+      (UnresolvedAttribute(\"d\") === UnresolvedAttribute(\"i\")) -> TrueLiteral)\n+\n+    val expectedBranches = Seq(\n+      (UnresolvedAttribute(\"d\") > UnresolvedAttribute(\"i\")) -> FalseLiteral,\n+      (UnresolvedAttribute(\"d\") === UnresolvedAttribute(\"i\")) -> TrueLiteral)\n+\n+    testJoin(\n+      originalCond = CaseWhen(originalBranches, FalseLiteral),\n+      expectedCond = CaseWhen(expectedBranches, FalseLiteral))\n+  }\n+\n+  test(\"inability to replace null literals in join conditions (1)\") {\n+    // this test is only for joins as the condition involves columns from different relations\n+    val branches = Seq(\n+      (UnresolvedAttribute(\"d\") > UnresolvedAttribute(\"i\")) -> Literal(null, BooleanType),\n+      (UnresolvedAttribute(\"d\") === UnresolvedAttribute(\"i\")) -> TrueLiteral)\n+    val condition = UnresolvedAttribute(\"b\") === CaseWhen(branches, FalseLiteral)\n+    testJoin(originalCond = condition, expectedCond = condition)\n+  }\n+\n+  test(\"successful replacement of null literals in if predicates (1)\") {\n+    val predicate = And(GreaterThan(UnresolvedAttribute(\"i\"), Literal(0.5)), Literal(null))\n+    testProjection(\n+      originalExpr = If(predicate, Literal(5), Literal(1)).as(\"out\"),\n+      expectedExpr = Literal(1).as(\"out\"))\n+  }\n+\n+  test(\"successful replacement of null literals in if predicates (2)\") {\n+    val predicate = If(\n+      And(GreaterThan(UnresolvedAttribute(\"i\"), Literal(0.5)), Literal(null)),\n+      TrueLiteral,\n+      FalseLiteral)\n+    testProjection(\n+      originalExpr = If(predicate, Literal(5), Literal(1)).as(\"out\"),\n+      expectedExpr = Literal(1).as(\"out\"))\n+  }\n+\n+  test(\"inability to replace null literals in if predicates\") {\n+    val predicate = GreaterThan(\n+      UnresolvedAttribute(\"i\"),\n+      If(UnresolvedAttribute(\"b\"), Literal(null, IntegerType), Literal(4)))\n+    val column = If(predicate, Literal(5), Literal(1)).as(\"out\")\n+    testProjection(originalExpr = column, expectedExpr = column)\n+  }\n+\n+  test(\"successful replacement of null literals in branches of case when (1)\") {\n+    val branches = Seq(\n+      And(GreaterThan(UnresolvedAttribute(\"i\"), Literal(0.5)), Literal(null)) -> Literal(5))\n+    testProjection(\n+      originalExpr = CaseWhen(branches, Literal(2)).as(\"out\"),\n+      expectedExpr = Literal(2).as(\"out\"))\n+  }\n+\n+  test(\"successful replacement of null literals in branches of case when (2)\") {\n+    val nestedCaseWhen = CaseWhen(\n+      Seq(And(UnresolvedAttribute(\"b\"), Literal(null)) -> Literal(5)),\n+      Literal(2))\n+    val branches = Seq(GreaterThan(Literal(3), nestedCaseWhen) -> Literal(1))\n+    testProjection(\n+      originalExpr = CaseWhen(branches).as(\"out\"),\n+      expectedExpr = Literal(1).as(\"out\"))\n+  }\n+\n+  test(\"inability to replace null literals in branches of case when\") {\n+    val condition = GreaterThan(\n+      UnresolvedAttribute(\"i\"),\n+      If(UnresolvedAttribute(\"b\"), Literal(null, IntegerType), Literal(4)))\n+    val column = CaseWhen(Seq(condition -> Literal(5)), Literal(2)).as(\"out\")\n+    testProjection(originalExpr = column, expectedExpr = column)\n+  }\n+\n+  private def testFilter(originalCond: Expression, expectedCond: Expression): Unit = {\n+    test((rel, exp) => rel.where(exp), originalCond, expectedCond)\n+  }\n+\n+  private def testJoin(originalCond: Expression, expectedCond: Expression): Unit = {\n+    test((rel, exp) => rel.join(anotherTestRelation, Inner, Some(exp)), originalCond, expectedCond)\n+  }\n+\n+  private def testProjection(originalExpr: Expression, expectedExpr: Expression): Unit = {\n+    test((rel, exp) => rel.select(exp), originalExpr, expectedExpr)\n+  }\n+\n+  private def test(\n+      func: (LogicalPlan, Expression) => LogicalPlan,\n+      originalExpr: Expression,\n+      expectedExpr: Expression): Unit = {\n+\n+    val originalPlan = func(testRelation, originalExpr).analyze\n+    val optimizedPlan = Optimize.execute(originalPlan)\n+    val expectedPlan = func(testRelation, expectedExpr).analyze\n+    comparePlans(optimizedPlan, expectedPlan)\n+  }\n+"
  }],
  "prId": 22857
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thank you for pinging me, @dbtsai . And, thank you for contribution, @aokolnychyi .\r\nI also clearly feel the benefit of this optimizer. It's worth to be review throughly. \r\n\r\nBTW, the test case names are very unclear to me. It only looks like `positive case (1)~(13)` and `negative case (1) ~ (3)`. Can we have more elaborated and specific names? It will help readability of these test cases and shorten review process.\r\n```\r\n- successful replacement of null literals in filter and join conditions (1)\r\n...\r\n- successful replacement of null literals in filter and join conditions (13)\r\n- inability to replace null literals in filter and join conditions (1)\r\n...\r\n- inability to replace null literals in filter and join conditions (3)\r\n```",
    "commit": "5499651485c70beff67c7a9f83ca49da626ee49b",
    "createdAt": "2018-10-28T18:49:51Z",
    "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.expressions.{And, CaseWhen, Expression, GreaterThan, If, Literal, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.{FalseLiteral, TrueLiteral}\n+import org.apache.spark.sql.catalyst.plans.{Inner, PlanTest}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.RuleExecutor\n+import org.apache.spark.sql.types.{BooleanType, IntegerType}\n+\n+class ReplaceNullWithFalseSuite extends PlanTest {\n+\n+  object Optimize extends RuleExecutor[LogicalPlan] {\n+    val batches =\n+      Batch(\"Replace null literals\", FixedPoint(10),\n+        NullPropagation,\n+        ConstantFolding,\n+        BooleanSimplification,\n+        SimplifyConditionals,\n+        ReplaceNullWithFalse) :: Nil\n+  }\n+\n+  private val testRelation = LocalRelation('i.int, 'b.boolean)\n+  private val anotherTestRelation = LocalRelation('d.int)\n+\n+  test(\"successful replacement of null literals in filter and join conditions (1)\") {\n+    testFilter(originalCond = Literal(null), expectedCond = FalseLiteral)\n+    testJoin(originalCond = Literal(null), expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (2)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      FalseLiteral,\n+      Literal(null, BooleanType))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (3)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      TrueLiteral && Literal(null, BooleanType),\n+      UnresolvedAttribute(\"b\") && Literal(null, BooleanType))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (4)\") {\n+    val branches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> FalseLiteral)\n+    val originalCond = CaseWhen(branches, Literal(null, BooleanType))\n+    val expectedCond = CaseWhen(branches, FalseLiteral)\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (5)\") {\n+    val branches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> Literal(null, BooleanType),\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> FalseLiteral)\n+    val originalCond = CaseWhen(branches, Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (6)\") {\n+    val originalBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) ->\n+        If(UnresolvedAttribute(\"i\") < Literal(20), Literal(null, BooleanType), FalseLiteral),\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> TrueLiteral)\n+    val originalCond = CaseWhen(originalBranches)\n+\n+    val expectedBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> FalseLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(40)) -> TrueLiteral)\n+    val expectedCond = CaseWhen(expectedBranches)\n+\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (7)\") {\n+    val originalBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (Literal(6) <= Literal(1)) -> FalseLiteral,\n+      (Literal(4) === Literal(5)) -> FalseLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(10)) -> Literal(null, BooleanType),\n+      (Literal(4) === Literal(4)) -> TrueLiteral)\n+    val originalCond = CaseWhen(originalBranches)\n+\n+    val expectedBranches = Seq(\n+      (UnresolvedAttribute(\"i\") < Literal(10)) -> TrueLiteral,\n+      (UnresolvedAttribute(\"i\") > Literal(10)) -> FalseLiteral,\n+      TrueLiteral -> TrueLiteral)\n+    val expectedCond = CaseWhen(expectedBranches)\n+\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (8)\") {\n+    val originalCond = Or(UnresolvedAttribute(\"b\"), Literal(null))\n+    val expectedCond = UnresolvedAttribute(\"b\")\n+    testFilter(originalCond, expectedCond)\n+    testJoin(originalCond, expectedCond)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (9)\") {\n+    val originalCond = And(UnresolvedAttribute(\"b\"), Literal(null))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (10)\") {\n+    val originalCond = And(\n+      And(UnresolvedAttribute(\"b\"), Literal(null)),\n+      Or(Literal(null), And(Literal(null), And(UnresolvedAttribute(\"b\"), Literal(null)))))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (11)\") {\n+    val originalCond = If(\n+      UnresolvedAttribute(\"i\") > Literal(10),\n+      FalseLiteral,\n+      And(UnresolvedAttribute(\"b\"), Literal(null, BooleanType)))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (12)\") {\n+    val originalCond = And(\n+      UnresolvedAttribute(\"b\"),\n+      If(\n+        UnresolvedAttribute(\"i\") > Literal(10),\n+        Literal(null),\n+        And(FalseLiteral, UnresolvedAttribute(\"b\"))))\n+    testFilter(originalCond, expectedCond = FalseLiteral)\n+    testJoin(originalCond, expectedCond = FalseLiteral)\n+  }\n+\n+  test(\"successful replacement of null literals in filter and join conditions (13)\") {"
  }],
  "prId": 22857
}]