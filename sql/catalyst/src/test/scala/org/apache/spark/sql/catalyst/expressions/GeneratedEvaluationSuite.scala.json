[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Best to take this out into a separate file, since that's the common standard across all Spark modules (each test suite has its own file)\n",
    "commit": "96ef82c4afbf0b3eabb246e29209d953d58b3d99",
    "createdAt": "2014-07-24T07:41:52Z",
    "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+\n+/**\n+ * Overrides our expression evaluation tests to use code generation for evaluation.\n+ */\n+class GeneratedEvaluationSuite extends ExpressionEvaluationSuite {\n+  override def checkEvaluation(\n+      expression: Expression,\n+      expected: Any,\n+      inputRow: Row = EmptyRow): Unit = {\n+    val plan = try {\n+      GenerateMutableProjection(Alias(expression, s\"Optimized($expression)\")() :: Nil)()\n+    } catch {\n+      case e: Throwable =>\n+        val evaluated = GenerateProjection.expressionEvaluator(expression)\n+        fail(\n+          s\"\"\"\n+            |Code generation of $expression failed:\n+            |${evaluated.code.mkString(\"\\n\")}\n+            |$e\n+          \"\"\".stripMargin)\n+    }\n+\n+    val actual  = plan(inputRow).apply(0)\n+    if(actual != expected) {\n+      val input = if(inputRow == EmptyRow) \"\" else s\", input: $inputRow\"\n+      fail(s\"Incorrect Evaluation: $expression, actual: $actual, expected: $expected$input\")\n+    }\n+  }\n+\n+\n+  test(\"multithreaded eval\") {\n+    import scala.concurrent._\n+    import ExecutionContext.Implicits.global\n+    import scala.concurrent.duration._\n+\n+    val futures = (1 to 20).map { _ =>\n+      future {\n+        GeneratePredicate(EqualTo(Literal(1), Literal(1)))\n+        GenerateProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateMutableProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateOrdering(Add(Literal(1), Literal(1)).asc :: Nil)\n+      }\n+    }\n+\n+    futures.foreach(Await.result(_, 10.seconds))\n+  }\n+}\n+\n+/**\n+ * Overrides our expression evaluation tests to use generated code on mutable rows.\n+ */\n+class GeneratedMutableEvaluationSuite extends ExpressionEvaluationSuite {"
  }],
  "prId": 993
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "nitpick - add a new line\n",
    "commit": "96ef82c4afbf0b3eabb246e29209d953d58b3d99",
    "createdAt": "2014-07-24T07:42:02Z",
    "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+\n+/**\n+ * Overrides our expression evaluation tests to use code generation for evaluation.\n+ */\n+class GeneratedEvaluationSuite extends ExpressionEvaluationSuite {\n+  override def checkEvaluation(\n+      expression: Expression,\n+      expected: Any,\n+      inputRow: Row = EmptyRow): Unit = {\n+    val plan = try {\n+      GenerateMutableProjection(Alias(expression, s\"Optimized($expression)\")() :: Nil)()\n+    } catch {\n+      case e: Throwable =>\n+        val evaluated = GenerateProjection.expressionEvaluator(expression)\n+        fail(\n+          s\"\"\"\n+            |Code generation of $expression failed:\n+            |${evaluated.code.mkString(\"\\n\")}\n+            |$e\n+          \"\"\".stripMargin)\n+    }\n+\n+    val actual  = plan(inputRow).apply(0)\n+    if(actual != expected) {\n+      val input = if(inputRow == EmptyRow) \"\" else s\", input: $inputRow\"\n+      fail(s\"Incorrect Evaluation: $expression, actual: $actual, expected: $expected$input\")\n+    }\n+  }\n+\n+\n+  test(\"multithreaded eval\") {\n+    import scala.concurrent._\n+    import ExecutionContext.Implicits.global\n+    import scala.concurrent.duration._\n+\n+    val futures = (1 to 20).map { _ =>\n+      future {\n+        GeneratePredicate(EqualTo(Literal(1), Literal(1)))\n+        GenerateProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateMutableProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateOrdering(Add(Literal(1), Literal(1)).asc :: Nil)\n+      }\n+    }\n+\n+    futures.foreach(Await.result(_, 10.seconds))\n+  }\n+}\n+\n+/**\n+ * Overrides our expression evaluation tests to use generated code on mutable rows.\n+ */\n+class GeneratedMutableEvaluationSuite extends ExpressionEvaluationSuite {\n+  override def checkEvaluation(\n+      expression: Expression,\n+      expected: Any,\n+      inputRow: Row = EmptyRow): Unit = {\n+    lazy val evaluated = GenerateProjection.expressionEvaluator(expression)\n+\n+    val plan = try {\n+      GenerateProjection(Alias(expression, s\"Optimized($expression)\")() :: Nil)\n+    } catch {\n+      case e: Throwable =>\n+        fail(\n+          s\"\"\"\n+            |Code generation of $expression failed:\n+            |${evaluated.code.mkString(\"\\n\")}\n+            |$e\n+          \"\"\".stripMargin)\n+    }\n+\n+    val actual = plan(inputRow)\n+    val expectedRow = new GenericRow(Array[Any](expected))\n+    if (actual.hashCode() != expectedRow.hashCode()) {\n+      fail(\n+        s\"\"\"\n+          |Mismatched hashCodes for values: $actual, $expectedRow\n+          |Hash Codes: ${actual.hashCode()} != ${expectedRow.hashCode()}\n+          |${evaluated.code.mkString(\"\\n\")}\n+        \"\"\".stripMargin)\n+    }\n+    if (actual != expectedRow) {\n+      val input = if(inputRow == EmptyRow) \"\" else s\", input: $inputRow\"\n+      fail(s\"Incorrect Evaluation: $expression, actual: $actual, expected: $expected$input\")\n+    }\n+  }\n+}"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Yeah, we should make scalastyle check test files too... though I'm afraid there will be a fair amount of work to make that pass.\n",
    "commit": "96ef82c4afbf0b3eabb246e29209d953d58b3d99",
    "createdAt": "2014-07-26T19:56:19Z",
    "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen._\n+\n+/**\n+ * Overrides our expression evaluation tests to use code generation for evaluation.\n+ */\n+class GeneratedEvaluationSuite extends ExpressionEvaluationSuite {\n+  override def checkEvaluation(\n+      expression: Expression,\n+      expected: Any,\n+      inputRow: Row = EmptyRow): Unit = {\n+    val plan = try {\n+      GenerateMutableProjection(Alias(expression, s\"Optimized($expression)\")() :: Nil)()\n+    } catch {\n+      case e: Throwable =>\n+        val evaluated = GenerateProjection.expressionEvaluator(expression)\n+        fail(\n+          s\"\"\"\n+            |Code generation of $expression failed:\n+            |${evaluated.code.mkString(\"\\n\")}\n+            |$e\n+          \"\"\".stripMargin)\n+    }\n+\n+    val actual  = plan(inputRow).apply(0)\n+    if(actual != expected) {\n+      val input = if(inputRow == EmptyRow) \"\" else s\", input: $inputRow\"\n+      fail(s\"Incorrect Evaluation: $expression, actual: $actual, expected: $expected$input\")\n+    }\n+  }\n+\n+\n+  test(\"multithreaded eval\") {\n+    import scala.concurrent._\n+    import ExecutionContext.Implicits.global\n+    import scala.concurrent.duration._\n+\n+    val futures = (1 to 20).map { _ =>\n+      future {\n+        GeneratePredicate(EqualTo(Literal(1), Literal(1)))\n+        GenerateProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateMutableProjection(EqualTo(Literal(1), Literal(1)) :: Nil)\n+        GenerateOrdering(Add(Literal(1), Literal(1)).asc :: Nil)\n+      }\n+    }\n+\n+    futures.foreach(Await.result(_, 10.seconds))\n+  }\n+}\n+\n+/**\n+ * Overrides our expression evaluation tests to use generated code on mutable rows.\n+ */\n+class GeneratedMutableEvaluationSuite extends ExpressionEvaluationSuite {\n+  override def checkEvaluation(\n+      expression: Expression,\n+      expected: Any,\n+      inputRow: Row = EmptyRow): Unit = {\n+    lazy val evaluated = GenerateProjection.expressionEvaluator(expression)\n+\n+    val plan = try {\n+      GenerateProjection(Alias(expression, s\"Optimized($expression)\")() :: Nil)\n+    } catch {\n+      case e: Throwable =>\n+        fail(\n+          s\"\"\"\n+            |Code generation of $expression failed:\n+            |${evaluated.code.mkString(\"\\n\")}\n+            |$e\n+          \"\"\".stripMargin)\n+    }\n+\n+    val actual = plan(inputRow)\n+    val expectedRow = new GenericRow(Array[Any](expected))\n+    if (actual.hashCode() != expectedRow.hashCode()) {\n+      fail(\n+        s\"\"\"\n+          |Mismatched hashCodes for values: $actual, $expectedRow\n+          |Hash Codes: ${actual.hashCode()} != ${expectedRow.hashCode()}\n+          |${evaluated.code.mkString(\"\\n\")}\n+        \"\"\".stripMargin)\n+    }\n+    if (actual != expectedRow) {\n+      val input = if(inputRow == EmptyRow) \"\" else s\", input: $inputRow\"\n+      fail(s\"Incorrect Evaluation: $expression, actual: $actual, expected: $expected$input\")\n+    }\n+  }\n+}"
  }],
  "prId": 993
}]