[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why do we need this check? isn't `Cast.canANSIStoreAssign(w, r)` enough?",
    "commit": "af0f7390e61455682cb5089f8e8dd3c0e60d32b1",
    "createdAt": "2019-08-27T07:54:45Z",
    "diffHunk": "@@ -22,20 +22,296 @@ import scala.collection.mutable\n import org.apache.spark.SparkFunSuite\n import org.apache.spark.sql.catalyst.analysis\n import org.apache.spark.sql.catalyst.expressions.Cast\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf.StoreAssignmentPolicy\n \n-class DataTypeWriteCompatibilitySuite extends SparkFunSuite {\n-  private val atomicTypes = Seq(BooleanType, ByteType, ShortType, IntegerType, LongType, FloatType,\n-    DoubleType, DateType, TimestampType, StringType, BinaryType)\n+class StrictDataTypeWriteCompatibilitySuite extends DataTypeWriteCompatibilityBaseSuite {\n+  override protected def storeAssignmentPolicy: SQLConf.StoreAssignmentPolicy.Value =\n+    StoreAssignmentPolicy.STRICT\n \n-  private val point2 = StructType(Seq(\n+  test(\"Check atomic types: write allowed only when casting is safe\") {\n+    atomicTypes.foreach { w =>\n+      atomicTypes.foreach { r =>\n+        if (Cast.canUpCast(w, r)) {\n+          assertAllowed(w, r, \"t\", s\"Should allow writing $w to $r because cast is safe\")\n+\n+        } else {\n+          assertSingleError(w, r, \"t\",\n+            s\"Should not allow writing $w to $r because cast is not safe\") { err =>\n+            assert(err.contains(\"'t'\"), \"Should include the field name context\")\n+            assert(err.contains(\"Cannot safely cast\"), \"Should identify unsafe cast\")\n+            assert(err.contains(s\"$w\"), \"Should include write type\")\n+            assert(err.contains(s\"$r\"), \"Should include read type\")\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  test(\"Check struct types: unsafe casts are not allowed\") {\n+    assertNumErrors(widerPoint2, point2, \"t\",\n+      \"Should fail because types require unsafe casts\", 2) { errs =>\n+\n+      assert(errs(0).contains(\"'t.x'\"), \"Should include the nested field name context\")\n+      assert(errs(0).contains(\"Cannot safely cast\"))\n+\n+      assert(errs(1).contains(\"'t.y'\"), \"Should include the nested field name context\")\n+      assert(errs(1).contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check array types: unsafe casts are not allowed\") {\n+    val arrayOfLong = ArrayType(LongType)\n+    val arrayOfInt = ArrayType(IntegerType)\n+\n+    assertSingleError(arrayOfLong, arrayOfInt, \"arr\",\n+      \"Should not allow array of longs to array of ints\") { err =>\n+      assert(err.contains(\"'arr.element'\"),\n+        \"Should identify problem with named array's element type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check map value types: casting Long to Integer is not allowed\") {\n+    val mapOfLong = MapType(StringType, LongType)\n+    val mapOfInt = MapType(StringType, IntegerType)\n+\n+    assertSingleError(mapOfLong, mapOfInt, \"m\",\n+      \"Should not allow map of longs to map of ints\") { err =>\n+      assert(err.contains(\"'m.value'\"), \"Should identify problem with named map's value type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check map key types: unsafe casts are not allowed\") {\n+    val mapKeyLong = MapType(LongType, StringType)\n+    val mapKeyInt = MapType(IntegerType, StringType)\n+\n+    assertSingleError(mapKeyLong, mapKeyInt, \"m\",\n+      \"Should not allow map of long keys to map of int keys\") { err =>\n+      assert(err.contains(\"'m.key'\"), \"Should identify problem with named map's key type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check types with multiple errors\") {\n+    val readType = StructType(Seq(\n+      StructField(\"a\", ArrayType(DoubleType, containsNull = false)),\n+      StructField(\"arr_of_structs\", ArrayType(point2, containsNull = false)),\n+      StructField(\"bad_nested_type\", ArrayType(StringType)),\n+      StructField(\"m\", MapType(LongType, FloatType, valueContainsNull = false)),\n+      StructField(\"map_of_structs\", MapType(StringType, point3, valueContainsNull = false)),\n+      StructField(\"x\", IntegerType, nullable = false),\n+      StructField(\"missing1\", StringType, nullable = false),\n+      StructField(\"missing2\", StringType)\n+    ))\n+\n+    val missingMiddleField = StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"z\", FloatType, nullable = false)))\n+\n+    val writeType = StructType(Seq(\n+      StructField(\"a\", ArrayType(StringType)),\n+      StructField(\"arr_of_structs\", ArrayType(point3)),\n+      StructField(\"bad_nested_type\", point3),\n+      StructField(\"m\", MapType(DoubleType, DoubleType)),\n+      StructField(\"map_of_structs\", MapType(StringType, missingMiddleField)),\n+      StructField(\"y\", LongType)\n+    ))\n+\n+    assertNumErrors(writeType, readType, \"top\", \"Should catch 14 errors\", 14) { errs =>\n+      assert(errs(0).contains(\"'top.a.element'\"), \"Should identify bad type\")\n+      assert(errs(0).contains(\"Cannot safely cast\"))\n+      assert(errs(0).contains(\"StringType to DoubleType\"))\n+\n+      assert(errs(1).contains(\"'top.a'\"), \"Should identify bad type\")\n+      assert(errs(1).contains(\"Cannot write nullable elements to array of non-nulls\"))\n+\n+      assert(errs(2).contains(\"'top.arr_of_structs.element'\"), \"Should identify bad type\")\n+      assert(errs(2).contains(\"'z'\"), \"Should identify bad field\")\n+      assert(errs(2).contains(\"Cannot write extra fields to struct\"))\n+\n+      assert(errs(3).contains(\"'top.arr_of_structs'\"), \"Should identify bad type\")\n+      assert(errs(3).contains(\"Cannot write nullable elements to array of non-nulls\"))\n+\n+      assert(errs(4).contains(\"'top.bad_nested_type'\"), \"Should identify bad type\")\n+      assert(errs(4).contains(\"is incompatible with\"))\n+\n+      assert(errs(5).contains(\"'top.m.key'\"), \"Should identify bad type\")\n+      assert(errs(5).contains(\"Cannot safely cast\"))\n+      assert(errs(5).contains(\"DoubleType to LongType\"))\n+\n+      assert(errs(6).contains(\"'top.m.value'\"), \"Should identify bad type\")\n+      assert(errs(6).contains(\"Cannot safely cast\"))\n+      assert(errs(6).contains(\"DoubleType to FloatType\"))\n+\n+      assert(errs(7).contains(\"'top.m'\"), \"Should identify bad type\")\n+      assert(errs(7).contains(\"Cannot write nullable values to map of non-nulls\"))\n+\n+      assert(errs(8).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n+      assert(errs(8).contains(\"expected 'y', found 'z'\"), \"Should detect name mismatch\")\n+      assert(errs(8).contains(\"field name does not match\"), \"Should identify name problem\")\n+\n+      assert(errs(9).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n+      assert(errs(9).contains(\"'z'\"), \"Should identify missing field\")\n+      assert(errs(9).contains(\"missing fields\"), \"Should detect missing field\")\n+\n+      assert(errs(10).contains(\"'top.map_of_structs'\"), \"Should identify bad type\")\n+      assert(errs(10).contains(\"Cannot write nullable values to map of non-nulls\"))\n+\n+      assert(errs(11).contains(\"'top.x'\"), \"Should identify bad type\")\n+      assert(errs(11).contains(\"Cannot safely cast\"))\n+      assert(errs(11).contains(\"LongType to IntegerType\"))\n+\n+      assert(errs(12).contains(\"'top'\"), \"Should identify bad type\")\n+      assert(errs(12).contains(\"expected 'x', found 'y'\"), \"Should detect name mismatch\")\n+      assert(errs(12).contains(\"field name does not match\"), \"Should identify name problem\")\n+\n+      assert(errs(13).contains(\"'top'\"), \"Should identify bad type\")\n+      assert(errs(13).contains(\"'missing1'\"), \"Should identify missing field\")\n+      assert(errs(13).contains(\"missing fields\"), \"Should detect missing field\")\n+    }\n+  }\n+}\n+\n+class ANSIDataTypeWriteCompatibilitySuite extends DataTypeWriteCompatibilityBaseSuite {\n+  override protected def storeAssignmentPolicy: SQLConf.StoreAssignmentPolicy.Value =\n+    StoreAssignmentPolicy.ANSI\n+\n+  test(\"Check atomic types: write allowed only when casting is safe\") {\n+    atomicTypes.foreach { w =>\n+      atomicTypes.foreach { r =>\n+        if ((w.isInstanceOf[NumericType] && r.isInstanceOf[NumericType]) ||"
  }, {
    "author": {
      "login": "gengliangwang"
    },
    "body": "I thought we were using the method `canANSIStoreAssign` to test the method itself. But it also makes sense to just use `Cast.canANSIStoreAssign(w, r)`, we need to guarantee that the method is used accurately.",
    "commit": "af0f7390e61455682cb5089f8e8dd3c0e60d32b1",
    "createdAt": "2019-08-27T08:17:33Z",
    "diffHunk": "@@ -22,20 +22,296 @@ import scala.collection.mutable\n import org.apache.spark.SparkFunSuite\n import org.apache.spark.sql.catalyst.analysis\n import org.apache.spark.sql.catalyst.expressions.Cast\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.internal.SQLConf.StoreAssignmentPolicy\n \n-class DataTypeWriteCompatibilitySuite extends SparkFunSuite {\n-  private val atomicTypes = Seq(BooleanType, ByteType, ShortType, IntegerType, LongType, FloatType,\n-    DoubleType, DateType, TimestampType, StringType, BinaryType)\n+class StrictDataTypeWriteCompatibilitySuite extends DataTypeWriteCompatibilityBaseSuite {\n+  override protected def storeAssignmentPolicy: SQLConf.StoreAssignmentPolicy.Value =\n+    StoreAssignmentPolicy.STRICT\n \n-  private val point2 = StructType(Seq(\n+  test(\"Check atomic types: write allowed only when casting is safe\") {\n+    atomicTypes.foreach { w =>\n+      atomicTypes.foreach { r =>\n+        if (Cast.canUpCast(w, r)) {\n+          assertAllowed(w, r, \"t\", s\"Should allow writing $w to $r because cast is safe\")\n+\n+        } else {\n+          assertSingleError(w, r, \"t\",\n+            s\"Should not allow writing $w to $r because cast is not safe\") { err =>\n+            assert(err.contains(\"'t'\"), \"Should include the field name context\")\n+            assert(err.contains(\"Cannot safely cast\"), \"Should identify unsafe cast\")\n+            assert(err.contains(s\"$w\"), \"Should include write type\")\n+            assert(err.contains(s\"$r\"), \"Should include read type\")\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  test(\"Check struct types: unsafe casts are not allowed\") {\n+    assertNumErrors(widerPoint2, point2, \"t\",\n+      \"Should fail because types require unsafe casts\", 2) { errs =>\n+\n+      assert(errs(0).contains(\"'t.x'\"), \"Should include the nested field name context\")\n+      assert(errs(0).contains(\"Cannot safely cast\"))\n+\n+      assert(errs(1).contains(\"'t.y'\"), \"Should include the nested field name context\")\n+      assert(errs(1).contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check array types: unsafe casts are not allowed\") {\n+    val arrayOfLong = ArrayType(LongType)\n+    val arrayOfInt = ArrayType(IntegerType)\n+\n+    assertSingleError(arrayOfLong, arrayOfInt, \"arr\",\n+      \"Should not allow array of longs to array of ints\") { err =>\n+      assert(err.contains(\"'arr.element'\"),\n+        \"Should identify problem with named array's element type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check map value types: casting Long to Integer is not allowed\") {\n+    val mapOfLong = MapType(StringType, LongType)\n+    val mapOfInt = MapType(StringType, IntegerType)\n+\n+    assertSingleError(mapOfLong, mapOfInt, \"m\",\n+      \"Should not allow map of longs to map of ints\") { err =>\n+      assert(err.contains(\"'m.value'\"), \"Should identify problem with named map's value type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check map key types: unsafe casts are not allowed\") {\n+    val mapKeyLong = MapType(LongType, StringType)\n+    val mapKeyInt = MapType(IntegerType, StringType)\n+\n+    assertSingleError(mapKeyLong, mapKeyInt, \"m\",\n+      \"Should not allow map of long keys to map of int keys\") { err =>\n+      assert(err.contains(\"'m.key'\"), \"Should identify problem with named map's key type\")\n+      assert(err.contains(\"Cannot safely cast\"))\n+    }\n+  }\n+\n+  test(\"Check types with multiple errors\") {\n+    val readType = StructType(Seq(\n+      StructField(\"a\", ArrayType(DoubleType, containsNull = false)),\n+      StructField(\"arr_of_structs\", ArrayType(point2, containsNull = false)),\n+      StructField(\"bad_nested_type\", ArrayType(StringType)),\n+      StructField(\"m\", MapType(LongType, FloatType, valueContainsNull = false)),\n+      StructField(\"map_of_structs\", MapType(StringType, point3, valueContainsNull = false)),\n+      StructField(\"x\", IntegerType, nullable = false),\n+      StructField(\"missing1\", StringType, nullable = false),\n+      StructField(\"missing2\", StringType)\n+    ))\n+\n+    val missingMiddleField = StructType(Seq(\n+      StructField(\"x\", FloatType, nullable = false),\n+      StructField(\"z\", FloatType, nullable = false)))\n+\n+    val writeType = StructType(Seq(\n+      StructField(\"a\", ArrayType(StringType)),\n+      StructField(\"arr_of_structs\", ArrayType(point3)),\n+      StructField(\"bad_nested_type\", point3),\n+      StructField(\"m\", MapType(DoubleType, DoubleType)),\n+      StructField(\"map_of_structs\", MapType(StringType, missingMiddleField)),\n+      StructField(\"y\", LongType)\n+    ))\n+\n+    assertNumErrors(writeType, readType, \"top\", \"Should catch 14 errors\", 14) { errs =>\n+      assert(errs(0).contains(\"'top.a.element'\"), \"Should identify bad type\")\n+      assert(errs(0).contains(\"Cannot safely cast\"))\n+      assert(errs(0).contains(\"StringType to DoubleType\"))\n+\n+      assert(errs(1).contains(\"'top.a'\"), \"Should identify bad type\")\n+      assert(errs(1).contains(\"Cannot write nullable elements to array of non-nulls\"))\n+\n+      assert(errs(2).contains(\"'top.arr_of_structs.element'\"), \"Should identify bad type\")\n+      assert(errs(2).contains(\"'z'\"), \"Should identify bad field\")\n+      assert(errs(2).contains(\"Cannot write extra fields to struct\"))\n+\n+      assert(errs(3).contains(\"'top.arr_of_structs'\"), \"Should identify bad type\")\n+      assert(errs(3).contains(\"Cannot write nullable elements to array of non-nulls\"))\n+\n+      assert(errs(4).contains(\"'top.bad_nested_type'\"), \"Should identify bad type\")\n+      assert(errs(4).contains(\"is incompatible with\"))\n+\n+      assert(errs(5).contains(\"'top.m.key'\"), \"Should identify bad type\")\n+      assert(errs(5).contains(\"Cannot safely cast\"))\n+      assert(errs(5).contains(\"DoubleType to LongType\"))\n+\n+      assert(errs(6).contains(\"'top.m.value'\"), \"Should identify bad type\")\n+      assert(errs(6).contains(\"Cannot safely cast\"))\n+      assert(errs(6).contains(\"DoubleType to FloatType\"))\n+\n+      assert(errs(7).contains(\"'top.m'\"), \"Should identify bad type\")\n+      assert(errs(7).contains(\"Cannot write nullable values to map of non-nulls\"))\n+\n+      assert(errs(8).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n+      assert(errs(8).contains(\"expected 'y', found 'z'\"), \"Should detect name mismatch\")\n+      assert(errs(8).contains(\"field name does not match\"), \"Should identify name problem\")\n+\n+      assert(errs(9).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n+      assert(errs(9).contains(\"'z'\"), \"Should identify missing field\")\n+      assert(errs(9).contains(\"missing fields\"), \"Should detect missing field\")\n+\n+      assert(errs(10).contains(\"'top.map_of_structs'\"), \"Should identify bad type\")\n+      assert(errs(10).contains(\"Cannot write nullable values to map of non-nulls\"))\n+\n+      assert(errs(11).contains(\"'top.x'\"), \"Should identify bad type\")\n+      assert(errs(11).contains(\"Cannot safely cast\"))\n+      assert(errs(11).contains(\"LongType to IntegerType\"))\n+\n+      assert(errs(12).contains(\"'top'\"), \"Should identify bad type\")\n+      assert(errs(12).contains(\"expected 'x', found 'y'\"), \"Should detect name mismatch\")\n+      assert(errs(12).contains(\"field name does not match\"), \"Should identify name problem\")\n+\n+      assert(errs(13).contains(\"'top'\"), \"Should identify bad type\")\n+      assert(errs(13).contains(\"'missing1'\"), \"Should identify missing field\")\n+      assert(errs(13).contains(\"missing fields\"), \"Should detect missing field\")\n+    }\n+  }\n+}\n+\n+class ANSIDataTypeWriteCompatibilitySuite extends DataTypeWriteCompatibilityBaseSuite {\n+  override protected def storeAssignmentPolicy: SQLConf.StoreAssignmentPolicy.Value =\n+    StoreAssignmentPolicy.ANSI\n+\n+  test(\"Check atomic types: write allowed only when casting is safe\") {\n+    atomicTypes.foreach { w =>\n+      atomicTypes.foreach { r =>\n+        if ((w.isInstanceOf[NumericType] && r.isInstanceOf[NumericType]) ||"
  }],
  "prId": 25581
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "it looks to me that, we can make the code simpler if this method takes the policy parameter. e.g.\r\n```\r\ntest(\"Check atomic types: write allowed only when casting is safe\") {\r\n  atomicTypes.foreach { w =>\r\n    atomicTypes.foreach { r =>\r\n      if (Cast.canUpCast(w, r)) {\r\n        assertAllowed(Policy.STRICT, ...)\r\n      } else {\r\n        assertSingleError(Policy.STRICT, ...)\r\n      }\r\n      if (Cast.canANSIStoreAssign(w, r)) ...\r\n    } \r\n  }\r\n}\r\n```",
    "commit": "af0f7390e61455682cb5089f8e8dd3c0e60d32b1",
    "createdAt": "2019-08-27T07:59:31Z",
    "diffHunk": "@@ -297,87 +508,10 @@ class DataTypeWriteCompatibilitySuite extends SparkFunSuite {\n       \"Should allow map of int written to map of long column\")\n   }\n \n-  test(\"Check types with multiple errors\") {\n-    val readType = StructType(Seq(\n-      StructField(\"a\", ArrayType(DoubleType, containsNull = false)),\n-      StructField(\"arr_of_structs\", ArrayType(point2, containsNull = false)),\n-      StructField(\"bad_nested_type\", ArrayType(StringType)),\n-      StructField(\"m\", MapType(LongType, FloatType, valueContainsNull = false)),\n-      StructField(\"map_of_structs\", MapType(StringType, point3, valueContainsNull = false)),\n-      StructField(\"x\", IntegerType, nullable = false),\n-      StructField(\"missing1\", StringType, nullable = false),\n-      StructField(\"missing2\", StringType)\n-    ))\n-\n-    val missingMiddleField = StructType(Seq(\n-      StructField(\"x\", FloatType, nullable = false),\n-      StructField(\"z\", FloatType, nullable = false)))\n-\n-    val writeType = StructType(Seq(\n-      StructField(\"a\", ArrayType(StringType)),\n-      StructField(\"arr_of_structs\", ArrayType(point3)),\n-      StructField(\"bad_nested_type\", point3),\n-      StructField(\"m\", MapType(DoubleType, DoubleType)),\n-      StructField(\"map_of_structs\", MapType(StringType, missingMiddleField)),\n-      StructField(\"y\", LongType)\n-    ))\n-\n-    assertNumErrors(writeType, readType, \"top\", \"Should catch 14 errors\", 14) { errs =>\n-      assert(errs(0).contains(\"'top.a.element'\"), \"Should identify bad type\")\n-      assert(errs(0).contains(\"Cannot safely cast\"))\n-      assert(errs(0).contains(\"StringType to DoubleType\"))\n-\n-      assert(errs(1).contains(\"'top.a'\"), \"Should identify bad type\")\n-      assert(errs(1).contains(\"Cannot write nullable elements to array of non-nulls\"))\n-\n-      assert(errs(2).contains(\"'top.arr_of_structs.element'\"), \"Should identify bad type\")\n-      assert(errs(2).contains(\"'z'\"), \"Should identify bad field\")\n-      assert(errs(2).contains(\"Cannot write extra fields to struct\"))\n-\n-      assert(errs(3).contains(\"'top.arr_of_structs'\"), \"Should identify bad type\")\n-      assert(errs(3).contains(\"Cannot write nullable elements to array of non-nulls\"))\n-\n-      assert(errs(4).contains(\"'top.bad_nested_type'\"), \"Should identify bad type\")\n-      assert(errs(4).contains(\"is incompatible with\"))\n-\n-      assert(errs(5).contains(\"'top.m.key'\"), \"Should identify bad type\")\n-      assert(errs(5).contains(\"Cannot safely cast\"))\n-      assert(errs(5).contains(\"DoubleType to LongType\"))\n-\n-      assert(errs(6).contains(\"'top.m.value'\"), \"Should identify bad type\")\n-      assert(errs(6).contains(\"Cannot safely cast\"))\n-      assert(errs(6).contains(\"DoubleType to FloatType\"))\n-\n-      assert(errs(7).contains(\"'top.m'\"), \"Should identify bad type\")\n-      assert(errs(7).contains(\"Cannot write nullable values to map of non-nulls\"))\n-\n-      assert(errs(8).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n-      assert(errs(8).contains(\"expected 'y', found 'z'\"), \"Should detect name mismatch\")\n-      assert(errs(8).contains(\"field name does not match\"), \"Should identify name problem\")\n-\n-      assert(errs(9).contains(\"'top.map_of_structs.value'\"), \"Should identify bad type\")\n-      assert(errs(9).contains(\"'z'\"), \"Should identify missing field\")\n-      assert(errs(9).contains(\"missing fields\"), \"Should detect missing field\")\n-\n-      assert(errs(10).contains(\"'top.map_of_structs'\"), \"Should identify bad type\")\n-      assert(errs(10).contains(\"Cannot write nullable values to map of non-nulls\"))\n-\n-      assert(errs(11).contains(\"'top.x'\"), \"Should identify bad type\")\n-      assert(errs(11).contains(\"Cannot safely cast\"))\n-      assert(errs(11).contains(\"LongType to IntegerType\"))\n-\n-      assert(errs(12).contains(\"'top'\"), \"Should identify bad type\")\n-      assert(errs(12).contains(\"expected 'x', found 'y'\"), \"Should detect name mismatch\")\n-      assert(errs(12).contains(\"field name does not match\"), \"Should identify name problem\")\n-\n-      assert(errs(13).contains(\"'top'\"), \"Should identify bad type\")\n-      assert(errs(13).contains(\"'missing1'\"), \"Should identify missing field\")\n-      assert(errs(13).contains(\"missing fields\"), \"Should detect missing field\")\n-    }\n-  }\n-\n   // Helper functions\n \n+  protected def storeAssignmentPolicy: StoreAssignmentPolicy.Value\n+\n   def assertAllowed("
  }],
  "prId": 25581
}]