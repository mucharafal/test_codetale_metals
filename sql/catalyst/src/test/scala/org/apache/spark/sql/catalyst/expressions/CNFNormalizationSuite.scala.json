[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Please avoid using variable names like `l`. Use `lhs`/`rhs` or `left`/`right` here instead.\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T13:44:14Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r"
  }],
  "prId": 8200
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "`atoms` doesn't seem to be an accurate name since you're actually collecting all sub-expressions that are not `Or`, which are not necessarily \"atoms\".\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:02:45Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]"
  }],
  "prId": 8200
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "~~Seems that this method is equivalent to:~~\n\n``` scala\nexpression\n  .collect { case e if !e.isInstanceOf[Or] => e }\n  .sortBy(_.toString)\n  .reduce(Or)\n```\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:23:49Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Maybe just return a `Seq[Expression]` without the final `reduce(Or)`.\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:26:26Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "~~(The assumption here is that `expression` has already gone through CNF transformation, so that any sub-expression that is not an `Or` doesn't contain any `Or` either.)~~\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:36:57Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Sorry, please ignore my comments above, made a mistake and the assumption is wrong...\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:38:32Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "yjshen"
    },
    "body": "Is that possible we still get Not(expr) even we finished boolean simplification? If so, simply matching `!e.isInstanceOf[Or]` and collect seems not proper?\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:40:55Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Actually... It seems to be correct? Since you first do a `splitConjunctivePredicates` and then pass in elements of the result to this method... :dizzy_face: \n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:43:33Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "yjshen"
    },
    "body": "I mean, will `Not(expr)` be collected as `Not(expr)` and `expr` as two separate expressions?\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:47:37Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "@yjshen Yeah, the above assumption is only correct if you do REAL CNF conversion in this PR. Currently De Morgan law is not considered.\n\n(This one replies [this comment](https://github.com/apache/spark/pull/8200#discussion_r37082551).)\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:47:59Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "@yjshen If you do real CNF conversion here (namely, taking `Not` into consideration), then it would be OK, since `e` in `Not(e)` cannot be `Or`.\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:52:56Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Your current code also suffers from the `Not(Or(x, y))` case (`x` and `y` are atoms), because you're using `foreachUp` rather than `transformUp` here.\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:57:09Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }"
  }],
  "prId": 8200
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Can we test the expression directly without introducing `testRelation` and the analysis phase?\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:30:02Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }\n+\n+  private def checkCondition(input: Expression, expected: Expression): Unit = {\n+    val actual = testRelation.where(input).analyze\n+    val correctAnswer = testRelation.where(expected).analyze\n+\n+    val resultFilterExpression = actual.collectFirst { case f: Filter => f.condition }.get\n+    val expectedFilterExpression = correctAnswer.collectFirst { case f: Filter => f.condition }.get"
  }],
  "prId": 8200
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "By making `normalizeOrExpression` return a `Seq[Expression]`, you can replace the `map` here with a `flatMap` and get a `Seq` of expressions containing no `Or`.\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T14:31:08Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }\n+\n+  private def checkCondition(input: Expression, expected: Expression): Unit = {\n+    val actual = testRelation.where(input).analyze\n+    val correctAnswer = testRelation.where(expected).analyze\n+\n+    val resultFilterExpression = actual.collectFirst { case f: Filter => f.condition }.get\n+    val expectedFilterExpression = correctAnswer.collectFirst { case f: Filter => f.condition }.get\n+\n+    val exprs = splitConjunctivePredicates(cnfNormalization(resultFilterExpression)).\n+      map(normalizeOrExpression).sortBy(_.toString)"
  }, {
    "author": {
      "login": "yjshen"
    },
    "body": "I think I still need `reduce(Or)` because after `flatMap` I cannot sort them. therefore, (a || b || c) && (a || b || d) is still not equal to (a || b || d) && (a || b || c).\n",
    "commit": "91b2c26028696bd7a80045a9f7075a1d8d9561ff",
    "createdAt": "2015-08-14T16:57:13Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.dsl.plans._\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+\n+class CNFNormalizationSuite extends SparkFunSuite with PredicateHelper {\n+\n+  val testRelation = LocalRelation('a.int, 'b.int, 'c.int, 'd.int, 'e.int)\n+\n+  // Take in expression without And, normalize to its leftmost representation to be comparable\n+  private def normalizeOrExpression(expression: Expression): Expression = {\n+    val atoms = ArrayBuffer.empty[Expression]\n+    expression.foreachUp {\n+      case Or(l: Or, r: Or) => // do nothing\n+      case Or(l, r: Or) => atoms += l\n+      case Or(l: Or, r) => atoms += r\n+      case Or(l, r) => atoms += l; atoms += r\n+      case _ => // do nothing\n+    }\n+    if (!expression.isInstanceOf[Or]) {\n+      atoms += expression\n+    }\n+    atoms.sortBy(_.toString).reduce(Or)\n+  }\n+\n+  private def checkCondition(input: Expression, expected: Expression): Unit = {\n+    val actual = testRelation.where(input).analyze\n+    val correctAnswer = testRelation.where(expected).analyze\n+\n+    val resultFilterExpression = actual.collectFirst { case f: Filter => f.condition }.get\n+    val expectedFilterExpression = correctAnswer.collectFirst { case f: Filter => f.condition }.get\n+\n+    val exprs = splitConjunctivePredicates(cnfNormalization(resultFilterExpression)).\n+      map(normalizeOrExpression).sortBy(_.toString)"
  }],
  "prId": 8200
}]