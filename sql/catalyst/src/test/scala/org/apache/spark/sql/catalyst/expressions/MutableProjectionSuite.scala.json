[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we also test that we should fail if the target row is unsafe row?",
    "commit": "4cdc5040feb3da1e4cf9efcf434138d5873fae04",
    "createdAt": "2018-10-24T01:39:48Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+class MutableProjectionSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  private def createMutableProjection(dataTypes: Array[DataType]): MutableProjection = {\n+    MutableProjection.create(dataTypes.zipWithIndex.map(x => BoundReference(x._2, x._1, true)))\n+  }\n+\n+  testBothCodegenAndInterpreted(\"fixed-length types\") {\n+    val fixedLengthTypes = Array[DataType](\n+      BooleanType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType,\n+      DateType, TimestampType)\n+    val proj = createMutableProjection(fixedLengthTypes)\n+    val inputRow = InternalRow.fromSeq(\n+      Seq(false, 3.toByte, 15.toShort, -83, 129L, 1.0f, 5.0, 100, 200L))\n+    assert(proj(inputRow) === inputRow)\n+\n+    // Use UnsafeRow as buffer\n+    val numBytes = UnsafeRow.calculateBitSetWidthInBytes(fixedLengthTypes.length)\n+    val unsafeBuffer = UnsafeRow.createFromByteArray(numBytes, fixedLengthTypes.length)\n+    val projUnsafeRow = proj.target(unsafeBuffer)(inputRow)\n+    assert(FromUnsafeProjection(fixedLengthTypes)(projUnsafeRow) === inputRow)\n+  }\n+\n+  testBothCodegenAndInterpreted(\"variable-length types\") {\n+    val variableLengthTypes = Array(\n+      StringType, DecimalType.defaultConcreteType, CalendarIntervalType, BinaryType,\n+      ArrayType(StringType), MapType(IntegerType, StringType),\n+      StructType.fromDDL(\"a INT, b STRING\"), ObjectType(classOf[java.lang.Integer]))\n+    val proj = createMutableProjection(variableLengthTypes)",
    "line": 58
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "sure.",
    "commit": "4cdc5040feb3da1e4cf9efcf434138d5873fae04",
    "createdAt": "2018-10-24T02:40:34Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+class MutableProjectionSuite extends SparkFunSuite with ExpressionEvalHelper {\n+\n+  private def createMutableProjection(dataTypes: Array[DataType]): MutableProjection = {\n+    MutableProjection.create(dataTypes.zipWithIndex.map(x => BoundReference(x._2, x._1, true)))\n+  }\n+\n+  testBothCodegenAndInterpreted(\"fixed-length types\") {\n+    val fixedLengthTypes = Array[DataType](\n+      BooleanType, ByteType, ShortType, IntegerType, LongType, FloatType, DoubleType,\n+      DateType, TimestampType)\n+    val proj = createMutableProjection(fixedLengthTypes)\n+    val inputRow = InternalRow.fromSeq(\n+      Seq(false, 3.toByte, 15.toShort, -83, 129L, 1.0f, 5.0, 100, 200L))\n+    assert(proj(inputRow) === inputRow)\n+\n+    // Use UnsafeRow as buffer\n+    val numBytes = UnsafeRow.calculateBitSetWidthInBytes(fixedLengthTypes.length)\n+    val unsafeBuffer = UnsafeRow.createFromByteArray(numBytes, fixedLengthTypes.length)\n+    val projUnsafeRow = proj.target(unsafeBuffer)(inputRow)\n+    assert(FromUnsafeProjection(fixedLengthTypes)(projUnsafeRow) === inputRow)\n+  }\n+\n+  testBothCodegenAndInterpreted(\"variable-length types\") {\n+    val variableLengthTypes = Array(\n+      StringType, DecimalType.defaultConcreteType, CalendarIntervalType, BinaryType,\n+      ArrayType(StringType), MapType(IntegerType, StringType),\n+      StructType.fromDDL(\"a INT, b STRING\"), ObjectType(classOf[java.lang.Integer]))\n+    val proj = createMutableProjection(variableLengthTypes)",
    "line": 58
  }],
  "prId": 22512
}]