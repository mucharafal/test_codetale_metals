[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Should we keep benchmark code in PR? cc @yhuai \n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-18T18:20:36Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+object UnsafeProjectionBenchmark {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "yea, I think it is fine (as long as we provide enough doc on how to run it). We also have `ParquetReadBenchmark` in the repo.\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-18T18:23:46Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+object UnsafeProjectionBenchmark {"
  }],
  "prId": 10809
}, {
  "comments": [{
    "author": {
      "login": "nongli"
    },
    "body": "can you paste the results here as a comment?\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-18T19:20:24Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark [[UnsafeProjection]] for flat schema(primitive-type fields).\n+ */\n+object UnsafeProjectionBenchmark {\n+\n+  def generateRows(schema: StructType, numRows: Int): Array[InternalRow] = {\n+    val generator = RandomDataGenerator.forType(schema, nullable = false).get\n+    val encoder = RowEncoder(schema)\n+    (1 to numRows).map(_ => encoder.toRow(generator().asInstanceOf[Row]).copy()).toArray\n+  }\n+\n+  def main(args: Array[String]) {\n+    val iters = 1024 * 16\n+    val numRows = 1024 * 16\n+\n+    val benchmark = new Benchmark(\"unsafe projection\", iters * numRows)\n+\n+\n+    val schema1 = new StructType().add(\"l\", LongType, false)\n+    val attrs1 = schema1.toAttributes\n+    val rows1 = generateRows(schema1, numRows)\n+    val projection1 = UnsafeProjection.create(attrs1, attrs1)\n+\n+    benchmark.addCase(\"single long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection1(rows1(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    val schema2 = new StructType().add(\"l\", LongType, true)\n+    val attrs2 = schema2.toAttributes\n+    val rows2 = generateRows(schema2, numRows)\n+    val projection2 = UnsafeProjection.create(attrs2, attrs2)\n+\n+    benchmark.addCase(\"single nullable long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection2(rows2(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema3 = new StructType()\n+      .add(\"boolean\", BooleanType, false)\n+      .add(\"byte\", ByteType, false)\n+      .add(\"short\", ShortType, false)\n+      .add(\"int\", IntegerType, false)\n+      .add(\"long\", LongType, false)\n+      .add(\"float\", FloatType, false)\n+      .add(\"double\", DoubleType, false)\n+    val attrs3 = schema3.toAttributes\n+    val rows3 = generateRows(schema3, numRows)\n+    val projection3 = UnsafeProjection.create(attrs3, attrs3)\n+\n+    benchmark.addCase(\"primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection3(rows3(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema4 = new StructType()\n+      .add(\"boolean\", BooleanType, true)\n+      .add(\"byte\", ByteType, true)\n+      .add(\"short\", ShortType, true)\n+      .add(\"int\", IntegerType, true)\n+      .add(\"long\", LongType, true)\n+      .add(\"float\", FloatType, true)\n+      .add(\"double\", DoubleType, true)\n+    val attrs4 = schema4.toAttributes\n+    val rows4 = generateRows(schema4, numRows)\n+    val projection4 = UnsafeProjection.create(attrs4, attrs4)\n+\n+    benchmark.addCase(\"nullable primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection4(rows4(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    benchmark.run()"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "just put the result of new version? Actually I copy and paste this benchmark to master and run, so that I can see how much this PR speeds up.\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-18T19:38:21Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark [[UnsafeProjection]] for flat schema(primitive-type fields).\n+ */\n+object UnsafeProjectionBenchmark {\n+\n+  def generateRows(schema: StructType, numRows: Int): Array[InternalRow] = {\n+    val generator = RandomDataGenerator.forType(schema, nullable = false).get\n+    val encoder = RowEncoder(schema)\n+    (1 to numRows).map(_ => encoder.toRow(generator().asInstanceOf[Row]).copy()).toArray\n+  }\n+\n+  def main(args: Array[String]) {\n+    val iters = 1024 * 16\n+    val numRows = 1024 * 16\n+\n+    val benchmark = new Benchmark(\"unsafe projection\", iters * numRows)\n+\n+\n+    val schema1 = new StructType().add(\"l\", LongType, false)\n+    val attrs1 = schema1.toAttributes\n+    val rows1 = generateRows(schema1, numRows)\n+    val projection1 = UnsafeProjection.create(attrs1, attrs1)\n+\n+    benchmark.addCase(\"single long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection1(rows1(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    val schema2 = new StructType().add(\"l\", LongType, true)\n+    val attrs2 = schema2.toAttributes\n+    val rows2 = generateRows(schema2, numRows)\n+    val projection2 = UnsafeProjection.create(attrs2, attrs2)\n+\n+    benchmark.addCase(\"single nullable long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection2(rows2(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema3 = new StructType()\n+      .add(\"boolean\", BooleanType, false)\n+      .add(\"byte\", ByteType, false)\n+      .add(\"short\", ShortType, false)\n+      .add(\"int\", IntegerType, false)\n+      .add(\"long\", LongType, false)\n+      .add(\"float\", FloatType, false)\n+      .add(\"double\", DoubleType, false)\n+    val attrs3 = schema3.toAttributes\n+    val rows3 = generateRows(schema3, numRows)\n+    val projection3 = UnsafeProjection.create(attrs3, attrs3)\n+\n+    benchmark.addCase(\"primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection3(rows3(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema4 = new StructType()\n+      .add(\"boolean\", BooleanType, true)\n+      .add(\"byte\", ByteType, true)\n+      .add(\"short\", ShortType, true)\n+      .add(\"int\", IntegerType, true)\n+      .add(\"long\", LongType, true)\n+      .add(\"float\", FloatType, true)\n+      .add(\"double\", DoubleType, true)\n+    val attrs4 = schema4.toAttributes\n+    val rows4 = generateRows(schema4, numRows)\n+    val projection4 = UnsafeProjection.create(attrs4, attrs4)\n+\n+    benchmark.addCase(\"nullable primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection4(rows4(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    benchmark.run()"
  }, {
    "author": {
      "login": "nongli"
    },
    "body": "Just the new table from the PR comment is good. I like to include these so readers get a rough sense of what is happening.\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-19T19:08:20Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark [[UnsafeProjection]] for flat schema(primitive-type fields).\n+ */\n+object UnsafeProjectionBenchmark {\n+\n+  def generateRows(schema: StructType, numRows: Int): Array[InternalRow] = {\n+    val generator = RandomDataGenerator.forType(schema, nullable = false).get\n+    val encoder = RowEncoder(schema)\n+    (1 to numRows).map(_ => encoder.toRow(generator().asInstanceOf[Row]).copy()).toArray\n+  }\n+\n+  def main(args: Array[String]) {\n+    val iters = 1024 * 16\n+    val numRows = 1024 * 16\n+\n+    val benchmark = new Benchmark(\"unsafe projection\", iters * numRows)\n+\n+\n+    val schema1 = new StructType().add(\"l\", LongType, false)\n+    val attrs1 = schema1.toAttributes\n+    val rows1 = generateRows(schema1, numRows)\n+    val projection1 = UnsafeProjection.create(attrs1, attrs1)\n+\n+    benchmark.addCase(\"single long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection1(rows1(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    val schema2 = new StructType().add(\"l\", LongType, true)\n+    val attrs2 = schema2.toAttributes\n+    val rows2 = generateRows(schema2, numRows)\n+    val projection2 = UnsafeProjection.create(attrs2, attrs2)\n+\n+    benchmark.addCase(\"single nullable long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection2(rows2(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema3 = new StructType()\n+      .add(\"boolean\", BooleanType, false)\n+      .add(\"byte\", ByteType, false)\n+      .add(\"short\", ShortType, false)\n+      .add(\"int\", IntegerType, false)\n+      .add(\"long\", LongType, false)\n+      .add(\"float\", FloatType, false)\n+      .add(\"double\", DoubleType, false)\n+    val attrs3 = schema3.toAttributes\n+    val rows3 = generateRows(schema3, numRows)\n+    val projection3 = UnsafeProjection.create(attrs3, attrs3)\n+\n+    benchmark.addCase(\"primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection3(rows3(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema4 = new StructType()\n+      .add(\"boolean\", BooleanType, true)\n+      .add(\"byte\", ByteType, true)\n+      .add(\"short\", ShortType, true)\n+      .add(\"int\", IntegerType, true)\n+      .add(\"long\", LongType, true)\n+      .add(\"float\", FloatType, true)\n+      .add(\"double\", DoubleType, true)\n+    val attrs4 = schema4.toAttributes\n+    val rows4 = generateRows(schema4, numRows)\n+    val projection4 = UnsafeProjection.create(attrs4, attrs4)\n+\n+    benchmark.addCase(\"nullable primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection4(rows4(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    benchmark.run()"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "+1 for posting it here, it will be easy to track the performance improvements.\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-19T21:01:38Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark [[UnsafeProjection]] for flat schema(primitive-type fields).\n+ */\n+object UnsafeProjectionBenchmark {\n+\n+  def generateRows(schema: StructType, numRows: Int): Array[InternalRow] = {\n+    val generator = RandomDataGenerator.forType(schema, nullable = false).get\n+    val encoder = RowEncoder(schema)\n+    (1 to numRows).map(_ => encoder.toRow(generator().asInstanceOf[Row]).copy()).toArray\n+  }\n+\n+  def main(args: Array[String]) {\n+    val iters = 1024 * 16\n+    val numRows = 1024 * 16\n+\n+    val benchmark = new Benchmark(\"unsafe projection\", iters * numRows)\n+\n+\n+    val schema1 = new StructType().add(\"l\", LongType, false)\n+    val attrs1 = schema1.toAttributes\n+    val rows1 = generateRows(schema1, numRows)\n+    val projection1 = UnsafeProjection.create(attrs1, attrs1)\n+\n+    benchmark.addCase(\"single long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection1(rows1(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    val schema2 = new StructType().add(\"l\", LongType, true)\n+    val attrs2 = schema2.toAttributes\n+    val rows2 = generateRows(schema2, numRows)\n+    val projection2 = UnsafeProjection.create(attrs2, attrs2)\n+\n+    benchmark.addCase(\"single nullable long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection2(rows2(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema3 = new StructType()\n+      .add(\"boolean\", BooleanType, false)\n+      .add(\"byte\", ByteType, false)\n+      .add(\"short\", ShortType, false)\n+      .add(\"int\", IntegerType, false)\n+      .add(\"long\", LongType, false)\n+      .add(\"float\", FloatType, false)\n+      .add(\"double\", DoubleType, false)\n+    val attrs3 = schema3.toAttributes\n+    val rows3 = generateRows(schema3, numRows)\n+    val projection3 = UnsafeProjection.create(attrs3, attrs3)\n+\n+    benchmark.addCase(\"primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection3(rows3(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema4 = new StructType()\n+      .add(\"boolean\", BooleanType, true)\n+      .add(\"byte\", ByteType, true)\n+      .add(\"short\", ShortType, true)\n+      .add(\"int\", IntegerType, true)\n+      .add(\"long\", LongType, true)\n+      .add(\"float\", FloatType, true)\n+      .add(\"double\", DoubleType, true)\n+    val attrs4 = schema4.toAttributes\n+    val rows4 = generateRows(schema4, numRows)\n+    val projection4 = UnsafeProjection.create(attrs4, attrs4)\n+\n+    benchmark.addCase(\"nullable primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection4(rows4(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    benchmark.run()"
  }],
  "prId": 10809
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Could you say `7 primitive types`, or it's weird to see that why primitive types is so slow.\n",
    "commit": "f79f63cbead61f561e34270154f236dcae786e16",
    "createdAt": "2016-01-19T21:01:01Z",
    "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.types._\n+import org.apache.spark.util.Benchmark\n+\n+/**\n+ * Benchmark [[UnsafeProjection]] for flat schema(primitive-type fields).\n+ */\n+object UnsafeProjectionBenchmark {\n+\n+  def generateRows(schema: StructType, numRows: Int): Array[InternalRow] = {\n+    val generator = RandomDataGenerator.forType(schema, nullable = false).get\n+    val encoder = RowEncoder(schema)\n+    (1 to numRows).map(_ => encoder.toRow(generator().asInstanceOf[Row]).copy()).toArray\n+  }\n+\n+  def main(args: Array[String]) {\n+    val iters = 1024 * 16\n+    val numRows = 1024 * 16\n+\n+    val benchmark = new Benchmark(\"unsafe projection\", iters * numRows)\n+\n+\n+    val schema1 = new StructType().add(\"l\", LongType, false)\n+    val attrs1 = schema1.toAttributes\n+    val rows1 = generateRows(schema1, numRows)\n+    val projection1 = UnsafeProjection.create(attrs1, attrs1)\n+\n+    benchmark.addCase(\"single long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection1(rows1(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+    val schema2 = new StructType().add(\"l\", LongType, true)\n+    val attrs2 = schema2.toAttributes\n+    val rows2 = generateRows(schema2, numRows)\n+    val projection2 = UnsafeProjection.create(attrs2, attrs2)\n+\n+    benchmark.addCase(\"single nullable long\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection2(rows2(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema3 = new StructType()\n+      .add(\"boolean\", BooleanType, false)\n+      .add(\"byte\", ByteType, false)\n+      .add(\"short\", ShortType, false)\n+      .add(\"int\", IntegerType, false)\n+      .add(\"long\", LongType, false)\n+      .add(\"float\", FloatType, false)\n+      .add(\"double\", DoubleType, false)\n+    val attrs3 = schema3.toAttributes\n+    val rows3 = generateRows(schema3, numRows)\n+    val projection3 = UnsafeProjection.create(attrs3, attrs3)\n+\n+    benchmark.addCase(\"primitive types\") { _ =>\n+      for (_ <- 1 to iters) {\n+        var sum = 0L\n+        var i = 0\n+        while (i < numRows) {\n+          sum += projection3(rows3(i)).getLong(0)\n+          i += 1\n+        }\n+      }\n+    }\n+\n+\n+    val schema4 = new StructType()\n+      .add(\"boolean\", BooleanType, true)\n+      .add(\"byte\", ByteType, true)\n+      .add(\"short\", ShortType, true)\n+      .add(\"int\", IntegerType, true)\n+      .add(\"long\", LongType, true)\n+      .add(\"float\", FloatType, true)\n+      .add(\"double\", DoubleType, true)\n+    val attrs4 = schema4.toAttributes\n+    val rows4 = generateRows(schema4, numRows)\n+    val projection4 = UnsafeProjection.create(attrs4, attrs4)\n+\n+    benchmark.addCase(\"nullable primitive types\") { _ =>"
  }],
  "prId": 10809
}]