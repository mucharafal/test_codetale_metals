[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Total nit, but you can: `val (data21, data22) = data.zipWithIndex.partition(_._2 % 5 != 0).map(_._1)`, I believe",
    "commit": "02af468b8c249103e65e97ce0945309e0d48e1a3",
    "createdAt": "2019-10-04T23:10:21Z",
    "diffHunk": "@@ -169,5 +170,22 @@ class QuantileSummariesSuite extends SparkFunSuite {\n       checkQuantile(0.1, data, s)\n       checkQuantile(0.001, data, s)\n     }\n+\n+    // length of data21 is 4 * length of data22\n+    val data21 = data.zipWithIndex.filter(_._2 % 5 != 0).map(_._1).toSeq",
    "line": 6
  }, {
    "author": {
      "login": "sitegui"
    },
    "body": "Hello @srowen , thanks a lot for the remarks. I've fixed the other two, but for this one, if I understood the usage correctly, I need to do something on the lines of:\r\n\r\n```scala\r\nval (iterData21, iterData22) = data.zipWithIndex.partition(_._2 % 5 != 0)\r\nval data21 = iterData21.map(_._1).toSeq\r\nval data22 = iterData22.map(_._1).toSeq\r\n```\r\n\r\nOr is there a cleaner way to do it?",
    "commit": "02af468b8c249103e65e97ce0945309e0d48e1a3",
    "createdAt": "2019-10-05T09:19:32Z",
    "diffHunk": "@@ -169,5 +170,22 @@ class QuantileSummariesSuite extends SparkFunSuite {\n       checkQuantile(0.1, data, s)\n       checkQuantile(0.001, data, s)\n     }\n+\n+    // length of data21 is 4 * length of data22\n+    val data21 = data.zipWithIndex.filter(_._2 % 5 != 0).map(_._1).toSeq",
    "line": 6
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Nah, disregard this then if .toSeq is necessary",
    "commit": "02af468b8c249103e65e97ce0945309e0d48e1a3",
    "createdAt": "2019-10-05T13:16:00Z",
    "diffHunk": "@@ -169,5 +170,22 @@ class QuantileSummariesSuite extends SparkFunSuite {\n       checkQuantile(0.1, data, s)\n       checkQuantile(0.001, data, s)\n     }\n+\n+    // length of data21 is 4 * length of data22\n+    val data21 = data.zipWithIndex.filter(_._2 % 5 != 0).map(_._1).toSeq",
    "line": 6
  }],
  "prId": 26029
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: `queryQuantile`",
    "commit": "02af468b8c249103e65e97ce0945309e0d48e1a3",
    "createdAt": "2019-10-04T23:10:32Z",
    "diffHunk": "@@ -169,5 +170,22 @@ class QuantileSummariesSuite extends SparkFunSuite {\n       checkQuantile(0.1, data, s)\n       checkQuantile(0.001, data, s)\n     }\n+\n+    // length of data21 is 4 * length of data22\n+    val data21 = data.zipWithIndex.filter(_._2 % 5 != 0).map(_._1).toSeq\n+    val data22 = data.zipWithIndex.filter(_._2 % 5 == 0).map(_._1).toSeq\n+\n+    test(\n+      s\"Merging unbalanced interleaved lists with epsi=$epsi and seq=$seq_name, \" +\n+        s\"compression=$compression\") {\n+      val s1 = buildSummary(data21, epsi, compression)\n+      val s2 = buildSummary(data22, epsi, compression)\n+      val s = s1.merge(s2)\n+      // Check all quantiles\n+      for (query_rank <- 1 to n) {\n+        val query_quantile = query_rank.toDouble / n.toDouble"
  }],
  "prId": 26029
}]