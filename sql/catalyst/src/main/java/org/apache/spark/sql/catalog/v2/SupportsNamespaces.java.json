[{
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "Should this list the top-level namespaces or within the `defaultNamespace`? If it's also just going to return `a`, why does it need to return an array of arrays instead of just an array?",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-25T22:18:53Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.",
    "line": 55
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "It should list top-level namespaces. The default namespace is the one used as Spark's current namespace when the catalog is the default and should not change the behavior of the catalog.\r\n\r\nIt returns an array of arrays so you can pass each result into `listNamespaces(Array[String])`. `Array[String]` is the type that we consistently use for a namespace, so I think it is correct to return it here.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:22:45Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.",
    "line": 55
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "Adding to my comment about listing top-level namespaces: if the default namespace changed the catalog's behavior, we would have to document exactly how it should change the behavior and have a way to configure it.\r\n\r\nI like keeping this simple instead, so these methods do the same thing every time and Spark doesn't require the plugin to maintain a current namespace as state.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:28:06Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.",
    "line": 55
  }],
  "prId": 24560
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "`createNamespace` instead of `createNamespaceMetadata`",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-25T22:21:38Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I recently changed this and I think it fits better with the semantics that we require. Namespaces are required to exist if they contain a table. We don't check whether the namespace exists on table creation and leave that to the implementation. So it makes more sense if this is create namespace metadata, because the namespace may already exist and we don't want to throw NamespaceAlreadyExists if there isn't already metadata. Does that make sense?",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:17:30Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "See this test: https://github.com/apache/spark/pull/24560/files#diff-dbc34e865cad1087fa8c24afe5e5e1aeR761-R773\r\n\r\nBecause the table exists, the namespace already exists. It would be surprising to fail the create because it was implicitly created earlier, and it would also be surprising to allow a create when it already exists. Adding \"metadata\" to the method name makes this more obvious because you can create the namespace metadata.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:20:19Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "got it, that's fair.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:20:52Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Do you mean sometimes `createNamespaceMetadata` is the same as adding properties to an existing namespace?",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:27:20Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@cloud-fan, look at the test case that I linked to. In that case, the namespace exists because it contains a table. Calling `createNamespaceMetadata` is allowed because it doesn't have metadata associated with it, which makes it exist independent of tables. So, yes, this does function like adding properties the first time.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:36:31Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "This behavior is a little counter-intuitive to me. When I run `mkdir -p /dir1/dir2/dir3` to create a bunch of directories, `mkdir /dir1` fails even if `dir1` was created implicitly.\r\n\r\nIt also complicates the abstraction. Now namespace has 2 different kinds: created explicitly and created implicitly. The one created explicitly will make `createNamespaceMetadata` fail, and the one created implicitly will make `createNamespaceMetadata` success.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:46:08Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@cloud-fan, that's why this was renamed to `createNamespaceMetadata`, not `createNamespace`.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T17:36:00Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "It seems to me that a simple `createNamespace` method is more useful, instead of a `createNamespaceMetadata` method that needs more document to clarify the behavior.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-29T06:12:39Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@cloud-fan, if we do that, then do you think implementations that extend `SupportsNamespaces` should fail to create a table if its namespace doesn't exist? I think that's a bad idea -- think about file system tables where directories are namespaces and may not exist.\r\n\r\nI understand not liking the method name, but we need some way to solve this problem. Curious about what you'd suggest.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-29T16:33:48Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "If you run `CREATE db.tbl ...` in JDBC, it will complain about `db` not exist. This is the same in Spark, Hive, Preso and RDBMS like postgres.\r\n\r\nI think it's more common to fail the table creation if the namespace doesn't exist. Even for file systems, `mkdir` fails if the parent directory doesn't exist, unless you add the `-p` option.\r\n\r\nWe can add a variant of `createTable` method in the future, which is similar to `mkdir -p` and can create the missing namespaces automatically. By default I think table creation should fail if the namespace doesn't exist, to simplify the semantic.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-30T12:03:39Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@cloud-fan, some sources like JDBC and Hive will throw an exception when the namespace doesn't exist. The problem is that we don't want to require this for all sources where it doesn't make sense, like a catalog that stores tables in an object store. Object stores don't necessarily have the concept of a directory that exists independently (s3 FS wrappers have conventions like `_$folder$` objects).\r\n\r\nThat's why failing to create a table if the namespace doesn't exist is optional, and creating namespaces implicitly is allowed. This isn't something we can (or should) change.\r\n\r\nSo the question is how do we handle this in this API? I think that it makes sense to allow namespace creation that is independent of tables -- by creating namespace metadata.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-30T16:24:25Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "mccheah"
    },
    "body": "Instead of `createNamespaceMetadata` can we make this something like `tryCreateNamespace`, which is not required to throw an exception if the namespace already exists? Or, `getOrCreateNamespace`, for a similar effect?",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-30T17:23:00Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "@rdblue If the namespace already exists (implicitly for that matter), wouldn't you use alterNamespace to add the metadata?\r\n\r\n\r\n",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-30T20:22:30Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "@brkyvz, that also works (and has a test in this PR).\r\n\r\n@mccheah, I would be surprised if `tryCreateNamespace` and `getOrCreateNamespace` updated the namespace metadata, which I think is part of the intent here.\r\n\r\nAnother option is `ensureNamespaceExists` without metadata, which would create or do nothing if it already exists. Then metadata could be added using `alterNamespace`. I don't think that is a very good option either because there is no clean create with metadata operation.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-30T21:22:06Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I'm not a fan of \"implementation is free to decide the behaviors\". When end-users run SQL queries in Spark, Spark should behave deterministically and consistently, instead of telling end-users \"you will see different behaviors if you connect to different catalogs\".\r\n\r\nIMO, `CREATE TABLE` should fail if the namespace doesn't exist, as it's intuitive and commonly seen in other databases. If a catalog stores tables in an object store, and is hard to detect namespace existence, then it should not support namespace, or try harder to figure out a workaround.\r\n\r\nWe can add an option/SQL syntax to allow `CREATE TABLE` to create namespaces automatically, but it should be the end-users who decide which behavior to pick, not the catalog. This is similar to `mkdir`. Users must add the `-p` option to create non-existing parent directories. It's pretty bad if we say \"mkdir may or may not create parent directories, it depends on which Linux distribution you run it\".",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-31T10:44:46Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "@cloud-fan But the whole goal of DSV2 is to let the implementation decide the (internal) behavior, but have Spark to enforce the semantics. If you truncate a table with Spark, all Spark needs is that the next time that table is queried that there is no data in the table. It doesn't care if the table (datasource) decided to physically delete all the data or just did a logical deletion.\r\n\r\n - `CREATE TABLE` should fail if the namespace doesn't exist => This makes sense to me. I'd say this is the behavior that users expect. I don't think this would be a blocker if people start to implement object store backed catalogs. Then they can run `CREATE NAMESPACE a.b.c`, and then try the CREATE TABLE again\r\n - If a namespace already exists, then IMHO CREATE NAMESPACE should throw an error and they should run ALTER NAMESPACE to add the metadata\r\n - Regarding implicit namespaces in object stores, I feel that this still means that someone created the namespace through some other means (imagine using a GUI to create a MySQL table instead of the shell), and alter namespace should be used to add the metadata.\r\n\r\nwdyt @rdblue @mccheah ",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-31T18:03:59Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "@brkyvz when I say \"behavior\", I don't mean the internal behavior that is invisible to end-users, I actually mean the semantic that is visible to end-users.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-08-01T08:22:10Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata("
  }],
  "prId": 24560
}, {
  "comments": [{
    "author": {
      "login": "brkyvz"
    },
    "body": "can we not have a boolean flag here called `cascade` that deletes all the Namespaces and Tables under this namespace if it is not empty?",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T00:37:41Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata(\n+      String[] namespace,\n+      Map<String, String> metadata) throws NamespaceAlreadyExistsException;\n+\n+  /**\n+   * Apply a set of metadata changes to a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param changes a collection of changes to apply to the namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  void alterNamespace(\n+      String[] namespace,\n+      NamespaceChange... changes) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Drop a namespace from the catalog.\n+   * <p>\n+   * This operation may be rejected by the catalog implementation if the namespace is not empty by\n+   * throwing {@link IllegalStateException}. If the catalog implementation does not support this\n+   * operation, it may throw {@link UnsupportedOperationException}.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace was dropped\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws IllegalStateException If the namespace is not empty\n+   * @throws UnsupportedOperationException If drop is not a supported operation\n+   */\n+  boolean dropNamespace(String[] namespace) throws NoSuchNamespaceException;",
    "line": 144
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "+1",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T02:23:14Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata(\n+      String[] namespace,\n+      Map<String, String> metadata) throws NamespaceAlreadyExistsException;\n+\n+  /**\n+   * Apply a set of metadata changes to a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param changes a collection of changes to apply to the namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  void alterNamespace(\n+      String[] namespace,\n+      NamespaceChange... changes) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Drop a namespace from the catalog.\n+   * <p>\n+   * This operation may be rejected by the catalog implementation if the namespace is not empty by\n+   * throwing {@link IllegalStateException}. If the catalog implementation does not support this\n+   * operation, it may throw {@link UnsupportedOperationException}.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace was dropped\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws IllegalStateException If the namespace is not empty\n+   * @throws UnsupportedOperationException If drop is not a supported operation\n+   */\n+  boolean dropNamespace(String[] namespace) throws NoSuchNamespaceException;",
    "line": 144
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "We can consider adding it later. We should decide whether we want to require implementations to build that, or whether that should be done by Spark.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:15:44Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata(\n+      String[] namespace,\n+      Map<String, String> metadata) throws NamespaceAlreadyExistsException;\n+\n+  /**\n+   * Apply a set of metadata changes to a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param changes a collection of changes to apply to the namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  void alterNamespace(\n+      String[] namespace,\n+      NamespaceChange... changes) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Drop a namespace from the catalog.\n+   * <p>\n+   * This operation may be rejected by the catalog implementation if the namespace is not empty by\n+   * throwing {@link IllegalStateException}. If the catalog implementation does not support this\n+   * operation, it may throw {@link UnsupportedOperationException}.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace was dropped\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws IllegalStateException If the namespace is not empty\n+   * @throws UnsupportedOperationException If drop is not a supported operation\n+   */\n+  boolean dropNamespace(String[] namespace) throws NoSuchNamespaceException;",
    "line": 144
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "I see what you mean. Spark can list all tables within all namespaces and delete them if cascade = true, and not have the catalog do it. I can see the pros of that. I think something like that opens you up to race conditions too though. This is fine for now, just wanted to bring it up. If there's a real need (ask) we can always add it later",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:23:29Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata(\n+      String[] namespace,\n+      Map<String, String> metadata) throws NamespaceAlreadyExistsException;\n+\n+  /**\n+   * Apply a set of metadata changes to a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param changes a collection of changes to apply to the namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  void alterNamespace(\n+      String[] namespace,\n+      NamespaceChange... changes) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Drop a namespace from the catalog.\n+   * <p>\n+   * This operation may be rejected by the catalog implementation if the namespace is not empty by\n+   * throwing {@link IllegalStateException}. If the catalog implementation does not support this\n+   * operation, it may throw {@link UnsupportedOperationException}.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace was dropped\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws IllegalStateException If the namespace is not empty\n+   * @throws UnsupportedOperationException If drop is not a supported operation\n+   */\n+  boolean dropNamespace(String[] namespace) throws NoSuchNamespaceException;",
    "line": 144
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "I'm generally in favor of Spark taking care of operations like these. Otherwise it puts a lot of responsibility on catalog plugins and we want to avoid making those too complex. Required complexity in a plugin will lead to buggy implementations and unreliable behavior across plugins.",
    "commit": "44afb5ca97a02f2353669bfb16cb7733c9d53b17",
    "createdAt": "2019-07-26T16:26:07Z",
    "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalog.v2;\n+\n+import org.apache.spark.sql.catalyst.analysis.NamespaceAlreadyExistsException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchNamespaceException;\n+\n+import java.util.Map;\n+\n+/**\n+ * Catalog methods for working with namespaces.\n+ * <p>\n+ * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+ * and must be returned by the discovery methods {@link #listNamespaces()} and\n+ * {@link #listNamespaces(String[])}.\n+ * <p>\n+ * Catalog implementations are not required to maintain the existence of namespaces independent of\n+ * objects in a namespace. For example, a function catalog that loads functions using reflection\n+ * and uses Java packages as namespaces is not required to support the methods to create, alter, or\n+ * drop a namespace. Implementations are allowed to discover the existence of objects or namespaces\n+ * without throwing {@link NoSuchNamespaceException} when no namespace is found.\n+ */\n+public interface SupportsNamespaces extends CatalogPlugin {\n+\n+  /**\n+   * Return a default namespace for the catalog.\n+   * <p>\n+   * When this catalog is set as the current catalog, the namespace returned by this method will be\n+   * set as the current namespace.\n+   * <p>\n+   * The namespace returned by this method is not required to exist.\n+   *\n+   * @return a multi-part namespace\n+   */\n+  default String[] defaultNamespace() {\n+    return new String[0];\n+  }\n+\n+  /**\n+   * List top-level namespaces from the catalog.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * must return [\"a\"] in the result array.\n+   *\n+   * @return an array of multi-part namespace names\n+   */\n+  String[][] listNamespaces() throws NoSuchNamespaceException;\n+\n+  /**\n+   * List namespaces in a namespace.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist\n+   * and must be returned by this discovery method. For example, if table a.b.t exists, this method\n+   * invoked as listNamespaces([\"a\"]) must return [\"a\", \"b\"] in the result array.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return an array of multi-part namespace names\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   */\n+  String[][] listNamespaces(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Test whether a namespace exists.\n+   * <p>\n+   * If an object such as a table, view, or function exists, its parent namespaces must also exist.\n+   * For example, if table a.b.t exists, this method invoked as namespaceExists([\"a\"]) or\n+   * namespaceExists([\"a\", \"b\"]) must return true.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace exists, false otherwise\n+   */\n+  default boolean namespaceExists(String[] namespace) {\n+    try {\n+      loadNamespaceMetadata(namespace);\n+      return true;\n+    } catch (NoSuchNamespaceException e) {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Load metadata properties for a namespace.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return a string map of properties for the given namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  Map<String, String> loadNamespaceMetadata(String[] namespace) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Create a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param metadata a string map of properties for the given namespace\n+   * @throws NamespaceAlreadyExistsException If the namespace already exists\n+   * @throws UnsupportedOperationException If create is not a supported operation\n+   */\n+  void createNamespaceMetadata(\n+      String[] namespace,\n+      Map<String, String> metadata) throws NamespaceAlreadyExistsException;\n+\n+  /**\n+   * Apply a set of metadata changes to a namespace in the catalog.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @param changes a collection of changes to apply to the namespace\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws UnsupportedOperationException If namespace properties are not supported\n+   */\n+  void alterNamespace(\n+      String[] namespace,\n+      NamespaceChange... changes) throws NoSuchNamespaceException;\n+\n+  /**\n+   * Drop a namespace from the catalog.\n+   * <p>\n+   * This operation may be rejected by the catalog implementation if the namespace is not empty by\n+   * throwing {@link IllegalStateException}. If the catalog implementation does not support this\n+   * operation, it may throw {@link UnsupportedOperationException}.\n+   *\n+   * @param namespace a multi-part namespace\n+   * @return true if the namespace was dropped\n+   * @throws NoSuchNamespaceException If the namespace does not exist (optional)\n+   * @throws IllegalStateException If the namespace is not empty\n+   * @throws UnsupportedOperationException If drop is not a supported operation\n+   */\n+  boolean dropNamespace(String[] namespace) throws NoSuchNamespaceException;",
    "line": 144
  }],
  "prId": 24560
}]