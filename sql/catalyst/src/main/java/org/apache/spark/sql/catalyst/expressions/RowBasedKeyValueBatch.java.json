[{
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: record length = 4 + 4 + klen + vlen + 8\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:00:59Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Let's update/add docs about why this data structure is backed by a single page.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:01:59Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up."
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: `MemoryConsumer {`\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:02:36Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "might be just okay to call them `page` and `base` for brevity. We should make it clear in the class docs about why that's the current/only page\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:03:29Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: `requiredSize`\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:03:54Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Let's also log the exception here\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:04:35Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Let's explicitly cast `recordLength` as long to prevent inadvertant overflows while multiplying 2 integers\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:05:16Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "can fold this into the line above\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:06:07Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Can we add a small comment saying that this returns the value row?\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:06:47Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "We seem to be wasting space here for fixed length. As discussed offline, let's just have the fixed length case in a different class that extends this class (or a common base class). This would significantly make it easier to reason about the 2 cases. As a side affect, we can then also set klen, vlen etc. to final for the fixed length case.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:09:07Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;"
  }, {
    "author": {
      "login": "ooq"
    },
    "body": "Sounds good. Let's do that.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:10:49Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Given that this can never spill, could we just increment and use `numRows` here?\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:10:44Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: delete extra new line\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:11:06Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: these can all be in a single line\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:12:08Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "out of curiosity, why do we need to add 4 here?\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:12:25Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Let's log this before throwing.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:13:04Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: maybe `initialized`?\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:13:35Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "Can we just subtract 4 here and above so that it's actually `totalLength` (i.e., totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage) - 4;). You would then have to make slight modifications to the code below but I think it might be less confusing to read.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T00:15:03Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;\n+\n+      private void init() {\n+        if (currentAndOnlyPage != null) {\n+          offsetInPage = currentAndOnlyPage.getBaseOffset();\n+          recordsInPage = Platform.getInt(currentAndOnlyBase, offsetInPage);\n+          offsetInPage += 4;\n+        }\n+        inited = true;\n+      }\n+\n+      @Override\n+      public boolean next() {\n+        if (!inited) init();\n+        //searching for the next non empty page is records is now zero\n+        if (recordsInPage == 0) {\n+          freeCurrentPage();\n+          return false;\n+        }\n+\n+        if (allFixedLength) {\n+          totalLength = klen + vlen + 4;\n+          currentklen = klen;\n+          currentvlen = vlen;\n+        } else {\n+          totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage);"
  }, {
    "author": {
      "login": "ooq"
    },
    "body": "Makes sense. Do you think it makes easier to do `Platform.putInt(base, offset, klen + vlen);` instead of `Platform.putInt(base, offset, klen + vlen + 4);`? I personally think the former is less confusing and I went with later to be consistent with previous implementations.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T19:04:41Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;\n+\n+      private void init() {\n+        if (currentAndOnlyPage != null) {\n+          offsetInPage = currentAndOnlyPage.getBaseOffset();\n+          recordsInPage = Platform.getInt(currentAndOnlyBase, offsetInPage);\n+          offsetInPage += 4;\n+        }\n+        inited = true;\n+      }\n+\n+      @Override\n+      public boolean next() {\n+        if (!inited) init();\n+        //searching for the next non empty page is records is now zero\n+        if (recordsInPage == 0) {\n+          freeCurrentPage();\n+          return false;\n+        }\n+\n+        if (allFixedLength) {\n+          totalLength = klen + vlen + 4;\n+          currentklen = klen;\n+          currentvlen = vlen;\n+        } else {\n+          totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage);"
  }, {
    "author": {
      "login": "sameeragarwal"
    },
    "body": "I'm not entirely sure why the bytes to bytes map used `klen + vlen + 4` in the first place, but it seemed intentional (@rxin do you know?). It could have something to do with the spilling logic in which case it should be safe to remove here. But if we don't find the reason, perhaps we can just add 4 to be consistent with the previous implementation for now and revisit this in future.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T19:13:17Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;\n+\n+      private void init() {\n+        if (currentAndOnlyPage != null) {\n+          offsetInPage = currentAndOnlyPage.getBaseOffset();\n+          recordsInPage = Platform.getInt(currentAndOnlyBase, offsetInPage);\n+          offsetInPage += 4;\n+        }\n+        inited = true;\n+      }\n+\n+      @Override\n+      public boolean next() {\n+        if (!inited) init();\n+        //searching for the next non empty page is records is now zero\n+        if (recordsInPage == 0) {\n+          freeCurrentPage();\n+          return false;\n+        }\n+\n+        if (allFixedLength) {\n+          totalLength = klen + vlen + 4;\n+          currentklen = klen;\n+          currentvlen = vlen;\n+        } else {\n+          totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage);"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "where was it doing it in the past? if there is no documentation on why we should document it.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T19:20:53Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;\n+\n+      private void init() {\n+        if (currentAndOnlyPage != null) {\n+          offsetInPage = currentAndOnlyPage.getBaseOffset();\n+          recordsInPage = Platform.getInt(currentAndOnlyBase, offsetInPage);\n+          offsetInPage += 4;\n+        }\n+        inited = true;\n+      }\n+\n+      @Override\n+      public boolean next() {\n+        if (!inited) init();\n+        //searching for the next non empty page is records is now zero\n+        if (recordsInPage == 0) {\n+          freeCurrentPage();\n+          return false;\n+        }\n+\n+        if (allFixedLength) {\n+          totalLength = klen + vlen + 4;\n+          currentklen = klen;\n+          currentvlen = vlen;\n+        } else {\n+          totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage);"
  }, {
    "author": {
      "login": "sameeragarwal"
    },
    "body": "In BytesToBytesMap [here](https://github.com/apache/spark/blob/master/core/src/main/java/org/apache/spark/unsafe/map/BytesToBytesMap.java#L55). It seems that it has to do something with being compatible with [UnsafeKVExternalSorter](https://github.com/apache/spark/blob/master/sql/core/src/main/java/org/apache/spark/sql/execution/UnsafeKVExternalSorter.java#L266-L270) but I'm not sure why the latter needs it.\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-19T19:34:17Z",
    "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+import org.apache.spark.unsafe.Platform;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. The format for each record looks like this:\n+ * [4 bytes total size = (klen + vlen + 4)] [4 bytes key size = klen]\n+ * [UnsafeRow for key of length klen] [UnsafeRow for Value of length vlen]\n+ * [8 bytes pointer to next]\n+ * Thus, record length = 8 + klen + vlen + 8\n+ *\n+ * RowBasedKeyValueBatch will automatically acquire new pages (MemoryBlock) when the current page\n+ * is used up.\n+ *\n+ * TODO: making each entry more compact, e.g., combine key and value into a single UnsafeRow\n+ */\n+public final class RowBasedKeyValueBatch extends MemoryConsumer{\n+  private static final int DEFAULT_CAPACITY = 1 << 16;\n+  private static final long DEFAULT_PAGE_SIZE = 64 * 1024 * 1024;\n+\n+  private final StructType keySchema;\n+  private final StructType valueSchema;\n+  private final int capacity;\n+  private int numRows = 0;\n+\n+  // Staging row returned from getRow.\n+  final UnsafeRow keyRow;\n+  final UnsafeRow valueRow;\n+\n+  // ids for current key row and value row being retrieved\n+  private int keyRowId = -1;\n+\n+  // full addresses for key rows and value rows\n+  private long[] keyOffsets;\n+\n+  // if all data types in the schema are fixed length\n+  private boolean allFixedLength;\n+  private int klen;\n+  private int vlen;\n+  private int recordLength;\n+\n+  private MemoryBlock currentAndOnlyPage = null;\n+  private Object currentAndOnlyBase = null;\n+  private long recordStartOffset;\n+  private long pageCursor = 0;\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, DEFAULT_CAPACITY, manager);\n+  }\n+\n+  public static RowBasedKeyValueBatch allocate(StructType keySchema, StructType valueSchema,\n+                                               TaskMemoryManager manager, int maxRows) {\n+    return new RowBasedKeyValueBatch(keySchema, valueSchema, maxRows, manager);\n+  }\n+\n+  public int numRows() { return numRows; }\n+\n+  public void close() {\n+    if (currentAndOnlyPage != null) {\n+      freePage(currentAndOnlyPage);\n+      currentAndOnlyPage = null;\n+    }\n+  }\n+\n+  private boolean acquireNewPage(long required) {\n+    try {\n+      currentAndOnlyPage = allocatePage(required);\n+    } catch (OutOfMemoryError e) {\n+      return false;\n+    }\n+    currentAndOnlyBase = currentAndOnlyPage.getBaseObject();\n+    Platform.putInt(currentAndOnlyBase, currentAndOnlyPage.getBaseOffset(), 0);\n+    pageCursor = 4;\n+    recordStartOffset = pageCursor + currentAndOnlyPage.getBaseOffset();\n+\n+    return true;\n+  }\n+\n+  private long getKeyOffsetForFixedLengthRecords(int rowId) {\n+    return recordStartOffset + rowId * recordLength + 8;\n+  }\n+\n+  public UnsafeRow appendRow(Object kbase, long koff, int klen,\n+                             Object vbase, long voff, int vlen) {\n+    final long recordLength = 8 + klen + vlen + 8;\n+    // if run out of max supported rows or page size, return null\n+    if (numRows >= capacity || currentAndOnlyPage == null\n+            || currentAndOnlyPage.size() - pageCursor < recordLength) {\n+      return null;\n+    }\n+\n+    final Object base = currentAndOnlyBase;\n+    long offset = currentAndOnlyPage.getBaseOffset() + pageCursor;\n+    final long recordOffset = offset;\n+    if (!allFixedLength) { // we only put lengths info for variable length\n+      Platform.putInt(base, offset, klen + vlen + 4);\n+      Platform.putInt(base, offset + 4, klen);\n+    }\n+    offset += 8;\n+    Platform.copyMemory(kbase, koff, base, offset, klen);\n+    offset += klen;\n+    Platform.copyMemory(vbase, voff, base, offset, vlen);\n+    offset += vlen;\n+    Platform.putLong(base, offset, 0);\n+\n+    offset = currentAndOnlyPage.getBaseOffset();\n+    Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);\n+    pageCursor += recordLength;\n+\n+\n+    if (!allFixedLength) keyOffsets[numRows] = recordOffset + 8;\n+\n+    keyRowId = numRows;\n+    keyRow.pointTo(base, recordOffset + 8, klen);\n+    valueRow.pointTo(base, recordOffset + 8 + klen, vlen + 4);\n+    numRows++;\n+    return valueRow;\n+  }\n+\n+  /**\n+   * Returns the key row in this batch at `rowId`. Returned key row is reused across calls.\n+   */\n+  public UnsafeRow getKeyRow(int rowId) {\n+    assert(rowId >= 0);\n+    assert(rowId < numRows);\n+    if (keyRowId != rowId) { // if keyRowId == rowId, desired keyRow is already cached\n+      if (allFixedLength) {\n+        long offset = getKeyOffsetForFixedLengthRecords(rowId);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      } else {\n+        long offset = keyOffsets[rowId];\n+        klen = Platform.getInt(currentAndOnlyBase, offset - 4);\n+        keyRow.pointTo(currentAndOnlyBase, offset, klen);\n+      }\n+      // set keyRowId so we can check if desired row is cached\n+      keyRowId = rowId;\n+    }\n+    return keyRow;\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  public UnsafeRow getValueRow(int rowId) {\n+    return getValueFromKey(rowId);\n+  }\n+\n+  /**\n+   * Returns the value row in this batch at `rowId`.\n+   * It can be a faster path if `keyRowId` is equal to `rowId`, which means the preceding\n+   * key row has just been accessed. This is always the case so far.\n+   * Returned value row is reused across calls.\n+   */\n+  private UnsafeRow getValueFromKey(int rowId) {\n+    if (keyRowId != rowId) {\n+      getKeyRow(rowId);\n+    }\n+    assert(rowId >= 0);\n+    if (allFixedLength) {\n+      valueRow.pointTo(currentAndOnlyBase,\n+              keyRow.getBaseOffset() + klen,\n+              vlen + 4);\n+    } else {\n+      long offset = keyOffsets[rowId];\n+      vlen = Platform.getInt(currentAndOnlyBase, offset - 8) - klen - 4;\n+      valueRow.pointTo(currentAndOnlyBase,\n+              offset + klen,\n+              vlen + 4);\n+    }\n+    return valueRow;\n+  }\n+\n+  public long spill(long size, MemoryConsumer trigger) throws IOException {\n+    throw new OutOfMemoryError(\"row batch should never spill\");\n+  }\n+\n+  /**\n+   * Returns an iterator to go through all rows\n+   */\n+  public org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow> rowIterator() {\n+    return new org.apache.spark.unsafe.KVIterator<UnsafeRow, UnsafeRow>() {\n+      private final UnsafeRow key = new UnsafeRow(keySchema.length());\n+      private final UnsafeRow value = new UnsafeRow(valueSchema.length());\n+\n+      private long offsetInPage = 0;\n+      private int recordsInPage = 0;\n+\n+      private int currentklen;\n+      private int currentvlen;\n+      private int totalLength;\n+\n+      private boolean inited = false;\n+\n+      private void init() {\n+        if (currentAndOnlyPage != null) {\n+          offsetInPage = currentAndOnlyPage.getBaseOffset();\n+          recordsInPage = Platform.getInt(currentAndOnlyBase, offsetInPage);\n+          offsetInPage += 4;\n+        }\n+        inited = true;\n+      }\n+\n+      @Override\n+      public boolean next() {\n+        if (!inited) init();\n+        //searching for the next non empty page is records is now zero\n+        if (recordsInPage == 0) {\n+          freeCurrentPage();\n+          return false;\n+        }\n+\n+        if (allFixedLength) {\n+          totalLength = klen + vlen + 4;\n+          currentklen = klen;\n+          currentvlen = vlen;\n+        } else {\n+          totalLength = Platform.getInt(currentAndOnlyBase, offsetInPage);"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "nit: fields\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-22T18:27:33Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. Each record contains one key and one value\n+ * and some auxiliary data, which differs based on implementation:\n+ * i.e., `FixedLengthRowBasedKeyValueBatch` and `VariableLengthRowBasedKeyValueBatch`.\n+ *\n+ * We use `FixedLengthRowBasedKeyValueBatch` if all fiends in the key and the value are fixed-length"
  }],
  "prId": 14174
}, {
  "comments": [{
    "author": {
      "login": "sameeragarwal"
    },
    "body": "This and `DEFAULT_PAGE_SIZE` can probably be private?\n",
    "commit": "5bd4bca5c20cd1f59436280d641c6c3a17fef290",
    "createdAt": "2016-07-22T18:28:20Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.sql.catalyst.expressions;\n+\n+import java.io.IOException;\n+\n+import org.apache.spark.memory.MemoryConsumer;\n+import org.apache.spark.memory.TaskMemoryManager;\n+import org.apache.spark.sql.types.*;\n+import org.apache.spark.unsafe.memory.MemoryBlock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * RowBasedKeyValueBatch stores key value pairs in contiguous memory region.\n+ *\n+ * Each key or value is stored as a single UnsafeRow. Each record contains one key and one value\n+ * and some auxiliary data, which differs based on implementation:\n+ * i.e., `FixedLengthRowBasedKeyValueBatch` and `VariableLengthRowBasedKeyValueBatch`.\n+ *\n+ * We use `FixedLengthRowBasedKeyValueBatch` if all fiends in the key and the value are fixed-length\n+ * data types. Otherwise we use `VariableLengthRowBasedKeyValueBatch`.\n+ *\n+ * RowBasedKeyValueBatch is backed by a single page / MemoryBlock (defaults to 64MB). If the page\n+ * is full, the aggregate logic should fallback to a second level, larger hash map. We intentionally\n+ * use the single-page design because it simplifies memory address encoding & decoding for each\n+ * key-value pair. Because the maximum capacity for RowBasedKeyValueBatch is only 2^16, it is\n+ * unlikely we need a second page anyway. Filling the page requires an average size for key value\n+ * pairs to be larger than 1024 bytes.\n+ *\n+ */\n+public abstract class RowBasedKeyValueBatch extends MemoryConsumer {\n+  protected final Logger logger = LoggerFactory.getLogger(RowBasedKeyValueBatch.class);\n+\n+  protected static final int DEFAULT_CAPACITY = 1 << 16;"
  }],
  "prId": 14174
}]