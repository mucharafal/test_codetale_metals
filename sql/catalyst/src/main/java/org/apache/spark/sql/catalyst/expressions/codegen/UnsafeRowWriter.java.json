[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Even it's fixed, we could still call `setOffsetAndSize(ordinal, 16)`, that could be more clear.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T19:34:36Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.array.ByteArrayMethods;\n+import org.apache.spark.unsafe.bitset.BitSetMethods;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeRow` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeRowWriter {\n+\n+  private GlobalBufferHolder holder;\n+  // The offset of the global buffer where we start to write this row.\n+  private int startingOffset;\n+  private int nullBitsSize;\n+\n+  public void initialize(GlobalBufferHolder holder, int numFields) {\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);\n+\n+    // grow the global buffer to make sure it has enough space to write fixed-length data.\n+    final int fixedSize = nullBitsSize + 8 * numFields;\n+    holder.grow(fixedSize);\n+    holder.cursor += fixedSize;\n+\n+    // zero-out the null bits region\n+    for (int i = 0; i < nullBitsSize; i += 8) {\n+      Platform.putLong(holder.buffer, startingOffset + i, 0L);\n+    }\n+  }\n+\n+  private void zeroOutPaddingBytes(int numBytes) {\n+    if ((numBytes & 0x07) > 0) {\n+      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);\n+    }\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);\n+  }\n+\n+  public long getFieldOffset(int ordinal) {\n+    return startingOffset + nullBitsSize + 8 * ordinal;\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long size) {\n+    setOffsetAndSize(ordinal, holder.cursor, size);\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {\n+    final long relativeOffset = currentCursor - startingOffset;\n+    final long fieldOffset = getFieldOffset(ordinal);\n+    final long offsetAndSize = (relativeOffset << 32) | size;\n+\n+    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);\n+  }\n+\n+  // Do word alignment for this row and return the number of bytes padded.\n+  // todo: remove this after we make unsafe array data word align.\n+  public void alignWords(int numBytes) {\n+    final int remainder = numBytes & 0x07;\n+\n+    if (remainder > 0) {\n+      final int paddingBytes = 8 - remainder;\n+      holder.grow(paddingBytes);\n+\n+      final byte[] orignalValues = new byte[remainder];\n+      Platform.copyMemory(\n+        holder.buffer,\n+        holder.cursor - remainder,\n+        orignalValues,\n+        Platform.BYTE_ARRAY_OFFSET,\n+        remainder);\n+\n+      Platform.putLong(holder.buffer, holder.cursor - remainder, 0);\n+\n+      Platform.copyMemory(\n+        orignalValues,\n+        Platform.BYTE_ARRAY_OFFSET,\n+        holder.buffer,\n+        holder.cursor - remainder,\n+        remainder);\n+\n+      holder.cursor += paddingBytes;\n+    }\n+  }\n+\n+\n+\n+  public void writeCompactDecimal(int ordinal, Decimal input, int precision, int scale) {\n+    // make sure Decimal object has the same scale as DecimalType\n+    if (input.changePrecision(precision, scale)) {\n+      Platform.putLong(holder.buffer, getFieldOffset(ordinal), input.toUnscaledLong());\n+    } else {\n+      setNullAt(ordinal);\n+    }\n+  }\n+\n+  public void write(int ordinal, Decimal input, int precision, int scale) {\n+    // grow the global buffer before writing data.\n+    holder.grow(16);\n+\n+    // zero-out the bytes\n+    Platform.putLong(holder.buffer, holder.cursor, 0L);\n+    Platform.putLong(holder.buffer, holder.cursor + 8, 0L);\n+\n+    // Make sure Decimal object has the same scale as DecimalType.\n+    // Note that we may pass in null Decimal object to set null for it.\n+    if (input == null || !input.changePrecision(precision, scale)) {\n+      BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+      // keep the offset for future update\n+      final long relativeOffset = holder.cursor - startingOffset;\n+      Platform.putLong(holder.buffer, getFieldOffset(ordinal), relativeOffset << 32);\n+    } else {\n+      final byte[] bytes = input.toJavaBigDecimal().unscaledValue().toByteArray();\n+      assert bytes.length <= 16;\n+\n+      // Write the bytes to the variable length portion.\n+      Platform.copyMemory(\n+        bytes, Platform.BYTE_ARRAY_OFFSET, holder.buffer, holder.cursor, bytes.length);\n+      setOffsetAndSize(ordinal, bytes.length);\n+    }\n+\n+    // move the cursor forward.\n+    holder.cursor += 16;\n+  }\n+\n+  public void write(int ordinal, UTF8String input) {\n+    final int numBytes = input.numBytes();\n+    final int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(numBytes);\n+\n+    // grow the global buffer before writing data.\n+    holder.grow(roundedSize);\n+\n+    zeroOutPaddingBytes(numBytes);\n+\n+    // Write the bytes to the variable length portion.\n+    input.writeToMemory(holder.buffer, holder.cursor);\n+\n+    setOffsetAndSize(ordinal, numBytes);\n+\n+    // move the cursor forward.\n+    holder.cursor += roundedSize;\n+  }\n+\n+  public void write(int ordinal, byte[] input) {\n+    final int numBytes = input.length;\n+    final int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(numBytes);\n+\n+    // grow the global buffer before writing data.\n+    holder.grow(roundedSize);\n+\n+    zeroOutPaddingBytes(numBytes);\n+\n+    // Write the bytes to the variable length portion.\n+    Platform.copyMemory(input, Platform.BYTE_ARRAY_OFFSET, holder.buffer, holder.cursor, numBytes);\n+\n+    setOffsetAndSize(ordinal, numBytes);\n+\n+    // move the cursor forward.\n+    holder.cursor += roundedSize;\n+  }\n+\n+  public void write(int ordinal, CalendarInterval input) {\n+    // grow the global buffer before writing data.\n+    holder.grow(16);\n+\n+    // Write the months and microseconds fields of Interval to the variable length portion.\n+    Platform.putLong(holder.buffer, holder.cursor, input.months);\n+    Platform.putLong(holder.buffer, holder.cursor + 8, input.microseconds);\n+\n+    // Set the fixed length portion, we don't need size here because it's fixed as 16."
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "alignToWords?\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T19:48:04Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.array.ByteArrayMethods;\n+import org.apache.spark.unsafe.bitset.BitSetMethods;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeRow` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeRowWriter {\n+\n+  private GlobalBufferHolder holder;\n+  // The offset of the global buffer where we start to write this row.\n+  private int startingOffset;\n+  private int nullBitsSize;\n+\n+  public void initialize(GlobalBufferHolder holder, int numFields) {\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);\n+\n+    // grow the global buffer to make sure it has enough space to write fixed-length data.\n+    final int fixedSize = nullBitsSize + 8 * numFields;\n+    holder.grow(fixedSize);\n+    holder.cursor += fixedSize;\n+\n+    // zero-out the null bits region\n+    for (int i = 0; i < nullBitsSize; i += 8) {\n+      Platform.putLong(holder.buffer, startingOffset + i, 0L);\n+    }\n+  }\n+\n+  private void zeroOutPaddingBytes(int numBytes) {\n+    if ((numBytes & 0x07) > 0) {\n+      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);\n+    }\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);\n+  }\n+\n+  public long getFieldOffset(int ordinal) {\n+    return startingOffset + nullBitsSize + 8 * ordinal;\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long size) {\n+    setOffsetAndSize(ordinal, holder.cursor, size);\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {\n+    final long relativeOffset = currentCursor - startingOffset;\n+    final long fieldOffset = getFieldOffset(ordinal);\n+    final long offsetAndSize = (relativeOffset << 32) | size;\n+\n+    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);\n+  }\n+\n+  // Do word alignment for this row and return the number of bytes padded.\n+  // todo: remove this after we make unsafe array data word align.\n+  public void alignWords(int numBytes) {"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "This could be re-used.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T19:50:44Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.array.ByteArrayMethods;\n+import org.apache.spark.unsafe.bitset.BitSetMethods;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeRow` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeRowWriter {\n+\n+  private GlobalBufferHolder holder;\n+  // The offset of the global buffer where we start to write this row.\n+  private int startingOffset;\n+  private int nullBitsSize;\n+\n+  public void initialize(GlobalBufferHolder holder, int numFields) {\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);\n+\n+    // grow the global buffer to make sure it has enough space to write fixed-length data.\n+    final int fixedSize = nullBitsSize + 8 * numFields;\n+    holder.grow(fixedSize);\n+    holder.cursor += fixedSize;\n+\n+    // zero-out the null bits region\n+    for (int i = 0; i < nullBitsSize; i += 8) {\n+      Platform.putLong(holder.buffer, startingOffset + i, 0L);\n+    }\n+  }\n+\n+  private void zeroOutPaddingBytes(int numBytes) {\n+    if ((numBytes & 0x07) > 0) {\n+      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);\n+    }\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);\n+  }\n+\n+  public long getFieldOffset(int ordinal) {\n+    return startingOffset + nullBitsSize + 8 * ordinal;\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long size) {\n+    setOffsetAndSize(ordinal, holder.cursor, size);\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {\n+    final long relativeOffset = currentCursor - startingOffset;\n+    final long fieldOffset = getFieldOffset(ordinal);\n+    final long offsetAndSize = (relativeOffset << 32) | size;\n+\n+    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);\n+  }\n+\n+  // Do word alignment for this row and return the number of bytes padded.\n+  // todo: remove this after we make unsafe array data word align.\n+  public void alignWords(int numBytes) {\n+    final int remainder = numBytes & 0x07;\n+\n+    if (remainder > 0) {\n+      final int paddingBytes = 8 - remainder;\n+      holder.grow(paddingBytes);\n+\n+      final byte[] orignalValues = new byte[remainder];"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "It's better to call `putByte(buffer, cursor, 0)` in a loop. Because there are loops in copyMemory() already.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T19:53:09Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.array.ByteArrayMethods;\n+import org.apache.spark.unsafe.bitset.BitSetMethods;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeRow` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeRowWriter {\n+\n+  private GlobalBufferHolder holder;\n+  // The offset of the global buffer where we start to write this row.\n+  private int startingOffset;\n+  private int nullBitsSize;\n+\n+  public void initialize(GlobalBufferHolder holder, int numFields) {\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);\n+\n+    // grow the global buffer to make sure it has enough space to write fixed-length data.\n+    final int fixedSize = nullBitsSize + 8 * numFields;\n+    holder.grow(fixedSize);\n+    holder.cursor += fixedSize;\n+\n+    // zero-out the null bits region\n+    for (int i = 0; i < nullBitsSize; i += 8) {\n+      Platform.putLong(holder.buffer, startingOffset + i, 0L);\n+    }\n+  }\n+\n+  private void zeroOutPaddingBytes(int numBytes) {\n+    if ((numBytes & 0x07) > 0) {\n+      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);\n+    }\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);\n+  }\n+\n+  public long getFieldOffset(int ordinal) {\n+    return startingOffset + nullBitsSize + 8 * ordinal;\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long size) {\n+    setOffsetAndSize(ordinal, holder.cursor, size);\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {\n+    final long relativeOffset = currentCursor - startingOffset;\n+    final long fieldOffset = getFieldOffset(ordinal);\n+    final long offsetAndSize = (relativeOffset << 32) | size;\n+\n+    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);\n+  }\n+\n+  // Do word alignment for this row and return the number of bytes padded.\n+  // todo: remove this after we make unsafe array data word align.\n+  public void alignWords(int numBytes) {\n+    final int remainder = numBytes & 0x07;\n+\n+    if (remainder > 0) {\n+      final int paddingBytes = 8 - remainder;\n+      holder.grow(paddingBytes);\n+\n+      final byte[] orignalValues = new byte[remainder];\n+      Platform.copyMemory(\n+        holder.buffer,\n+        holder.cursor - remainder,\n+        orignalValues,\n+        Platform.BYTE_ARRAY_OFFSET,\n+        remainder);\n+\n+      Platform.putLong(holder.buffer, holder.cursor - remainder, 0);"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "setOffsetAndSize(ordinal, 0)\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T19:55:16Z",
    "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeRow;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.array.ByteArrayMethods;\n+import org.apache.spark.unsafe.bitset.BitSetMethods;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeRow` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeRowWriter {\n+\n+  private GlobalBufferHolder holder;\n+  // The offset of the global buffer where we start to write this row.\n+  private int startingOffset;\n+  private int nullBitsSize;\n+\n+  public void initialize(GlobalBufferHolder holder, int numFields) {\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);\n+\n+    // grow the global buffer to make sure it has enough space to write fixed-length data.\n+    final int fixedSize = nullBitsSize + 8 * numFields;\n+    holder.grow(fixedSize);\n+    holder.cursor += fixedSize;\n+\n+    // zero-out the null bits region\n+    for (int i = 0; i < nullBitsSize; i += 8) {\n+      Platform.putLong(holder.buffer, startingOffset + i, 0L);\n+    }\n+  }\n+\n+  private void zeroOutPaddingBytes(int numBytes) {\n+    if ((numBytes & 0x07) > 0) {\n+      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);\n+    }\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);\n+  }\n+\n+  public long getFieldOffset(int ordinal) {\n+    return startingOffset + nullBitsSize + 8 * ordinal;\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long size) {\n+    setOffsetAndSize(ordinal, holder.cursor, size);\n+  }\n+\n+  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {\n+    final long relativeOffset = currentCursor - startingOffset;\n+    final long fieldOffset = getFieldOffset(ordinal);\n+    final long offsetAndSize = (relativeOffset << 32) | size;\n+\n+    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);\n+  }\n+\n+  // Do word alignment for this row and return the number of bytes padded.\n+  // todo: remove this after we make unsafe array data word align.\n+  public void alignWords(int numBytes) {\n+    final int remainder = numBytes & 0x07;\n+\n+    if (remainder > 0) {\n+      final int paddingBytes = 8 - remainder;\n+      holder.grow(paddingBytes);\n+\n+      final byte[] orignalValues = new byte[remainder];\n+      Platform.copyMemory(\n+        holder.buffer,\n+        holder.cursor - remainder,\n+        orignalValues,\n+        Platform.BYTE_ARRAY_OFFSET,\n+        remainder);\n+\n+      Platform.putLong(holder.buffer, holder.cursor - remainder, 0);\n+\n+      Platform.copyMemory(\n+        orignalValues,\n+        Platform.BYTE_ARRAY_OFFSET,\n+        holder.buffer,\n+        holder.cursor - remainder,\n+        remainder);\n+\n+      holder.cursor += paddingBytes;\n+    }\n+  }\n+\n+\n+\n+  public void writeCompactDecimal(int ordinal, Decimal input, int precision, int scale) {\n+    // make sure Decimal object has the same scale as DecimalType\n+    if (input.changePrecision(precision, scale)) {\n+      Platform.putLong(holder.buffer, getFieldOffset(ordinal), input.toUnscaledLong());\n+    } else {\n+      setNullAt(ordinal);\n+    }\n+  }\n+\n+  public void write(int ordinal, Decimal input, int precision, int scale) {\n+    // grow the global buffer before writing data.\n+    holder.grow(16);\n+\n+    // zero-out the bytes\n+    Platform.putLong(holder.buffer, holder.cursor, 0L);\n+    Platform.putLong(holder.buffer, holder.cursor + 8, 0L);\n+\n+    // Make sure Decimal object has the same scale as DecimalType.\n+    // Note that we may pass in null Decimal object to set null for it.\n+    if (input == null || !input.changePrecision(precision, scale)) {\n+      BitSetMethods.set(holder.buffer, startingOffset, ordinal);\n+      // keep the offset for future update\n+      final long relativeOffset = holder.cursor - startingOffset;\n+      Platform.putLong(holder.buffer, getFieldOffset(ordinal), relativeOffset << 32);"
  }],
  "prId": 8747
}]