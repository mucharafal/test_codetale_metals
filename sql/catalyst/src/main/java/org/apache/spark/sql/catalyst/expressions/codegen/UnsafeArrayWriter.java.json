[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Maybe we could move this header out of `UnsafeArrayWriter`, that could be more clear (reducing branches).\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T16:59:10Z",
    "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeArrayData;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeArrayData` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeArrayWriter {\n+\n+  private BufferHolder holder;\n+  // The offset of the global buffer where we start to write this array.\n+  private int startingOffset;\n+\n+  public void initialize(\n+      BufferHolder holder,\n+      int numElements,\n+      boolean needHeader,\n+      int fixedElementSize) {\n+\n+    // We need 4 bytes each element to store offset.\n+    final int fixedSize = 4 * numElements;\n+\n+    if (needHeader) {\n+      // If header is required, we need extra 4 bytes to store the header.\n+      holder.grow(fixedSize + 4);\n+      // Writes the number of elements into first 4 bytes;\n+      Platform.putInt(holder.buffer, holder.cursor, numElements);"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "grow() can handler `needSize` with 0, so this check is not necessary.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T17:00:26Z",
    "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeArrayData;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeArrayData` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeArrayWriter {\n+\n+  private BufferHolder holder;\n+  // The offset of the global buffer where we start to write this array.\n+  private int startingOffset;\n+\n+  public void initialize(\n+      BufferHolder holder,\n+      int numElements,\n+      boolean needHeader,\n+      int fixedElementSize) {\n+\n+    // We need 4 bytes each element to store offset.\n+    final int fixedSize = 4 * numElements;\n+\n+    if (needHeader) {\n+      // If header is required, we need extra 4 bytes to store the header.\n+      holder.grow(fixedSize + 4);\n+      // Writes the number of elements into first 4 bytes;\n+      Platform.putInt(holder.buffer, holder.cursor, numElements);\n+      holder.cursor += 4;\n+    } else {\n+      holder.grow(fixedSize);\n+    }\n+\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+\n+    holder.cursor += fixedSize;\n+\n+    // Grows the global buffer ahead for fixed size data.\n+    if (fixedElementSize > 0) {"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "remove empty lines\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T17:01:03Z",
    "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeArrayData;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeArrayData` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeArrayWriter {\n+\n+  private BufferHolder holder;\n+  // The offset of the global buffer where we start to write this array.\n+  private int startingOffset;\n+\n+  public void initialize(\n+      BufferHolder holder,\n+      int numElements,\n+      boolean needHeader,\n+      int fixedElementSize) {\n+\n+    // We need 4 bytes each element to store offset.\n+    final int fixedSize = 4 * numElements;\n+\n+    if (needHeader) {\n+      // If header is required, we need extra 4 bytes to store the header.\n+      holder.grow(fixedSize + 4);\n+      // Writes the number of elements into first 4 bytes;\n+      Platform.putInt(holder.buffer, holder.cursor, numElements);\n+      holder.cursor += 4;\n+    } else {\n+      holder.grow(fixedSize);\n+    }\n+\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+\n+    holder.cursor += fixedSize;\n+\n+    // Grows the global buffer ahead for fixed size data.\n+    if (fixedElementSize > 0) {\n+      holder.grow(fixedElementSize * numElements);\n+    }\n+  }\n+\n+  private long getElementOffset(int ordinal) {\n+    return startingOffset + 4 * ordinal;\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    final int relativeOffset = holder.cursor - startingOffset;\n+    // Writes negative offset value to represent null element.\n+    Platform.putInt(holder.buffer, getElementOffset(ordinal), -relativeOffset);\n+  }\n+\n+  public void setOffset(int ordinal) {\n+    final int relativeOffset = holder.cursor - startingOffset;\n+    Platform.putInt(holder.buffer, getElementOffset(ordinal), relativeOffset);\n+  }\n+\n+"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Same to here, it's better to move this out of this method.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T17:10:03Z",
    "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen;\n+\n+import org.apache.spark.sql.catalyst.expressions.UnsafeArrayData;\n+import org.apache.spark.sql.types.Decimal;\n+import org.apache.spark.unsafe.Platform;\n+import org.apache.spark.unsafe.types.CalendarInterval;\n+import org.apache.spark.unsafe.types.UTF8String;\n+\n+/**\n+ * A helper class to write data into global row buffer using `UnsafeArrayData` format,\n+ * used by {@link org.apache.spark.sql.catalyst.expressions.codegen.GenerateUnsafeProjection}.\n+ */\n+public class UnsafeArrayWriter {\n+\n+  private BufferHolder holder;\n+  // The offset of the global buffer where we start to write this array.\n+  private int startingOffset;\n+\n+  public void initialize(\n+      BufferHolder holder,\n+      int numElements,\n+      boolean needHeader,\n+      int fixedElementSize) {\n+\n+    // We need 4 bytes each element to store offset.\n+    final int fixedSize = 4 * numElements;\n+\n+    if (needHeader) {\n+      // If header is required, we need extra 4 bytes to store the header.\n+      holder.grow(fixedSize + 4);\n+      // Writes the number of elements into first 4 bytes;\n+      Platform.putInt(holder.buffer, holder.cursor, numElements);\n+      holder.cursor += 4;\n+    } else {\n+      holder.grow(fixedSize);\n+    }\n+\n+    this.holder = holder;\n+    this.startingOffset = holder.cursor;\n+\n+    holder.cursor += fixedSize;\n+\n+    // Grows the global buffer ahead for fixed size data.\n+    if (fixedElementSize > 0) {\n+      holder.grow(fixedElementSize * numElements);\n+    }\n+  }\n+\n+  private long getElementOffset(int ordinal) {\n+    return startingOffset + 4 * ordinal;\n+  }\n+\n+  public void setNullAt(int ordinal) {\n+    final int relativeOffset = holder.cursor - startingOffset;\n+    // Writes negative offset value to represent null element.\n+    Platform.putInt(holder.buffer, getElementOffset(ordinal), -relativeOffset);\n+  }\n+\n+  public void setOffset(int ordinal) {\n+    final int relativeOffset = holder.cursor - startingOffset;\n+    Platform.putInt(holder.buffer, getElementOffset(ordinal), relativeOffset);\n+  }\n+\n+\n+\n+  public void writeCompactDecimal(int ordinal, Decimal input, int precision, int scale) {\n+    // make sure Decimal object has the same scale as DecimalType\n+    if (input.changePrecision(precision, scale)) {\n+      Platform.putLong(holder.buffer, holder.cursor, input.toUnscaledLong());\n+      setOffset(ordinal);\n+      holder.cursor += 8;\n+    } else {\n+      setNullAt(ordinal);\n+    }\n+  }\n+\n+  public void write(int ordinal, Decimal input, int precision, int scale) {\n+    // make sure Decimal object has the same scale as DecimalType\n+    if (input.changePrecision(precision, scale)) {\n+      final byte[] bytes = input.toJavaBigDecimal().unscaledValue().toByteArray();\n+      assert bytes.length <= 16;\n+      holder.grow(bytes.length);\n+\n+      // Write the bytes to the variable length portion.\n+      Platform.copyMemory(\n+        bytes, Platform.BYTE_ARRAY_OFFSET, holder.buffer, holder.cursor, bytes.length);\n+      setOffset(ordinal);\n+      holder.cursor += bytes.length;\n+    } else {\n+      setNullAt(ordinal);\n+    }\n+  }\n+\n+  public void write(int ordinal, UTF8String input) {\n+    final int numBytes = input.numBytes();\n+\n+    // grow the global buffer before writing data.\n+    holder.grow(numBytes);\n+\n+    // Write the bytes to the variable length portion.\n+    input.writeToMemory(holder.buffer, holder.cursor);\n+\n+    setOffset(ordinal);\n+\n+    // move the cursor forward.\n+    holder.cursor += numBytes;\n+  }\n+\n+  public void write(int ordinal, byte[] input) {\n+    // grow the global buffer before writing data.\n+    holder.grow(input.length);\n+\n+    // Write the bytes to the variable length portion.\n+    Platform.copyMemory(\n+      input, Platform.BYTE_ARRAY_OFFSET, holder.buffer, holder.cursor, input.length);\n+\n+    setOffset(ordinal);\n+\n+    // move the cursor forward.\n+    holder.cursor += input.length;\n+  }\n+\n+  public void write(int ordinal, CalendarInterval input) {\n+    // grow the global buffer before writing data.\n+    holder.grow(16);\n+\n+    // Write the months and microseconds fields of Interval to the variable length portion.\n+    Platform.putLong(holder.buffer, holder.cursor, input.months);\n+    Platform.putLong(holder.buffer, holder.cursor + 8, input.microseconds);\n+\n+    setOffset(ordinal);\n+\n+    // move the cursor forward.\n+    holder.cursor += 16;\n+  }\n+\n+\n+\n+  // If this array is already an UnsafeArray, we don't need to go through all elements, we can\n+  // directly write it.\n+  public static void directWrite(\n+      BufferHolder holder,\n+      UnsafeArrayData input,\n+      boolean needHeader) {\n+    final int numBytes = input.getSizeInBytes();\n+\n+    if (needHeader) {\n+      // If header is required, we need extra 4 bytes to store the header.\n+      holder.grow(numBytes + 4);\n+      // Writes the number of elements into first 4 bytes;\n+      Platform.putInt(holder.buffer, holder.cursor, input.numElements());"
  }],
  "prId": 8747
}]