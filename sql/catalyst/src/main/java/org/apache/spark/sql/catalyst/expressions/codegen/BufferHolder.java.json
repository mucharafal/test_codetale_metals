[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "`...too big` might be a bit to vague.... Can you use something like `...exceeds the maximum number of variables (268435455).`\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-22T01:50:36Z",
    "diffHunk": "@@ -45,7 +45,12 @@ public BufferHolder(UnsafeRow row) {\n   }\n \n   public BufferHolder(UnsafeRow row, int initialSize) {\n-    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();\n+    int bitsetWidthInBytes = UnsafeRow.calculateBitSetWidthInBytes(row.numFields());\n+    if (row.numFields() > (Integer.MAX_VALUE - initialSize) / 8) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot create BufferHolder from input UnsafeRow because it is too big.\");"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`...BufferHolder from input UnsafeRow...` -> `...BufferHolder for input UnsafeRow...`\n\nWe only get the `numFields` from the unsafe row and allocate memory for it.\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-22T06:59:23Z",
    "diffHunk": "@@ -45,7 +45,12 @@ public BufferHolder(UnsafeRow row) {\n   }\n \n   public BufferHolder(UnsafeRow row, int initialSize) {\n-    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();\n+    int bitsetWidthInBytes = UnsafeRow.calculateBitSetWidthInBytes(row.numFields());\n+    if (row.numFields() > (Integer.MAX_VALUE - initialSize) / 8) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot create BufferHolder from input UnsafeRow because it is too big.\");"
  }],
  "prId": 13829
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we move this check into the if branch below? then we can just check `length * 2 <= Integer.MAX_VALUE` and others can understand it very easily as there is a `final byte[] tmp = new byte[length * 2];` next line.\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-22T07:01:52Z",
    "diffHunk": "@@ -55,6 +60,11 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE / 2 - totalSize()) {"
  }, {
    "author": {
      "login": "clockfly"
    },
    "body": "`final int length = totalSize() + neededSize;`, this can cause integer overflow, as well as `length * 2`\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-22T20:44:44Z",
    "diffHunk": "@@ -55,6 +60,11 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE / 2 - totalSize()) {"
  }],
  "prId": 13829
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I don't quite understand this, we are trying to avoid overflow of `this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();` right? Why we `- initialSize` here?\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-29T01:28:09Z",
    "diffHunk": "@@ -45,7 +45,13 @@ public BufferHolder(UnsafeRow row) {\n   }\n \n   public BufferHolder(UnsafeRow row, int initialSize) {\n-    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();\n+    int bitsetWidthInBytes = UnsafeRow.calculateBitSetWidthInBytes(row.numFields());\n+    if (row.numFields() > (Integer.MAX_VALUE - initialSize - bitsetWidthInBytes) / 8) {",
    "line": 6
  }, {
    "author": {
      "login": "clockfly"
    },
    "body": "Check line \nhttps://github.com/apache/spark/pull/13829/files#diff-e68c5a074209b9a20ee2aa42936571ceR55\n\n```\nthis.buffer = new byte[fixedSize + initialSize];\n```\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-29T06:21:39Z",
    "diffHunk": "@@ -45,7 +45,13 @@ public BufferHolder(UnsafeRow row) {\n   }\n \n   public BufferHolder(UnsafeRow row, int initialSize) {\n-    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();\n+    int bitsetWidthInBytes = UnsafeRow.calculateBitSetWidthInBytes(row.numFields());\n+    if (row.numFields() > (Integer.MAX_VALUE - initialSize - bitsetWidthInBytes) / 8) {",
    "line": 6
  }],
  "prId": 13829
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "One more thought: Can we grow the buffer to `Integer.MAX_VALUE` if we can't double its size?  Then we have another chance to continue the execution and finish it.\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-29T06:25:33Z",
    "diffHunk": "@@ -55,6 +61,11 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE / 2 - totalSize()) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot grow BufferHolder by size \" + neededSize + \" because the size after growing \" +\n+          \"exceeds size limitation \" + Integer.MAX_VALUE / 2);\n+    }\n     final int length = totalSize() + neededSize;\n     if (buffer.length < length) {\n       // This will not happen frequently, because the buffer is re-used."
  }, {
    "author": {
      "login": "clockfly"
    },
    "body": "@cloud-fan \n\nCurrently the limit for `neededSize + totalSize` is `Integer.MAX_VALUE / 2`, I don't see there is a big difference to enlarge the limit to `Integer.MAX_VALUE`.\n\n`Integer.MAX_VALUE / 2` is about 1 GB, it is quite rare for a single row to exceed this limit. \n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-29T23:55:34Z",
    "diffHunk": "@@ -55,6 +61,11 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE / 2 - totalSize()) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot grow BufferHolder by size \" + neededSize + \" because the size after growing \" +\n+          \"exceeds size limitation \" + Integer.MAX_VALUE / 2);\n+    }\n     final int length = totalSize() + neededSize;\n     if (buffer.length < length) {\n       // This will not happen frequently, because the buffer is re-used."
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think it's good to try our best to finish user's job instead of failing it. And it's not a lot of work, should be worth it, just grow the buffer to `Integer.MAX_VALUE` when `neededSize + totalSize` is between `Integer.MAX_VALUE / 2 + 1` and `Integer.MAX_VALUE`\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-30T01:13:37Z",
    "diffHunk": "@@ -55,6 +61,11 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE / 2 - totalSize()) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot grow BufferHolder by size \" + neededSize + \" because the size after growing \" +\n+          \"exceeds size limitation \" + Integer.MAX_VALUE / 2);\n+    }\n     final int length = totalSize() + neededSize;\n     if (buffer.length < length) {\n       // This will not happen frequently, because the buffer is re-used."
  }],
  "prId": 13829
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit: `Integer.MAX_VALUE /2` -> `Integer.MAX_VALUE / 2`, you missed a space...\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-30T01:45:50Z",
    "diffHunk": "@@ -55,10 +61,16 @@ public BufferHolder(UnsafeRow row, int initialSize) {\n    * Grows the buffer by at least neededSize and points the row to the buffer.\n    */\n   public void grow(int neededSize) {\n+    if (neededSize > Integer.MAX_VALUE - totalSize()) {\n+      throw new UnsupportedOperationException(\n+        \"Cannot grow BufferHolder by size \" + neededSize + \" because the size after growing \" +\n+          \"exceeds size limitation \" + Integer.MAX_VALUE);\n+    }\n     final int length = totalSize() + neededSize;\n     if (buffer.length < length) {\n       // This will not happen frequently, because the buffer is re-used.\n-      final byte[] tmp = new byte[length * 2];\n+      int newLength = length < Integer.MAX_VALUE /2 ? length * 2 : Integer.MAX_VALUE;"
  }],
  "prId": 13829
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "maybe `nullBitsLength` is a better name?\n",
    "commit": "943f7de62204af5fee228e938d293e3283f4b395",
    "createdAt": "2016-06-30T01:46:33Z",
    "diffHunk": "@@ -45,7 +45,13 @@ public BufferHolder(UnsafeRow row) {\n   }\n \n   public BufferHolder(UnsafeRow row, int initialSize) {\n-    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();\n+    int bitsetWidthInBytes = UnsafeRow.calculateBitSetWidthInBytes(row.numFields());",
    "line": 5
  }],
  "prId": 13829
}]