[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Is this a DeveloperApi for now?\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-22T01:18:56Z",
    "diffHunk": "@@ -31,6 +31,7 @@ import org.apache.spark.sql.types.StructType\n  * and reuse internal buffers to improve performance.\n  */\n trait Encoder[T] {",
    "line": 3
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Everything in `catalyst.*` is considered unstable and is excluded from the generated documentation.  So, usually we don't mark them developer API too.\n\nHowever, since this is a user facing concept, we'll need to move at least `trait Encoder[T]` before the release.  I don't know where we want to put it though, `org.apache.spark.sql`? `org.apache.spark`?\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-22T17:29:56Z",
    "diffHunk": "@@ -31,6 +31,7 @@ import org.apache.spark.sql.types.StructType\n  * and reuse internal buffers to improve performance.\n  */\n trait Encoder[T] {",
    "line": 3
  }],
  "prId": 9190
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "It would be nice if these were separate from the process of actually encoding stuff. Otherwise users that want to make custom encoders will have to do lots of work. It's not super clear at a glance what each of these APIs are for and when each will recalled (i.e. bind vs bindOrdinals vs rebind).\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-22T01:20:40Z",
    "diffHunk": "@@ -46,13 +47,27 @@ trait Encoder[T] {\n \n   /**\n    * Returns an object of type `T`, extracting the required values from the provided row.  Note that\n-   * you must bind the encoder to a specific schema before you can call this function.\n+   * you must `bind` an encoder to a specific schema before you can call this function.\n    */\n   def fromRow(row: InternalRow): T\n \n   /**\n    * Returns a new copy of this encoder, where the expressions used by `fromRow` are bound to the\n-   * given schema\n+   * given schema.\n    */\n   def bind(schema: Seq[Attribute]): Encoder[T]",
    "line": 22
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "To simplify it, maybe we can just use \"schema\" to figure out the order of field names this Encoder expects, and internally project the rows we pass to it so that they're in that order. It might be somewhat less efficient though, I guess, but it would be nice if this API was closer to being open-able because some people might like to play with it in 1.6.\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-22T01:27:09Z",
    "diffHunk": "@@ -46,13 +47,27 @@ trait Encoder[T] {\n \n   /**\n    * Returns an object of type `T`, extracting the required values from the provided row.  Note that\n-   * you must bind the encoder to a specific schema before you can call this function.\n+   * you must `bind` an encoder to a specific schema before you can call this function.\n    */\n   def fromRow(row: InternalRow): T\n \n   /**\n    * Returns a new copy of this encoder, where the expressions used by `fromRow` are bound to the\n-   * given schema\n+   * given schema.\n    */\n   def bind(schema: Seq[Attribute]): Encoder[T]",
    "line": 22
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "I agree that this is needs to be reworked.  In particular we should separate resolution from binding (as mentioned in the PR description).  The way we are doing it today allows us to do very efficient codegen (no extra copies) and correctly handles things like joins that produce ambiguous column names (since internally we are binding to AttributeReferences).\n\nGiven limited time before 1.6 code freeze, I'd rather mark the Encoder API as private and focus on fleshing out the user facing API.  I think that long term we'll do what you suggest and have a wrapper that reorders input for custom encoders, and stick with pure expressions for the built in encoders for performance reasons.\n",
    "commit": "e251f87a830df9f40d523f00bbe14c174c91b2ae",
    "createdAt": "2015-10-22T17:27:01Z",
    "diffHunk": "@@ -46,13 +47,27 @@ trait Encoder[T] {\n \n   /**\n    * Returns an object of type `T`, extracting the required values from the provided row.  Note that\n-   * you must bind the encoder to a specific schema before you can call this function.\n+   * you must `bind` an encoder to a specific schema before you can call this function.\n    */\n   def fromRow(row: InternalRow): T\n \n   /**\n    * Returns a new copy of this encoder, where the expressions used by `fromRow` are bound to the\n-   * given schema\n+   * given schema.\n    */\n   def bind(schema: Seq[Attribute]): Encoder[T]",
    "line": 22
  }],
  "prId": 9190
}]