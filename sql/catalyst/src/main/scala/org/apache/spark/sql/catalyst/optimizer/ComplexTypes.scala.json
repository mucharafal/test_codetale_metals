[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Since the constant folding covers foldable cases, we need to check if key is unfoldable? ",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-03-27T01:18:16Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I don't think so. Constant folding is executed before this, hence if the key is foldable we never get here. So the check is useless. We can add it and a comment for explaining when this case happens if you think is needed, but it'd be anyway quite clear from the history and the description of this PR...",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-03-27T08:52:38Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Since we can remove the rule thru `spark.sql.optimizer.excludedRules`, I feel we'd better to add the check. I leave it to other reviewers.",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-04-01T02:04:52Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "+1 for @maropu 's comment. Let's add `if` check or `assert` or the comment about the assumption.",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-04-01T02:33:46Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r"
  }],
  "prId": 24223
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Don't bother unless you're changing it otherwise, but `.foreach { case (kt, vt, (key, value)) =>`?\r\nIs the ListBuffer there for efficiency vs just flatMap-ing to two elements for every map element?\r\n```\r\nval result = map.flatMap { case ((kt, vt, (key, value)) => Seq(Literal(key, kt), Literal(value, vt)) }\r\n```",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-03-28T00:40:28Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r\n+        val elems = new mutable.ListBuffer[Literal]\r\n+        map.foreach(kt, vt, (key, value) => {\r",
    "line": 23
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "well, `map` is a `MapData` object, which has a `foreach`, but no `flatMap` at all, so what you are suggesting is just not feasible, unless we add the flatMap method in `MapData`, but that is an overkill IMO",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-03-28T09:13:04Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r\n+        val elems = new mutable.ListBuffer[Literal]\r\n+        map.foreach(kt, vt, (key, value) => {\r",
    "line": 23
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Ah right, disregard that.",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-03-28T14:01:30Z",
    "diffHunk": "@@ -59,6 +63,13 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) =>\r\n+        val elems = new mutable.ListBuffer[Literal]\r\n+        map.foreach(kt, vt, (key, value) => {\r",
    "line": 23
  }],
  "prId": 24223
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Why is `CaseKeyWhen` faster than `GetMapValue`? they both do a linear scan right?",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-04-03T02:31:46Z",
    "diffHunk": "@@ -59,6 +63,16 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      // The case below happens when the map is foldable, but the key is not, so ConstantFolding\r\n+      // converts the map in a Literal, but the GetMapValue is still there since the key is not\r\n+      // foldable. It cannot happen in any other case.\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) if !key.foldable =>\r\n+        val elems = new mutable.ListBuffer[Literal]\r\n+        map.foreach(kt, vt, (key, value) => {\r\n+          elems.append(Literal(key, kt))\r\n+          elems.append(Literal(value, vt))\r\n+        })\r\n+        CaseKeyWhen(key, elems.result())\r",
    "line": 27
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "and what if the map has 1 million entires? `CaseKeyWhen` will generate a lot of code which is unnecessary.",
    "commit": "ef6af618dc7923dc2ce4ca5c235c97f710757c6c",
    "createdAt": "2019-04-03T02:33:39Z",
    "diffHunk": "@@ -59,6 +63,16 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {\n           Literal(null, ga.dataType)\r\n         }\r\n       case GetMapValue(CreateMap(elems), key) => CaseKeyWhen(key, elems)\r\n+      // The case below happens when the map is foldable, but the key is not, so ConstantFolding\r\n+      // converts the map in a Literal, but the GetMapValue is still there since the key is not\r\n+      // foldable. It cannot happen in any other case.\r\n+      case GetMapValue(Literal(map: MapData, MapType(kt, vt, _)), key) if !key.foldable =>\r\n+        val elems = new mutable.ListBuffer[Literal]\r\n+        map.foreach(kt, vt, (key, value) => {\r\n+          elems.append(Literal(key, kt))\r\n+          elems.append(Literal(value, vt))\r\n+        })\r\n+        CaseKeyWhen(key, elems.result())\r",
    "line": 27
  }],
  "prId": 24223
}]