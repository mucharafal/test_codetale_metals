[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Space before `}`\n",
    "commit": "dedda56fce0f50f7d7b4f2579e279306833d6c92",
    "createdAt": "2014-10-15T00:20:54Z",
    "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.util\n+\n+import scala.collection.mutable\n+\n+import org.json4s._\n+import org.json4s.jackson.JsonMethods._\n+\n+/**\n+ * Metadata is a wrapper over Map[String, Any] that limits the value type to simple ones: Boolean,\n+ * Long, Double, String, Metadata, Array[Boolean], Array[Long], Array[Double], Array[String], and\n+ * Array[Metadata]. JSON is used for serialization.\n+ *\n+ * The default constructor is private. User should use either [[MetadataBuilder]] or\n+ * [[Metadata$#fromJson]] to create Metadata instances.\n+ *\n+ * @param map an immutable map that stores the data\n+ */\n+sealed class Metadata private[util] (private[util] val map: Map[String, Any]) extends Serializable {\n+\n+  /** Gets a Long. */\n+  def getLong(key: String): Long = get(key)\n+\n+  /** Gets a Double. */\n+  def getDouble(key: String): Double = get(key)\n+\n+  /** Gets a Boolean. */\n+  def getBoolean(key: String): Boolean = get(key)\n+\n+  /** Gets a String. */\n+  def getString(key: String): String = get(key)\n+\n+  /** Gets a Metadata. */\n+  def getMetadata(key: String): Metadata = get(key)\n+\n+  /** Gets a Long array. */\n+  def getLongArray(key: String): Array[Long] = get(key)\n+\n+  /** Gets a Double array. */\n+  def getDoubleArray(key: String): Array[Double] = get(key)\n+\n+  /** Gets a Boolean array. */\n+  def getBooleanArray(key: String): Array[Boolean] = get(key)\n+\n+  /** Gets a String array. */\n+  def getStringArray(key: String): Array[String] = get(key)\n+\n+  /** Gets a Metadata array. */\n+  def getMetadataArray(key: String): Array[Metadata] = get(key)\n+\n+  /** Converts to its JSON representation. */\n+  def json: String = compact(render(jsonValue))\n+\n+  override def toString: String = json\n+\n+  override def equals(obj: Any): Boolean = {\n+    obj match {\n+      case that: Metadata =>\n+        if (map.keySet == that.map.keySet) {\n+          map.keys.forall { k =>\n+            (map(k), that.map(k)) match {\n+              case (v0: Array[_], v1: Array[_]) =>\n+                v0.view == v1.view\n+              case (v0, v1) =>\n+                v0 == v1\n+            }\n+          }\n+        } else {\n+          false\n+        }\n+      case other =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = Metadata.hash(this)\n+\n+  private def get[T](key: String): T = {\n+    map(key).asInstanceOf[T]\n+  }\n+\n+  private[sql] def jsonValue: JValue = Metadata.toJsonValue(this)\n+}\n+\n+object Metadata {\n+\n+  /** Returns an empty Metadata. */\n+  def empty: Metadata = new Metadata(Map.empty)\n+\n+  /** Creates a Metadata instance from JSON. */\n+  def fromJson(json: String): Metadata = {\n+    fromJObject(parse(json).asInstanceOf[JObject])\n+  }\n+\n+  /** Creates a Metadata instance from JSON AST. */\n+  private[sql] def fromJObject(jObj: JObject): Metadata = {\n+    val builder = new MetadataBuilder\n+    jObj.obj.foreach {\n+      case (key, JInt(value)) =>\n+        builder.putLong(key, value.toLong)\n+      case (key, JDouble(value)) =>\n+        builder.putDouble(key, value)\n+      case (key, JBool(value)) =>\n+        builder.putBoolean(key, value)\n+      case (key, JString(value)) =>\n+        builder.putString(key, value)\n+      case (key, o: JObject) =>\n+        builder.putMetadata(key, fromJObject(o))\n+      case (key, JArray(value)) =>\n+        if (value.isEmpty) {\n+          // If it is an empty array, we cannot infer its element type. We put an empty Array[Long].\n+          builder.putLongArray(key, Array.empty)\n+        } else {\n+          value.head match {\n+            case _: JInt =>\n+              builder.putLongArray(key, value.asInstanceOf[List[JInt]].map(_.num.toLong).toArray)\n+            case _: JDouble =>\n+              builder.putDoubleArray(key, value.asInstanceOf[List[JDouble]].map(_.num).toArray)\n+            case _: JBool =>\n+              builder.putBooleanArray(key, value.asInstanceOf[List[JBool]].map(_.value).toArray)\n+            case _: JString =>\n+              builder.putStringArray(key, value.asInstanceOf[List[JString]].map(_.s).toArray)\n+            case _: JObject =>\n+              builder.putMetadataArray(\n+                key, value.asInstanceOf[List[JObject]].map(fromJObject).toArray)\n+            case other =>\n+              throw new RuntimeException(s\"Do not support array of type ${other.getClass}.\")\n+          }\n+        }\n+      case other =>\n+        throw new RuntimeException(s\"Do not support type ${other.getClass}.\")\n+    }\n+    builder.build()\n+  }\n+\n+  /** Converts to JSON AST. */\n+  private def toJsonValue(obj: Any): JValue = {\n+    obj match {\n+      case map: Map[_, _] =>\n+        val fields = map.toList.map { case (k: String, v) => (k, toJsonValue(v))}"
  }],
  "prId": 2701
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Do we want to use `Array` or `Seq` here?  I always find the variance semantics of using `Array` to be kind of confusing and so usually prefer `Seq` unless the space/performance is critical.\n",
    "commit": "dedda56fce0f50f7d7b4f2579e279306833d6c92",
    "createdAt": "2014-10-20T23:38:20Z",
    "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.util\n+\n+import scala.collection.mutable\n+\n+import org.json4s._\n+import org.json4s.jackson.JsonMethods._\n+\n+/**\n+ * Metadata is a wrapper over Map[String, Any] that limits the value type to simple ones: Boolean,\n+ * Long, Double, String, Metadata, Array[Boolean], Array[Long], Array[Double], Array[String], and",
    "line": 27
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "This is easy for Java users and mirroring the API for Python. Array of primitive types is also more memory-efficient that Seq.\n",
    "commit": "dedda56fce0f50f7d7b4f2579e279306833d6c92",
    "createdAt": "2014-10-21T01:40:34Z",
    "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.util\n+\n+import scala.collection.mutable\n+\n+import org.json4s._\n+import org.json4s.jackson.JsonMethods._\n+\n+/**\n+ * Metadata is a wrapper over Map[String, Any] that limits the value type to simple ones: Boolean,\n+ * Long, Double, String, Metadata, Array[Boolean], Array[Long], Array[Double], Array[String], and",
    "line": 27
  }],
  "prId": 2701
}]