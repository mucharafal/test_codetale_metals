[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Just to briefly clarify, I guess that the problem was that `AtLeastNNulls` also dropped `NaNs` but that we can't do that since it would lead to a violation of our NaN-equality semantics when joining on float/double columns?\n",
    "commit": "c02fc3f4179df860ebb8c24614247c016c3603e6",
    "createdAt": "2015-07-30T23:14:05Z",
    "diffHunk": "@@ -210,14 +210,58 @@ case class IsNotNull(child: Expression) extends UnaryExpression with Predicate {\n   }\n }\n \n+/**\n+ * A predicate that is evaluated to be true if there are at least `n` null values.\n+ */\n+case class AtLeastNNulls(n: Int, children: Seq[Expression]) extends Predicate {",
    "line": 7
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Yeah. Because `null` means `Unknown`, so when you have a predicate `null = null`, the result is false (meaning `Unknown`). But for `NaN`, in our current semantic, two `NaN` are equal.\n",
    "commit": "c02fc3f4179df860ebb8c24614247c016c3603e6",
    "createdAt": "2015-07-31T18:36:21Z",
    "diffHunk": "@@ -210,14 +210,58 @@ case class IsNotNull(child: Expression) extends UnaryExpression with Predicate {\n   }\n }\n \n+/**\n+ * A predicate that is evaluated to be true if there are at least `n` null values.\n+ */\n+case class AtLeastNNulls(n: Int, children: Seq[Expression]) extends Predicate {",
    "line": 7
  }],
  "prId": 7768
}]