[{
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "nit: remove `|`.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T00:57:56Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "We still need to support 2 arguments. Please add a constructor `def this(str: Expression, pattern: Expression)`.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T00:59:32Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "For test coverage, better to add tests in `string-functions.sql`  for the two cases: two arguments and three arguments.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T01:16:21Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@maropu which tests use `string-functions.sql`? would like to add tests here but not sure how to explicitly kick off the test as there are no `*Suites` which use this file it seems.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-27T18:00:34Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "^ ignore this! found it @maropu ",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-27T18:09:34Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Can you refine the description and the format along with the others, e.g., `RLike`\r\nhttps://github.com/apache/spark/blob/ceb3f41238c8731606164cea5c45a0b87bb5d6f2/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/regexpExpressions.scala#L78",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T01:03:38Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "hmm, is it possible to make this usage more compact? I think the usage here should be concise.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T01:21:58Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\","
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@viirya i'll take a crack at it -- the usage is a bit funky given the different behavior based on what `limit` is, I wanted to err on the side of verbose",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-27T14:03:01Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\","
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I think it is better to keep original example for default value.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T01:22:48Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);",
    "line": 36
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I think we still need to do some check on `limit`. According to Presto document, `limit` must be a positive number. -1 is only used when no `limit` parameter is given (default value).",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-25T01:25:51Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: pattern :: limit :: Nil\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {",
    "line": 57
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@viirya the underlying implementation of this method is `Java.lang.String`, correct? This method does allow non-positive values for limit, not sure what Presto is using. ",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-27T13:39:07Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +\n+    \"therefore affects the length of the resulting array. If the limit n is \" +\n+    \"greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"non-positive then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\",\n   examples = \"\"\"\n     Examples:\n-      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n        [\"one\",\"two\",\"three\",\"\"]\n+|      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+ |       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, pattern: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: pattern :: limit :: Nil\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {",
    "line": 57
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can we be more concise? e.g. presto's doc is just\r\n\r\n\"Splits string on delimiter and returns an array of size at most limit. The last element in the array always contain everything left in the string. limit must be a positive number.\"",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-26T06:05:01Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "you should say if limit is ignored if it is a non-positive number.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-26T06:05:58Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@rxin the underlying implementation of this method is Java.lang.String, correct? This method does allow non-positive values for `limit`, not sure what Presto is using. The text I've put here corresponds with the definition (rather long) from Java.lang.String.\r\n\r\n",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-27T13:38:16Z",
    "diffHunk": "@@ -232,30 +232,41 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied and \" +"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "+1 for https://github.com/apache/spark/pull/22227#discussion_r212815685. The doc should better be concise.\r\n\r\nCan we just move those `limit` specific description into the arguments at `limit - a..`? This looks a bit messy.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-28T03:41:39Z",
    "diffHunk": "@@ -232,30 +232,49 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied. If the limit \" +\n+    \"n is greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"less than 0, then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\","
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "will do!",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-28T13:40:32Z",
    "diffHunk": "@@ -232,30 +232,49 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n  * Splits str around pat (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`.\" +\n+    \"The `limit` parameter controls the number of times the pattern is applied. If the limit \" +\n+    \"n is greater than zero then the pattern will be applied at most n - 1 times, \" +\n+    \"the array's length will be no greater than n, and the array's last entry \" +\n+    \"will contain all input beyond the last matched delimiter. If n is \" +\n+    \"less than 0, then the pattern will be applied as many times as \" +\n+    \"possible and the array can have any length. If n is zero then the \" +\n+    \"pattern will be applied as many times as possible, the array can \" +\n+    \"have any length, and trailing empty strings will be discarded.\","
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Add the netative case?",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T03:57:20Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * pattern - a string representing a regular expression. The pattern string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the pattern is applied.\n+\n+        limit > 0:\n+          The resulting array's length will not be more than `limit`, and the resulting array's\n+          last entry will contain all input beyond the last matched pattern.\n+\n+        limit < 0:\n+          `pattern` will be applied as many times as possible, and the resulting\n+          array can be of any size.\n+\n+        limit = 0:\n+          `pattern` will be applied as many times as possible, the resulting array can\n+          be of any size, and trailing empty strings will be discarded.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+|     > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 0);\n+       [\"one\",\"two\",\"three\"]\n+|     > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]",
    "line": 39
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "pattern? regex? we should use a consisntent word.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T04:00:07Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression)."
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "going to switch to `regex`, makes more sense given that with the use of `pattern` we always have to define it as a regex",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T21:42:19Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression)."
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "drop `|`",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T04:12:52Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * pattern - a string representing a regular expression. The pattern string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the pattern is applied.\n+\n+        limit > 0:\n+          The resulting array's length will not be more than `limit`, and the resulting array's\n+          last entry will contain all input beyond the last matched pattern.\n+\n+        limit < 0:\n+          `pattern` will be applied as many times as possible, and the resulting\n+          array can be of any size.\n+\n+        limit = 0:\n+          `pattern` will be applied as many times as possible, the resulting array can\n+          be of any size, and trailing empty strings will be discarded.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+|     > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 0);"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "ditto",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T04:13:00Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * pattern - a string representing a regular expression. The pattern string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the pattern is applied.\n+\n+        limit > 0:\n+          The resulting array's length will not be more than `limit`, and the resulting array's\n+          last entry will contain all input beyond the last matched pattern.\n+\n+        limit < 0:\n+          `pattern` will be applied as many times as possible, and the resulting\n+          array can be of any size.\n+\n+        limit = 0:\n+          `pattern` will be applied as many times as possible, the resulting array can\n+          be of any size, and trailing empty strings will be discarded.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+|     > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 0);\n+       [\"one\",\"two\",\"three\"]\n+|     > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about this formatting?;\r\n```\r\n\r\n function_desc | Extended Usage:\r\n    Arguments:\r\n      * str - a string expression to split.\r\n      * pattern - a string representing a regular expression. The pattern string should be a\r\n        Java regular expression.\r\n      * limit - an integer expression which controls the number of times the pattern is applied.\r\n\r\n        limit > 0: The resulting array's length will not be more than `limit`, and the resulting array's\r\n                   last entry will contain all input beyond the last matched pattern.\r\n        limit < 0: `pattern` will be applied as many times as possible, and the resulting\r\n                   array can be of any size.\r\n        limit = 0: `pattern` will be applied as many times as possible, the resulting array can\r\n                   be of any size, and trailing empty strings will be discarded.\r\n  \r\n    Examples:\r\n      > SELECT split('oneAtwoBthreeC', '[ABC]');\r\n       [\"one\",\"two\",\"three\",\"\"]\r\n      > SELECT split('oneAtwoBthreeC', '[ABC]', 0);\r\n       [\"one\",\"two\",\"three\"]\r\n      > SELECT split('oneAtwoBthreeC', '[ABC]', 2);\r\n       [\"one\",\"twoBthreeC\"]\r\n```",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-29T04:19:54Z",
    "diffHunk": "@@ -229,33 +229,59 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around pattern (pattern is a regular expression).\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * pattern - a string representing a regular expression. The pattern string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the pattern is applied.\n+\n+        limit > 0:\n+          The resulting array's length will not be more than `limit`, and the resulting array's\n+          last entry will contain all input beyond the last matched pattern.\n+\n+        limit < 0:\n+          `pattern` will be applied as many times as possible, and the resulting\n+          array can be of any size.\n+\n+        limit = 0:\n+          `pattern` will be applied as many times as possible, the resulting array can\n+          be of any size, and trailing empty strings will be discarded.\n+  \"\"\",",
    "line": 31
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "why do we want to build into split to remove trailing empty strings?",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-30T18:15:37Z",
    "diffHunk": "@@ -229,33 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`, and the resulting\n+                   array's last entry will contain all input beyond the last matched regex.\n+\n+        limit < 0: `regex` will be applied as many times as possible, and the resulting\n+                   array can be of any size.\n+\n+        limit = 0: `regex` will be applied as many times as possible, the resulting array can"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@rxin this is default behavior for java lang string's `split` implementation. https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split(java.lang.String,%20int), nothing has been specifically built into it here.\r\n\r\n",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-30T18:26:41Z",
    "diffHunk": "@@ -229,33 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`, and the resulting\n+                   array's last entry will contain all input beyond the last matched regex.\n+\n+        limit < 0: `regex` will be applied as many times as possible, and the resulting\n+                   array can be of any size.\n+\n+        limit = 0: `regex` will be applied as many times as possible, the resulting array can"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "yea but i'd focus on what behavior we want to enable. do other database systems have this split=0 semantics? if not, i'd rewrite split=0 internally to just -1.\r\n",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-30T18:28:24Z",
    "diffHunk": "@@ -229,33 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`, and the resulting\n+                   array's last entry will contain all input beyond the last matched regex.\n+\n+        limit < 0: `regex` will be applied as many times as possible, and the resulting\n+                   array can be of any size.\n+\n+        limit = 0: `regex` will be applied as many times as possible, the resulting array can"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "I see this as a value-add in that the user just gets more ammunition to answer a given question about his/her data. Sure, it's not necessary to have the `limit = 0` case, but if a user can get what they need by writing fewer lines of code because it exists I'd say it's definitely worth exposing.\r\n\r\n",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-30T20:13:30Z",
    "diffHunk": "@@ -229,33 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`, and the resulting\n+                   array's last entry will contain all input beyond the last matched regex.\n+\n+        limit < 0: `regex` will be applied as many times as possible, and the resulting\n+                   array can be of any size.\n+\n+        limit = 0: `regex` will be applied as many times as possible, the resulting array can"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "To make all the split behaviour consistent in Spark, how about trying to fix code in `UTF8String.split` directly? (We need to check if the change does not break the existing behaviour, too) cc: @ueshin @HyukjinKwon ",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-31T22:51:01Z",
    "diffHunk": "@@ -229,36 +229,74 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n+       [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, regex: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: regex :: limit :: Nil\n+\n+  def this(exp: Expression, regex: Expression) = this(exp, regex, Literal(-1));\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {\n+    val strings = string.asInstanceOf[UTF8String].split(\n+      regex.asInstanceOf[UTF8String], maybeFallbackLimitValue(limit.asInstanceOf[Int]))\n     new GenericArrayData(strings.asInstanceOf[Array[Any]])\n   }\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     val arrayClass = classOf[GenericArrayData].getName\n-    nullSafeCodeGen(ctx, ev, (str, pattern) =>\n+    nullSafeCodeGen(ctx, ev, (str, regex, limit) => {\n       // Array in java is covariant, so we don't need to cast UTF8String[] to Object[].\n-      s\"\"\"${ev.value} = new $arrayClass($str.split($pattern, -1));\"\"\")\n+      s\"\"\"${ev.value} = new $arrayClass($str.split(\n+         $regex,${handleCodeGenLimitFallback(limit)}));\"\"\".stripMargin\n+    })\n   }\n \n   override def prettyName: String = \"split\"\n+\n+  /**\n+   * Java String's split method supports \"ignore empty string\" behavior when the limit is 0.\n+   * To avoid this, we fall back to -1 when the limit is 0. Otherwise, this is a noop.\n+   */\n+  def maybeFallbackLimitValue(limit: Int): Int = {"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "+1, and please add `limit = 0` case in `UTF8StringSuite`.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-08-31T23:58:20Z",
    "diffHunk": "@@ -229,36 +229,74 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n+       [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, regex: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: regex :: limit :: Nil\n+\n+  def this(exp: Expression, regex: Expression) = this(exp, regex, Literal(-1));\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {\n+    val strings = string.asInstanceOf[UTF8String].split(\n+      regex.asInstanceOf[UTF8String], maybeFallbackLimitValue(limit.asInstanceOf[Int]))\n     new GenericArrayData(strings.asInstanceOf[Array[Any]])\n   }\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     val arrayClass = classOf[GenericArrayData].getName\n-    nullSafeCodeGen(ctx, ev, (str, pattern) =>\n+    nullSafeCodeGen(ctx, ev, (str, regex, limit) => {\n       // Array in java is covariant, so we don't need to cast UTF8String[] to Object[].\n-      s\"\"\"${ev.value} = new $arrayClass($str.split($pattern, -1));\"\"\")\n+      s\"\"\"${ev.value} = new $arrayClass($str.split(\n+         $regex,${handleCodeGenLimitFallback(limit)}));\"\"\".stripMargin\n+    })\n   }\n \n   override def prettyName: String = \"split\"\n+\n+  /**\n+   * Java String's split method supports \"ignore empty string\" behavior when the limit is 0.\n+   * To avoid this, we fall back to -1 when the limit is 0. Otherwise, this is a noop.\n+   */\n+  def maybeFallbackLimitValue(limit: Int): Int = {"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "done!",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-01T15:36:31Z",
    "diffHunk": "@@ -229,36 +229,74 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n+       [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, regex: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: regex :: limit :: Nil\n+\n+  def this(exp: Expression, regex: Expression) = this(exp, regex, Literal(-1));\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {\n+    val strings = string.asInstanceOf[UTF8String].split(\n+      regex.asInstanceOf[UTF8String], maybeFallbackLimitValue(limit.asInstanceOf[Int]))\n     new GenericArrayData(strings.asInstanceOf[Array[Any]])\n   }\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     val arrayClass = classOf[GenericArrayData].getName\n-    nullSafeCodeGen(ctx, ev, (str, pattern) =>\n+    nullSafeCodeGen(ctx, ev, (str, regex, limit) => {\n       // Array in java is covariant, so we don't need to cast UTF8String[] to Object[].\n-      s\"\"\"${ev.value} = new $arrayClass($str.split($pattern, -1));\"\"\")\n+      s\"\"\"${ev.value} = new $arrayClass($str.split(\n+         $regex,${handleCodeGenLimitFallback(limit)}));\"\"\".stripMargin\n+    })\n   }\n \n   override def prettyName: String = \"split\"\n+\n+  /**\n+   * Java String's split method supports \"ignore empty string\" behavior when the limit is 0.\n+   * To avoid this, we fall back to -1 when the limit is 0. Otherwise, this is a noop.\n+   */\n+  def maybeFallbackLimitValue(limit: Int): Int = {"
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "done!",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-01T15:39:42Z",
    "diffHunk": "@@ -229,36 +229,74 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n+       [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, regex: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: regex :: limit :: Nil\n+\n+  def this(exp: Expression, regex: Expression) = this(exp, regex, Literal(-1));\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {\n+    val strings = string.asInstanceOf[UTF8String].split(\n+      regex.asInstanceOf[UTF8String], maybeFallbackLimitValue(limit.asInstanceOf[Int]))\n     new GenericArrayData(strings.asInstanceOf[Array[Any]])\n   }\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     val arrayClass = classOf[GenericArrayData].getName\n-    nullSafeCodeGen(ctx, ev, (str, pattern) =>\n+    nullSafeCodeGen(ctx, ev, (str, regex, limit) => {\n       // Array in java is covariant, so we don't need to cast UTF8String[] to Object[].\n-      s\"\"\"${ev.value} = new $arrayClass($str.split($pattern, -1));\"\"\")\n+      s\"\"\"${ev.value} = new $arrayClass($str.split(\n+         $regex,${handleCodeGenLimitFallback(limit)}));\"\"\".stripMargin\n+    })\n   }\n \n   override def prettyName: String = \"split\"\n+\n+  /**\n+   * Java String's split method supports \"ignore empty string\" behavior when the limit is 0.\n+   * To avoid this, we fall back to -1 when the limit is 0. Otherwise, this is a noop.\n+   */\n+  def maybeFallbackLimitValue(limit: Int): Int = {"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Not a big deal but let's revert unrelated newline change.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-03T01:51:14Z",
    "diffHunk": "@@ -229,36 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size.\n+  \"\"\",\n   examples = \"\"\"\n     Examples:\n       > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]');\n        [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', -1);\n+       [\"one\",\"two\",\"three\",\"\"]\n+      > SELECT _FUNC_('oneAtwoBthreeC', '[ABC]', 2);\n+       [\"one\",\"twoBthreeC\"]\n   \"\"\")\n-case class StringSplit(str: Expression, pattern: Expression)\n-  extends BinaryExpression with ImplicitCastInputTypes {\n+case class StringSplit(str: Expression, regex: Expression, limit: Expression)\n+  extends TernaryExpression with ImplicitCastInputTypes {\n \n-  override def left: Expression = str\n-  override def right: Expression = pattern\n   override def dataType: DataType = ArrayType(StringType)\n-  override def inputTypes: Seq[DataType] = Seq(StringType, StringType)\n+  override def inputTypes: Seq[DataType] = Seq(StringType, StringType, IntegerType)\n+  override def children: Seq[Expression] = str :: regex :: limit :: Nil\n+\n+  def this(exp: Expression, regex: Expression) = this(exp, regex, Literal(-1));\n \n-  override def nullSafeEval(string: Any, regex: Any): Any = {\n-    val strings = string.asInstanceOf[UTF8String].split(regex.asInstanceOf[UTF8String], -1)\n+  override def nullSafeEval(string: Any, regex: Any, limit: Any): Any = {\n+    val strings = string.asInstanceOf[UTF8String].split(\n+      regex.asInstanceOf[UTF8String], limit.asInstanceOf[Int])\n     new GenericArrayData(strings.asInstanceOf[Array[Any]])\n   }\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     val arrayClass = classOf[GenericArrayData].getName\n-    nullSafeCodeGen(ctx, ev, (str, pattern) =>\n+    nullSafeCodeGen(ctx, ev, (str, regex, limit) => {\n       // Array in java is covariant, so we don't need to cast UTF8String[] to Object[].\n-      s\"\"\"${ev.value} = new $arrayClass($str.split($pattern, -1));\"\"\")\n+      s\"\"\"${ev.value} = new $arrayClass($str.split($regex,$limit));\"\"\".stripMargin\n+    })\n   }\n \n   override def prettyName: String = \"split\"\n+"
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I would do this:\r\n\r\n```\r\n        * limit > 0: The resulting array's length will not be more than `limit`,\r\n           and the resulting array's last entry will contain all input\r\n           beyond the last matched regex.\r\n        * limit <= 0: `regex` will be applied as many times as possible, and\r\n           the resulting array can be of any size.\r\n```\r\n\r\nThis is just markdown rendered by mkdocs; so probably, it's better to make it consistent with other docs.",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-03T01:54:17Z",
    "diffHunk": "@@ -229,36 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size."
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Current bullt doc is:\r\n\r\n![screen shot 2018-09-03 at 10 04 46 am](https://user-images.githubusercontent.com/6477701/44964013-e47e3e00-af60-11e8-975a-41d5dc5f1e6e.png)\r\n\r\nwhich doesn;t look quite nice. Please verify the output by referring https://github.com/apache/spark/tree/master/docs",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-03T02:06:01Z",
    "diffHunk": "@@ -229,36 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size."
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "@HyukjinKwon sorry, but where can I get the markdown output of the `regexExpressions.scala`? When I run unidoc, I'm only seeing the html corresponding to python, java, r (and these are from the functions, not from `regexExpressions.scala`.\r\n\r\nI'm running \r\n```\r\nbuild/sbt unidoc\r\n```",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-06T15:59:07Z",
    "diffHunk": "@@ -229,36 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size."
  }, {
    "author": {
      "login": "phegstrom"
    },
    "body": "got it, nvm",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-06T17:07:08Z",
    "diffHunk": "@@ -229,36 +229,58 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+\n+        limit > 0: The resulting array's length will not be more than `limit`,\n+                   and the resulting array's last entry will contain all input\n+                   beyond the last matched regex.\n+        limit <= 0: `regex` will be applied as many times as possible, and\n+                    the resulting array can be of any size."
  }],
  "prId": 22227
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "indentation:\r\n\r\n```\r\n* limit > 0: The resulting array's length will not be more than `limit`,\r\n  and the resulting array's last entry will contain all input\r\n  beyond the last matched regex.\r\n```",
    "commit": "34ba74f79aad2a0e2fe9e0d6f6110a10a51c8108",
    "createdAt": "2018-09-13T23:26:15Z",
    "diffHunk": "@@ -229,33 +229,53 @@ case class RLike(left: Expression, right: Expression) extends StringRegexExpress\n \n \n /**\n- * Splits str around pat (pattern is a regular expression).\n+ * Splits str around matches of the given regex.\n  */\n @ExpressionDescription(\n-  usage = \"_FUNC_(str, regex) - Splits `str` around occurrences that match `regex`.\",\n+  usage = \"_FUNC_(str, regex, limit) - Splits `str` around occurrences that match `regex`\" +\n+    \" and returns an array with a length of at most `limit`\",\n+  arguments = \"\"\"\n+    Arguments:\n+      * str - a string expression to split.\n+      * regex - a string representing a regular expression. The regex string should be a\n+        Java regular expression.\n+      * limit - an integer expression which controls the number of times the regex is applied.\n+          * limit > 0: The resulting array's length will not be more than `limit`,\n+                     and the resulting array's last entry will contain all input\n+                     beyond the last matched regex."
  }],
  "prId": 22227
}]