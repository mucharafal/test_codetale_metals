[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "At here, `deltaX` means `currentValue - previousAvg`, right? If so, because we have already updated `currentAvg`, `deltaX` means `currentValue - updatedAvg`.\n",
    "commit": "a170f433cd9d8304212b5d3aae66cc8aff7df12d",
    "createdAt": "2015-08-09T20:51:14Z",
    "diffHunk": "@@ -302,3 +302,87 @@ case class Sum(child: Expression) extends AlgebraicAggregate {\n \n   override val evaluateExpression = Cast(currentSum, resultType)\n }\n+\n+/**\n+ * Calculates the unbiased Standard Deviation using the online formula here:\n+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n+ */\n+case class StandardDeviation(child: Expression) extends AlgebraicAggregate {\n+\n+  override def children: Seq[Expression] = child :: Nil\n+\n+  override def nullable: Boolean = true\n+\n+  // Return data type.\n+  override def dataType: DataType = resultType\n+\n+  // Expected input data type.\n+  override def inputTypes: Seq[AbstractDataType] = Seq(TypeCollection(NumericType, NullType))\n+\n+  private lazy val resultType = child.dataType match {\n+    case DecimalType.Fixed(p, s) =>\n+      DecimalType.bounded(p + 4, s + 4)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val sumDataType = child.dataType match {\n+    case _ @ DecimalType.Fixed(p, s) => DecimalType.bounded(p + 10, s)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val currentCount = AttributeReference(\"currentCount\", LongType)()\n+  private lazy val currentAvg = AttributeReference(\"currentAverage\", sumDataType)()\n+  private lazy val currentMk = AttributeReference(\"currentMoment\", sumDataType)()\n+\n+  // the values should be updated in a special order, because they re-use each other\n+  override lazy val bufferAttributes = currentCount :: currentAvg :: currentMk :: Nil\n+\n+  override lazy val initialValues = Seq(\n+    /* currentCount = */ Literal(0L),\n+    /* currentAvg = */ Cast(Literal(0), sumDataType),\n+    /* currentMk = */ Cast(Literal(0), sumDataType)\n+  )\n+\n+  override lazy val updateExpressions = {\n+    val currentValue = Coalesce(Cast(child, sumDataType) :: Cast(Literal(0), sumDataType) :: Nil)\n+    val deltaX = Subtract(currentValue, currentAvg)\n+    val updatedCount = If(IsNull(child), currentCount, currentCount + 1L)\n+    val updatedAvg = Add(currentAvg, Divide(deltaX, updatedCount))\n+    Seq(\n+      /* currentCount = */ updatedCount,\n+      /* currentAvg = */ If(IsNull(child), currentAvg, updatedAvg),\n+      /* currentMk = */ If(IsNull(child),\n+        currentMk, Add(currentMk, deltaX * Subtract(currentValue, updatedAvg)))"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "For now, maybe we can add a `deltaX` field in the buffer to let you store the value of `currentValue - previousAvg` to workaround the problem.\n",
    "commit": "a170f433cd9d8304212b5d3aae66cc8aff7df12d",
    "createdAt": "2015-08-09T20:55:22Z",
    "diffHunk": "@@ -302,3 +302,87 @@ case class Sum(child: Expression) extends AlgebraicAggregate {\n \n   override val evaluateExpression = Cast(currentSum, resultType)\n }\n+\n+/**\n+ * Calculates the unbiased Standard Deviation using the online formula here:\n+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n+ */\n+case class StandardDeviation(child: Expression) extends AlgebraicAggregate {\n+\n+  override def children: Seq[Expression] = child :: Nil\n+\n+  override def nullable: Boolean = true\n+\n+  // Return data type.\n+  override def dataType: DataType = resultType\n+\n+  // Expected input data type.\n+  override def inputTypes: Seq[AbstractDataType] = Seq(TypeCollection(NumericType, NullType))\n+\n+  private lazy val resultType = child.dataType match {\n+    case DecimalType.Fixed(p, s) =>\n+      DecimalType.bounded(p + 4, s + 4)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val sumDataType = child.dataType match {\n+    case _ @ DecimalType.Fixed(p, s) => DecimalType.bounded(p + 10, s)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val currentCount = AttributeReference(\"currentCount\", LongType)()\n+  private lazy val currentAvg = AttributeReference(\"currentAverage\", sumDataType)()\n+  private lazy val currentMk = AttributeReference(\"currentMoment\", sumDataType)()\n+\n+  // the values should be updated in a special order, because they re-use each other\n+  override lazy val bufferAttributes = currentCount :: currentAvg :: currentMk :: Nil\n+\n+  override lazy val initialValues = Seq(\n+    /* currentCount = */ Literal(0L),\n+    /* currentAvg = */ Cast(Literal(0), sumDataType),\n+    /* currentMk = */ Cast(Literal(0), sumDataType)\n+  )\n+\n+  override lazy val updateExpressions = {\n+    val currentValue = Coalesce(Cast(child, sumDataType) :: Cast(Literal(0), sumDataType) :: Nil)\n+    val deltaX = Subtract(currentValue, currentAvg)\n+    val updatedCount = If(IsNull(child), currentCount, currentCount + 1L)\n+    val updatedAvg = Add(currentAvg, Divide(deltaX, updatedCount))\n+    Seq(\n+      /* currentCount = */ updatedCount,\n+      /* currentAvg = */ If(IsNull(child), currentAvg, updatedAvg),\n+      /* currentMk = */ If(IsNull(child),\n+        currentMk, Add(currentMk, deltaX * Subtract(currentValue, updatedAvg)))"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "I will take a look at mutable projection and try to move field update part after evaluating expressions.\n",
    "commit": "a170f433cd9d8304212b5d3aae66cc8aff7df12d",
    "createdAt": "2015-08-09T21:30:30Z",
    "diffHunk": "@@ -302,3 +302,87 @@ case class Sum(child: Expression) extends AlgebraicAggregate {\n \n   override val evaluateExpression = Cast(currentSum, resultType)\n }\n+\n+/**\n+ * Calculates the unbiased Standard Deviation using the online formula here:\n+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n+ */\n+case class StandardDeviation(child: Expression) extends AlgebraicAggregate {\n+\n+  override def children: Seq[Expression] = child :: Nil\n+\n+  override def nullable: Boolean = true\n+\n+  // Return data type.\n+  override def dataType: DataType = resultType\n+\n+  // Expected input data type.\n+  override def inputTypes: Seq[AbstractDataType] = Seq(TypeCollection(NumericType, NullType))\n+\n+  private lazy val resultType = child.dataType match {\n+    case DecimalType.Fixed(p, s) =>\n+      DecimalType.bounded(p + 4, s + 4)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val sumDataType = child.dataType match {\n+    case _ @ DecimalType.Fixed(p, s) => DecimalType.bounded(p + 10, s)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val currentCount = AttributeReference(\"currentCount\", LongType)()\n+  private lazy val currentAvg = AttributeReference(\"currentAverage\", sumDataType)()\n+  private lazy val currentMk = AttributeReference(\"currentMoment\", sumDataType)()\n+\n+  // the values should be updated in a special order, because they re-use each other\n+  override lazy val bufferAttributes = currentCount :: currentAvg :: currentMk :: Nil\n+\n+  override lazy val initialValues = Seq(\n+    /* currentCount = */ Literal(0L),\n+    /* currentAvg = */ Cast(Literal(0), sumDataType),\n+    /* currentMk = */ Cast(Literal(0), sumDataType)\n+  )\n+\n+  override lazy val updateExpressions = {\n+    val currentValue = Coalesce(Cast(child, sumDataType) :: Cast(Literal(0), sumDataType) :: Nil)\n+    val deltaX = Subtract(currentValue, currentAvg)\n+    val updatedCount = If(IsNull(child), currentCount, currentCount + 1L)\n+    val updatedAvg = Add(currentAvg, Divide(deltaX, updatedCount))\n+    Seq(\n+      /* currentCount = */ updatedCount,\n+      /* currentAvg = */ If(IsNull(child), currentAvg, updatedAvg),\n+      /* currentMk = */ If(IsNull(child),\n+        currentMk, Add(currentMk, deltaX * Subtract(currentValue, updatedAvg)))"
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "That unfortunately doesn't totally solve the problem for SortBasedAggregation, and it corrupts the result for TungstenAggregation :( Because TungstenAggregation was happy with the way things were.\n",
    "commit": "a170f433cd9d8304212b5d3aae66cc8aff7df12d",
    "createdAt": "2015-08-10T06:19:52Z",
    "diffHunk": "@@ -302,3 +302,87 @@ case class Sum(child: Expression) extends AlgebraicAggregate {\n \n   override val evaluateExpression = Cast(currentSum, resultType)\n }\n+\n+/**\n+ * Calculates the unbiased Standard Deviation using the online formula here:\n+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n+ */\n+case class StandardDeviation(child: Expression) extends AlgebraicAggregate {\n+\n+  override def children: Seq[Expression] = child :: Nil\n+\n+  override def nullable: Boolean = true\n+\n+  // Return data type.\n+  override def dataType: DataType = resultType\n+\n+  // Expected input data type.\n+  override def inputTypes: Seq[AbstractDataType] = Seq(TypeCollection(NumericType, NullType))\n+\n+  private lazy val resultType = child.dataType match {\n+    case DecimalType.Fixed(p, s) =>\n+      DecimalType.bounded(p + 4, s + 4)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val sumDataType = child.dataType match {\n+    case _ @ DecimalType.Fixed(p, s) => DecimalType.bounded(p + 10, s)\n+    case _ => DoubleType\n+  }\n+\n+  private lazy val currentCount = AttributeReference(\"currentCount\", LongType)()\n+  private lazy val currentAvg = AttributeReference(\"currentAverage\", sumDataType)()\n+  private lazy val currentMk = AttributeReference(\"currentMoment\", sumDataType)()\n+\n+  // the values should be updated in a special order, because they re-use each other\n+  override lazy val bufferAttributes = currentCount :: currentAvg :: currentMk :: Nil\n+\n+  override lazy val initialValues = Seq(\n+    /* currentCount = */ Literal(0L),\n+    /* currentAvg = */ Cast(Literal(0), sumDataType),\n+    /* currentMk = */ Cast(Literal(0), sumDataType)\n+  )\n+\n+  override lazy val updateExpressions = {\n+    val currentValue = Coalesce(Cast(child, sumDataType) :: Cast(Literal(0), sumDataType) :: Nil)\n+    val deltaX = Subtract(currentValue, currentAvg)\n+    val updatedCount = If(IsNull(child), currentCount, currentCount + 1L)\n+    val updatedAvg = Add(currentAvg, Divide(deltaX, updatedCount))\n+    Seq(\n+      /* currentCount = */ updatedCount,\n+      /* currentAvg = */ If(IsNull(child), currentAvg, updatedAvg),\n+      /* currentMk = */ If(IsNull(child),\n+        currentMk, Add(currentMk, deltaX * Subtract(currentValue, updatedAvg)))"
  }],
  "prId": 8058
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "How about we name it `SampleStandardDeviation`? \n",
    "commit": "a170f433cd9d8304212b5d3aae66cc8aff7df12d",
    "createdAt": "2015-08-10T19:55:10Z",
    "diffHunk": "@@ -302,3 +302,101 @@ case class Sum(child: Expression) extends AlgebraicAggregate {\n \n   override val evaluateExpression = Cast(currentSum, resultType)\n }\n+\n+/**\n+ * Calculates the unbiased Standard Deviation using the online formula here:\n+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm\n+ */\n+case class StandardDeviation(child: Expression) extends AlgebraicAggregate {"
  }],
  "prId": 8058
}]