[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "We don't need to and can't merge split functions in inner classes.\r\n\r\nWe don't need to to do it because the split functions are not call in a sequence like this:\r\n```\r\neltFunc_1(...)\r\neltFunc_2(...)\r\n...\r\n```\r\n\r\nThe calls are embedded in the default branch in each split function. So we won't call all split inner functions in outer class.\r\n",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T11:01:56Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "We can't merge them because the `makeSplitFunction` will create invalid merged function if used with the given `foldFunctions`:\r\n\r\n```java\r\nprivate UTF8String eltFunc(InternalRow i, int index) { \r\n\r\n  UTF8String stringVal = null;\r\n  switch (index) {\r\n    UTF8String stringVal = eltFunc_999(i, index);\r\n    default:\r\n      return nestedClassInstance.eltFunc_999(i, index);\r\n  }\r\n  return stringVal;\r\n}\r\n```\r\n",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T11:07:37Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "yes but in this way we can hit the 64KB limit. Moreover I think that the current implementation is quite complex. What about making it similar to any other implementations using a `while` loop instead of a `switch`?\r\nIn this way we can ensure the 64KB limit won't be a problem and the code would be easier to understand IMHO.\r\n WDYT?",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T11:24:23Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Why we can hit the 64kb limit?",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T12:53:13Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I have thought about it. Other implementation needs to introduce at least one global variable such as case when case. If we can tolerate it, it is ok for me. Let's see what other reviewers think about it.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T12:56:03Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "let's not complicated the already-complex `splitExpressions`, I'm ok to use some global variables to simplify the code.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T13:04:27Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "@viirya I think we can hit it, with an outstanding number of parameters to the function. I am not saying that it is likely to happen, but IMHO it is feasible to make it happening",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T13:10:11Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. Let me replace it with simpler codes. Thanks.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T13:21:37Z",
    "diffHunk": "@@ -299,33 +299,35 @@ case class Elt(children: Seq[Expression])\n       \"\"\"\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n+    var prevFunc = \"null\"\n+    var codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = \"UTF8String\",\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |UTF8String $stringVal = null;\n+           |switch ($indexVal) {\n+           |  $body\n+           |  default:\n+           |    return $prevFunc;\n+           |}\n+           |return $stringVal;\n+        \"\"\".stripMargin,\n+      foldFunctions = funcs => s\"UTF8String $stringVal = ${funcs.last};\",\n+      makeFunctionCallback = f => prevFunc = s\"$f(${ctx.INPUT_ROW}, $indexVal)\",\n+      mergeSplit = false)"
  }],
  "prId": 19964
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "this can be a `boolean` instead of a `byte` IMHO",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:22:15Z",
    "diffHunk": "@@ -289,53 +289,61 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+\n+    // -1 means the given index doesn't match indices of strings in split function.\n+    val NOT_MATCHED = -1\n+    // 0 means the given index matches one of indices of strings in split function.\n+    val MATCHED = 0\n+    val resultState = ctx.freshName(\"eltResultState\")"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "oh, right. :-)\r\n",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:23:30Z",
    "diffHunk": "@@ -289,53 +289,61 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+\n+    // -1 means the given index doesn't match indices of strings in split function.\n+    val NOT_MATCHED = -1\n+    // 0 means the given index matches one of indices of strings in split function.\n+    val MATCHED = 0\n+    val resultState = ctx.freshName(\"eltResultState\")"
  }],
  "prId": 19964
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "only 2 possible values, we can use boolean",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:23:25Z",
    "diffHunk": "@@ -289,53 +289,61 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+\n+    // -1 means the given index doesn't match indices of strings in split function.\n+    val NOT_MATCHED = -1\n+    // 0 means the given index matches one of indices of strings in split function."
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "yea, missing it.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:27:30Z",
    "diffHunk": "@@ -289,53 +289,61 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+\n+    // -1 means the given index doesn't match indices of strings in split function.\n+    val NOT_MATCHED = -1\n+    // 0 means the given index matches one of indices of strings in split function."
  }],
  "prId": 19964
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "maybe this can have a better name now that it is a boolean.... I am not very good at naming, but something like `indexFound` or anything you feel appropriate...",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:36:55Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val resultState = ctx.freshName(\"eltResultState\")"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:37:53Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val resultState = ctx.freshName(\"eltResultState\")"
  }],
  "prId": 19964
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "nit: I would prefer `$stringVal = null` to enforce this, Because later we rely on `stringVal` to be init to `null`. Anyway the current implementation is right. If we have a UT which checks that it returns `null` when it should, we should be safe.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T14:52:43Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n-    }\n+    val codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = ctx.JAVA_BOOLEAN,\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+           |do {\n+           |  $body\n+           |} while (false);\n+           |return $indexMatched;\n+         \"\"\".stripMargin,\n+      foldFunctions = _.map { funcCall =>\n+        s\"\"\"\n+           |$indexMatched = $funcCall;\n+           |if ($indexMatched) {\n+           |  continue;\n+           |}\n+         \"\"\".stripMargin\n+      }.mkString)\n \n     ev.copy(\n       s\"\"\"\n-      ${index.code}\n-      final int $indexVal = ${index.value};\n-      $codes\n-      UTF8String ${ev.value} = $stringVal;\n-      final boolean ${ev.isNull} = ${ev.value} == null;\n-    \"\"\")\n+         |${index.code}\n+         |final int $indexVal = ${index.value};\n+         |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+         |$stringVal = ${ctx.defaultValue(dataType)};"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think we have required tests in `StringExpressionsSuite`.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T15:01:54Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n-    }\n+    val codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = ctx.JAVA_BOOLEAN,\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+           |do {\n+           |  $body\n+           |} while (false);\n+           |return $indexMatched;\n+         \"\"\".stripMargin,\n+      foldFunctions = _.map { funcCall =>\n+        s\"\"\"\n+           |$indexMatched = $funcCall;\n+           |if ($indexMatched) {\n+           |  continue;\n+           |}\n+         \"\"\".stripMargin\n+      }.mkString)\n \n     ev.copy(\n       s\"\"\"\n-      ${index.code}\n-      final int $indexVal = ${index.value};\n-      $codes\n-      UTF8String ${ev.value} = $stringVal;\n-      final boolean ${ev.isNull} = ${ev.value} == null;\n-    \"\"\")\n+         |${index.code}\n+         |final int $indexVal = ${index.value};\n+         |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+         |$stringVal = ${ctx.defaultValue(dataType)};"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "+1, since at the end we do `final boolean ${ev.isNull} = ${ev.value} == null;`.",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T15:09:16Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)\n-    val codes = if (cases.length == 1) {\n-      s\"\"\"\n-        UTF8String $stringVal = null;\n-        switch ($indexVal) {\n-          ${cases.head}\n-        }\n-       \"\"\"\n-    } else {\n-      var prevFunc = \"null\"\n-      for (c <- cases.reverse) {\n-        val funcName = ctx.freshName(\"eltFunc\")\n-        val funcBody = s\"\"\"\n-         private UTF8String $funcName(InternalRow ${ctx.INPUT_ROW}, int $indexVal) {\n-           UTF8String $stringVal = null;\n-           switch ($indexVal) {\n-             $c\n-             default:\n-               return $prevFunc;\n-           }\n-           return $stringVal;\n-         }\n-        \"\"\"\n-        val fullFuncName = ctx.addNewFunction(funcName, funcBody)\n-        prevFunc = s\"$fullFuncName(${ctx.INPUT_ROW}, $indexVal)\"\n-      }\n-      s\"UTF8String $stringVal = $prevFunc;\"\n-    }\n+    val codes = ctx.splitExpressionsWithCurrentInputs(\n+      expressions = assignStringValue,\n+      funcName = \"eltFunc\",\n+      extraArguments = (\"int\", indexVal) :: Nil,\n+      returnType = ctx.JAVA_BOOLEAN,\n+      makeSplitFunction = body =>\n+        s\"\"\"\n+           |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+           |do {\n+           |  $body\n+           |} while (false);\n+           |return $indexMatched;\n+         \"\"\".stripMargin,\n+      foldFunctions = _.map { funcCall =>\n+        s\"\"\"\n+           |$indexMatched = $funcCall;\n+           |if ($indexMatched) {\n+           |  continue;\n+           |}\n+         \"\"\".stripMargin\n+      }.mkString)\n \n     ev.copy(\n       s\"\"\"\n-      ${index.code}\n-      final int $indexVal = ${index.value};\n-      $codes\n-      UTF8String ${ev.value} = $stringVal;\n-      final boolean ${ev.isNull} = ${ev.value} == null;\n-    \"\"\")\n+         |${index.code}\n+         |final int $indexVal = ${index.value};\n+         |${ctx.JAVA_BOOLEAN} $indexMatched = false;\n+         |$stringVal = ${ctx.defaultValue(dataType)};"
  }],
  "prId": 19964
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "now `ctx.buildCodeBlock` doesn't need to be a separate method, can we revert that change and inline `buildCodeBlock` to `splitExpressions`?",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T15:10:19Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)",
    "line": 25
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "`splitExpressions` is quite complicated. I think it is still good to have `buildCodeBlock` as a separate method. Maybe makes it as `private`?",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T15:17:35Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)",
    "line": 25
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "sounds good",
    "commit": "69aab6109dff2b10d4dcdd6ef97587740da695a2",
    "createdAt": "2017-12-13T15:29:26Z",
    "diffHunk": "@@ -289,53 +289,56 @@ case class Elt(children: Seq[Expression])\n     val index = indexExpr.genCode(ctx)\n     val strings = stringExprs.map(_.genCode(ctx))\n     val indexVal = ctx.freshName(\"index\")\n+    val indexMatched = ctx.freshName(\"eltIndexMatched\")\n+\n     val stringVal = ctx.freshName(\"stringVal\")\n+    ctx.addMutableState(ctx.javaType(dataType), stringVal)\n+\n     val assignStringValue = strings.zipWithIndex.map { case (eval, index) =>\n       s\"\"\"\n-        case ${index + 1}:\n-          ${eval.code}\n-          $stringVal = ${eval.isNull} ? null : ${eval.value};\n-          break;\n-      \"\"\"\n+         |if ($indexVal == ${index + 1}) {\n+         |  ${eval.code}\n+         |  $stringVal = ${eval.isNull} ? null : ${eval.value};\n+         |  $indexMatched = true;\n+         |  continue;\n+         |}\n+      \"\"\".stripMargin\n     }\n \n-    val cases = ctx.buildCodeBlocks(assignStringValue)",
    "line": 25
  }],
  "prId": 19964
}]