[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Same argument on `count` and `n` usage. Calling them `n` and `newN` might be better.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:40Z",
    "diffHunk": "@@ -29,165 +28,95 @@ import org.apache.spark.sql.types._\n  * Definition of Pearson correlation can be found at\n  * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n  */\n-case class Corr(\n-    left: Expression,\n-    right: Expression,\n-    mutableAggBufferOffset: Int = 0,\n-    inputAggBufferOffset: Int = 0)\n-  extends ImperativeAggregate {\n-\n-  def this(left: Expression, right: Expression) =\n-    this(left, right, mutableAggBufferOffset = 0, inputAggBufferOffset = 0)\n-\n-  override def children: Seq[Expression] = Seq(left, right)\n+case class Corr(x: Expression, y: Expression) extends DeclarativeAggregate {\n \n+  override def children: Seq[Expression] = Seq(x, y)\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n-\n   override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType, DoubleType)\n \n-  override def checkInputDataTypes(): TypeCheckResult = {\n-    if (left.dataType.isInstanceOf[DoubleType] && right.dataType.isInstanceOf[DoubleType]) {\n-      TypeCheckResult.TypeCheckSuccess\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val xAvg = AttributeReference(\"xAvg\", DoubleType, nullable = false)()\n+  protected val yAvg = AttributeReference(\"yAvg\", DoubleType, nullable = false)()\n+  protected val ck = AttributeReference(\"ck\", DoubleType, nullable = false)()\n+  protected val xMk = AttributeReference(\"xMk\", DoubleType, nullable = false)()\n+  protected val yMk = AttributeReference(\"yMk\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes: Seq[AttributeReference] = Seq(count, xAvg, yAvg, ck, xMk, yMk)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* xAvg = */ Literal(0.0),\n+    /* yAvg = */ Literal(0.0),\n+    /* ck = */ Literal(0.0),\n+    /* xMk = */ Literal(0.0),\n+    /* yMk = */ Literal(0.0)\n+  )\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is equivalent to the original update rule. However, for reference purpose, we shouldn't change it. So users can easily map the formula on the wikipedia page to the implementation here. Shall we change it back to `y - newYAvg`? Same applies to the two lines below.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:41Z",
    "diffHunk": "@@ -29,165 +28,95 @@ import org.apache.spark.sql.types._\n  * Definition of Pearson correlation can be found at\n  * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n  */\n-case class Corr(\n-    left: Expression,\n-    right: Expression,\n-    mutableAggBufferOffset: Int = 0,\n-    inputAggBufferOffset: Int = 0)\n-  extends ImperativeAggregate {\n-\n-  def this(left: Expression, right: Expression) =\n-    this(left, right, mutableAggBufferOffset = 0, inputAggBufferOffset = 0)\n-\n-  override def children: Seq[Expression] = Seq(left, right)\n+case class Corr(x: Expression, y: Expression) extends DeclarativeAggregate {\n \n+  override def children: Seq[Expression] = Seq(x, y)\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n-\n   override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType, DoubleType)\n \n-  override def checkInputDataTypes(): TypeCheckResult = {\n-    if (left.dataType.isInstanceOf[DoubleType] && right.dataType.isInstanceOf[DoubleType]) {\n-      TypeCheckResult.TypeCheckSuccess\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val xAvg = AttributeReference(\"xAvg\", DoubleType, nullable = false)()\n+  protected val yAvg = AttributeReference(\"yAvg\", DoubleType, nullable = false)()\n+  protected val ck = AttributeReference(\"ck\", DoubleType, nullable = false)()\n+  protected val xMk = AttributeReference(\"xMk\", DoubleType, nullable = false)()\n+  protected val yMk = AttributeReference(\"yMk\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes: Seq[AttributeReference] = Seq(count, xAvg, yAvg, ck, xMk, yMk)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* xAvg = */ Literal(0.0),\n+    /* yAvg = */ Literal(0.0),\n+    /* ck = */ Literal(0.0),\n+    /* xMk = */ Literal(0.0),\n+    /* yMk = */ Literal(0.0)\n+  )\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val dx = x - xAvg\n+    val dxN = dx / n\n+    val dy = y - yAvg\n+    val dyN = dy / n\n+    val newXAvg = xAvg + dxN\n+    val newYAvg = yAvg + dyN\n+    val newCk = ck + dx * (dy - dyN)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Similar here. Is it the same as the following?\n\n``` scala\nIf(IsNull(x) || IsNull(y),\n  Seq(count, xAvg, yAvg, ck, xMk, yMk),\n  Seq(n, newXAvg, newYAvg, newCk, newXMk, newYMk))\n```\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:43Z",
    "diffHunk": "@@ -29,165 +28,95 @@ import org.apache.spark.sql.types._\n  * Definition of Pearson correlation can be found at\n  * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n  */\n-case class Corr(\n-    left: Expression,\n-    right: Expression,\n-    mutableAggBufferOffset: Int = 0,\n-    inputAggBufferOffset: Int = 0)\n-  extends ImperativeAggregate {\n-\n-  def this(left: Expression, right: Expression) =\n-    this(left, right, mutableAggBufferOffset = 0, inputAggBufferOffset = 0)\n-\n-  override def children: Seq[Expression] = Seq(left, right)\n+case class Corr(x: Expression, y: Expression) extends DeclarativeAggregate {\n \n+  override def children: Seq[Expression] = Seq(x, y)\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n-\n   override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType, DoubleType)\n \n-  override def checkInputDataTypes(): TypeCheckResult = {\n-    if (left.dataType.isInstanceOf[DoubleType] && right.dataType.isInstanceOf[DoubleType]) {\n-      TypeCheckResult.TypeCheckSuccess\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val xAvg = AttributeReference(\"xAvg\", DoubleType, nullable = false)()\n+  protected val yAvg = AttributeReference(\"yAvg\", DoubleType, nullable = false)()\n+  protected val ck = AttributeReference(\"ck\", DoubleType, nullable = false)()\n+  protected val xMk = AttributeReference(\"xMk\", DoubleType, nullable = false)()\n+  protected val yMk = AttributeReference(\"yMk\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes: Seq[AttributeReference] = Seq(count, xAvg, yAvg, ck, xMk, yMk)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* xAvg = */ Literal(0.0),\n+    /* yAvg = */ Literal(0.0),\n+    /* ck = */ Literal(0.0),\n+    /* xMk = */ Literal(0.0),\n+    /* yMk = */ Literal(0.0)\n+  )\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val dx = x - xAvg\n+    val dxN = dx / n\n+    val dy = y - yAvg\n+    val dyN = dy / n\n+    val newXAvg = xAvg + dxN\n+    val newYAvg = yAvg + dyN\n+    val newCk = ck + dx * (dy - dyN)\n+    val newXMk = xMk + dx * (dx - dxN)\n+    val newYMk = yMk + dy * (dy - dyN)\n+\n+    val isNull = Or(IsNull(x), IsNull(y))"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`EqualTo` => `===`\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:49Z",
    "diffHunk": "@@ -29,165 +28,95 @@ import org.apache.spark.sql.types._\n  * Definition of Pearson correlation can be found at\n  * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n  */\n-case class Corr(\n-    left: Expression,\n-    right: Expression,\n-    mutableAggBufferOffset: Int = 0,\n-    inputAggBufferOffset: Int = 0)\n-  extends ImperativeAggregate {\n-\n-  def this(left: Expression, right: Expression) =\n-    this(left, right, mutableAggBufferOffset = 0, inputAggBufferOffset = 0)\n-\n-  override def children: Seq[Expression] = Seq(left, right)\n+case class Corr(x: Expression, y: Expression) extends DeclarativeAggregate {\n \n+  override def children: Seq[Expression] = Seq(x, y)\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n-\n   override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType, DoubleType)\n \n-  override def checkInputDataTypes(): TypeCheckResult = {\n-    if (left.dataType.isInstanceOf[DoubleType] && right.dataType.isInstanceOf[DoubleType]) {\n-      TypeCheckResult.TypeCheckSuccess\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val xAvg = AttributeReference(\"xAvg\", DoubleType, nullable = false)()\n+  protected val yAvg = AttributeReference(\"yAvg\", DoubleType, nullable = false)()\n+  protected val ck = AttributeReference(\"ck\", DoubleType, nullable = false)()\n+  protected val xMk = AttributeReference(\"xMk\", DoubleType, nullable = false)()\n+  protected val yMk = AttributeReference(\"yMk\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes: Seq[AttributeReference] = Seq(count, xAvg, yAvg, ck, xMk, yMk)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* xAvg = */ Literal(0.0),\n+    /* yAvg = */ Literal(0.0),\n+    /* ck = */ Literal(0.0),\n+    /* xMk = */ Literal(0.0),\n+    /* yMk = */ Literal(0.0)\n+  )\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val dx = x - xAvg\n+    val dxN = dx / n\n+    val dy = y - yAvg\n+    val dyN = dy / n\n+    val newXAvg = xAvg + dxN\n+    val newYAvg = yAvg + dyN\n+    val newCk = ck + dx * (dy - dyN)\n+    val newXMk = xMk + dx * (dx - dxN)\n+    val newYMk = yMk + dy * (dy - dyN)\n+\n+    val isNull = Or(IsNull(x), IsNull(y))\n+    if (x.nullable || y.nullable) {\n+      Seq(\n+        /* count = */ If(isNull, count, n),\n+        /* xAvg = */ If(isNull, xAvg, newXAvg),\n+        /* yAvg = */ If(isNull, yAvg, newYAvg),\n+        /* ck = */ If(isNull, ck, newCk),\n+        /* xMk = */ If(isNull, xMk, newXMk),\n+        /* yMk = */ If(isNull, yMk, newYMk)\n+      )\n     } else {\n-      TypeCheckResult.TypeCheckFailure(\n-        s\"corr requires that both arguments are double type, \" +\n-          s\"not (${left.dataType}, ${right.dataType}).\")\n+      Seq(\n+        /* count = */ n,\n+        /* xAvg = */ newXAvg,\n+        /* yAvg = */ newYAvg,\n+        /* ck = */ newCk,\n+        /* xMk = */ newXMk,\n+        /* yMk = */ newYMk\n+      )\n     }\n   }\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n-\n-  override def inputAggBufferAttributes: Seq[AttributeReference] = {\n-    aggBufferAttributes.map(_.newInstance())\n+  override val mergeExpressions: Seq[Expression] = {\n+\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val dx = xAvg.right - xAvg.left\n+    val dxN = If(EqualTo(n, Literal(0.0)), Literal(0.0), dx / n)"
  }],
  "prId": 10960
}]