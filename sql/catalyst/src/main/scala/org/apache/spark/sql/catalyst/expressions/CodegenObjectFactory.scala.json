[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Can we make this an abstract class in which we just need to implement hooks for the  code generated and interpreted versions, i.e.:\r\n```scala\r\nobject CodegenError {\r\n  def unapply(throwable: Throwable): Option[Exception] = throwable match {\r\n    case e: InternalCompilerException => Some(e)\r\n    case e: CompileException => Some(e)\r\n    case _ => None\r\n  }\r\n}\r\n\r\nabstract class CodegenObjectFactory[IN, OUT] {\r\n  def create(in: IN): OUT = try createCodeGeneratedObject(in) catch {\r\n    case CodegenError(_) =>createInterpretedObject(in)\r\n  }\r\n\r\n  protected def createCodeGeneratedObject(in: IN): OUT\r\n  protected def createInterpretedObject(in: IN): OUT\r\n}\r\n\r\nobject UnsafeProjectionCreator extends CodegenObjectFactory[Seq[Expression], UnsafeProjection] {\r\n  ...\r\n}\r\n```",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-04-19T15:47:54Z",
    "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+object CodegenObjectFactory {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "This looks good to me, except that I think `UnsafeProjectionCreator` should still support `UnsafeProjectionCreator`'s APIs. So we can replace all usage of `UnsafeProjection` with `UnsafeProjectionCreator`.",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-04-20T00:15:31Z",
    "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+object CodegenObjectFactory {"
  }],
  "prId": 21106
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "We can only access SQLConf on the driver. Now this causes test failure. We can't know this config value inside `createObject` which can be called on executors. \r\n\r\nTo solve this, `UnsafeProjection` can't be an object as now, but a case class with a fallback mode parameter. So we can create this factory on driver. @cloud-fan @hvanhovell WDYT?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-06T22:52:32Z",
    "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {\n+\n+  // Creates wanted object. First trying codegen implementation. If any compile error happens,\n+  // fallbacks to interpreted version.\n+  def createObject(in: IN): OUT = {\n+    val fallbackMode = SQLConf.get.getConf(SQLConf.CODEGEN_OBJECT_FALLBACK)"
  }],
  "prId": 21106
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This SQL config can only be useful for unit test against codegen and interpreted unsafe projection.",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-07T23:33:37Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_OBJECT_FALLBACK)\n+      CodegenObjectFactoryMode.withName(config)"
  }],
  "prId": 21106
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I'm rethinking about it. Do you think this conf is useful if there is a perf problem in codegen and users want to use interpreted version?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-08T06:43:26Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_OBJECT_FALLBACK)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {\n+\n+  def createObject(in: IN): OUT = {\n+    // We are allowed to choose codegen-only or no-codegen modes if under tests."
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Hmm, possible. If users are aware of codegen objects like unsafe projection can be controlled too. Currently when we fallback from wholestage codegen to interpreted mode, we still use codegen unsafe projection if it doesn't fail compile. If it has perf problem, users can't do anything.",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-08T06:56:41Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_OBJECT_FALLBACK)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {\n+\n+  def createObject(in: IN): OUT = {\n+    // We are allowed to choose codegen-only or no-codegen modes if under tests."
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "So do we want to have this conf for not only test but also production?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-09T10:16:39Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_OBJECT_FALLBACK)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {\n+\n+  def createObject(in: IN): OUT = {\n+    // We are allowed to choose codegen-only or no-codegen modes if under tests."
  }],
  "prId": 21106
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "any better name? How about `CodeGeneratorWithInterpretedFallback` and make it extends `CodeGenerator`?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-11T04:53:14Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Why it needs `CodeGenerator`? I think this `CodeGeneratorWithInterpretedFallback` just delegate to various `CodeGenerator` (e.g., `GenerateUnsafeProjection`) to produce codegen object.",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-11T06:13:58Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`GenerateUnsafeProjection` also extends `CodeGenerator`.\r\n\r\nIs there any class we want it to extend `CodegenObjectFactory` but not `CodeGenerator`?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-11T13:28:43Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yes, no doubt `GenerateUnsafeProjection` extends `CodeGenerator`. It's the class doing generators of byte codes.\r\n\r\nPreviously `UnsafeProjection` has its own interface `UnsafeProjectionCreator`, does not extends `CodeGenerator`. So currently I let it follow previous `UnsafeProjection`'s API.\r\n\r\nWe can change it to implement `CodeGenerator` and also change the places using `UnsafeProjection`, if you think it is necessary.\r\n\r\n\r\n\r\n",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-11T15:01:21Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ok let's keep the previous way to minimize code changes. How about just rename it to `CodeGeneratorWithInterpretedFallback`?",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-11T16:51:06Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. Reamed.",
    "commit": "5527595b83b9cd394ba6d52e82711b777259f569",
    "createdAt": "2018-05-13T01:33:20Z",
    "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.codehaus.commons.compiler.CompileException\n+import org.codehaus.janino.InternalCompilerException\n+\n+import org.apache.spark.TaskContext\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * Catches compile error during code generation.\n+ */\n+object CodegenError {\n+  def unapply(throwable: Throwable): Option[Exception] = throwable match {\n+    case e: InternalCompilerException => Some(e)\n+    case e: CompileException => Some(e)\n+    case _ => None\n+  }\n+}\n+\n+/**\n+ * Defines values for `SQLConf` config of fallback mode. Use for test only.\n+ */\n+object CodegenObjectFactoryMode extends Enumeration {\n+  val AUTO, CODEGEN_ONLY, NO_CODEGEN = Value\n+\n+  def currentMode: CodegenObjectFactoryMode.Value = {\n+    // If we weren't on task execution, accesses that config.\n+    if (TaskContext.get == null) {\n+      val config = SQLConf.get.getConf(SQLConf.CODEGEN_FACTORY_MODE)\n+      CodegenObjectFactoryMode.withName(config)\n+    } else {\n+      CodegenObjectFactoryMode.AUTO\n+    }\n+  }\n+}\n+\n+/**\n+ * A factory which can be used to create objects that have both codegen and interpreted\n+ * implementations. This tries to create codegen object first, if any compile error happens,\n+ * it fallbacks to interpreted version.\n+ */\n+abstract class CodegenObjectFactory[IN, OUT] {"
  }],
  "prId": 21106
}]