[{
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Instead of explicit expose the `bufferOffset`, probably people prefer using the `BoundReference`, it's created by `BindReferences.bindReference`, I think we can pass in the associated `BoundReference` (bind with bufferSchema) while `initialize` the `AggregateFunction2` in each executor.\n\nWe can add the implicit function in this class, to convert `BoundReference` => Int. So people can write code like:\n`mutableRow.isNullAt(BoundReference)` \n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T11:05:37Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate2\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.errors.TreeNodeException\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.types._\n+\n+/** The mode of an [[AggregateFunction]]. */\n+private[sql] sealed trait AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[Partial]] mode is used for partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object Partial extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object PartialMerge extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function and the generate final result.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Final extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction2]] with [[Partial]] mode is used to evaluate this function directly\n+ * from original input rows without any partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Complete extends AggregateMode\n+\n+private[sql] case object NoOp extends Expression {\n+  override def nullable: Boolean = true\n+  override def eval(input: InternalRow): Any = {\n+    throw new TreeNodeException(\n+      this, s\"No function to evaluate expression. type: ${this.nodeName}\")\n+  }\n+  override def dataType: DataType = NullType\n+  override def children: Seq[Expression] = Nil\n+}\n+\n+/**\n+ * A container for an [[AggregateFunction2]] with its [[AggregateMode]] and a field\n+ * (`isDistinct`) indicating if DISTINCT keyword is specified for this function.\n+ * @param aggregateFunction\n+ * @param mode\n+ * @param isDistinct\n+ */\n+private[sql] case class AggregateExpression2(\n+    aggregateFunction: AggregateFunction2,\n+    mode: AggregateMode,\n+    isDistinct: Boolean) extends Expression {\n+\n+  override def children: Seq[Expression] = aggregateFunction :: Nil\n+  override def dataType: DataType = aggregateFunction.dataType\n+  override def foldable: Boolean = false\n+  override def nullable: Boolean = aggregateFunction.nullable\n+\n+  override def toString: String = s\"(${aggregateFunction}2,mode=$mode,isDistinct=$isDistinct)\"\n+\n+  override def eval(input: InternalRow = null): Any = {\n+    throw new TreeNodeException(\n+      this, s\"No function to evaluate expression. type: ${this.nodeName}\")\n+  }\n+}\n+\n+abstract class AggregateFunction2\n+  extends Expression {\n+\n+  self: Product =>\n+\n+  /** An aggregate function is not foldable. */\n+  override def foldable: Boolean = false\n+\n+  /**\n+   * The offset of this function's buffer in the underlying buffer shared with other functions.\n+   */\n+  var bufferOffset: Int = 0"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Thanks for the suggestion.\n\n`bufferOffset` is an internal thing. For our built-in aggregate functions, we will try to implement them based on `AlgebraicAggregate`, which supports code-generation. The developers of `AlgebraicAggregate` do not need to use `bufferOffset`. For UDAFs, they should be implemented based on `UserDefinedAggregateFunction`. We will hide this offset from UDAFs. So, hopefully developers will not need to use `bufferOffset` at all. \n\nI will think about this part and see if there is any other way. I will also go through those new interfaces to make sure we properly set their access modifiers.\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T17:19:12Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate2\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.errors.TreeNodeException\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.types._\n+\n+/** The mode of an [[AggregateFunction]]. */\n+private[sql] sealed trait AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[Partial]] mode is used for partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object Partial extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object PartialMerge extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function and the generate final result.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Final extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction2]] with [[Partial]] mode is used to evaluate this function directly\n+ * from original input rows without any partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Complete extends AggregateMode\n+\n+private[sql] case object NoOp extends Expression {\n+  override def nullable: Boolean = true\n+  override def eval(input: InternalRow): Any = {\n+    throw new TreeNodeException(\n+      this, s\"No function to evaluate expression. type: ${this.nodeName}\")\n+  }\n+  override def dataType: DataType = NullType\n+  override def children: Seq[Expression] = Nil\n+}\n+\n+/**\n+ * A container for an [[AggregateFunction2]] with its [[AggregateMode]] and a field\n+ * (`isDistinct`) indicating if DISTINCT keyword is specified for this function.\n+ * @param aggregateFunction\n+ * @param mode\n+ * @param isDistinct\n+ */\n+private[sql] case class AggregateExpression2(\n+    aggregateFunction: AggregateFunction2,\n+    mode: AggregateMode,\n+    isDistinct: Boolean) extends Expression {\n+\n+  override def children: Seq[Expression] = aggregateFunction :: Nil\n+  override def dataType: DataType = aggregateFunction.dataType\n+  override def foldable: Boolean = false\n+  override def nullable: Boolean = aggregateFunction.nullable\n+\n+  override def toString: String = s\"(${aggregateFunction}2,mode=$mode,isDistinct=$isDistinct)\"\n+\n+  override def eval(input: InternalRow = null): Any = {\n+    throw new TreeNodeException(\n+      this, s\"No function to evaluate expression. type: ${this.nodeName}\")\n+  }\n+}\n+\n+abstract class AggregateFunction2\n+  extends Expression {\n+\n+  self: Product =>\n+\n+  /** An aggregate function is not foldable. */\n+  override def foldable: Boolean = false\n+\n+  /**\n+   * The offset of this function's buffer in the underlying buffer shared with other functions.\n+   */\n+  var bufferOffset: Int = 0"
  }],
  "prId": 7458
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "We should move this out and comment it.\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-17T20:50:09Z",
    "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate2\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.errors.TreeNodeException\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.Row\n+\n+/** The mode of an [[AggregateFunction]]. */\n+private[sql] sealed trait AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[Partial]] mode is used for partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object Partial extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object PartialMerge extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function and the generate final result.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Final extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction2]] with [[Partial]] mode is used to evaluate this function directly\n+ * from original input rows without any partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Complete extends AggregateMode\n+\n+private[sql] case object NoOp extends Expression {"
  }],
  "prId": 7458
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Will add comments to it and figure out the right place for it later.\n",
    "commit": "7865f5ef072d1877b73276f28e84afa98c247a82",
    "createdAt": "2015-07-20T05:07:31Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate2\n+\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.errors.TreeNodeException\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.types._\n+\n+/** The mode of an [[AggregateFunction1]]. */\n+private[sql] sealed trait AggregateMode\n+\n+/**\n+ * An [[AggregateFunction1]] with [[Partial]] mode is used for partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object Partial extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction1]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the aggregation buffer is returned.\n+ */\n+private[sql] case object PartialMerge extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction1]] with [[PartialMerge]] mode is used to merge aggregation buffers\n+ * containing intermediate results for this function and the generate final result.\n+ * This function updates the given aggregation buffer by merging multiple aggregation buffers.\n+ * When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Final extends AggregateMode\n+\n+/**\n+ * An [[AggregateFunction2]] with [[Partial]] mode is used to evaluate this function directly\n+ * from original input rows without any partial aggregation.\n+ * This function updates the given aggregation buffer with the original input of this\n+ * function. When it has processed all input rows, the final result of this function is returned.\n+ */\n+private[sql] case object Complete extends AggregateMode\n+\n+private[sql] case object NoOp extends Expression with Unevaluable {"
  }],
  "prId": 7458
}]