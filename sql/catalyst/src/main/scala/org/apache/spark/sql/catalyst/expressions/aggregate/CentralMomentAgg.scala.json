[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Creating a Cast() here is very expensive\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-01-28T06:55:35Z",
    "diffHunk": "@@ -109,7 +109,7 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n    * Update the central moments buffer.\n    */\n   override def update(buffer: MutableRow, input: InternalRow): Unit = {\n-    val v = Cast(child, DoubleType).eval(input)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Those `if` branches are important to save computation for low-order statistics. Even we won't use `CentralMomentAgg` for second-order statistics, it is still good to keep them.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-01-28T18:06:16Z",
    "diffHunk": "@@ -125,19 +125,15 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n       mean += deltaN\n       buffer.setDouble(meanOffset, mean)\n \n-      if (momentOrder >= 2) {\n-        m2 = buffer.getDouble(secondMomentOffset)\n-        m2 += delta * (delta - deltaN)\n-        buffer.setDouble(secondMomentOffset, m2)\n-      }\n+      m2 = buffer.getDouble(secondMomentOffset)\n+      m2 += delta * (delta - deltaN)\n+      buffer.setDouble(secondMomentOffset, m2)\n \n-      if (momentOrder >= 3) {"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we call it `n`? Otherwise, we have both `count` and `n` in the code. It is not clear that `n` means `newCount`. If we rename it, we can use `n` and `newN`.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:12Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we make `.take(momentOrder + 1)` a private method (`trimHigherOrder`?) and have it documented?\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:14Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If my understanding is correct, there exists some unnecessary expression calculation when we don't need 3rd- or 4th-order statistics. But this is a one-time overhead because `updateExpression` is only called once before codegen. If this is correct, it would be helpful to leave a comment here to explain why we don't need `if` branches.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:16Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It might be easier to understand if we write\n\n``` scala\ntrimHigherOrder(\n  If(IsNull(child),\n    Seq(count, avg, m2, m3, m4),\n    Seq(n, newAvg, newM2, newM3, newM4)))\n```\n\nPlease let me know if it doesn't work. Btw, I guess `if (child.nullable)` is automatically checked by `IsNull` (https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/BoundAttribute.scala#L74). Then we can remove that check to simplify the code here.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:18Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "The `if` here is not necessary, will be removed (compiler can remove it)\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:59:21Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The comment `/* count = */` seems unnecessary to me because it is clear from the variable name.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:21Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Please also remove comments when the variable names provide sufficient info.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:53Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we use `===` to replace `EqualTo` to make the code more readable?\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:55Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The `if` branch is not necessary because we will trim the result at the end. Shall we follow the approach in `updateExpression` and remove it? It is still useful to leave a comment here.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:32:57Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "These expression require `m3.right`, it is not valid if momentOrder < 3, will add a comment.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:36:04Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Then shall we make `updateExpression` follow the same style?\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:39:22Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "`updateExpression` does not need that.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:46:28Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I understand that `updateExpression` is not necessary. This is just to make the code more consistent. For example, I figured it out why this is not necessary in `updateExpression`, then I was confused by why we use the `if` branches here. The logic would be clearer if we use `if` branches in both methods.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:49:53Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Btw, `StddevPop` is simply `Sqrt(VariancePop)` (and `StddevSamp = Sqrt(VarianceSamp)`). I'm not sure whether it can help simplify the code here.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:12Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)\n   }\n+}\n \n-  // Note: although this simply copies aggBufferAttributes, this common code can not be placed\n-  // in the superclass because that will lead to initialization ordering issues.\n-  override val inputAggBufferAttributes: Seq[AttributeReference] =\n-    aggBufferAttributes.map(_.newInstance())\n-\n-  // buffer offsets\n-  private[this] val nOffset = mutableAggBufferOffset\n-  private[this] val meanOffset = mutableAggBufferOffset + 1\n-  private[this] val secondMomentOffset = mutableAggBufferOffset + 2\n-  private[this] val thirdMomentOffset = mutableAggBufferOffset + 3\n-  private[this] val fourthMomentOffset = mutableAggBufferOffset + 4\n-\n-  // frequently used values for online updates\n-  private[this] var delta = 0.0\n-  private[this] var deltaN = 0.0\n-  private[this] var delta2 = 0.0\n-  private[this] var deltaN2 = 0.0\n-  private[this] var n = 0.0\n-  private[this] var mean = 0.0\n-  private[this] var m2 = 0.0\n-  private[this] var m3 = 0.0\n-  private[this] var m4 = 0.0\n+// Compute the population standard deviation of a column\n+case class StddevPop(child: Expression) extends CentralMomentAgg(child) {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "We may still want to have a good name when you call `explain`, I'd like to keep them.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T08:00:28Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)\n   }\n+}\n \n-  // Note: although this simply copies aggBufferAttributes, this common code can not be placed\n-  // in the superclass because that will lead to initialization ordering issues.\n-  override val inputAggBufferAttributes: Seq[AttributeReference] =\n-    aggBufferAttributes.map(_.newInstance())\n-\n-  // buffer offsets\n-  private[this] val nOffset = mutableAggBufferOffset\n-  private[this] val meanOffset = mutableAggBufferOffset + 1\n-  private[this] val secondMomentOffset = mutableAggBufferOffset + 2\n-  private[this] val thirdMomentOffset = mutableAggBufferOffset + 3\n-  private[this] val fourthMomentOffset = mutableAggBufferOffset + 4\n-\n-  // frequently used values for online updates\n-  private[this] var delta = 0.0\n-  private[this] var deltaN = 0.0\n-  private[this] var delta2 = 0.0\n-  private[this] var deltaN2 = 0.0\n-  private[this] var n = 0.0\n-  private[this] var mean = 0.0\n-  private[this] var m2 = 0.0\n-  private[this] var m3 = 0.0\n-  private[this] var m4 = 0.0\n+// Compute the population standard deviation of a column\n+case class StddevPop(child: Expression) extends CentralMomentAgg(child) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Sounds good.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T08:02:11Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)\n   }\n+}\n \n-  // Note: although this simply copies aggBufferAttributes, this common code can not be placed\n-  // in the superclass because that will lead to initialization ordering issues.\n-  override val inputAggBufferAttributes: Seq[AttributeReference] =\n-    aggBufferAttributes.map(_.newInstance())\n-\n-  // buffer offsets\n-  private[this] val nOffset = mutableAggBufferOffset\n-  private[this] val meanOffset = mutableAggBufferOffset + 1\n-  private[this] val secondMomentOffset = mutableAggBufferOffset + 2\n-  private[this] val thirdMomentOffset = mutableAggBufferOffset + 3\n-  private[this] val fourthMomentOffset = mutableAggBufferOffset + 4\n-\n-  // frequently used values for online updates\n-  private[this] var delta = 0.0\n-  private[this] var deltaN = 0.0\n-  private[this] var delta2 = 0.0\n-  private[this] var deltaN2 = 0.0\n-  private[this] var n = 0.0\n-  private[this] var mean = 0.0\n-  private[this] var m2 = 0.0\n-  private[this] var m3 = 0.0\n-  private[this] var m4 = 0.0\n+// Compute the population standard deviation of a column\n+case class StddevPop(child: Expression) extends CentralMomentAgg(child) {"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Using `===` instead?\n\n``` scala\nIf(count === Literal(0.0), Literal.create(null, DoubleType), Sqrt(m2 / count))\n```\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:22Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)\n   }\n+}\n \n-  // Note: although this simply copies aggBufferAttributes, this common code can not be placed\n-  // in the superclass because that will lead to initialization ordering issues.\n-  override val inputAggBufferAttributes: Seq[AttributeReference] =\n-    aggBufferAttributes.map(_.newInstance())\n-\n-  // buffer offsets\n-  private[this] val nOffset = mutableAggBufferOffset\n-  private[this] val meanOffset = mutableAggBufferOffset + 1\n-  private[this] val secondMomentOffset = mutableAggBufferOffset + 2\n-  private[this] val thirdMomentOffset = mutableAggBufferOffset + 3\n-  private[this] val fourthMomentOffset = mutableAggBufferOffset + 4\n-\n-  // frequently used values for online updates\n-  private[this] var delta = 0.0\n-  private[this] var deltaN = 0.0\n-  private[this] var delta2 = 0.0\n-  private[this] var deltaN2 = 0.0\n-  private[this] var n = 0.0\n-  private[this] var mean = 0.0\n-  private[this] var m2 = 0.0\n-  private[this] var m3 = 0.0\n-  private[this] var m4 = 0.0\n+// Compute the population standard deviation of a column\n+case class StddevPop(child: Expression) extends CentralMomentAgg(child) {\n \n-  /**\n-   * Initialize all moments to zero.\n-   */\n-  override def initialize(buffer: MutableRow): Unit = {\n-    for (aggIndex <- 0 until bufferSize) {\n-      buffer.setDouble(mutableAggBufferOffset + aggIndex, 0.0)\n-    }\n+  override protected def momentOrder = 2\n+\n+  override val evaluateExpression: Expression = {\n+    If(EqualTo(count, Literal(0.0)), Literal.create(null, DoubleType),"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "ditto on `EqualTo` => `===`\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:33:26Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)\n   }\n+}\n \n-  // Note: although this simply copies aggBufferAttributes, this common code can not be placed\n-  // in the superclass because that will lead to initialization ordering issues.\n-  override val inputAggBufferAttributes: Seq[AttributeReference] =\n-    aggBufferAttributes.map(_.newInstance())\n-\n-  // buffer offsets\n-  private[this] val nOffset = mutableAggBufferOffset\n-  private[this] val meanOffset = mutableAggBufferOffset + 1\n-  private[this] val secondMomentOffset = mutableAggBufferOffset + 2\n-  private[this] val thirdMomentOffset = mutableAggBufferOffset + 3\n-  private[this] val fourthMomentOffset = mutableAggBufferOffset + 4\n-\n-  // frequently used values for online updates\n-  private[this] var delta = 0.0\n-  private[this] var deltaN = 0.0\n-  private[this] var delta2 = 0.0\n-  private[this] var deltaN2 = 0.0\n-  private[this] var n = 0.0\n-  private[this] var mean = 0.0\n-  private[this] var m2 = 0.0\n-  private[this] var m3 = 0.0\n-  private[this] var m4 = 0.0\n+// Compute the population standard deviation of a column\n+case class StddevPop(child: Expression) extends CentralMomentAgg(child) {\n \n-  /**\n-   * Initialize all moments to zero.\n-   */\n-  override def initialize(buffer: MutableRow): Unit = {\n-    for (aggIndex <- 0 until bufferSize) {\n-      buffer.setDouble(mutableAggBufferOffset + aggIndex, 0.0)\n-    }\n+  override protected def momentOrder = 2\n+\n+  override val evaluateExpression: Expression = {\n+    If(EqualTo(count, Literal(0.0)), Literal.create(null, DoubleType),\n+      Sqrt(m2 / count))\n   }\n \n-  /**\n-   * Update the central moments buffer.\n-   */\n-  override def update(buffer: MutableRow, input: InternalRow): Unit = {\n-    val v = Cast(child, DoubleType).eval(input)\n-    if (v != null) {\n-      val updateValue = v match {\n-        case d: Double => d\n-      }\n-\n-      n = buffer.getDouble(nOffset)\n-      mean = buffer.getDouble(meanOffset)\n-\n-      n += 1.0\n-      buffer.setDouble(nOffset, n)\n-      delta = updateValue - mean\n-      deltaN = delta / n\n-      mean += deltaN\n-      buffer.setDouble(meanOffset, mean)\n-\n-      if (momentOrder >= 2) {\n-        m2 = buffer.getDouble(secondMomentOffset)\n-        m2 += delta * (delta - deltaN)\n-        buffer.setDouble(secondMomentOffset, m2)\n-      }\n-\n-      if (momentOrder >= 3) {\n-        delta2 = delta * delta\n-        deltaN2 = deltaN * deltaN\n-        m3 = buffer.getDouble(thirdMomentOffset)\n-        m3 += -3.0 * deltaN * m2 + delta * (delta2 - deltaN2)\n-        buffer.setDouble(thirdMomentOffset, m3)\n-      }\n-\n-      if (momentOrder >= 4) {\n-        m4 = buffer.getDouble(fourthMomentOffset)\n-        m4 += -4.0 * deltaN * m3 - 6.0 * deltaN2 * m2 +\n-          delta * (delta * delta2 - deltaN * deltaN2)\n-        buffer.setDouble(fourthMomentOffset, m4)\n-      }\n-    }\n+  override def prettyName: String = \"stddev_pop\"\n+}\n+\n+// Compute the sample standard deviation of a column\n+case class StddevSamp(child: Expression) extends CentralMomentAgg(child) {\n+\n+  override protected def momentOrder = 2\n+\n+  override val evaluateExpression: Expression = {\n+    If(EqualTo(count, Literal(0.0)), Literal.create(null, DoubleType),"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This could be simplified to `trimHigherOrder(Seq(n, newAvg, newM2, newM3, newM4))`, which won't reduce readability.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T07:36:22Z",
    "diffHunk": "@@ -57,173 +55,170 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n \n   override def dataType: DataType = DoubleType\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val count = AttributeReference(\"count\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  override val aggBufferAttributes = Seq(count, avg, m2, m3, m4).take(momentOrder + 1)\n+\n+  override val initialValues: Seq[Expression] = Seq(\n+    /* count = */ Literal(0.0),\n+    /* avg = */ Literal(0.0),\n+    /* m2 = */ Literal(0.0),\n+    /* m3 = */ Literal(0.0),\n+    /* m4 = */ Literal(0.0)\n+  ).take(momentOrder + 1)\n+\n+  override lazy val updateExpressions: Seq[Expression] = {\n+    val n = count + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / n\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+\n+    val newM4 = m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+      delta * (delta * delta2 - deltaN * deltaN2)\n+\n+    if (child.nullable) {\n+      Seq(\n+        /* count = */ If(IsNull(child), count, n),\n+        /* avg = */ If(IsNull(child), avg, newAvg),\n+        /* m2 = */ If(IsNull(child), m2, newM2),\n+        /* m3 = */ If(IsNull(child), m3, newM3),\n+        /* m4 = */ If(IsNull(child), m4, newM4)\n+      ).take(momentOrder + 1)\n+    } else {\n+      Seq(\n+        /* count = */ n,\n+        /* avg = */ newAvg,\n+        /* m2 = */ newM2,\n+        /* m3 = */ newM3,\n+        /* m4 = */ newM4\n+      ).take(momentOrder + 1)\n+    }\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override lazy val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = count.left\n+    val n2 = count.right\n+    val n = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(n, Literal(0.0)), Literal(0.0), delta / n)\n+    val newAvg = avg.left + deltaN * n2\n \n-  /**\n-   * Size of aggregation buffer.\n-   */\n-  private[this] val bufferSize = 5\n+    // higher order moments computed according to:\n+    // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Higher-order_statistics\n+    val newM2 = m2.left + m2.right + delta * deltaN * n1 * n2\n+    val newM3 = if (momentOrder >= 3) {\n+      m3.left + m3.right + deltaN * deltaN * delta * n1 * n2 * (n1 - n2) +\n+        Literal(3.0) * deltaN * (n1 * m2.right - n2 * m2.left)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4.left + m4.right +\n+        deltaN * deltaN * deltaN * delta * n1 * n2 * (n1 * n1 - n1 * n2 + n2 * n2) +\n+        Literal(6.0) * deltaN * deltaN * (n1 * n1 * m2.right + n2 * n2 * m2.left) +\n+        Literal(4.0) * deltaN * (n1 * m3.right - n2 * m3.left)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override val aggBufferAttributes: Seq[AttributeReference] = Seq.tabulate(bufferSize) { i =>\n-    AttributeReference(s\"M$i\", DoubleType)()\n+    Seq(\n+      /* count = */ n,\n+      /* avg = */ newAvg,\n+      /* m2 = */ newM2,\n+      /* m3 = */ newM3,\n+      /* m4 = */ newM4\n+    ).take(momentOrder + 1)"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Sorry for some miscommunication. The previous inline comments are useful here because `Lit(0.0)` carries no information. The comments are not necessary when the variable names can clearly tell what they are. Please recover the inline comments for initial values.\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T10:05:10Z",
    "diffHunk": "@@ -52,178 +50,162 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n   protected def momentOrder: Int\n \n   override def children: Seq[Expression] = Seq(child)\n-\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val n = AttributeReference(\"n\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  private def trimHigherOrder[T](expressions: Seq[T]) = expressions.take(momentOrder + 1)\n+\n+  override val aggBufferAttributes = trimHigherOrder(Seq(n, avg, m2, m3, m4))\n+\n+  override val initialValues: Seq[Expression] =\n+    trimHigherOrder(Seq(Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0)))"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "There is no difference for these initial values, the order does not matter here. Do you still think we should keep those comments? Or should I change to use `fill()`?\n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T18:01:08Z",
    "diffHunk": "@@ -52,178 +50,162 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n   protected def momentOrder: Int\n \n   override def children: Seq[Expression] = Seq(child)\n-\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val n = AttributeReference(\"n\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  private def trimHigherOrder[T](expressions: Seq[T]) = expressions.take(momentOrder + 1)\n+\n+  override val aggBufferAttributes = trimHigherOrder(Seq(n, avg, m2, m3, m4))\n+\n+  override val initialValues: Seq[Expression] =\n+    trimHigherOrder(Seq(Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0)))"
  }],
  "prId": 10960
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`EqualTo` => `===` (please check other occurrences) \n",
    "commit": "fe6fe50eae2490e7669a40200c34483533d2b632",
    "createdAt": "2016-02-02T10:05:15Z",
    "diffHunk": "@@ -52,178 +50,162 @@ abstract class CentralMomentAgg(child: Expression) extends ImperativeAggregate w\n   protected def momentOrder: Int\n \n   override def children: Seq[Expression] = Seq(child)\n-\n   override def nullable: Boolean = true\n-\n   override def dataType: DataType = DoubleType\n+  override def inputTypes: Seq[AbstractDataType] = Seq(DoubleType)\n+\n+  protected val n = AttributeReference(\"n\", DoubleType, nullable = false)()\n+  protected val avg = AttributeReference(\"avg\", DoubleType, nullable = false)()\n+  protected val m2 = AttributeReference(\"m2\", DoubleType, nullable = false)()\n+  protected val m3 = AttributeReference(\"m3\", DoubleType, nullable = false)()\n+  protected val m4 = AttributeReference(\"m4\", DoubleType, nullable = false)()\n+\n+  private def trimHigherOrder[T](expressions: Seq[T]) = expressions.take(momentOrder + 1)\n+\n+  override val aggBufferAttributes = trimHigherOrder(Seq(n, avg, m2, m3, m4))\n+\n+  override val initialValues: Seq[Expression] =\n+    trimHigherOrder(Seq(Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0), Literal(0.0)))\n+\n+  override val updateExpressions: Seq[Expression] = {\n+    val newN = n + Literal(1.0)\n+    val delta = child - avg\n+    val deltaN = delta / newN\n+    val newAvg = avg + deltaN\n+    val newM2 = m2 + delta * (delta - deltaN)\n+\n+    val delta2 = delta * delta\n+    val deltaN2 = deltaN * deltaN\n+    val newM3 = if (momentOrder >= 3) {\n+      m3 - Literal(3.0) * deltaN * newM2 + delta * (delta2 - deltaN2)\n+    } else {\n+      Literal(0.0)\n+    }\n+    val newM4 = if (momentOrder >= 4) {\n+      m4 - Literal(4.0) * deltaN * newM3 - Literal(6.0) * deltaN2 * newM2 +\n+        delta * (delta * delta2 - deltaN * deltaN2)\n+    } else {\n+      Literal(0.0)\n+    }\n \n-  override def inputTypes: Seq[AbstractDataType] = Seq(NumericType)\n+    trimHigherOrder(Seq(\n+      If(IsNull(child), n, newN),\n+      If(IsNull(child), avg, newAvg),\n+      If(IsNull(child), m2, newM2),\n+      If(IsNull(child), m3, newM3),\n+      If(IsNull(child), m4, newM4)\n+    ))\n+  }\n \n-  override def checkInputDataTypes(): TypeCheckResult =\n-    TypeUtils.checkForNumericExpr(child.dataType, s\"function $prettyName\")\n+  override val mergeExpressions: Seq[Expression] = {\n \n-  override def aggBufferSchema: StructType = StructType.fromAttributes(aggBufferAttributes)\n+    val n1 = n.left\n+    val n2 = n.right\n+    val newN = n1 + n2\n+    val delta = avg.right - avg.left\n+    val deltaN = If(EqualTo(newN, Literal(0.0)), Literal(0.0), delta / newN)"
  }],
  "prId": 10960
}]