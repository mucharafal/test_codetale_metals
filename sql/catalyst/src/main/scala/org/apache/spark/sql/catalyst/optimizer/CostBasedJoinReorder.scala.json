[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Can you just recurse into the join? There is no point in repeating the code.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:22:19Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "How are you dealing with projects that create join columns, or columns that are used in the result?\r\n\r\nAt this stage of optimization it is relatively safe to assume that projects are there for a reason.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:51:31Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think we should assume the project list expressions are all attribute",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T23:48:20Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "@hvanhovell My goal is dealing with only consecutive joins, but due to column pruning, there could be Projects that break join chains. So I only want to support joins and projects from column pruning here.\r\nBut I didn't realize there could be other projects like you mentioned above.\r\nThen what about we recurse only when the project list are all attributes (not compound expression like `a+b`)?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T05:31:24Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Yeah, just check attribute only projections.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T09:19:27Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Same here: please recurse into the join. Also see the other comment about mutable state.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:22:48Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "This begs the question. Is this the right place to do the reordering? It seems to me that it would be an improvement to do this when we know the distribution and ordering of our the inputs. However the state of the art seems to first do local join reordering, and then optimize for distribution and ordering in a post processing stage.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:41:04Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "This is a good point. Ideally, choices of join order, join algorithm and enforcer like distribute and sort are made in the same algorithm, but two issues make this difficult to do in Spark.\r\n1. Catalyst separates logical optimization, physical implementation (strategies) and enforcer (EnsureRequirements) into different stages.\r\n2. If we want to consider choosing algorithms and enforcers, we need physical cost evaluation to guide us, while we don't have this now.\r\n\r\nSo in the current stage, join reordering is logical optimization. In the future after we support physical cost evaluation and maybe modify catalyst's structure, we can have a more mature algorithm. The DP framework will still work, the difference should be the logic of plan cost comparison.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:15:13Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Nit - it is a little bit shorter to write: `cond.toSet.flatMap(splitConjunctivePredicates)`",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:46:04Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Also make sure the predicates have been cannonicalized. That might improve your yield when reducing the plan.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:55:06Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Sorry can you explain a little more here? Why should I canonicalize?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T05:35:54Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Well I thought it might reduce the number of expressions by doing so, but it is probably not worth it.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T12:35:55Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Can we also add LeftSemi joins here?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:53:30Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "NVM you cannot decouple the predicate from the join.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:11:51Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Same comment: Just recurse into the join.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T10:56:01Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "I am not really sure you need this. Just internalize this in the `search` and `searchForLevel` functions. That will also allow you to turn this into an object.\r\n\r\nBTW, if ever need to do something like this again. Use: `Array.fill(items.length)(mutable.Map.empty)` ",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T11:27:06Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Use `k <= level - k` or something more like that?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T11:28:59Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "This is a very complex way of writing: `(i <- 0 until joinPlansLevelK.size) { }`",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T11:54:18Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "It took me a while to understand that you are writing to this. Please reorganize this into a function that takes the previous results and generates new result. For example:\r\n```scala\r\ntype JoinPlanMap = Map[Set[Int], JoinPlan]\r\nprivate def searchLevel(previous: Seq[JoinPlanMap]): JoinPlanMap = {\r\n  val result = mutable.Map.empty[JoinPlanMap]\r\n  val level = previous.size\r\n  var k = 0\r\n  while (k <= level - k) {\r\n    // Current code\r\n    ...\r\n    k += 1\r\n  }\r\n  result\r\n}\r\n```\r\nand then you use the following in `search`:\r\n```scala\r\n// Create the initial plans: each plan is a single item with zero cost.\r\nval foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\r\n  case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0))\r\n})\r\n\r\n// Build the next plans.\r\nvar level = 1\r\nwhile (i < items.length) {\r\n  foundPlans += searchLevel(level)\r\n  level += 1\r\n}\r\n```",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:14:48Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "What is happening to index `0`? Are you skipping this on purpose?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:15:26Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Yes, I just want level i to represent plans for i items, it's more intuitive I think.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:17:50Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I personally think it is more confusing if you start at `1`.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T12:36:59Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Doesn't this mean that the algorithm might not converge as as soon as we have a cross join in there? We should either just plan the cross joins at the end, or return a result for them.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:46:16Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space."
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "After the `ReorderJoin` optimization rule, cross join are all at the end. Maybe I should use `Inner` join type instead of `InnerLike` while collecting joinable items, such that we don't need to worry about cross join during reordering?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:21:45Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space."
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I am not entirely sure we should count on this. It is generally better not to make assumption on the result of rules that should have been running.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T16:12:10Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space."
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Do we need a separate `Cost` class? Or are we planning to use different cost models?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:47:55Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Yes, in the future we could have a more comprehensive model including physical costs.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:27:36Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "I am not sure if this is Ok according to the style guide :)...\r\n\r\nSame for `<`...",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:48:44Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Sorry can you give me a clue about the style? Is it about the method name? I see `BitSet.scala` has something similar like `def &(other: BitSet): BitSet`.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:30:10Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`def +` should be OK, but `def <` looks weird as it's not symmetric. How about we add `def value: Double` and use `cost1.value < cost2.value`?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T00:02:39Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "We need to compute a relative value inside the comparison logic, how about change the name to `def lt` or `def lessThan`?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T06:57:01Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I am just talking about overloading symbols. I suppose this is fine for now.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T12:38:08Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "In databricks scala style, it says:\r\n\r\n> Do NOT use symbolic method names, unless you are defining them for natural arithmetic operations (e.g. +, -, *, /). \r\n\r\nHere both `+` and `<` are natural arithmetic operations, so I think they are ok.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T02:35:56Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Ok good :)",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T09:30:10Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {\n+            Project(newJoin.output.filter(neededAttr.contains), newJoin)\n+          } else {\n+            newJoin\n+          }\n+        val itemIds = curJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+        return Some(JoinPlan(itemIds, newPlan, cost))\n+      }\n+    }\n+    None\n+  }\n+\n+  private def collectJoinConds(plan: LogicalPlan): Set[Expression] = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val leftConditions = collectJoinConds(left)\n+      val rightConditions = collectJoinConds(right)\n+      cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++ leftConditions ++ rightConditions\n+    case _ =>\n+      Set()\n+  }\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, sizeInBytes: BigInt) {\n+  /**\n+   * An empirical value for the weights of cardinality (number of rows) in the cost formula:\n+   * cost = rows * weight + size * (1 - weight), usually cardinality is more important than size.\n+   */\n+  val weight = 0.7\n+\n+  def +(other: Cost): Cost = Cost(rows + other.rows, sizeInBytes + other.sizeInBytes)"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "NIT: Just make one filter condition?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T12:51:11Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "This seems like a relatively expensive way to collect join conditions. Shouldn't we just add it to the `JoinPlan`?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T13:27:41Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "What is the rationale behind this cost calculation? Why aren't we using `JoinEstimation` here? ",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T13:30:02Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "JoinEstimation estimates the output size and cardinality of a join node. Here the cost of a JoinPlan is the sum of costs of all intermediate joins.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T15:25:43Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "But that means you are counting things twice right? Calling `LogicalPlan.stats(conf)` recursively determines costs for a `LogicalPlan`. The `JoinPlan` contains costs for the children of the join or 0 if there is no join. So if you combine those things seem to the duplicated, for example:\r\n```\r\nCURRENT = (TABLE A) JOIN (TABLE B) => Cost = c_A + c_B\r\nOTHER   = (TABLE C)\r\nJOIN    = ((TABLE A) JOIN (TABLE B) JOIN (TABLE C))\r\n```\r\nThis given the following cost structure (`J` is the join statistics estimation function):\r\n```\r\nCosts(CURRENT) = c_A + c_B\r\nCosts(OTHER)   = c_C\r\nCosts(JOIN)    = Costs(Current) + Cost(Other) + Cost((TABLE A) JOIN (TABLE B)) + Cost((TABLE C))\r\n               = c_A + c_B + J(c_A, c_B) + c_C\r\n```",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T16:09:21Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "- Join estimation give us output of a LogicalPlan `p`(its size and cardinality), denoted as `T(p)` for simplicity.\r\n- Cost of the plan is: `Cost(p) = sum(T(join))`, that is, the sum of output of all **intermediate** joins inside the tree of `p`, thus not include leaves or the root of tree. E.g. if p is (A J B) J C, A/B/C are leaves, then cost(p) is just T(A J B), rather than T(p) + T(A J B).\r\n\r\nThen, in the above example, suppose A/B/C are all joins, A J B is just another join, so we denote it as D.\r\n```\r\nCosts(CURRENT) = Costs(D) = sum(T(join1)), join1 doesn't contain D\r\nCosts(OTHER) = Costs(C) = sum(T(join2)), join2 doesn't contain C\r\nCosts(NEW_JOIN) = Costs(CURRENT) + Costs(OTHER) + T(D) + T(C)\r\n```\r\nSo there's no duplication here.\r\nMaybe it would be less confusing if the code looks like:\r\n```\r\nval cost = Cost(\r\n  curJoinPlan.cost.rows + curPlanStats.rowCount.get + otherJoinPlan.cost.rows + otherPlanStats.rowCount.get, \r\n  curJoinPlan.cost.size + curPlanStats.size + otherJoinPlan.cost.size + otherPlanStats.size)\r\n```",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T11:02:51Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Let's move `newJoin.outputSet.filter(neededAttr.contains)` into a separate variable.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T13:36:18Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {\n+        // Now both curPlan and otherPlan become intermediate joins, so the cost of the\n+        // new join should also include their costs.\n+        val cost = curJoinPlan.cost + otherJoinPlan.cost +\n+          Cost(curPlanStats.rowCount.get, curPlanStats.sizeInBytes) +\n+          Cost(otherPlanStats.rowCount.get, otherPlanStats.sizeInBytes)\n+\n+        // Put the deeper side on the left, tend to build a left-deep tree.\n+        val (left, right) = if (curJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+          (curPlan, otherPlan)\n+        } else {\n+          (otherPlan, curPlan)\n+        }\n+        val newJoin = Join(left, right, Inner, joinCond.reduceOption(And))\n+        val remainingConds = conditions -- collectJoinConds(newJoin)\n+        val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+        val newPlan =\n+          if ((newJoin.outputSet -- newJoin.outputSet.filter(neededAttr.contains)).nonEmpty) {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "When does this happen?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-03T13:39:26Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "When join estimation for `curPlan` and `otherPlan` both succeed.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T11:07:05Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Sorry, I mean the other way around. When will estimation fail? Will we still converge if estimation fails?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T12:32:09Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Estimation fails when at least one side (say plan A) of the join don't have rowCount in statistics.\r\nThen every plan who wants to join with A will fail. Finally there will be no plan in the last level, so the whole procedure of join reorder will also fail.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-04T13:51:39Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Shouldn't try to fail early here? We should certainly check if we can fail early when we cannot do this for one of the inputs.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T09:29:31Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "yea good point, we should check every item's rowCount at the beginning. Thanks.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T13:15:38Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:\n+ * First we put all items (basic joined nodes) into level 1, then we build all two-way joins\n+ * at level 2 from plans at level 1 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 1: p({A}), p({B}), p({C}), p({D})\n+ * level 2: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 3: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 4: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+case class JoinReorderDP(\n+    conf: CatalystConf,\n+    items: Seq[LogicalPlan],\n+    conditions: Set[Expression],\n+    topOutput: AttributeSet) extends PredicateHelper{\n+\n+  /** Level i maintains all found plans for sets of i joinable items. */\n+  val foundPlans = new Array[mutable.Map[Set[Int], JoinPlan]](items.length + 1)\n+  for (i <- 1 to items.length) foundPlans(i) = mutable.Map.empty\n+\n+  def search(): Option[LogicalPlan] = {\n+    // Start from the first level: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    foundPlans(1) ++=\n+      itemIndex.map { case (item, id) => Set(id) -> JoinPlan(Set(id), item, Cost(0, 0)) }\n+\n+    for (lev <- 2 to items.length) {\n+      searchForLevel(lev)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans in one level, based on previous levels. */\n+  private def searchForLevel(level: Int): Unit = {\n+    val foundPlansCurLevel = foundPlans(level)\n+    var k = 1\n+    var continue = true\n+    while (continue) {\n+      val otherLevel = level - k\n+      if (k > otherLevel) {\n+        // We can break from here, because when building a join from A and B, both A J B and B J A\n+        // are handled.\n+        continue = false\n+      } else {\n+        val joinPlansLevelK = foundPlans(k).values.toSeq\n+        for (i <- joinPlansLevelK.indices) {\n+          val curJoinPlan = joinPlansLevelK(i)\n+\n+          val joinPlansOtherLevel = if (k == otherLevel) {\n+            // Both sides of a join are at the same level, no need to repeat for previous ones.\n+            joinPlansLevelK.drop(i)\n+          } else {\n+            foundPlans(otherLevel).values.toSeq\n+          }\n+\n+          joinPlansOtherLevel.foreach { otherJoinPlan =>\n+            // Should not join two overlapping item sets.\n+            if (curJoinPlan.itemIds.intersect(otherJoinPlan.itemIds).isEmpty) {\n+              val joinPlan = buildJoin(curJoinPlan, otherJoinPlan)\n+              if (joinPlan.nonEmpty) {\n+                // Check if it's the first plan for the item set, or it's a better plan than\n+                // the existing one due to lower cost.\n+                val existingPlan = foundPlansCurLevel.get(joinPlan.get.itemIds)\n+                if (existingPlan.isEmpty || joinPlan.get.cost < existingPlan.get.cost) {\n+                  foundPlansCurLevel.update(joinPlan.get.itemIds, joinPlan.get)\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        k += 1\n+      }\n+    }\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(curJoinPlan: JoinPlan, otherJoinPlan: JoinPlan): Option[JoinPlan] = {\n+    // Check if these two nodes are inner joinable. We consider cartesian product very\n+    // costly, thus exclude such plans. This also helps us to reduce the search space.\n+    val curPlan = curJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    val joinCond = conditions\n+      .filterNot(l => canEvaluate(l, curPlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(curPlan.outputSet ++ otherPlan.outputSet))\n+\n+    if (joinCond.nonEmpty) {\n+      val curPlanStats = curPlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      if (curPlanStats.rowCount.nonEmpty && otherPlanStats.rowCount.nonEmpty) {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Could you mention which paper this comes from and the name algorithm you are using? The name of the algorithm is `DPsize` right?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T09:27:09Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "I referred to Selinger's paper: Access Path Selection in a Relational Database Management System.\r\nThe ideas are similar, but I don't know the reference of DPsize.\r\nAnyway, I'll mention Selinger's paper in the comment.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T13:31:30Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "The following slide deck mentions `DPSize`: http://dsg.uwaterloo.ca/seminars/notes/Guido.pdf\r\n\r\nThey seem to favor a more advanced DP approach called `DPccp`. ",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T14:06:55Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Thanks for the material. \r\nUsually for small number of joins (say less than 12), the current DP algorithm can work well. It has support from both academy (Selinger's paper) and industry (postgresql's standard join reorder). \r\nFor more complex joins and large number of joins, there will need lots of research and comparison for many kinds of algorithms, e.g. genetic algorithm is used in postgresql.\r\n",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-06T16:32:33Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }, {
    "author": {
      "login": "ron8hu"
    },
    "body": "@hvanhovell We had a meeting with Sameer and Wenchen on 2/21/2017.  We did not meet you as you were not in San Francisco office on that day.  In the meeting, we agreed to have a good join reorder algorithm implemented in CBO's first release as long as the algorithm has a good reference base.  We can improve the join reorder algorithm later in CBO's second release.  After all, we run short of time for Spark 2.2.  We decided to use the algorithm in Selinger's paper.  For CBO's first release, we will be happy with the join reorder algorithm if it can improve TPC-DS query performance without causing regression.   ",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-07T19:45:02Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "@ron8hu I am not saying we should change the algorithm. I was just wondering how we selected it. I think it is a good idea to start with a proven algorithm, so I think`DPSize` is a good idea.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-07T21:23:46Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      val (leftPlans, leftConditions) = extractInnerJoins(left)\n+      val (rightPlans, rightConditions) = extractInnerJoins(right)\n+      (leftPlans ++ rightPlans, cond.map(splitConjunctivePredicates).getOrElse(Nil).toSet ++\n+        leftConditions ++ rightConditions)\n+    case _ =>\n+      (Seq(plan), Set())\n+  }\n+\n+  def setOrdered(plan: LogicalPlan): Unit = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case Project(_, j @ Join(left, right, _: InnerLike, cond)) =>\n+      j.ordered = true\n+      setOrdered(left)\n+      setOrdered(right)\n+    case _ =>\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm:"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why do we have this case?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T08:12:51Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "I need to know the final output attributes to do column pruning when building new join nodes.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T08:21:47Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "can't we just transform to the child join node and leave the project node on top?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T08:33:38Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can we reuse `ExtractFiltersAndInnerJoins`?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T08:13:52Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "1. It's used before filter pushdown and column pruning, so the tree structure are different from that in our case.\r\n2. It only supports left-deep tree.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T08:24:18Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) if !j.ordered =>\n+          reorder(j, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) if !j.ordered =>\n+          reorder(j, j.outputSet)\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty) {\n+        JoinReorderDP(conf, items, conditions, output).search().getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set all inside joins ordered.\n+    setOrdered(result)\n+    result\n+  }\n+\n+  /**\n+   * Extract inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = plan match {"
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "NIT: You can make this pattern match a bit more precise by also checking if `join` is an actual `Join`.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T09:49:07Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>",
    "line": 90
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "It is even shorter when you make this a unary node :)",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T09:49:09Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {",
    "line": 97
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "NIT: I assume that you want to transform down the tree? If you do it is better to use `transformDown`.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T10:05:22Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {",
    "line": 39
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Just for my understanding: you are doing this to capture an attribute only projection on top of a join? Projections with meaningful expressions will just return the original plan.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T10:11:17Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>",
    "line": 40
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "You can put this in a val.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-08T10:12:01Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {\n+    override def left: LogicalPlan = join.left\n+    override def right: LogicalPlan = join.right\n+    override def output: Seq[Attribute] = join.output\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm. This implementation is based on the\n+ * paper: Access Path Selection in a Relational Database Management System.\n+ * http://www.inf.ed.ac.uk/teaching/courses/adbs/AccessPath.pdf\n+ *\n+ * First we put all items (basic joined nodes) into level 0, then we build all two-way joins\n+ * at level 1 from plans at level 0 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 0: p({A}), p({B}), p({C}), p({D})\n+ * level 1: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 2: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 3: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+object JoinReorderDP extends PredicateHelper {\n+\n+  def search(\n+      conf: CatalystConf,\n+      items: Seq[LogicalPlan],\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): Option[LogicalPlan] = {\n+\n+    // Level i maintains all found plans for i + 1 items.\n+    // Create the initial plans: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    val foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\n+      case (item, id) => Set(id) -> JoinPlan(Set(id), item, Set(), Cost(0, 0))\n+    }.toMap)\n+\n+    for (lev <- 1 until items.length) {\n+      // Build plans for the next level.\n+      foundPlans += searchLevel(foundPlans, conf, conditions, topOutput)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length - 1)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans at the next level, based on existing levels. */\n+  private def searchLevel(\n+      existingLevels: Seq[JoinPlanMap],\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlanMap = {\n+\n+    val nextLevel = mutable.Map.empty[Set[Int], JoinPlan]\n+    var k = 0\n+    val lev = existingLevels.length - 1\n+    // Build plans for the next level from plans at level k (one side of the join) and level\n+    // lev - k (the other side of the join).\n+    // For the lower level k, we only need to search from 0 to lev - k, because when building\n+    // a join from A and B, both A J B and B J A are handled.\n+    while (k <= lev - k) {\n+      val oneSideCandidates = existingLevels(k).values.toSeq\n+      for (i <- oneSideCandidates.indices) {\n+        val oneSidePlan = oneSideCandidates(i)\n+        val otherSideCandidates = if (k == lev - k) {\n+          // Both sides of a join are at the same level, no need to repeat for previous ones.\n+          oneSideCandidates.drop(i)\n+        } else {\n+          existingLevels(lev - k).values.toSeq\n+        }\n+\n+        otherSideCandidates.foreach { otherSidePlan =>\n+          // Should not join two overlapping item sets.\n+          if (oneSidePlan.itemIds.intersect(otherSidePlan.itemIds).isEmpty) {\n+            val joinPlan = buildJoin(oneSidePlan, otherSidePlan, conf, conditions, topOutput)\n+            // Check if it's the first plan for the item set, or it's a better plan than\n+            // the existing one due to lower cost.\n+            val existingPlan = nextLevel.get(joinPlan.itemIds)\n+            if (existingPlan.isEmpty || joinPlan.cost.lessThan(existingPlan.get.cost)) {\n+              nextLevel.update(joinPlan.itemIds, joinPlan)\n+            }\n+          }\n+        }\n+      }\n+      k += 1\n+    }\n+    nextLevel.toMap\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(\n+      oneJoinPlan: JoinPlan,\n+      otherJoinPlan: JoinPlan,\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlan = {\n+\n+    val onePlan = oneJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    // Now both onePlan and otherPlan become intermediate joins, so the cost of the\n+    // new join should also include their own cardinalities and sizes.\n+    val newCost = if (isCartesianProduct(onePlan) || isCartesianProduct(otherPlan)) {\n+      // We consider cartesian product very expensive, thus set a very large cost for it.\n+      // This enables to plan all the cartesian products at the end, because having a cartesian\n+      // product as an intermediate join will significantly increase a plan's cost, making it\n+      // impossible to be selected as the best plan for the items, unless there's no other choice.\n+      Cost(\n+        rows = BigInt(Long.MaxValue) * BigInt(Long.MaxValue),",
    "line": 220
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "How about\r\n\r\n`Extracts the join conditions and sub-plans of consecutive inner joins`",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T04:44:40Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.",
    "line": 68
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Nit: `items` -> `subplans`?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T04:45:11Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "By `items` I want to say that they are leaf plans. `subplan` sounds to include intermediate nodes.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T06:59:28Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Are we excluding non-leaf nodes here? It could be any sub-plan, right? For example, an outer join node could be returned as items?",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T07:07:27Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "Sorry my words were not accurate. By `leaf plan` I mean basic reorder unit, it can be any node. I want to use `item` to mean it's a basic unit, while `subplan` can be any level reordered results.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T14:22:38Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "`subplan` is a very general term. It is like sub-trees. `Items` does not convey the semantics you want. How about `inputPlans`",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T15:54:39Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "ok",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-19T03:54:31Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)",
    "line": 53
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Nit: `cond` -> `_`",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T04:48:32Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>",
    "line": 86
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "`rows` is confusing. Maybe `rowCount` or `numRows`. Or if you think it is too long, you also can use `card`.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T06:32:02Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {\n+    override def left: LogicalPlan = join.left\n+    override def right: LogicalPlan = join.right\n+    override def output: Seq[Attribute] = join.output\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm. This implementation is based on the\n+ * paper: Access Path Selection in a Relational Database Management System.\n+ * http://www.inf.ed.ac.uk/teaching/courses/adbs/AccessPath.pdf\n+ *\n+ * First we put all items (basic joined nodes) into level 0, then we build all two-way joins\n+ * at level 1 from plans at level 0 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 0: p({A}), p({B}), p({C}), p({D})\n+ * level 1: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 2: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 3: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+object JoinReorderDP extends PredicateHelper {\n+\n+  def search(\n+      conf: CatalystConf,\n+      items: Seq[LogicalPlan],\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): Option[LogicalPlan] = {\n+\n+    // Level i maintains all found plans for i + 1 items.\n+    // Create the initial plans: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    val foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\n+      case (item, id) => Set(id) -> JoinPlan(Set(id), item, Set(), Cost(0, 0))\n+    }.toMap)\n+\n+    for (lev <- 1 until items.length) {\n+      // Build plans for the next level.\n+      foundPlans += searchLevel(foundPlans, conf, conditions, topOutput)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length - 1)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans at the next level, based on existing levels. */\n+  private def searchLevel(\n+      existingLevels: Seq[JoinPlanMap],\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlanMap = {\n+\n+    val nextLevel = mutable.Map.empty[Set[Int], JoinPlan]\n+    var k = 0\n+    val lev = existingLevels.length - 1\n+    // Build plans for the next level from plans at level k (one side of the join) and level\n+    // lev - k (the other side of the join).\n+    // For the lower level k, we only need to search from 0 to lev - k, because when building\n+    // a join from A and B, both A J B and B J A are handled.\n+    while (k <= lev - k) {\n+      val oneSideCandidates = existingLevels(k).values.toSeq\n+      for (i <- oneSideCandidates.indices) {\n+        val oneSidePlan = oneSideCandidates(i)\n+        val otherSideCandidates = if (k == lev - k) {\n+          // Both sides of a join are at the same level, no need to repeat for previous ones.\n+          oneSideCandidates.drop(i)\n+        } else {\n+          existingLevels(lev - k).values.toSeq\n+        }\n+\n+        otherSideCandidates.foreach { otherSidePlan =>\n+          // Should not join two overlapping item sets.\n+          if (oneSidePlan.itemIds.intersect(otherSidePlan.itemIds).isEmpty) {\n+            val joinPlan = buildJoin(oneSidePlan, otherSidePlan, conf, conditions, topOutput)\n+            // Check if it's the first plan for the item set, or it's a better plan than\n+            // the existing one due to lower cost.\n+            val existingPlan = nextLevel.get(joinPlan.itemIds)\n+            if (existingPlan.isEmpty || joinPlan.cost.lessThan(existingPlan.get.cost)) {\n+              nextLevel.update(joinPlan.itemIds, joinPlan)\n+            }\n+          }\n+        }\n+      }\n+      k += 1\n+    }\n+    nextLevel.toMap\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(\n+      oneJoinPlan: JoinPlan,\n+      otherJoinPlan: JoinPlan,\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlan = {\n+\n+    val onePlan = oneJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    // Now both onePlan and otherPlan become intermediate joins, so the cost of the\n+    // new join should also include their own cardinalities and sizes.\n+    val newCost = if (isCartesianProduct(onePlan) || isCartesianProduct(otherPlan)) {\n+      // We consider cartesian product very expensive, thus set a very large cost for it.\n+      // This enables to plan all the cartesian products at the end, because having a cartesian\n+      // product as an intermediate join will significantly increase a plan's cost, making it\n+      // impossible to be selected as the best plan for the items, unless there's no other choice.\n+      Cost(\n+        rows = BigInt(Long.MaxValue) * BigInt(Long.MaxValue),\n+        size = BigInt(Long.MaxValue) * BigInt(Long.MaxValue))\n+    } else {\n+      val onePlanStats = onePlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      Cost(\n+        rows = oneJoinPlan.cost.rows + onePlanStats.rowCount.get +\n+          otherJoinPlan.cost.rows + otherPlanStats.rowCount.get,\n+        size = oneJoinPlan.cost.size + onePlanStats.sizeInBytes +\n+          otherJoinPlan.cost.size + otherPlanStats.sizeInBytes)\n+    }\n+\n+    // Put the deeper side on the left, tend to build a left-deep tree.\n+    val (left, right) = if (oneJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+      (onePlan, otherPlan)\n+    } else {\n+      (otherPlan, onePlan)\n+    }\n+    val joinConds = conditions\n+      .filterNot(l => canEvaluate(l, onePlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(onePlan.outputSet ++ otherPlan.outputSet))\n+    // We use inner join whether join condition is empty or not. Since cross join is\n+    // equivalent to inner join without condition.\n+    val newJoin = Join(left, right, Inner, joinConds.reduceOption(And))\n+    val collectedJoinConds = joinConds ++ oneJoinPlan.joinConds ++ otherJoinPlan.joinConds\n+    val remainingConds = conditions -- collectedJoinConds\n+    val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+    val neededFromNewJoin = newJoin.outputSet.filter(neededAttr.contains)\n+    val newPlan =\n+      if ((newJoin.outputSet -- neededFromNewJoin).nonEmpty) {\n+        Project(neededFromNewJoin.toSeq, newJoin)\n+      } else {\n+        newJoin\n+      }\n+\n+    val itemIds = oneJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+    JoinPlan(itemIds, newPlan, collectedJoinConds, newCost)\n+  }\n+\n+  private def isCartesianProduct(plan: LogicalPlan): Boolean = plan match {\n+    case Join(_, _, _, None) => true\n+    case Project(_, Join(_, _, _, None)) => true\n+    case _ => false\n+  }\n+\n+  /** Map[set of item ids, join plan for these items] */\n+  type JoinPlanMap = Map[Set[Int], JoinPlan]\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param joinConds Join conditions included in the plan.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, joinConds: Set[Expression], cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, size: BigInt) {",
    "line": 281
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "ok, I'll change it in a follow up, thanks.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-18T07:00:13Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {\n+    override def left: LogicalPlan = join.left\n+    override def right: LogicalPlan = join.right\n+    override def output: Seq[Attribute] = join.output\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm. This implementation is based on the\n+ * paper: Access Path Selection in a Relational Database Management System.\n+ * http://www.inf.ed.ac.uk/teaching/courses/adbs/AccessPath.pdf\n+ *\n+ * First we put all items (basic joined nodes) into level 0, then we build all two-way joins\n+ * at level 1 from plans at level 0 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 0: p({A}), p({B}), p({C}), p({D})\n+ * level 1: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 2: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 3: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+object JoinReorderDP extends PredicateHelper {\n+\n+  def search(\n+      conf: CatalystConf,\n+      items: Seq[LogicalPlan],\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): Option[LogicalPlan] = {\n+\n+    // Level i maintains all found plans for i + 1 items.\n+    // Create the initial plans: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    val foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\n+      case (item, id) => Set(id) -> JoinPlan(Set(id), item, Set(), Cost(0, 0))\n+    }.toMap)\n+\n+    for (lev <- 1 until items.length) {\n+      // Build plans for the next level.\n+      foundPlans += searchLevel(foundPlans, conf, conditions, topOutput)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length - 1)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans at the next level, based on existing levels. */\n+  private def searchLevel(\n+      existingLevels: Seq[JoinPlanMap],\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlanMap = {\n+\n+    val nextLevel = mutable.Map.empty[Set[Int], JoinPlan]\n+    var k = 0\n+    val lev = existingLevels.length - 1\n+    // Build plans for the next level from plans at level k (one side of the join) and level\n+    // lev - k (the other side of the join).\n+    // For the lower level k, we only need to search from 0 to lev - k, because when building\n+    // a join from A and B, both A J B and B J A are handled.\n+    while (k <= lev - k) {\n+      val oneSideCandidates = existingLevels(k).values.toSeq\n+      for (i <- oneSideCandidates.indices) {\n+        val oneSidePlan = oneSideCandidates(i)\n+        val otherSideCandidates = if (k == lev - k) {\n+          // Both sides of a join are at the same level, no need to repeat for previous ones.\n+          oneSideCandidates.drop(i)\n+        } else {\n+          existingLevels(lev - k).values.toSeq\n+        }\n+\n+        otherSideCandidates.foreach { otherSidePlan =>\n+          // Should not join two overlapping item sets.\n+          if (oneSidePlan.itemIds.intersect(otherSidePlan.itemIds).isEmpty) {\n+            val joinPlan = buildJoin(oneSidePlan, otherSidePlan, conf, conditions, topOutput)\n+            // Check if it's the first plan for the item set, or it's a better plan than\n+            // the existing one due to lower cost.\n+            val existingPlan = nextLevel.get(joinPlan.itemIds)\n+            if (existingPlan.isEmpty || joinPlan.cost.lessThan(existingPlan.get.cost)) {\n+              nextLevel.update(joinPlan.itemIds, joinPlan)\n+            }\n+          }\n+        }\n+      }\n+      k += 1\n+    }\n+    nextLevel.toMap\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(\n+      oneJoinPlan: JoinPlan,\n+      otherJoinPlan: JoinPlan,\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlan = {\n+\n+    val onePlan = oneJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    // Now both onePlan and otherPlan become intermediate joins, so the cost of the\n+    // new join should also include their own cardinalities and sizes.\n+    val newCost = if (isCartesianProduct(onePlan) || isCartesianProduct(otherPlan)) {\n+      // We consider cartesian product very expensive, thus set a very large cost for it.\n+      // This enables to plan all the cartesian products at the end, because having a cartesian\n+      // product as an intermediate join will significantly increase a plan's cost, making it\n+      // impossible to be selected as the best plan for the items, unless there's no other choice.\n+      Cost(\n+        rows = BigInt(Long.MaxValue) * BigInt(Long.MaxValue),\n+        size = BigInt(Long.MaxValue) * BigInt(Long.MaxValue))\n+    } else {\n+      val onePlanStats = onePlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      Cost(\n+        rows = oneJoinPlan.cost.rows + onePlanStats.rowCount.get +\n+          otherJoinPlan.cost.rows + otherPlanStats.rowCount.get,\n+        size = oneJoinPlan.cost.size + onePlanStats.sizeInBytes +\n+          otherJoinPlan.cost.size + otherPlanStats.sizeInBytes)\n+    }\n+\n+    // Put the deeper side on the left, tend to build a left-deep tree.\n+    val (left, right) = if (oneJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+      (onePlan, otherPlan)\n+    } else {\n+      (otherPlan, onePlan)\n+    }\n+    val joinConds = conditions\n+      .filterNot(l => canEvaluate(l, onePlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(onePlan.outputSet ++ otherPlan.outputSet))\n+    // We use inner join whether join condition is empty or not. Since cross join is\n+    // equivalent to inner join without condition.\n+    val newJoin = Join(left, right, Inner, joinConds.reduceOption(And))\n+    val collectedJoinConds = joinConds ++ oneJoinPlan.joinConds ++ otherJoinPlan.joinConds\n+    val remainingConds = conditions -- collectedJoinConds\n+    val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+    val neededFromNewJoin = newJoin.outputSet.filter(neededAttr.contains)\n+    val newPlan =\n+      if ((newJoin.outputSet -- neededFromNewJoin).nonEmpty) {\n+        Project(neededFromNewJoin.toSeq, newJoin)\n+      } else {\n+        newJoin\n+      }\n+\n+    val itemIds = oneJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+    JoinPlan(itemIds, newPlan, collectedJoinConds, newCost)\n+  }\n+\n+  private def isCartesianProduct(plan: LogicalPlan): Boolean = plan match {\n+    case Join(_, _, _, None) => true\n+    case Project(_, Join(_, _, _, None)) => true\n+    case _ => false\n+  }\n+\n+  /** Map[set of item ids, join plan for these items] */\n+  type JoinPlanMap = Map[Set[Int], JoinPlan]\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param joinConds Join conditions included in the plan.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, joinConds: Set[Expression], cost: Cost)\n+}\n+\n+/** This class defines the cost model. */\n+case class Cost(rows: BigInt, size: BigInt) {",
    "line": 281
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This is pretty important class. Could you add @param for both parameters? ",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-19T06:13:37Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {\n+    override def left: LogicalPlan = join.left\n+    override def right: LogicalPlan = join.right\n+    override def output: Seq[Attribute] = join.output\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm. This implementation is based on the\n+ * paper: Access Path Selection in a Relational Database Management System.\n+ * http://www.inf.ed.ac.uk/teaching/courses/adbs/AccessPath.pdf\n+ *\n+ * First we put all items (basic joined nodes) into level 0, then we build all two-way joins\n+ * at level 1 from plans at level 0 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 0: p({A}), p({B}), p({C}), p({D})\n+ * level 1: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 2: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 3: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+object JoinReorderDP extends PredicateHelper {\n+\n+  def search(\n+      conf: CatalystConf,\n+      items: Seq[LogicalPlan],\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): Option[LogicalPlan] = {\n+\n+    // Level i maintains all found plans for i + 1 items.\n+    // Create the initial plans: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    val foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\n+      case (item, id) => Set(id) -> JoinPlan(Set(id), item, Set(), Cost(0, 0))\n+    }.toMap)\n+\n+    for (lev <- 1 until items.length) {\n+      // Build plans for the next level.\n+      foundPlans += searchLevel(foundPlans, conf, conditions, topOutput)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length - 1)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans at the next level, based on existing levels. */\n+  private def searchLevel(\n+      existingLevels: Seq[JoinPlanMap],\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlanMap = {\n+\n+    val nextLevel = mutable.Map.empty[Set[Int], JoinPlan]\n+    var k = 0\n+    val lev = existingLevels.length - 1\n+    // Build plans for the next level from plans at level k (one side of the join) and level\n+    // lev - k (the other side of the join).\n+    // For the lower level k, we only need to search from 0 to lev - k, because when building\n+    // a join from A and B, both A J B and B J A are handled.\n+    while (k <= lev - k) {\n+      val oneSideCandidates = existingLevels(k).values.toSeq\n+      for (i <- oneSideCandidates.indices) {\n+        val oneSidePlan = oneSideCandidates(i)\n+        val otherSideCandidates = if (k == lev - k) {\n+          // Both sides of a join are at the same level, no need to repeat for previous ones.\n+          oneSideCandidates.drop(i)\n+        } else {\n+          existingLevels(lev - k).values.toSeq\n+        }\n+\n+        otherSideCandidates.foreach { otherSidePlan =>\n+          // Should not join two overlapping item sets.\n+          if (oneSidePlan.itemIds.intersect(otherSidePlan.itemIds).isEmpty) {\n+            val joinPlan = buildJoin(oneSidePlan, otherSidePlan, conf, conditions, topOutput)\n+            // Check if it's the first plan for the item set, or it's a better plan than\n+            // the existing one due to lower cost.\n+            val existingPlan = nextLevel.get(joinPlan.itemIds)\n+            if (existingPlan.isEmpty || joinPlan.cost.lessThan(existingPlan.get.cost)) {\n+              nextLevel.update(joinPlan.itemIds, joinPlan)\n+            }\n+          }\n+        }\n+      }\n+      k += 1\n+    }\n+    nextLevel.toMap\n+  }\n+\n+  /** Build a new join node. */\n+  private def buildJoin(\n+      oneJoinPlan: JoinPlan,\n+      otherJoinPlan: JoinPlan,\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlan = {\n+\n+    val onePlan = oneJoinPlan.plan\n+    val otherPlan = otherJoinPlan.plan\n+    // Now both onePlan and otherPlan become intermediate joins, so the cost of the\n+    // new join should also include their own cardinalities and sizes.\n+    val newCost = if (isCartesianProduct(onePlan) || isCartesianProduct(otherPlan)) {\n+      // We consider cartesian product very expensive, thus set a very large cost for it.\n+      // This enables to plan all the cartesian products at the end, because having a cartesian\n+      // product as an intermediate join will significantly increase a plan's cost, making it\n+      // impossible to be selected as the best plan for the items, unless there's no other choice.\n+      Cost(\n+        rows = BigInt(Long.MaxValue) * BigInt(Long.MaxValue),\n+        size = BigInt(Long.MaxValue) * BigInt(Long.MaxValue))\n+    } else {\n+      val onePlanStats = onePlan.stats(conf)\n+      val otherPlanStats = otherPlan.stats(conf)\n+      Cost(\n+        rows = oneJoinPlan.cost.rows + onePlanStats.rowCount.get +\n+          otherJoinPlan.cost.rows + otherPlanStats.rowCount.get,\n+        size = oneJoinPlan.cost.size + onePlanStats.sizeInBytes +\n+          otherJoinPlan.cost.size + otherPlanStats.sizeInBytes)\n+    }\n+\n+    // Put the deeper side on the left, tend to build a left-deep tree.\n+    val (left, right) = if (oneJoinPlan.itemIds.size >= otherJoinPlan.itemIds.size) {\n+      (onePlan, otherPlan)\n+    } else {\n+      (otherPlan, onePlan)\n+    }\n+    val joinConds = conditions\n+      .filterNot(l => canEvaluate(l, onePlan))\n+      .filterNot(r => canEvaluate(r, otherPlan))\n+      .filter(e => e.references.subsetOf(onePlan.outputSet ++ otherPlan.outputSet))\n+    // We use inner join whether join condition is empty or not. Since cross join is\n+    // equivalent to inner join without condition.\n+    val newJoin = Join(left, right, Inner, joinConds.reduceOption(And))\n+    val collectedJoinConds = joinConds ++ oneJoinPlan.joinConds ++ otherJoinPlan.joinConds\n+    val remainingConds = conditions -- collectedJoinConds\n+    val neededAttr = AttributeSet(remainingConds.flatMap(_.references)) ++ topOutput\n+    val neededFromNewJoin = newJoin.outputSet.filter(neededAttr.contains)\n+    val newPlan =\n+      if ((newJoin.outputSet -- neededFromNewJoin).nonEmpty) {\n+        Project(neededFromNewJoin.toSeq, newJoin)\n+      } else {\n+        newJoin\n+      }\n+\n+    val itemIds = oneJoinPlan.itemIds.union(otherJoinPlan.itemIds)\n+    JoinPlan(itemIds, newPlan, collectedJoinConds, newCost)\n+  }\n+\n+  private def isCartesianProduct(plan: LogicalPlan): Boolean = plan match {\n+    case Join(_, _, _, None) => true\n+    case Project(_, Join(_, _, _, None)) => true\n+    case _ => false\n+  }\n+\n+  /** Map[set of item ids, join plan for these items] */\n+  type JoinPlanMap = Map[Set[Int], JoinPlan]\n+\n+  /**\n+   * Partial join order in a specific level.\n+   *\n+   * @param itemIds Set of item ids participating in this partial plan.\n+   * @param plan The plan tree with the lowest cost for these items found so far.\n+   * @param joinConds Join conditions included in the plan.\n+   * @param cost The cost of this plan is the sum of costs of all intermediate joins.\n+   */\n+  case class JoinPlan(itemIds: Set[Int], plan: LogicalPlan, joinConds: Set[Expression], cost: Cost)\n+}\n+\n+/** This class defines the cost model. */",
    "line": 280
  }],
  "prId": 17138
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "We need a better description for this function. Also need to document the input parameters and the potential outputs.",
    "commit": "757e3b65083e860aba3d1161c914c547545a28f5",
    "createdAt": "2017-03-19T06:30:00Z",
    "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.expressions.{And, Attribute, AttributeSet, Expression, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.{Inner, InnerLike}\n+import org.apache.spark.sql.catalyst.plans.logical.{BinaryNode, Join, LogicalPlan, Project}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+\n+/**\n+ * Cost-based join reorder.\n+ * We may have several join reorder algorithms in the future. This class is the entry of these\n+ * algorithms, and chooses which one to use.\n+ */\n+case class CostBasedJoinReorder(conf: CatalystConf) extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = {\n+    if (!conf.cboEnabled || !conf.joinReorderEnabled) {\n+      plan\n+    } else {\n+      val result = plan transform {\n+        case p @ Project(projectList, j @ Join(_, _, _: InnerLike, _)) =>\n+          reorder(p, p.outputSet)\n+        case j @ Join(_, _, _: InnerLike, _) =>\n+          reorder(j, j.outputSet)\n+      }\n+      // After reordering is finished, convert OrderedJoin back to Join\n+      result transform {\n+        case oj: OrderedJoin => oj.join\n+      }\n+    }\n+  }\n+\n+  def reorder(plan: LogicalPlan, output: AttributeSet): LogicalPlan = {\n+    val (items, conditions) = extractInnerJoins(plan)\n+    val result =\n+      // Do reordering if the number of items is appropriate and join conditions exist.\n+      // We also need to check if costs of all items can be evaluated.\n+      if (items.size > 2 && items.size <= conf.joinReorderDPThreshold && conditions.nonEmpty &&\n+          items.forall(_.stats(conf).rowCount.isDefined)) {\n+        JoinReorderDP.search(conf, items, conditions, output).getOrElse(plan)\n+      } else {\n+        plan\n+      }\n+    // Set consecutive join nodes ordered.\n+    replaceWithOrderedJoin(result)\n+  }\n+\n+  /**\n+   * Extract consecutive inner joinable items and join conditions.\n+   * This method works for bushy trees and left/right deep trees.\n+   */\n+  private def extractInnerJoins(plan: LogicalPlan): (Seq[LogicalPlan], Set[Expression]) = {\n+    plan match {\n+      case Join(left, right, _: InnerLike, cond) =>\n+        val (leftPlans, leftConditions) = extractInnerJoins(left)\n+        val (rightPlans, rightConditions) = extractInnerJoins(right)\n+        (leftPlans ++ rightPlans, cond.toSet.flatMap(splitConjunctivePredicates) ++\n+          leftConditions ++ rightConditions)\n+      case Project(projectList, join) if projectList.forall(_.isInstanceOf[Attribute]) =>\n+        extractInnerJoins(join)\n+      case _ =>\n+        (Seq(plan), Set())\n+    }\n+  }\n+\n+  private def replaceWithOrderedJoin(plan: LogicalPlan): LogicalPlan = plan match {\n+    case j @ Join(left, right, _: InnerLike, cond) =>\n+      val replacedLeft = replaceWithOrderedJoin(left)\n+      val replacedRight = replaceWithOrderedJoin(right)\n+      OrderedJoin(j.copy(left = replacedLeft, right = replacedRight))\n+    case p @ Project(_, join) =>\n+      p.copy(child = replaceWithOrderedJoin(join))\n+    case _ =>\n+      plan\n+  }\n+\n+  /** This is a wrapper class for a join node that has been ordered. */\n+  private case class OrderedJoin(join: Join) extends BinaryNode {\n+    override def left: LogicalPlan = join.left\n+    override def right: LogicalPlan = join.right\n+    override def output: Seq[Attribute] = join.output\n+  }\n+}\n+\n+/**\n+ * Reorder the joins using a dynamic programming algorithm. This implementation is based on the\n+ * paper: Access Path Selection in a Relational Database Management System.\n+ * http://www.inf.ed.ac.uk/teaching/courses/adbs/AccessPath.pdf\n+ *\n+ * First we put all items (basic joined nodes) into level 0, then we build all two-way joins\n+ * at level 1 from plans at level 0 (single items), then build all 3-way joins from plans\n+ * at previous levels (two-way joins and single items), then 4-way joins ... etc, until we\n+ * build all n-way joins and pick the best plan among them.\n+ *\n+ * When building m-way joins, we only keep the best plan (with the lowest cost) for the same set\n+ * of m items. E.g., for 3-way joins, we keep only the best plan for items {A, B, C} among\n+ * plans (A J B) J C, (A J C) J B and (B J C) J A.\n+ *\n+ * Thus the plans maintained for each level when reordering four items A, B, C, D are as follows:\n+ * level 0: p({A}), p({B}), p({C}), p({D})\n+ * level 1: p({A, B}), p({A, C}), p({A, D}), p({B, C}), p({B, D}), p({C, D})\n+ * level 2: p({A, B, C}), p({A, B, D}), p({A, C, D}), p({B, C, D})\n+ * level 3: p({A, B, C, D})\n+ * where p({A, B, C, D}) is the final output plan.\n+ *\n+ * For cost evaluation, since physical costs for operators are not available currently, we use\n+ * cardinalities and sizes to compute costs.\n+ */\n+object JoinReorderDP extends PredicateHelper {\n+\n+  def search(\n+      conf: CatalystConf,\n+      items: Seq[LogicalPlan],\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): Option[LogicalPlan] = {\n+\n+    // Level i maintains all found plans for i + 1 items.\n+    // Create the initial plans: each plan is a single item with zero cost.\n+    val itemIndex = items.zipWithIndex\n+    val foundPlans = mutable.Buffer[JoinPlanMap](itemIndex.map {\n+      case (item, id) => Set(id) -> JoinPlan(Set(id), item, Set(), Cost(0, 0))\n+    }.toMap)\n+\n+    for (lev <- 1 until items.length) {\n+      // Build plans for the next level.\n+      foundPlans += searchLevel(foundPlans, conf, conditions, topOutput)\n+    }\n+\n+    val plansLastLevel = foundPlans(items.length - 1)\n+    if (plansLastLevel.isEmpty) {\n+      // Failed to find a plan, fall back to the original plan\n+      None\n+    } else {\n+      // There must be only one plan at the last level, which contains all items.\n+      assert(plansLastLevel.size == 1 && plansLastLevel.head._1.size == items.length)\n+      Some(plansLastLevel.head._2.plan)\n+    }\n+  }\n+\n+  /** Find all possible plans at the next level, based on existing levels. */\n+  private def searchLevel(\n+      existingLevels: Seq[JoinPlanMap],\n+      conf: CatalystConf,\n+      conditions: Set[Expression],\n+      topOutput: AttributeSet): JoinPlanMap = {\n+\n+    val nextLevel = mutable.Map.empty[Set[Int], JoinPlan]\n+    var k = 0\n+    val lev = existingLevels.length - 1\n+    // Build plans for the next level from plans at level k (one side of the join) and level\n+    // lev - k (the other side of the join).\n+    // For the lower level k, we only need to search from 0 to lev - k, because when building\n+    // a join from A and B, both A J B and B J A are handled.\n+    while (k <= lev - k) {\n+      val oneSideCandidates = existingLevels(k).values.toSeq\n+      for (i <- oneSideCandidates.indices) {\n+        val oneSidePlan = oneSideCandidates(i)\n+        val otherSideCandidates = if (k == lev - k) {\n+          // Both sides of a join are at the same level, no need to repeat for previous ones.\n+          oneSideCandidates.drop(i)\n+        } else {\n+          existingLevels(lev - k).values.toSeq\n+        }\n+\n+        otherSideCandidates.foreach { otherSidePlan =>\n+          // Should not join two overlapping item sets.\n+          if (oneSidePlan.itemIds.intersect(otherSidePlan.itemIds).isEmpty) {\n+            val joinPlan = buildJoin(oneSidePlan, otherSidePlan, conf, conditions, topOutput)\n+            // Check if it's the first plan for the item set, or it's a better plan than\n+            // the existing one due to lower cost.\n+            val existingPlan = nextLevel.get(joinPlan.itemIds)\n+            if (existingPlan.isEmpty || joinPlan.cost.lessThan(existingPlan.get.cost)) {\n+              nextLevel.update(joinPlan.itemIds, joinPlan)\n+            }\n+          }\n+        }\n+      }\n+      k += 1\n+    }\n+    nextLevel.toMap\n+  }\n+\n+  /** Build a new join node. */",
    "line": 202
  }],
  "prId": 17138
}]