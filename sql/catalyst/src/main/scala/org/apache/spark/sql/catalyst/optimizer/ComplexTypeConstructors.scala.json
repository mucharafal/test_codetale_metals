[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "`indexOf` returns -1 if we cannot find the key, you can use that instead of `cm.keys.contains(...)`.",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T20:53:04Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r\n+          val idx = cm.keys.indexOf(key)\r"
  }],
  "prId": 16043
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "`key: Literal`?",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T20:54:01Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r"
  }, {
    "author": {
      "login": "eyalfa"
    },
    "body": "assume constant folding already did its thing, otherwise there's not much we can do anyway",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:18:09Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "`cm: CreateMap`?",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:19:41Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Yeah, that is fair to assume. The I mean you don't need to desugar the entire literal. So you could also write:\r\n```scala\r\ncase gmv @ GetMapValue(cm @ CreateMap(elems), key: Literal) =>\r\n```",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:20:46Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r"
  }],
  "prId": 16043
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "name the file `complexTypes.scala`",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:02:00Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r"
  }],
  "prId": 16043
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Nit: directly call `createNamedStructLike.valExprs(ordinal)`",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:18:00Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r"
  }],
  "prId": 16043
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Style issue: `Cast( Literal( null ), gmv.dataType)` -> `Cast(Literal(null), gmv.dataType)`",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:19:04Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r\n+          val idx = cm.keys.indexOf(key)\r\n+          cm.values(idx)\r\n+        } else {\r\n+          Cast( Literal( null ), gmv.dataType)\r"
  }, {
    "author": {
      "login": "eyalfa"
    },
    "body": "actually modified to  Literal.create(null, gmv.dataType)\r\nconstants folding would have done thins anyway\r\n",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:35:37Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r\n+          val idx = cm.keys.indexOf(key)\r\n+          cm.values(idx)\r\n+        } else {\r\n+          Cast( Literal( null ), gmv.dataType)\r"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "My comment is just the style issue. Remove the useless space. ",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T23:01:43Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r\n+          val idx = cm.keys.indexOf(key)\r\n+          cm.values(idx)\r\n+        } else {\r\n+          Cast( Literal( null ), gmv.dataType)\r"
  }],
  "prId": 16043
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "`if ( cm.keys.contains( key ) ) {` -> `if (cm.keys.contains(key)) {`",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:21:19Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r"
  }, {
    "author": {
      "login": "eyalfa"
    },
    "body": "already modified according to @hvanhovell  comments",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T21:36:35Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "This is just another comment about the space. Please follow the code base about the space usage.",
    "commit": "32805cfb2176ab74c21ca93ab53f92852ad7fb24",
    "createdAt": "2016-11-28T23:02:32Z",
    "diffHunk": "@@ -0,0 +1,79 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.sql.catalyst.optimizer\r\n+\r\n+import org.apache.spark.sql.catalyst.expressions.{Cast, CreateArray, CreateMap, CreateNamedStructLike, Expression, GetArrayItem, GetArrayStructFields, GetMapValue, GetStructField, IntegerLiteral, Literal}\r\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\r\n+import org.apache.spark.sql.catalyst.rules.Rule\r\n+\r\n+/**\r\n+* push down operations into [[CreateNamedStructLike]].\r\n+*/\r\n+object SimplifyCreateStructOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field extraction\r\n+      case GetStructField( createNamedStructLike : CreateNamedStructLike, ordinal, _ ) =>\r\n+        val value = createNamedStructLike.valExprs(ordinal)\r\n+        value\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateArray]].\r\n+*/\r\n+object SimplifyCreateArrayOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // push down field selection (array of structs)\r\n+      case GetArrayStructFields(CreateArray(elems), field, ordinal, numFields, containsNull) =>\r\n+        def getStructField( elem : Expression ) = {\r\n+          GetStructField( elem, ordinal, Some(field.name) )\r\n+        }\r\n+        CreateArray( elems.map(getStructField) )\r\n+      // push down item selection.\r\n+      case ga @ GetArrayItem( CreateArray(elems), IntegerLiteral( idx ) ) =>\r\n+        if ( idx >= 0 && idx < elems.size ) {\r\n+          elems(idx)\r\n+        } else {\r\n+          Cast( Literal( null), ga.dataType )\r\n+        }\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+/**\r\n+* push down operations into [[CreateMap]].\r\n+*/\r\n+object SimplifyCreateMapOps extends Rule[LogicalPlan]{\r\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\r\n+    plan.transformExpressionsUp{\r\n+      // attempt to unfold 'constant' key extraction,\r\n+      // this enables other optimizations to take place.\r\n+      case gmv @ GetMapValue(cm @ CreateMap(elems), key @ Literal(v, t)) =>\r\n+        if ( cm.keys.contains( key ) ) {\r"
  }],
  "prId": 16043
}]