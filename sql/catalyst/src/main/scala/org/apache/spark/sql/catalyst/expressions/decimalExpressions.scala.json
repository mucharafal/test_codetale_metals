[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Is there a performance advantage to caching the result of the `nullOnOverflow` check instead of putting an `if-else` in `def nullSafeEval` itself?\r\n\r\nMy intuition (possibly wrong) is that a method call indirecting through `doEval` is going to be more expensive than a simple boolean check inside the body of `nullSafeEval` (or at least comparable).\r\n\r\nIf we don't have a strong motivation for this approach, I have a preference for the simpler:\r\n\r\n```scala\r\nprotected override def nullSafeEval(input: Any): Any = {\r\n  if (nullOnOverflow) {\r\n    new Decimal().setOrNull(input.asInstanceOf[Long], precision, scale)\r\n  } else {\r\n    new Decimal().set(input.asInstanceOf[Long], precision, scale)\r\n  }\r\n}\r\n```\r\n\r\nbecause it more closely matches the `doGenCode`.",
    "commit": "4928330c928e988f71002a5f5f17ae9283232e2a",
    "createdAt": "2019-06-29T16:17:43Z",
    "diffHunk": "@@ -46,19 +47,35 @@ case class UnscaledValue(child: Expression) extends UnaryExpression {\n  */\n case class MakeDecimal(child: Expression, precision: Int, scale: Int) extends UnaryExpression {\n \n+  private val nullOnOverflow = SQLConf.get.decimalOperationsNullOnOverflow\n+  private lazy val doEval = if (nullOnOverflow) {"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Usually the focus on perf is a bit less stressed in the evaluated code since we should never execute it, while it is critical for the codegen case. I don't have a strong preference. I can go with your suggestion, thanks.",
    "commit": "4928330c928e988f71002a5f5f17ae9283232e2a",
    "createdAt": "2019-06-29T17:02:01Z",
    "diffHunk": "@@ -46,19 +47,35 @@ case class UnscaledValue(child: Expression) extends UnaryExpression {\n  */\n case class MakeDecimal(child: Expression, precision: Int, scale: Int) extends UnaryExpression {\n \n+  private val nullOnOverflow = SQLConf.get.decimalOperationsNullOnOverflow\n+  private lazy val doEval = if (nullOnOverflow) {"
  }],
  "prId": 25010
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Is it safe to skip the assignment to `${ev.isNull}` in the `nullable = false` branch? \r\n\r\nI'm concerned about what would happen when the underlying variable that the `${ev.isNull} = ` updates has already been initialized (possibly to a default value): I _guess_ that's okay because then then when `nullable == false` the `isNull` variable already has the correct value (`false`).\r\n\r\nI was just curious whether there's existing precedence for this in codegen.\r\n\r\nShould we limit scope and keep the `isNull` assignment as we had it before (deferring this additional optimization)? Or should we keep this additional optimization citing precedence? (I'm not a codegen expert; mostly asking for my own curiousity, plus general conservatism about reducing number of branches / cases to review).",
    "commit": "4928330c928e988f71002a5f5f17ae9283232e2a",
    "createdAt": "2019-06-29T16:41:52Z",
    "diffHunk": "@@ -46,19 +47,35 @@ case class UnscaledValue(child: Expression) extends UnaryExpression {\n  */\n case class MakeDecimal(child: Expression, precision: Int, scale: Int) extends UnaryExpression {\n \n+  private val nullOnOverflow = SQLConf.get.decimalOperationsNullOnOverflow\n+  private lazy val doEval = if (nullOnOverflow) {\n+    input: Long => new Decimal().setOrNull(input, precision, scale)\n+  } else {\n+    input: Long => new Decimal().set(input, precision, scale)\n+  }\n+\n   override def dataType: DataType = DecimalType(precision, scale)\n-  override def nullable: Boolean = true\n+  override def nullable: Boolean = child.nullable || nullOnOverflow\n   override def toString: String = s\"MakeDecimal($child,$precision,$scale)\"\n \n-  protected override def nullSafeEval(input: Any): Any =\n-    Decimal(input.asInstanceOf[Long], precision, scale)\n+  protected override def nullSafeEval(input: Any): Any = doEval(input.asInstanceOf[Long])\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     nullSafeCodeGen(ctx, ev, eval => {\n+      val setMethod = if (nullOnOverflow) {\n+        \"setOrNull\"\n+      } else {\n+        \"set\"\n+      }\n+      val setNull = if (nullable) {",
    "line": 38
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Not only it is safe, but it doesn't even compile to make that assignment in the nullable case. If a variable is not nullable, its `isNull` variable is just the constant `false`: so no assignment has to be done (please see the code in `nullSafeCodeGen`).\r\n\r\n> I was just curious whether there's existing precedence for this in codegen.\r\n\r\nYou can find similar patterns in `collectionOperations.scala`\r\n",
    "commit": "4928330c928e988f71002a5f5f17ae9283232e2a",
    "createdAt": "2019-06-29T17:05:43Z",
    "diffHunk": "@@ -46,19 +47,35 @@ case class UnscaledValue(child: Expression) extends UnaryExpression {\n  */\n case class MakeDecimal(child: Expression, precision: Int, scale: Int) extends UnaryExpression {\n \n+  private val nullOnOverflow = SQLConf.get.decimalOperationsNullOnOverflow\n+  private lazy val doEval = if (nullOnOverflow) {\n+    input: Long => new Decimal().setOrNull(input, precision, scale)\n+  } else {\n+    input: Long => new Decimal().set(input, precision, scale)\n+  }\n+\n   override def dataType: DataType = DecimalType(precision, scale)\n-  override def nullable: Boolean = true\n+  override def nullable: Boolean = child.nullable || nullOnOverflow\n   override def toString: String = s\"MakeDecimal($child,$precision,$scale)\"\n \n-  protected override def nullSafeEval(input: Any): Any =\n-    Decimal(input.asInstanceOf[Long], precision, scale)\n+  protected override def nullSafeEval(input: Any): Any = doEval(input.asInstanceOf[Long])\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     nullSafeCodeGen(ctx, ev, eval => {\n+      val setMethod = if (nullOnOverflow) {\n+        \"setOrNull\"\n+      } else {\n+        \"set\"\n+      }\n+      val setNull = if (nullable) {",
    "line": 38
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "TIL! Thanks for clarifying.",
    "commit": "4928330c928e988f71002a5f5f17ae9283232e2a",
    "createdAt": "2019-06-29T17:17:50Z",
    "diffHunk": "@@ -46,19 +47,35 @@ case class UnscaledValue(child: Expression) extends UnaryExpression {\n  */\n case class MakeDecimal(child: Expression, precision: Int, scale: Int) extends UnaryExpression {\n \n+  private val nullOnOverflow = SQLConf.get.decimalOperationsNullOnOverflow\n+  private lazy val doEval = if (nullOnOverflow) {\n+    input: Long => new Decimal().setOrNull(input, precision, scale)\n+  } else {\n+    input: Long => new Decimal().set(input, precision, scale)\n+  }\n+\n   override def dataType: DataType = DecimalType(precision, scale)\n-  override def nullable: Boolean = true\n+  override def nullable: Boolean = child.nullable || nullOnOverflow\n   override def toString: String = s\"MakeDecimal($child,$precision,$scale)\"\n \n-  protected override def nullSafeEval(input: Any): Any =\n-    Decimal(input.asInstanceOf[Long], precision, scale)\n+  protected override def nullSafeEval(input: Any): Any = doEval(input.asInstanceOf[Long])\n \n   override def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n     nullSafeCodeGen(ctx, ev, eval => {\n+      val setMethod = if (nullOnOverflow) {\n+        \"setOrNull\"\n+      } else {\n+        \"set\"\n+      }\n+      val setNull = if (nullable) {",
    "line": 38
  }],
  "prId": 25010
}]