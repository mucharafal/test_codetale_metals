[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about the case, `SELECT /*+ REPARTITION(a) */ * FROM t`?",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-23T02:30:02Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+",
    "line": 69
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Plz add tests for this exception.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-23T02:30:20Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)"
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "OK, I will add this later.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-23T03:53:36Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "You don't add this test yet?",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T06:30:30Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)"
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Plz update the description in the top: https://github.com/apache/spark/pull/25464/files#diff-746a6d090224c7cfbe15daa27fa27408R141",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T05:38:07Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression("
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "plz keep `$hintName` here.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T06:31:07Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+\n     def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n       case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n         val hintName = h.name.toUpperCase(Locale.ROOT)\n         val shuffle = hintName match {\n           case \"REPARTITION\" => true\n           case \"COALESCE\" => false\n         }\n-        val numPartitions = h.parameters match {\n+\n+        h.parameters match {\n           case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n           case Seq(numPartitions: Int) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n+\n+          case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+          case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+\n           case _ =>\n-            throw new AnalysisException(s\"$hintName Hint expects a partition number as parameter\")\n+            throw new AnalysisException(\"Repartition hint expects a partition number \" +"
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "The test is  [here](https://github.com/apache/spark/pull/25464/files#diff-c3ddf7b5305e8fd629f36dac45318636R191).",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T07:23:25Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+\n     def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n       case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n         val hintName = h.name.toUpperCase(Locale.ROOT)\n         val shuffle = hintName match {\n           case \"REPARTITION\" => true\n           case \"COALESCE\" => false\n         }\n-        val numPartitions = h.parameters match {\n+\n+        h.parameters match {\n           case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n           case Seq(numPartitions: Int) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n+\n+          case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+          case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+\n           case _ =>\n-            throw new AnalysisException(s\"$hintName Hint expects a partition number as parameter\")\n+            throw new AnalysisException(\"Repartition hint expects a partition number \" +"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Ah, nice.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-29T05:52:11Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+\n     def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n       case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n         val hintName = h.name.toUpperCase(Locale.ROOT)\n         val shuffle = hintName match {\n           case \"REPARTITION\" => true\n           case \"COALESCE\" => false\n         }\n-        val numPartitions = h.parameters match {\n+\n+        h.parameters match {\n           case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n           case Seq(numPartitions: Int) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n+\n+          case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+          case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)\n+\n           case _ =>\n-            throw new AnalysisException(s\"$hintName Hint expects a partition number as parameter\")\n+            throw new AnalysisException(\"Repartition hint expects a partition number \" +"
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "how about passing `param.tail` instead of `param` here?",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T06:31:48Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+\n     def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n       case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n         val hintName = h.name.toUpperCase(Locale.ROOT)\n         val shuffle = hintName match {\n           case \"REPARTITION\" => true\n           case \"COALESCE\" => false\n         }\n-        val numPartitions = h.parameters match {\n+\n+        h.parameters match {\n           case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n           case Seq(numPartitions: Int) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n+\n+          case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)"
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "Eum, that will be more elegantã€‚ ",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T07:26:42Z",
    "diffHunk": "@@ -143,22 +143,41 @@ object ResolveHints {\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n     private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n \n+    private def createRepartitionByExpression(\n+        numPartitions: Int, parameters: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+      val exprs = parameters.drop(1)\n+      val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+      if (errExprs.nonEmpty) throw new AnalysisException(\n+        s\"\"\"Invalid type exprs : $errExprs\n+           |expects UnresolvedAttribute type\n+        \"\"\".stripMargin)\n+      RepartitionByExpression(\n+        exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+    }\n+\n     def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n       case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n         val hintName = h.name.toUpperCase(Locale.ROOT)\n         val shuffle = hintName match {\n           case \"REPARTITION\" => true\n           case \"COALESCE\" => false\n         }\n-        val numPartitions = h.parameters match {\n+\n+        h.parameters match {\n           case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n           case Seq(numPartitions: Int) =>\n-            numPartitions\n+            Repartition(numPartitions, shuffle, h.child)\n+\n+          case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+            createRepartitionByExpression(numPartitions, param, h)"
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "ulysses-you"
    },
    "body": "Deal with `repartitionByRange` separately, same as `Dataset.repartitionByRange()`.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-08-28T10:49:16Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (errExprs.nonEmpty) throw new AnalysisException(\n+          s\"\"\"Invalid type exprs : $errExprs\n+             |expects UnresolvedAttribute type\n+             |\"\"\".stripMargin)\n+        RepartitionByExpression(\n+          exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+\n+        case _ =>\n+          throw new AnalysisException(s\"${h.name} hint expects a partition number \" +\n+            \"and columns\")\n+      }\n+    }\n+\n+    /**\n+     * same with repartitionByRange api\n+     */\n+    private def createRepartitionByRange("
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "ulysses-you"
    },
    "body": "We cannot match `Column` here because of module dependency. ",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-09-02T01:54:05Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "How about the case below?\r\n```\r\nscala> df.hint(\"repartition\", 1, df(\"a\")).groupBy(\"a\").sum().explain(true)\r\norg.apache.spark.sql.AnalysisException: Repartition hint parameter should be columns but was ArrayBuffer(a#10);\r\n  at org.apache.spark.sql.catalyst.analysis.ResolveHints$ResolveCoalesceHints$.createRepartitionByExpression$1(ResolveHints.scala:154)\r\n  at org.apache.spark.sql.catalyst.analysis.ResolveHints$ResolveCoalesceHints$.org$apache$spark$sql$catalyst$analysis$ResolveHints$ResolveCoalesceHints$$createRepartition(ResolveHints.scala:169)\r\n```",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-09-10T02:36:31Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])"
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "How about the case `  def repartitionByRange(partitionExprs: Column*): Dataset[T] = {`?\r\nIt seems this hint can have columns only as  a parameter.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-09-10T02:35:50Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    val COALESCE_HINT_NAMES: Set[String] = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (errExprs.nonEmpty) throw new AnalysisException(\n+          s\"Repartition hint parameter should be columns but was $errExprs\")\n+        RepartitionByExpression(\n+          exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+\n+        case _ =>\n+          throw new AnalysisException(s\"${h.name} hint expects a partition number \" +\n+            \"and columns\")\n+      }\n+    }\n+\n+    /**\n+     * same with repartitionByRange api\n+     */\n+    private def createRepartitionByRange(\n+        h: UnresolvedHint): RepartitionByExpression = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val sortOrder: Seq[SortOrder] = exprs.map {\n+          case expr: SortOrder => expr\n+          case expr: Expression => SortOrder(expr, Ascending)\n+          case _ => throw new AnalysisException(\n+            s\"RepartitionByRange hint parameter should be columns but was $exprs\")\n+        }\n+        RepartitionByExpression(sortOrder, h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+"
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "Yeah, we can add `SQLConf` to this class. So does `repartition(partitionExprs: Column*)`.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-09-10T04:47:28Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    val COALESCE_HINT_NAMES: Set[String] = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (errExprs.nonEmpty) throw new AnalysisException(\n+          s\"Repartition hint parameter should be columns but was $errExprs\")\n+        RepartitionByExpression(\n+          exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+\n+        case _ =>\n+          throw new AnalysisException(s\"${h.name} hint expects a partition number \" +\n+            \"and columns\")\n+      }\n+    }\n+\n+    /**\n+     * same with repartitionByRange api\n+     */\n+    private def createRepartitionByRange(\n+        h: UnresolvedHint): RepartitionByExpression = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val sortOrder: Seq[SortOrder] = exprs.map {\n+          case expr: SortOrder => expr\n+          case expr: Expression => SortOrder(expr, Ascending)\n+          case _ => throw new AnalysisException(\n+            s\"RepartitionByRange hint parameter should be columns but was $exprs\")\n+        }\n+        RepartitionByExpression(sortOrder, h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+"
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "IIUC this hint cannot accept all the `Exception`...",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-09-10T02:38:31Z",
    "diffHunk": "@@ -137,28 +137,83 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\" and \"REPARTITIONBYRANGE\".\n+   * Its parameter includes a partition number and columns.\n    */\n   object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+    val COALESCE_HINT_NAMES: Set[String] = Set(\"COALESCE\", \"REPARTITION\", \"REPARTITIONBYRANGE\")\n+\n+    /**\n+     * same with repartition api\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, h: UnresolvedHint): LogicalPlan = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val errExprs = exprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (errExprs.nonEmpty) throw new AnalysisException(\n+          s\"Repartition hint parameter should be columns but was $errExprs\")\n+        RepartitionByExpression(\n+          exprs.map(_.asInstanceOf[UnresolvedAttribute]), h.child, numPartitions)\n+      }\n+\n+      h.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, h.child)\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail, h)\n+\n+        case _ =>\n+          throw new AnalysisException(s\"${h.name} hint expects a partition number \" +\n+            \"and columns\")\n+      }\n+    }\n+\n+    /**\n+     * same with repartitionByRange api\n+     */\n+    private def createRepartitionByRange(\n+        h: UnresolvedHint): RepartitionByExpression = {\n+      def createRepartitionByExpression(\n+           numPartitions: Int, exprs: Seq[Any], h: UnresolvedHint): RepartitionByExpression = {\n+        val sortOrder: Seq[SortOrder] = exprs.map {\n+          case expr: SortOrder => expr\n+          case expr: Expression => SortOrder(expr, Ascending)",
    "line": 93
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Hm, It's `REPARTITION()` but why does it creates range partition in this case? Do you intend to support range partition by something like `REPARTITION(...)`?",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-24T05:49:35Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITIONBYRANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)",
    "line": 62
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "Yeah, I tried to keep consistent with `Dataset.repartition()`. The latter has two methods `repartition(numPartitions: Int)` and `repartition(numPartitions: Int, partitionExprs: Column*)`\r\n\r\n",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-25T00:43:36Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITIONBYRANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)",
    "line": 62
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "`createRepartitionByExpression` seems duplicated. Can we just make one private function to share?",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-24T05:50:13Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITIONBYRANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) if shuffle =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    /**\n+     * This function handles hints for \"REPARTITIONBYRANGE\".\n+     * The \"REPARTITIONBYRANGE\" hint must have column names and a partition number is optional.\n+     */\n+    private def createRepartitionByRange(hint: UnresolvedHint): RepartitionByExpression = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(",
    "line": 77
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "Duplicated is in order to make method clearly for `repartition(...)` and `repartitionByRange(...)`. ",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-25T01:18:48Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITIONBYRANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) if shuffle =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    /**\n+     * This function handles hints for \"REPARTITIONBYRANGE\".\n+     * The \"REPARTITIONBYRANGE\" hint must have column names and a partition number is optional.\n+     */\n+    private def createRepartitionByRange(hint: UnresolvedHint): RepartitionByExpression = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(",
    "line": 77
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Hm, both inner function and duplication are discouraged but okay.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-29T09:29:56Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITIONBYRANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) if shuffle =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    /**\n+     * This function handles hints for \"REPARTITIONBYRANGE\".\n+     * The \"REPARTITIONBYRANGE\" hint must have column names and a partition number is optional.\n+     */\n+    private def createRepartitionByRange(hint: UnresolvedHint): RepartitionByExpression = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(",
    "line": 77
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we then consistently throw an exception like `Dataset.repartition`?\r\n\r\n```scala\r\n    val sortOrders = partitionExprs.filter(_.expr.isInstanceOf[SortOrder])\r\n    if (sortOrders.nonEmpty) throw new IllegalArgumentException(\r\n      s\"\"\"Invalid partitionExprs specified: $sortOrders\r\n         |For range partitioning use repartitionByRange(...) instead.\r\n       \"\"\".stripMargin)\r\n```",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-29T09:31:03Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITION_BY_RANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(",
    "line": 42
  }, {
    "author": {
      "login": "ulysses-you"
    },
    "body": "Good point, add an IllegalArgumentException check.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-10-29T13:33:02Z",
    "diffHunk": "@@ -137,31 +137,96 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITION_BY_RANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(",
    "line": 42
  }],
  "prId": 25464
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shouldn't we return `hint` here? This will cause stack overflow once the hint is not the root node.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-11-22T11:05:14Z",
    "diffHunk": "@@ -137,31 +137,101 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITION_BY_RANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val sortOrders = partitionExprs.filter(_.isInstanceOf[SortOrder])\n+        if (sortOrders.nonEmpty) throw new IllegalArgumentException(\n+          s\"\"\"Invalid partitionExprs specified: $sortOrders\n+             |For range partitioning use REPARTITION_BY_RANGE instead.\n+           \"\"\".stripMargin)\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) if shuffle =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    /**\n+     * This function handles hints for \"REPARTITION_BY_RANGE\".\n+     * The \"REPARTITION_BY_RANGE\" hint must have column names and a partition number is optional.\n+     */\n+    private def createRepartitionByRange(hint: UnresolvedHint): RepartitionByExpression = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n         }\n-        val numPartitions = h.parameters match {\n-          case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n-          case Seq(numPartitions: Int) =>\n-            numPartitions\n-          case _ =>\n-            throw new AnalysisException(s\"$hintName Hint expects a partition number as parameter\")\n+        val sortOrder = partitionExprs.map {\n+          case expr: SortOrder => expr\n+          case expr: Expression => SortOrder(expr, Ascending)\n+        }\n+        RepartitionByExpression(sortOrder, hint.child, numPartitions)\n+      }\n+\n+      hint.parameters match {\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n+      case hint @ UnresolvedHint(hintName, _, _) => hintName.toUpperCase(Locale.ROOT) match {\n+          case \"REPARTITION\" =>\n+            createRepartition(shuffle = true, hint)\n+          case \"COALESCE\" =>\n+            createRepartition(shuffle = false, hint)\n+          case \"REPARTITION_BY_RANGE\" =>\n+            createRepartitionByRange(hint)\n+          case _ => plan",
    "line": 116
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Ah, yes. I will make a followup. Thanks for catching this.",
    "commit": "4ac7eb612bd11f1feced3f3b28cb7e8b2a43c11f",
    "createdAt": "2019-11-22T18:08:14Z",
    "diffHunk": "@@ -137,31 +137,101 @@ object ResolveHints {\n   }\n \n   /**\n-   * COALESCE Hint accepts name \"COALESCE\" and \"REPARTITION\".\n-   * Its parameter includes a partition number.\n+   * COALESCE Hint accepts names \"COALESCE\", \"REPARTITION\", and \"REPARTITION_BY_RANGE\".\n    */\n-  object ResolveCoalesceHints extends Rule[LogicalPlan] {\n-    private val COALESCE_HINT_NAMES = Set(\"COALESCE\", \"REPARTITION\")\n+  class ResolveCoalesceHints(conf: SQLConf) extends Rule[LogicalPlan] {\n+\n+    /**\n+     * This function handles hints for \"COALESCE\" and \"REPARTITION\".\n+     * The \"COALESCE\" hint only has a partition number as a parameter. The \"REPARTITION\" hint\n+     * has a partition number, columns, or both of them as parameters.\n+     */\n+    private def createRepartition(\n+        shuffle: Boolean, hint: UnresolvedHint): LogicalPlan = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val sortOrders = partitionExprs.filter(_.isInstanceOf[SortOrder])\n+        if (sortOrders.nonEmpty) throw new IllegalArgumentException(\n+          s\"\"\"Invalid partitionExprs specified: $sortOrders\n+             |For range partitioning use REPARTITION_BY_RANGE instead.\n+           \"\"\".stripMargin)\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n+        }\n+        RepartitionByExpression(\n+          partitionExprs.map(_.asInstanceOf[Expression]), hint.child, numPartitions)\n+      }\n \n-    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n-      case h: UnresolvedHint if COALESCE_HINT_NAMES.contains(h.name.toUpperCase(Locale.ROOT)) =>\n-        val hintName = h.name.toUpperCase(Locale.ROOT)\n-        val shuffle = hintName match {\n-          case \"REPARTITION\" => true\n-          case \"COALESCE\" => false\n+      hint.parameters match {\n+        case Seq(IntegerLiteral(numPartitions)) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        case Seq(numPartitions: Int) =>\n+          Repartition(numPartitions, shuffle, hint.child)\n+        // The \"COALESCE\" hint (shuffle = false) must have a partition number only\n+        case _ if !shuffle =>\n+          throw new AnalysisException(s\"$hintName Hint expects a partition number as a parameter\")\n+\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) if shuffle =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) if shuffle =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    /**\n+     * This function handles hints for \"REPARTITION_BY_RANGE\".\n+     * The \"REPARTITION_BY_RANGE\" hint must have column names and a partition number is optional.\n+     */\n+    private def createRepartitionByRange(hint: UnresolvedHint): RepartitionByExpression = {\n+      val hintName = hint.name.toUpperCase(Locale.ROOT)\n+\n+      def createRepartitionByExpression(\n+          numPartitions: Int, partitionExprs: Seq[Any]): RepartitionByExpression = {\n+        val invalidParams = partitionExprs.filter(!_.isInstanceOf[UnresolvedAttribute])\n+        if (invalidParams.nonEmpty) {\n+          throw new AnalysisException(s\"$hintName Hint parameter should include columns, but \" +\n+            s\"${invalidParams.mkString(\", \")} found\")\n         }\n-        val numPartitions = h.parameters match {\n-          case Seq(IntegerLiteral(numPartitions)) =>\n-            numPartitions\n-          case Seq(numPartitions: Int) =>\n-            numPartitions\n-          case _ =>\n-            throw new AnalysisException(s\"$hintName Hint expects a partition number as parameter\")\n+        val sortOrder = partitionExprs.map {\n+          case expr: SortOrder => expr\n+          case expr: Expression => SortOrder(expr, Ascending)\n+        }\n+        RepartitionByExpression(sortOrder, hint.child, numPartitions)\n+      }\n+\n+      hint.parameters match {\n+        case param @ Seq(IntegerLiteral(numPartitions), _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(numPartitions: Int, _*) =>\n+          createRepartitionByExpression(numPartitions, param.tail)\n+        case param @ Seq(_*) =>\n+          createRepartitionByExpression(conf.numShufflePartitions, param)\n+      }\n+    }\n+\n+    def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperators {\n+      case hint @ UnresolvedHint(hintName, _, _) => hintName.toUpperCase(Locale.ROOT) match {\n+          case \"REPARTITION\" =>\n+            createRepartition(shuffle = true, hint)\n+          case \"COALESCE\" =>\n+            createRepartition(shuffle = false, hint)\n+          case \"REPARTITION_BY_RANGE\" =>\n+            createRepartitionByRange(hint)\n+          case _ => plan",
    "line": 116
  }],
  "prId": 25464
}]