[{
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "why do we need this?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T13:56:35Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   can name collision occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            substituteCTE(currentPlan, cteName, traverseAndSubstituteCTE(ctePlan, true))\n+        }\n+\n+      case o if inTraverse =>\n+        o.transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, inTraverse))\n+        }\n+    }\n+\n+  // A CTE definition might not be used at all so ctePlan is call by name.\n+  private def substituteCTE(\n+      plan: LogicalPlan,\n+      cteName: String,\n+      ctePlan: => LogicalPlan): LogicalPlan = {\n+    lazy val lazyCTEPlan = ctePlan"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "Thanks @mgaido91! It is not needed indeed.",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T14:33:06Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   can name collision occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            substituteCTE(currentPlan, cteName, traverseAndSubstituteCTE(ctePlan, true))\n+        }\n+\n+      case o if inTraverse =>\n+        o.transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, inTraverse))\n+        }\n+    }\n+\n+  // A CTE definition might not be used at all so ctePlan is call by name.\n+  private def substituteCTE(\n+      plan: LogicalPlan,\n+      cteName: String,\n+      ctePlan: => LogicalPlan): LogicalPlan = {\n+    lazy val lazyCTEPlan = ctePlan"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "I remember now why I used lazy here. A CTE definition can be used multiple times in `WITH` but the call by name parameter (`ctePlan  = traverseAndSubstituteCTE(...)`) should be executed only once.\r\nBut now I believe it is better to use lazy outside of `substituteCTE` than inside, please review my commit https://github.com/apache/spark/pull/24831/commits/7d6910599134dc992bc841dfd3eff6f46d36647b.",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T19:11:00Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   can name collision occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            substituteCTE(currentPlan, cteName, traverseAndSubstituteCTE(ctePlan, true))\n+        }\n+\n+      case o if inTraverse =>\n+        o.transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, inTraverse))\n+        }\n+    }\n+\n+  // A CTE definition might not be used at all so ctePlan is call by name.\n+  private def substituteCTE(\n+      plan: LogicalPlan,\n+      cteName: String,\n+      ctePlan: => LogicalPlan): LogicalPlan = {\n+    lazy val lazyCTEPlan = ctePlan"
  }],
  "prId": 24831
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "```suggestion\r\n   *                   case name collision can occur\r\n```",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T14:00:14Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   can name collision occur"
  }],
  "prId": 24831
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "`inTraverse` can be replaced with `true`, right?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T14:01:08Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   can name collision occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            substituteCTE(currentPlan, cteName, traverseAndSubstituteCTE(ctePlan, true))\n+        }\n+\n+      case o if inTraverse =>\n+        o.transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, inTraverse))"
  }],
  "prId": 24831
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "private?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T23:00:28Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {"
  }],
  "prId": 24831
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Why we need this flag? Some tests would fail if we have not?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-01T23:31:54Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   case name collision can occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            lazy val substitutedCTEPlan = traverseAndSubstituteCTE(ctePlan, true)\n+            substituteCTE(currentPlan, cteName, substitutedCTEPlan)\n+        }\n+\n+      case o if inTraverse =>"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "No it would not, but I wanted to do CTE substitution in the current plan only (not in the subqueries) if it is safe. (CTE substitution will run for subqueries later anyway.)",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-02T06:18:36Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.internal.SQLConf\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {\n+  def apply(plan: LogicalPlan): LogicalPlan = if (SQLConf.get.legacyCTESubstitutionEnabled) {\n+    legacyTraverseAndsubstituteCTE(plan)\n+  } else {\n+    traverseAndSubstituteCTE(plan, false)\n+  }\n+\n+  def legacyTraverseAndsubstituteCTE(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {\n+    case With(child, relations) =>\n+      // substitute CTE expressions right-to-left to resolve references to previous CTEs:\n+      // with a as (select * from t), b as (select * from a) select * from b\n+      relations.foldRight(child) {\n+        case ((cteName, ctePlan), currentPlan) => substituteCTE(currentPlan, cteName, ctePlan)\n+      }\n+    case other => other\n+  }\n+\n+  /**\n+   * Traverse the plan and expression nodes as a tree and replace matching references to CTE\n+   * definitions.\n+   * - If the rule encounters a WITH node then it substitutes the child of the node with CTE\n+   *   definitions of the node right-to-left order as a definition can reference to a previous\n+   *   one.\n+   *   For example the following query is valid:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (SELECT * FROM t)\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains an inner WITH node then substitution of inner should take\n+   *   precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH\n+   *     t AS (SELECT 1),\n+   *     t2 AS (\n+   *       WITH t AS (SELECT 2)\n+   *       SELECT * FROM t\n+   *     )\n+   *   SELECT * FROM t2\n+   * - If a CTE definition contains a subquery that contains an inner WITH node then substitution\n+   *   of inner should take precedence because it can shadow an outer CTE definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1 AS c)\n+   *   SELECT max(c) FROM (\n+   *     WITH t AS (SELECT 2 AS c)\n+   *     SELECT * FROM t\n+   *   )\n+   * - If a CTE definition contains a subquery expression that contains an inner WITH node then\n+   *   substitution of inner should take precedence because it can shadow an outer CTE\n+   *   definition.\n+   *   For example the following query should return 2:\n+   *   WITH t AS (SELECT 1)\n+   *   SELECT (\n+   *     WITH t AS (SELECT 2)\n+   *     SELECT * FROM t\n+   *   )\n+   * @param plan  the plan to be traversed\n+   * @param inTraverse whether the current traverse is called from another traverse, only in this\n+   *                   case name collision can occur\n+   * @return then plan where CTE substitution is applied\n+   */\n+  private def traverseAndSubstituteCTE(plan: LogicalPlan, inTraverse: Boolean): LogicalPlan =\n+    plan.resolveOperatorsUp {\n+      case With(child: LogicalPlan, relations) =>\n+        val traversedChild = child transformExpressions {\n+          case e: SubqueryExpression => e.withNewPlan(traverseAndSubstituteCTE(e.plan, true))\n+        }\n+\n+        relations.foldRight(traversedChild) {\n+          case ((cteName, ctePlan), currentPlan) =>\n+            lazy val substitutedCTEPlan = traverseAndSubstituteCTE(ctePlan, true)\n+            substituteCTE(currentPlan, cteName, substitutedCTEPlan)\n+        }\n+\n+      case o if inTraverse =>"
  }],
  "prId": 24831
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "can we avoid moving the class, in order to keep the diff smaller?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-02T19:25:47Z",
    "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {"
  }, {
    "author": {
      "login": "peter-toth"
    },
    "body": "The idea of moving the rule to a separate file came from here: https://github.com/apache/spark/pull/24831#discussion_r298864911, but I think you are right @mgaido91, because we cut the scope and split the PR since that. Maybe the other part (https://github.com/apache/spark/pull/25029) could extract the rule to a separate file as that one makes the rule a bit more complicated. Does that work for you @maropu?",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-03T07:13:52Z",
    "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Yes, that was what I meant, we can move the rule in the other PR which refactors it more thoroughly. ",
    "commit": "9ec6eaf3f1b992ae3c0101464483f3a7c9c8f70a",
    "createdAt": "2019-07-03T08:11:57Z",
    "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.expressions.SubqueryExpression\n+import org.apache.spark.sql.catalyst.plans.logical.{LogicalPlan, With}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+/**\n+ * Analyze WITH nodes and substitute child plan with CTE definitions.\n+ */\n+object CTESubstitution extends Rule[LogicalPlan] {"
  }],
  "prId": 24831
}]