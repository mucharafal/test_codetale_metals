[{
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "nit: can we move this closer to when it is used, ie. before `val paramsFromColumns ...`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T20:43:59Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Moved.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-01T03:35:22Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "ditto",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T20:44:07Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "nit: I would prefer an if after pattern matching instead of two pattern matching, but it is fine also as it is now. If you prefer to let it like this, please just `b` -> `_` since `b` is never used",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T20:50:43Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "what about making this a mutable collection to avoid its complete copy here https://github.com/apache/spark/pull/19813/files#diff-0fcf78140c2c4edef3840822ac41563eR204?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T20:57:48Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "why `toSeq`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T20:58:33Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code == \"\") {\n+              inputVars += ((inputVar.expr, inputVar.exprCode))\n+            } else {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputVars.toSeq"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "shouldn't this line be removed? I think it is useless..",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T21:00:23Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "sorry for the question, I am just curious, why do longs and doubles require an additional param?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T21:03:06Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code == \"\") {\n+              inputVars += ((inputVar.expr, inputVar.exprCode))\n+            } else {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputVars.toSeq\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "It is based on the spec: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3\r\n\r\n> The total length is calculated by summing the contributions of the individual parameters, where a parameter of type long or double contributes two units to the length and a parameter of any other type contributes one unit. \r\n\r\nIf you ask why it requires two units, I don't know exactly the reason. But I guess it may related to the units long or double occupies in operand stack: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6.2 \r\n",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-01T02:49:33Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code == \"\") {\n+              inputVars += ((inputVar.expr, inputVar.exprCode))\n+            } else {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputVars.toSeq\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "thank you very much! :)",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-01T10:53:23Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code == \"\") {\n+              inputVars += ((inputVar.expr, inputVar.exprCode))\n+            } else {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputVars.toSeq\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "what about `map(calculateParamLength(ctx, _)).sum`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T21:05:28Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          if (first.inputRow != null) {\n+            inputRows += first.inputRow\n+          }\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code != \"\") {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputRows.toSeq\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes match {\n+        case first :: others =>\n+          exprCodes = others\n+          first.inputVars.foreach { inputVar =>\n+            if (inputVar.exprCode.code == \"\") {\n+              inputVars += ((inputVar.expr, inputVar.exprCode))\n+            } else {\n+              exprCodes = inputVar.exprCode :: exprCodes\n+            }\n+          }\n+        case _ =>\n+      }\n+    }\n+    inputVars.toSeq\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Start value is 1 for `this`.\n+    (inputs ++ subExprs).distinct.foldLeft(1) { case (curLength, input) =>"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "same comment as for `trackDownVar`",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-11-30T21:08:10Z",
    "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+      (subExprState.value, subExprState.isNull)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    var exprCodes: List[ExprCode] = List(exprCode)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "How about avoid duplication of similar logic in `getParamsForSubExprs`?  \r\nIn `getParamsForSubExprs`, I think that `subExprs` corresponds to `inputAttrs` and `inputVars` corresponds to `subExprs.map(ctx.subExprEliminationExprs(_))`.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-01T04:36:33Z",
    "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(",
    "line": 222
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yes, sure.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-01T04:53:07Z",
    "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val paramsFromSubExprs = getParamsForSubExprs(ctx, subExprs)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Given the list of eliminated subexpressions used in the children expressions, returns the\n+   * strings of funtion parameters. The first is the variable names used to call the function,\n+   * the second is the parameters used to declare the function in generated code.\n+   */\n+  def getParamsForSubExprs(\n+      ctx: CodegenContext,\n+      subExprs: Seq[Expression]): Seq[(String, String)] = {\n+    subExprs.flatMap { subExpr =>\n+      val argType = ctx.javaType(subExpr.dataType)\n+\n+      val subExprState = ctx.subExprEliminationExprs(subExpr)\n+\n+      if (!subExpr.nullable || subExprState.isNull == \"true\" || subExprState.isNull == \"false\") {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"))\n+      } else {\n+        Seq((subExprState.value, s\"$argType ${subExprState.value}\"),\n+          (subExprState.isNull, s\"boolean ${subExprState.isNull}\"))\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(",
    "line": 222
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "nit: what does `stat` mean? In general, it is related to `statistics`. Is it better to use another variable name?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T07:36:53Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val stat = ctx.subExprEliminationExprs(subExpr)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "It is for state. Yes, `state` is better and not to confuse.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T08:27:10Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val stat = ctx.subExprEliminationExprs(subExpr)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how to define `previously evaluated columns`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T07:49:44Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val stat = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = stat.value, isNull = stat.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.",
    "line": 142
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "They are output variables evaluated before generating code for this expression.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T08:30:02Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val stat = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = stat.value, isNull = stat.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.",
    "line": 142
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we support subexpression elimination when splitting codes to methods in the non-whole-stage-codegen path?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T07:55:13Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think so. The eliminated subexpressions will be extracted as parameters too.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-04T08:30:48Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I mean before your PR.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T06:11:34Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Oh, then it is no. Firstly we don't try to eliminate subexpressions before splitting codes now. Secondly, `splitExpressions` doesn't support subexpression elimination too.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T07:19:46Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think supporting subexpression elimination in `splitExpressions` really worth an individual JIRA, can we do it in a new PR? This PR should focus on supporting `splitExpressions` in whole stage codegen.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T07:35:35Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "If I get rid of the part of extracting subexpressions as parameters, some tests will be failed.\r\n\r\nBecause hash aggregation uses subexpression elimination under wholestage codegen, this PR enables splitting expression codes under wholestage codegen, so it inevitably needs to include subexpression parameters.\r\n\r\nThis PR doesn't yet to support `splitExpressions` in wholestage codegen. This is only applied to split codes of deeply nested expression now. But the added API can be applied to `splitExpressions` later to support wholestage codegen That is a TODO.\r\n\r\n",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T07:48:04Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Maybe we should move the supporting of subexpression elimination in `splitExpressions` to a new PR and merge that first. Reviewing 2 non-trivial optimizations at the same time is hard.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T08:55:52Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "This PR doesn't touch `splitExpressions`. Yes, the APIs created here can be used to support subexpression elimination and wholestage codegen for `splitExpressions`. I plan to add those support in later PRs.\r\n\r\nActually there are not too much change related to subexpression elimination support in this PR. Only two APIs `getSubExprInChildren` and `getSubExprCodes` are specified for that. They are relatively small change.\r\n\r\nIf you still think it is better to split this part to a new PR that adds subexpression elimination support to `splitExpressions`, I can make it. What do you think?\r\n\r\n",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T11:03:24Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Defines util methods",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T13:54:07Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation."
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think the whole stage codegen framework guarantees that, if one of the `ctx.currentVars` is referred by expressions, it must be evaluated. Did you hit cases that break it?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T13:57:57Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "You mean deferred expressions? Yes, we can't pass tests if we don't consider it. Some variables can be deferred to evaluate in the operators. ",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T14:12:53Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "In whole stage codegen framework, each operator defines the input attributes it needs, and the framework will pre-evaluate them. This means, if one of the `ctx.currentVars` is referred, it must have already been evaluated.\r\n\r\nDo you still remember which tests were failed? Maybe it's a bug.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T14:58:09Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "For example, `ProjectExec` doesn't pre-evaluate all input attributes from its child operator.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T15:11:29Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I just did a quick test. Some tests like `org.apache.spark.ml.tuning.TrainValidationSplitSuite` and `org.apache.spark.ml.classification.GBTClassifierSuite` will fail.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T15:38:19Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "yea, because the expressions in `ProjectExec` may only need a subset of the input attributes. For those input attributes that are not pre-evaluated, they should not be referred, or do I miss something?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-05T15:40:25Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Currently `ProjectExec` only pre-evaluates the input attributes which are referred more than twice. Otherwise, we defer the evaluation until input attribute is actually used.\r\n",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-06T01:31:27Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "`FilterExec` is another example. It doesn't pre-evaluate any input attributes and defer the evaluation to when we evaluate the related predicates.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-06T02:11:26Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ah i see, thanks for the explanation!",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T13:46:46Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines APIs used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.",
    "line": 39
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is it possible that `ev.value` is a literal?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:31:46Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Hmm, I think if an output is a literal, will we refer it as an attribute? Won't we replace all attribute reference for it with actual literal?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T15:42:29Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "If we have concern for this, shall we use a regex to test against if it is a literal?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T15:49:15Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "a common strategy we use: assign `ev.value` to a temp variable, and use that temp variable to build method parameters.\r\n\r\ncc @kiszk @mgaido91 who I think have done something like this.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T16:37:35Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. Sounds good.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T23:50:17Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "The strategy is useful when only one parameter. We may have many parameters now, seems to me it is a bit inefficient to create temp variables for all parameters.\r\n\r\nWe don't need regex to detect literals. Since we know the first character for Java variable is [a-zA-Z_$], can we just determine whether `ev.value` is a variable by looking at its first character?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-08T01:14:50Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "sounds good, we can create a `isLiteral` method in `ExprCode`",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-08T01:47:40Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[Expression], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(Expression, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq((b, ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(Expression, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(Expression, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += ((inputVar.expr, inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: Expression): Int = {\n+    ctx.javaType(input.dataType) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input.nullable => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input.nullable => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(\n+      ctx: CodegenContext,\n+      inputs: Seq[Expression],\n+      subExprs: Seq[Expression]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + (inputs ++ subExprs).distinct.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[Expression],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {\n+    inputAttrs.zip(inputVars).flatMap { case (input, ev) =>\n+      val argType = ctx.javaType(input.dataType)\n+\n+      if (!input.nullable || ev.isNull == \"true\" || ev.isNull == \"false\") {\n+        Seq((ev.value, s\"$argType ${ev.value}\"))\n+      } else {\n+        Seq((ev.value, s\"$argType ${ev.value}\"), (ev.isNull, s\"boolean ${ev.isNull}\"))"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "if code == \"\", we don't need to track down the row?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:35:08Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yea, it means the bound reference is based on an evaluated variable.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:58:13Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we have a real example of having more than one input row?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:35:55Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I just quickly ran some tests. For example, `DataFrameSuite` has few tests failed if we don't consider this.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T15:31:11Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is it true for all JVMs?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:36:19Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Not sure about this. Since it is defined by JVM spec, I think it is applied to all JVMs? cc @kiszk ",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T14:42:39Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "It is true for all JVMs. See [here](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.11)",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T16:52:40Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Thanks @kiszk ",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-07T23:50:37Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "note: since we split functions out if the code length is large enough, I think we won't possibly hit this limit. This is more like a safety guard.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-08T03:37:17Z",
    "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred bu children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subExprs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs, subExprs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "is `(Seq[ExprProperty], Seq[ExprCode])` just `Seq[ExprInputVar]`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T12:46:50Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yea, just `Seq[ExprInputVar]`.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:51:50Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I feel we can add a `isEvaluated` method in `ExprCode`, to make this assumption more explicit that empty code means already evaluated.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T12:55:56Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(ExprProperty, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:52:00Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(ExprProperty, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit: I feel it's more readable to first handle sub-expr, then input var, finally input row.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:00:11Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about just accepts `inputs: Seq[ExprInputVar]`?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:02:14Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(ExprProperty, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq(((b.dataType, b.nullable), ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(ExprProperty, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(ExprProperty, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += (((inputVar.dataType, inputVar.nullable), inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: ExprProperty): Int = {\n+    ctx.javaType(input._1) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input._2 => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input._2 => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(ctx: CodegenContext, inputs: Seq[ExprProperty]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + inputs.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[ExprProperty],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Sure.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:52:09Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal).code != \"\" =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code != \"\") {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): (Seq[ExprProperty], Seq[ExprCode]) = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct.unzip\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[(ExprProperty, ExprCode)] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).code == \"\" =>\n+        Seq(((b.dataType, b.nullable), ctx.currentVars(ordinal)))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[(ExprProperty, ExprCode)] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[(ExprProperty, ExprCode)]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.code == \"\") {\n+          inputVars += (((inputVar.dataType, inputVar.nullable), inputVar.exprCode))\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: ExprProperty): Int = {\n+    ctx.javaType(input._1) match {\n+      case (ctx.JAVA_LONG | ctx.JAVA_DOUBLE) if !input._2 => 2\n+      case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 3\n+      case _ if !input._2 => 1\n+      case _ => 2\n+    }\n+  }\n+\n+  /**\n+   * In Java, a method descriptor is valid only if it represents method parameters with a total\n+   * length of 255 or less. `this` contributes one unit and a parameter of type long or double\n+   * contributes two units.\n+   */\n+  def getParamLength(ctx: CodegenContext, inputs: Seq[ExprProperty]): Int = {\n+    // Initial value is 1 for `this`.\n+    1 + inputs.map(calculateParamLength(ctx, _)).sum\n+  }\n+\n+  /**\n+   * Given the lists of input attributes and variables to this expression, returns the strings of\n+   * funtion parameters. The first is the variable names used to call the function, the second is\n+   * the parameters used to declare the function in generated code.\n+   */\n+  def prepareFunctionParams(\n+      ctx: CodegenContext,\n+      inputAttrs: Seq[ExprProperty],\n+      inputVars: Seq[ExprCode]): Seq[(String, String)] = {"
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why do we need to add sub-expr to parameter list? ",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:04:04Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "seems we only need it for sub-expr of whole stage codegen?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:09:03Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Is it? Don't we also do sub-expr elimination in normal codegen?",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T13:52:57Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "in normal codegen the sub-expr `value` and `isNull` are all global variables.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T14:25:00Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Verified, yes. We can get rid of sub-expr parameters in normal codegen.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T14:31:44Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "let's not worried about it now, I feel we can get rid of global variables for normal sub-expr elimination.",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-11T14:35:31Z",
    "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  // Type alias for a tuple representing the data type and nullable for an expression.\n+  type ExprProperty = (DataType, Boolean)\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val (inputAttrs, inputVars) = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputAttrs, inputVars)\n+\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subAttrs = subExprs.map(e => (e.dataType, e.nullable))\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subAttrs, subExprCodes)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputAttrs ++ subAttrs) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {",
    "line": 87
  }],
  "prId": 19813
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit\r\n```\r\nctx.javaType(input.dataType) match {\r\n  case ctx.JAVA_LONG | ctx.JAVA_DOUBLE => 2\r\n  case _ => 1\r\n} + (if (input.isNullable) 1 else 0)\r\n```",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-12T07:22:02Z",
    "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subVars = subExprs.zip(subExprCodes).map { case (subExpr, subExprCode) =>\n+      ExprInputVar(subExprCode, subExpr.dataType, subExpr.nullable)\n+    }\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subVars)\n+\n+    val inputVars = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputVars)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputVars ++ subVars) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if !ctx.currentVars(ordinal).isEvaluated() =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (!inputVar.exprCode.isEvaluated()) {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): Seq[ExprInputVar] = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[ExprInputVar] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).isEvaluated() =>\n+        Seq(ExprInputVar(ctx.currentVars(ordinal), b.dataType, b.nullable))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[ExprInputVar] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[ExprInputVar]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.isEvaluated()) {\n+          inputVars += inputVar\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: ExprInputVar): Int = {\n+    ctx.javaType(input.dataType) match {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. ",
    "commit": "f35974e1dfb47387dc952d30a55eee0354bdea63",
    "createdAt": "2017-12-12T07:40:00Z",
    "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * Defines util methods used in expression code generation.\n+ */\n+object ExpressionCodegen {\n+\n+  /**\n+   * Given an expression, returns the all necessary parameters to evaluate it, so the generated\n+   * code of this expression can be split in a function.\n+   * The 1st string in returned tuple is the parameter strings used to call the function.\n+   * The 2nd string in returned tuple is the parameter strings used to declare the function.\n+   *\n+   * Returns `None` if it can't produce valid parameters.\n+   *\n+   * Params to include:\n+   * 1. Evaluated columns referred by this, children or deferred expressions.\n+   * 2. Rows referred by this, children or deferred expressions.\n+   * 3. Eliminated subexpressions referred by children expressions.\n+   */\n+  def getExpressionInputParams(\n+      ctx: CodegenContext,\n+      expr: Expression): Option[(Seq[String], Seq[String])] = {\n+    val subExprs = getSubExprInChildren(ctx, expr)\n+    val subExprCodes = getSubExprCodes(ctx, subExprs)\n+    val subVars = subExprs.zip(subExprCodes).map { case (subExpr, subExprCode) =>\n+      ExprInputVar(subExprCode, subExpr.dataType, subExpr.nullable)\n+    }\n+    val paramsFromSubExprs = prepareFunctionParams(ctx, subVars)\n+\n+    val inputVars = getInputVarsForChildren(ctx, expr)\n+    val paramsFromColumns = prepareFunctionParams(ctx, inputVars)\n+\n+    val inputRows = ctx.INPUT_ROW +: getInputRowsForChildren(ctx, expr)\n+    val paramsFromRows = inputRows.distinct.filter(_ != null).map { row =>\n+      (row, s\"InternalRow $row\")\n+    }\n+\n+    val paramsLength = getParamLength(ctx, inputVars ++ subVars) + paramsFromRows.length\n+    // Maximum allowed parameter number for Java's method descriptor.\n+    if (paramsLength > 255) {\n+      None\n+    } else {\n+      val allParams = (paramsFromRows ++ paramsFromColumns ++ paramsFromSubExprs).unzip\n+      val callParams = allParams._1.distinct\n+      val declParams = allParams._2.distinct\n+      Some((callParams, declParams))\n+    }\n+  }\n+\n+  /**\n+   * Returns the eliminated subexpressions in the children expressions.\n+   */\n+  def getSubExprInChildren(ctx: CodegenContext, expr: Expression): Seq[Expression] = {\n+    expr.children.flatMap { child =>\n+      child.collect {\n+        case e if ctx.subExprEliminationExprs.contains(e) => e\n+      }\n+    }.distinct\n+  }\n+\n+  /**\n+   * A small helper function to return `ExprCode`s that represent subexpressions.\n+   */\n+  def getSubExprCodes(ctx: CodegenContext, subExprs: Seq[Expression]): Seq[ExprCode] = {\n+    subExprs.map { subExpr =>\n+      val state = ctx.subExprEliminationExprs(subExpr)\n+      ExprCode(code = \"\", value = state.value, isNull = state.isNull)\n+    }\n+  }\n+\n+  /**\n+   * Retrieves previous input rows referred by children and deferred expressions.\n+   */\n+  def getInputRowsForChildren(ctx: CodegenContext, expr: Expression): Seq[String] = {\n+    expr.children.flatMap(getInputRows(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previous input rows referred by it or deferred expressions\n+   * which are needed to evaluate it.\n+   */\n+  def getInputRows(ctx: CodegenContext, child: Expression): Seq[String] = {\n+    child.flatMap {\n+      // An expression directly evaluates on current input row.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars == null ||\n+          ctx.currentVars(ordinal) == null =>\n+        Seq(ctx.INPUT_ROW)\n+\n+      // An expression which is not evaluated yet. Tracks down to find input rows.\n+      case BoundReference(ordinal, _, _) if !ctx.currentVars(ordinal).isEvaluated() =>\n+        trackDownRow(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down input rows referred by the generated code snippet.\n+   */\n+  def trackDownRow(ctx: CodegenContext, exprCode: ExprCode): Seq[String] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputRows = mutable.ArrayBuffer.empty[String]\n+\n+    while (exprCodes.nonEmpty) {\n+      val curExprCode = exprCodes.dequeue()\n+      if (curExprCode.inputRow != null) {\n+        inputRows += curExprCode.inputRow\n+      }\n+      curExprCode.inputVars.foreach { inputVar =>\n+        if (!inputVar.exprCode.isEvaluated()) {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputRows\n+  }\n+\n+  /**\n+   * Retrieves previously evaluated columns referred by children and deferred expressions.\n+   * Returned tuple contains the list of expressions and the list of generated codes.\n+   */\n+  def getInputVarsForChildren(\n+      ctx: CodegenContext,\n+      expr: Expression): Seq[ExprInputVar] = {\n+    expr.children.flatMap(getInputVars(ctx, _)).distinct\n+  }\n+\n+  /**\n+   * Given a child expression, retrieves previously evaluated columns referred by it or\n+   * deferred expressions which are needed to evaluate it.\n+   */\n+  def getInputVars(ctx: CodegenContext, child: Expression): Seq[ExprInputVar] = {\n+    if (ctx.currentVars == null) {\n+      return Seq.empty\n+    }\n+\n+    child.flatMap {\n+      // An evaluated variable.\n+      case b @ BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null &&\n+          ctx.currentVars(ordinal).isEvaluated() =>\n+        Seq(ExprInputVar(ctx.currentVars(ordinal), b.dataType, b.nullable))\n+\n+      // An input variable which is not evaluated yet. Tracks down to find any evaluated variables\n+      // in the expression path.\n+      // E.g., if this expression is \"d = c + 1\" and \"c\" is not evaluated. We need to track to\n+      // \"c = a + b\" and see if \"a\" and \"b\" are evaluated. If they are, we need to return them so\n+      // to include them into parameters, if not, we track down further.\n+      case BoundReference(ordinal, _, _) if ctx.currentVars(ordinal) != null =>\n+        trackDownVar(ctx, ctx.currentVars(ordinal))\n+\n+      case _ => Seq.empty\n+    }.distinct\n+  }\n+\n+  /**\n+   * Tracks down previously evaluated columns referred by the generated code snippet.\n+   */\n+  def trackDownVar(ctx: CodegenContext, exprCode: ExprCode): Seq[ExprInputVar] = {\n+    val exprCodes = mutable.Queue[ExprCode](exprCode)\n+    val inputVars = mutable.ArrayBuffer.empty[ExprInputVar]\n+\n+    while (exprCodes.nonEmpty) {\n+      exprCodes.dequeue().inputVars.foreach { inputVar =>\n+        if (inputVar.exprCode.isEvaluated()) {\n+          inputVars += inputVar\n+        } else {\n+          exprCodes.enqueue(inputVar.exprCode)\n+        }\n+      }\n+    }\n+    inputVars\n+  }\n+\n+  /**\n+   * Helper function to calculate the size of an expression as function parameter.\n+   */\n+  def calculateParamLength(ctx: CodegenContext, input: ExprInputVar): Int = {\n+    ctx.javaType(input.dataType) match {"
  }],
  "prId": 19813
}]