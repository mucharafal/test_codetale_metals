[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This is a dumb question, but, where is the actual bitwise-xor implemented? I just can't see it. For my own info.",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-22T14:58:51Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(",
    "line": 107
  }, {
    "author": {
      "login": "yaooqinn"
    },
    "body": "We can implement `updateExpressions`,  `mergeExpressions ` logically, and they would be eventually codegened in `*Exec`s like `HashAggregateExec`",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-23T02:52:16Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(",
    "line": 107
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "@srowen we can treat `Expression` as a DSL, then this function is implemented by the DSL.",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-23T04:23:58Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(",
    "line": 107
  }],
  "prId": 26205
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "`BitAndAgg`, `BitOrAgg`, and `BitXorAgg` has the similar logic, so can we share it by using a new trait (e.g., BitwiseOpLike)?",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-23T14:33:29Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(\n+  usage = \"_FUNC_(expr) - Returns the bitwise XOR of all non-null input values, or null if none.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col) FROM VALUES (3), (5) AS tab(col);\n+       6\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class BitXorAgg(child: Expression) extends DeclarativeAggregate with ExpectsInputTypes {"
  }, {
    "author": {
      "login": "yaooqinn"
    },
    "body": "sounds good, will update",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-24T11:55:05Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(\n+  usage = \"_FUNC_(expr) - Returns the bitwise XOR of all non-null input values, or null if none.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col) FROM VALUES (3), (5) AS tab(col);\n+       6\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class BitXorAgg(child: Expression) extends DeclarativeAggregate with ExpectsInputTypes {"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "I think you can make it much simpler like this;\r\n```\r\nabstract class BitAggregate extends DeclarativeAggregate with ExpectsInputTypes {\r\n\r\n  ...\r\n  override lazy val updateExpressions: Seq[Expression] =\r\n    If(IsNull(bitAgg),\r\n      child,\r\n      If(IsNull(child), bitAgg, bitOp(bitAgg, child))) :: Nil\r\n\r\n  override lazy val mergeExpressions: Seq[Expression] =\r\n    If(IsNull(bitAgg.left),\r\n      bitAgg.right,\r\n      If(IsNull(bitAgg.right), bitAgg.left, bitOp(bitAgg.left, bitAgg.right))) :: Nil\r\n}\r\n\r\ncase class BitAndAgg(child: Expression) extends BitAggregate {\r\n\r\n  override def nodeName: String = \"bit_and\"\r\n  override def bitOp(left: Expression, right: Expression): BinaryArithmetic =\r\n    BitwiseAnd(left, right)\r\n}\r\n```",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-24T13:24:00Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(\n+  usage = \"_FUNC_(expr) - Returns the bitwise XOR of all non-null input values, or null if none.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col) FROM VALUES (3), (5) AS tab(col);\n+       6\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class BitXorAgg(child: Expression) extends DeclarativeAggregate with ExpectsInputTypes {"
  }, {
    "author": {
      "login": "yaooqinn"
    },
    "body": "yea, much cooler, thanks",
    "commit": "1481aa89454ab1b3ce0b19ee67e4bac698543206",
    "createdAt": "2019-10-24T14:55:27Z",
    "diffHunk": "@@ -97,3 +97,42 @@ case class BitOrAgg(child: Expression) extends DeclarativeAggregate with Expects\n \n   override lazy val evaluateExpression: AttributeReference = bitOr\n }\n+\n+@ExpressionDescription(\n+  usage = \"_FUNC_(expr) - Returns the bitwise XOR of all non-null input values, or null if none.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col) FROM VALUES (3), (5) AS tab(col);\n+       6\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class BitXorAgg(child: Expression) extends DeclarativeAggregate with ExpectsInputTypes {"
  }],
  "prId": 26205
}]