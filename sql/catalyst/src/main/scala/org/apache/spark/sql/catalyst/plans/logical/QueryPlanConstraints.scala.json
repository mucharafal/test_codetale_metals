[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`eq` isn't used",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-26T09:10:07Z",
    "diffHunk": "@@ -29,12 +29,26 @@ trait QueryPlanConstraints { self: LogicalPlan =>\n    */\n   lazy val constraints: ExpressionSet = {\n     if (conf.constraintPropagationEnabled) {\n+      var relevantOutPutSet: AttributeSet = outputSet\n+      constraints.foreach {\n+        case eq @ EqualTo(l: Attribute, r: Attribute) =>"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "You can avoid computing each `subsetOf` twice here.",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-26T09:10:14Z",
    "diffHunk": "@@ -29,12 +29,26 @@ trait QueryPlanConstraints { self: LogicalPlan =>\n    */\n   lazy val constraints: ExpressionSet = {\n     if (conf.constraintPropagationEnabled) {\n+      var relevantOutPutSet: AttributeSet = outputSet\n+      constraints.foreach {\n+        case eq @ EqualTo(l: Attribute, r: Attribute) =>\n+          if (l.references.subsetOf(relevantOutPutSet)"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Use ` ++ ` syntax, rather than write it as a method invocation.",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-26T09:10:24Z",
    "diffHunk": "@@ -29,12 +29,26 @@ trait QueryPlanConstraints { self: LogicalPlan =>\n    */\n   lazy val constraints: ExpressionSet = {\n     if (conf.constraintPropagationEnabled) {\n+      var relevantOutPutSet: AttributeSet = outputSet\n+      constraints.foreach {\n+        case eq @ EqualTo(l: Attribute, r: Attribute) =>\n+          if (l.references.subsetOf(relevantOutPutSet)\n+            && !r.references.subsetOf(relevantOutPutSet)) {\n+            relevantOutPutSet = relevantOutPutSet.++(r.references)"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "The comment belongs to `constraints` not `allConstraints`",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-27T08:05:51Z",
    "diffHunk": "@@ -27,16 +27,15 @@ trait QueryPlanConstraints { self: LogicalPlan =>\n    * example, if this set contains the expression `a = 2` then that expression is guaranteed to\n    * evaluate to `true` for all rows produced."
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "This should also be guarded by `constraintPropagationEnabled`",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-27T23:31:38Z",
    "diffHunk": "@@ -23,20 +23,23 @@ import org.apache.spark.sql.catalyst.expressions._\n trait QueryPlanConstraints { self: LogicalPlan =>\n \n   /**\n-   * An [[ExpressionSet]] that contains invariants about the rows output by this operator. For\n-   * example, if this set contains the expression `a = 2` then that expression is guaranteed to\n-   * evaluate to `true` for all rows produced.\n-   */\n+    * An [[ExpressionSet]] that contains an additional set of constraints about equality\n+    * constraints and `isNotNull` constraints.\n+    */\n+  lazy val allConstraints: ExpressionSet = ExpressionSet(validConstraints"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "now we don't need this if.",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-28T09:19:54Z",
    "diffHunk": "@@ -22,21 +22,30 @@ import org.apache.spark.sql.catalyst.expressions._\n \n trait QueryPlanConstraints { self: LogicalPlan =>\n \n+  /**\n+   * An [[ExpressionSet]] that contains an additional set of constraints about equality\n+   * constraints and `isNotNull` constraints.\n+   */\n+  lazy val allConstraints: ExpressionSet = {\n+    if (conf.constraintPropagationEnabled) {\n+      ExpressionSet(validConstraints\n+        .union(inferAdditionalConstraints(validConstraints))\n+        .union(constructIsNotNullConstraints(validConstraints)))\n+    } else {\n+      ExpressionSet(Set.empty)\n+    }\n+  }\n+\n   /**\n    * An [[ExpressionSet]] that contains invariants about the rows output by this operator. For\n    * example, if this set contains the expression `a = 2` then that expression is guaranteed to\n    * evaluate to `true` for all rows produced.\n    */\n   lazy val constraints: ExpressionSet = {\n     if (conf.constraintPropagationEnabled) {"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "jiangxb1987"
    },
    "body": "The comment is not acute, we may have various kinds of constraints.",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-02-28T10:31:59Z",
    "diffHunk": "@@ -22,21 +22,30 @@ import org.apache.spark.sql.catalyst.expressions._\n \n trait QueryPlanConstraints { self: LogicalPlan =>\n \n+  /**\n+   * An [[ExpressionSet]] that contains an additional set of constraints about equality"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "Nit: indents",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-03-01T04:51:10Z",
    "diffHunk": "@@ -22,21 +22,24 @@ import org.apache.spark.sql.catalyst.expressions._\n \n trait QueryPlanConstraints { self: LogicalPlan =>\n \n+  /**\n+   * An [[ExpressionSet]] that contains an additional set of constraints, such as equality\n+   * constraints and `isNotNull` constraints, etc.\n+   */\n+  lazy val allConstraints: ExpressionSet = ExpressionSet(validConstraints\n+        .union(inferAdditionalConstraints(validConstraints))\n+        .union(constructIsNotNullConstraints(validConstraints)))"
  }],
  "prId": 20670
}, {
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "We still need `if (conf.constraintPropagationEnabled)`",
    "commit": "709ed39052a032d0dc2258b2c637ab107d4b4df7",
    "createdAt": "2018-03-01T04:53:54Z",
    "diffHunk": "@@ -22,21 +22,24 @@ import org.apache.spark.sql.catalyst.expressions._\n \n trait QueryPlanConstraints { self: LogicalPlan =>\n \n+  /**\n+   * An [[ExpressionSet]] that contains an additional set of constraints, such as equality\n+   * constraints and `isNotNull` constraints, etc.\n+   */\n+  lazy val allConstraints: ExpressionSet = ExpressionSet(validConstraints"
  }],
  "prId": 20670
}]