[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I feel this can be consolidated further with Java's array and list cases. But not do it now in order to reduce diff.",
    "commit": "50f1c2986e2aea0d69fd73061c551f6cf4a0818a",
    "createdAt": "2019-03-11T11:26:03Z",
    "diffHunk": "@@ -0,0 +1,429 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst\n+\n+import java.util.{Map => JMap}\n+\n+import scala.collection.Map\n+import scala.language.existentials\n+\n+import com.google.common.reflect.TypeToken\n+\n+import org.apache.spark.sql.catalyst.DeserializerBuildHelper._\n+import org.apache.spark.sql.catalyst.JavaTypeInference._\n+import org.apache.spark.sql.catalyst.ScalaReflection._\n+import org.apache.spark.sql.catalyst.ScalaReflection.universe._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, IsNull, MapKeys, MapValues}\n+import org.apache.spark.sql.catalyst.expressions.objects._\n+import org.apache.spark.sql.catalyst.util.ArrayBasedMapData\n+import org.apache.spark.sql.types.{ObjectType, SQLUserDefinedType, UDTRegistration, UserDefinedType}\n+\n+object TypeInference {\n+\n+  /**\n+   * Returns an expression that can be used to deserialize an input expression to an object of type\n+   * represented by an `TypeInference` with a compatible schema.\n+   *\n+   * @param t The `TypeInference` object providing type information.\n+   * @param path The expression which can be used to extract serialized value.\n+   * @param walkedTypePath The paths from top to bottom to access current field when deserializing.\n+   */\n+  def deserializerFor(\n+      t: TypeInference,\n+      path: Expression,\n+      walkedTypePath: WalkedTypePath): Expression = t match {\n+    case _ if t.isNotObjectType => path\n+    case _ if t.isJavaBoolean =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Boolean])\n+    case _ if t.isJavaByte =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Byte])\n+    case _ if t.isJavaInteger =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Integer])\n+    case _ if t.isJavaLong =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Long])\n+    case _ if t.isJavaDouble =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Double])\n+    case _ if t.isJavaFloat =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Float])\n+    case _ if t.isJavaShort =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Short])\n+    case _ if t.isJavaLocalDate =>\n+      createDeserializerForLocalDate(path)\n+    case _ if t.isJavaDate =>\n+      createDeserializerForSqlDate(path)\n+    case _ if t.isJavaInstant =>\n+      createDeserializerForInstant(path)\n+    case _ if t.isJavaTimestamp =>\n+      createDeserializerForSqlTimestamp(path)\n+    case _ if t.isJavaString =>\n+      createDeserializerForString(path, returnNullable = false)\n+    case _ if t.isJavaBigDecimal =>\n+      createDeserializerForJavaBigDecimal(path, returnNullable = false)\n+    case _ if t.isScalaBigDecimal =>\n+      createDeserializerForScalaBigDecimal(path, returnNullable = false)\n+    case _ if t.isJavaBigInteger =>\n+      createDeserializerForJavaBigInteger(path, returnNullable = false)\n+    case _ if t.isScalaBigInt =>\n+      createDeserializerForScalaBigInt(path)\n+\n+    case _ => t.deserializerFor(path, walkedTypePath)\n+  }\n+}\n+\n+trait TypeInference {\n+\n+  def isNotObjectType: Boolean = false\n+\n+  def isJavaShort: Boolean = false\n+  def isJavaInteger: Boolean = false\n+  def isJavaLong: Boolean = false\n+  def isJavaDouble: Boolean = false\n+  def isJavaFloat: Boolean = false\n+  def isJavaByte: Boolean = false\n+  def isJavaBoolean: Boolean = false\n+\n+  def isJavaLocalDate: Boolean = false\n+  def isJavaDate: Boolean = false\n+  def isJavaInstant: Boolean = false\n+  def isJavaTimestamp: Boolean = false\n+  def isJavaString: Boolean = false\n+  def isJavaBigDecimal: Boolean = false\n+  def isJavaBigInteger: Boolean = false\n+\n+  def isScalaBigDecimal: Boolean = false\n+  def isScalaBigInt: Boolean = false\n+\n+  /**\n+   * Defines deserializers for specified `TypeInference`.\n+   */\n+  def deserializerFor(path: Expression, walkedTypePath: WalkedTypePath): Expression\n+}\n+\n+case class ScalaInference(scalaType: `Type`) extends TypeInference {\n+\n+  val t = scalaType.dealias\n+\n+  override def isNotObjectType: Boolean = !dataTypeFor(t).isInstanceOf[ObjectType]\n+\n+  override def isJavaShort: Boolean = t <:< localTypeOf[java.lang.Short]\n+  override def isJavaInteger: Boolean = t <:< localTypeOf[java.lang.Integer]\n+  override def isJavaLong: Boolean = t <:< localTypeOf[java.lang.Long]\n+  override def isJavaDouble: Boolean = t <:< localTypeOf[java.lang.Double]\n+  override def isJavaFloat: Boolean = t <:< localTypeOf[java.lang.Float]\n+  override def isJavaByte: Boolean = t <:< localTypeOf[java.lang.Byte]\n+  override def isJavaBoolean: Boolean = t <:< localTypeOf[java.lang.Boolean]\n+\n+  override def isJavaLocalDate: Boolean = t <:< localTypeOf[java.time.LocalDate]\n+  override def isJavaDate: Boolean = t <:< localTypeOf[java.sql.Date]\n+  override def isJavaInstant: Boolean = t <:< localTypeOf[java.time.Instant]\n+  override def isJavaTimestamp: Boolean = t <:< localTypeOf[java.sql.Timestamp]\n+  override def isJavaString: Boolean = t <:< localTypeOf[java.lang.String]\n+  override def isJavaBigDecimal: Boolean = t <:< localTypeOf[java.math.BigDecimal]\n+  override def isJavaBigInteger: Boolean = t <:< localTypeOf[java.math.BigInteger]\n+\n+  override def isScalaBigDecimal: Boolean = t <:< localTypeOf[BigDecimal]\n+  override def isScalaBigInt: Boolean = t <:< localTypeOf[scala.math.BigInt]\n+\n+  def isSQLUserDefinedType: Boolean =\n+    t.typeSymbol.annotations.exists(_.tree.tpe =:= typeOf[SQLUserDefinedType])\n+  def isRegisteredUDT: Boolean = UDTRegistration.exists(getClassNameFromType(t))\n+\n+  def isScalaArray: Boolean = t <:< localTypeOf[Array[_]]\n+  def isScalaOption: Boolean = t <:< localTypeOf[Option[_]]\n+  def isScalaSeq: Boolean = t <:< localTypeOf[Seq[_]]\n+  def isScalaSet: Boolean = t <:< localTypeOf[scala.collection.Set[_]]\n+  def isScalaMap: Boolean = t <:< localTypeOf[Map[_, _]]\n+  def isDefinedByConstructorParams: Boolean = ScalaReflection.definedByConstructorParams(t)\n+\n+  override def deserializerFor(\n+      path: Expression,\n+      walkedTypePath: WalkedTypePath): Expression = this match {\n+    case _ if isScalaOption =>\n+      val TypeRef(_, _, Seq(optType)) = t\n+      val className = getClassNameFromType(optType)\n+      val newTypePath = walkedTypePath.recordOption(className)\n+      WrapOption(TypeInference.deserializerFor(ScalaInference(optType), path, newTypePath),\n+        dataTypeFor(optType))\n+\n+    case _ if isScalaArray =>"
  }],
  "prId": 24053
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "At `JavaTypeInference`, it was `returnNullable = true`, but at `ScalaReflection`, it was `returnNullable = false`. This inconsistency seems weird. Let me do `returnNullable = false` first to see if tests can be passed.",
    "commit": "50f1c2986e2aea0d69fd73061c551f6cf4a0818a",
    "createdAt": "2019-03-11T14:33:15Z",
    "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst\n+\n+import java.util.{Map => JMap}\n+\n+import scala.collection.Map\n+import scala.language.existentials\n+\n+import com.google.common.reflect.TypeToken\n+\n+import org.apache.spark.sql.catalyst.DeserializerBuildHelper._\n+import org.apache.spark.sql.catalyst.JavaTypeInference._\n+import org.apache.spark.sql.catalyst.ScalaReflection._\n+import org.apache.spark.sql.catalyst.ScalaReflection.universe._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, IsNull, MapKeys, MapValues}\n+import org.apache.spark.sql.catalyst.expressions.objects._\n+import org.apache.spark.sql.catalyst.util.ArrayBasedMapData\n+import org.apache.spark.sql.types.{ObjectType, SQLUserDefinedType, UDTRegistration, UserDefinedType}\n+\n+object TypeInference {\n+\n+  /**\n+   * Returns an expression that can be used to deserialize an input expression to an object of type\n+   * represented by an `TypeInference` with a compatible schema.\n+   *\n+   * @param t The `TypeInference` object providing type information.\n+   * @param path The expression which can be used to extract serialized value.\n+   * @param walkedTypePath The paths from top to bottom to access current field when deserializing.\n+   */\n+  def deserializerFor(\n+      t: TypeInference,\n+      path: Expression,\n+      walkedTypePath: WalkedTypePath): Expression = t match {\n+    case _ if t.isNotObjectType => path\n+    case _ if t.isJavaBoolean =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Boolean])\n+    case _ if t.isJavaByte =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Byte])\n+    case _ if t.isJavaInteger =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Integer])\n+    case _ if t.isJavaLong =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Long])\n+    case _ if t.isJavaDouble =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Double])\n+    case _ if t.isJavaFloat =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Float])\n+    case _ if t.isJavaShort =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Short])\n+    case _ if t.isJavaLocalDate =>\n+      createDeserializerForLocalDate(path)\n+    case _ if t.isJavaDate =>\n+      createDeserializerForSqlDate(path)\n+    case _ if t.isJavaInstant =>\n+      createDeserializerForInstant(path)\n+    case _ if t.isJavaTimestamp =>\n+      createDeserializerForSqlTimestamp(path)\n+    case _ if t.isJavaString =>\n+      createDeserializerForString(path, returnNullable = false)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "`returnNullable` is a parameter of `Invoke`, used to indicate the invoked method will always return non-null value if it is false. I also think it is reasonable to do `returnNullable = false` here.",
    "commit": "50f1c2986e2aea0d69fd73061c551f6cf4a0818a",
    "createdAt": "2019-03-11T14:34:46Z",
    "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst\n+\n+import java.util.{Map => JMap}\n+\n+import scala.collection.Map\n+import scala.language.existentials\n+\n+import com.google.common.reflect.TypeToken\n+\n+import org.apache.spark.sql.catalyst.DeserializerBuildHelper._\n+import org.apache.spark.sql.catalyst.JavaTypeInference._\n+import org.apache.spark.sql.catalyst.ScalaReflection._\n+import org.apache.spark.sql.catalyst.ScalaReflection.universe._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, IsNull, MapKeys, MapValues}\n+import org.apache.spark.sql.catalyst.expressions.objects._\n+import org.apache.spark.sql.catalyst.util.ArrayBasedMapData\n+import org.apache.spark.sql.types.{ObjectType, SQLUserDefinedType, UDTRegistration, UserDefinedType}\n+\n+object TypeInference {\n+\n+  /**\n+   * Returns an expression that can be used to deserialize an input expression to an object of type\n+   * represented by an `TypeInference` with a compatible schema.\n+   *\n+   * @param t The `TypeInference` object providing type information.\n+   * @param path The expression which can be used to extract serialized value.\n+   * @param walkedTypePath The paths from top to bottom to access current field when deserializing.\n+   */\n+  def deserializerFor(\n+      t: TypeInference,\n+      path: Expression,\n+      walkedTypePath: WalkedTypePath): Expression = t match {\n+    case _ if t.isNotObjectType => path\n+    case _ if t.isJavaBoolean =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Boolean])\n+    case _ if t.isJavaByte =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Byte])\n+    case _ if t.isJavaInteger =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Integer])\n+    case _ if t.isJavaLong =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Long])\n+    case _ if t.isJavaDouble =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Double])\n+    case _ if t.isJavaFloat =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Float])\n+    case _ if t.isJavaShort =>\n+      createDeserializerForTypesSupportValueOf(path, classOf[java.lang.Short])\n+    case _ if t.isJavaLocalDate =>\n+      createDeserializerForLocalDate(path)\n+    case _ if t.isJavaDate =>\n+      createDeserializerForSqlDate(path)\n+    case _ if t.isJavaInstant =>\n+      createDeserializerForInstant(path)\n+    case _ if t.isJavaTimestamp =>\n+      createDeserializerForSqlTimestamp(path)\n+    case _ if t.isJavaString =>\n+      createDeserializerForString(path, returnNullable = false)"
  }],
  "prId": 24053
}]