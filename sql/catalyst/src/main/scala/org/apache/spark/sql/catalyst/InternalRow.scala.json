[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "do we need size? maybe just keep one of length or size.\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T06:58:27Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length",
    "line": 36
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "agree. It's internal and we don't need to follow scala convention to provide `size`.\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T10:32:19Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length",
    "line": 36
  }],
  "prId": 6869
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "do we need this here?\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T06:59:00Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length\n \n-object InternalRow {\n-  def unapplySeq(row: InternalRow): Some[Seq[Any]] = Some(row.toSeq)\n+  /** Number of elements in the Row. */\n+  def length: Int\n \n   /**\n-   * This method can be used to construct a [[Row]] with the given values.\n+   * Schema for the row.\n    */\n-  def apply(values: Any*): InternalRow = new GenericRow(values.toArray)\n+  def schema: StructType = null",
    "line": 48
  }],
  "prId": 6869
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "As it's internal row, should we just return `UTF8String`?\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T10:35:17Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length\n \n-object InternalRow {\n-  def unapplySeq(row: InternalRow): Some[Seq[Any]] = Some(row.toSeq)\n+  /** Number of elements in the Row. */\n+  def length: Int\n \n   /**\n-   * This method can be used to construct a [[Row]] with the given values.\n+   * Schema for the row.\n    */\n-  def apply(values: Any*): InternalRow = new GenericRow(values.toArray)\n+  def schema: StructType = null\n \n   /**\n-   * This method can be used to construct a [[Row]] from a [[Seq]] of values.\n+   * Returns the value at position i. If the value is null, null is returned.\n    */\n-  def fromSeq(values: Seq[Any]): InternalRow = new GenericRow(values.toArray)\n+  def apply(i: Int): Any\n+\n+  /**\n+   * Returns the value at position i. If the value is null, null is returned.\n+   */\n+  def get(i: Int): Any = apply(i)\n+\n+  /** Checks whether the value at position i is null. */\n+  def isNullAt(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive boolean.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getBoolean(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive byte.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getByte(i: Int): Byte\n+\n+  /**\n+   * Returns the value at position i as a primitive short.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getShort(i: Int): Short\n+\n+  /**\n+   * Returns the value at position i as a primitive int.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getInt(i: Int): Int\n+\n+  /**\n+   * Returns the value at position i as a primitive long.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getLong(i: Int): Long\n \n-  def fromTuple(tuple: Product): InternalRow = fromSeq(tuple.productIterator.toSeq)\n+  /**\n+   * Returns the value at position i as a primitive float.\n+   * Throws an exception if the type mismatches or if the value is null.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getFloat(i: Int): Float\n \n   /**\n-   * Merge multiple rows into a single row, one after another.\n+   * Returns the value at position i as a primitive double.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n    */\n-  def merge(rows: InternalRow*): InternalRow = {\n-    // TODO: Improve the performance of this if used in performance critical part.\n-    new GenericRow(rows.flatMap(_.toSeq).toArray)\n+  def getDouble(i: Int): Double\n+\n+  /**\n+   * Returns the value at position i as a String object.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getString(i: Int): String = getAs[UTF8String](i).toString",
    "line": 133
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Maybe we can only define `getUTF8String` at `InternalRow` and define `getString` at user-facing `Row`?\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T10:47:23Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length\n \n-object InternalRow {\n-  def unapplySeq(row: InternalRow): Some[Seq[Any]] = Some(row.toSeq)\n+  /** Number of elements in the Row. */\n+  def length: Int\n \n   /**\n-   * This method can be used to construct a [[Row]] with the given values.\n+   * Schema for the row.\n    */\n-  def apply(values: Any*): InternalRow = new GenericRow(values.toArray)\n+  def schema: StructType = null\n \n   /**\n-   * This method can be used to construct a [[Row]] from a [[Seq]] of values.\n+   * Returns the value at position i. If the value is null, null is returned.\n    */\n-  def fromSeq(values: Seq[Any]): InternalRow = new GenericRow(values.toArray)\n+  def apply(i: Int): Any\n+\n+  /**\n+   * Returns the value at position i. If the value is null, null is returned.\n+   */\n+  def get(i: Int): Any = apply(i)\n+\n+  /** Checks whether the value at position i is null. */\n+  def isNullAt(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive boolean.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getBoolean(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive byte.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getByte(i: Int): Byte\n+\n+  /**\n+   * Returns the value at position i as a primitive short.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getShort(i: Int): Short\n+\n+  /**\n+   * Returns the value at position i as a primitive int.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getInt(i: Int): Int\n+\n+  /**\n+   * Returns the value at position i as a primitive long.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getLong(i: Int): Long\n \n-  def fromTuple(tuple: Product): InternalRow = fromSeq(tuple.productIterator.toSeq)\n+  /**\n+   * Returns the value at position i as a primitive float.\n+   * Throws an exception if the type mismatches or if the value is null.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getFloat(i: Int): Float\n \n   /**\n-   * Merge multiple rows into a single row, one after another.\n+   * Returns the value at position i as a primitive double.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n    */\n-  def merge(rows: InternalRow*): InternalRow = {\n-    // TODO: Improve the performance of this if used in performance critical part.\n-    new GenericRow(rows.flatMap(_.toSeq).toArray)\n+  def getDouble(i: Int): Double\n+\n+  /**\n+   * Returns the value at position i as a String object.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getString(i: Int): String = getAs[UTF8String](i).toString",
    "line": 133
  }],
  "prId": 6869
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "will this throw `NullPointerException`?\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T10:35:49Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length\n \n-object InternalRow {\n-  def unapplySeq(row: InternalRow): Some[Seq[Any]] = Some(row.toSeq)\n+  /** Number of elements in the Row. */\n+  def length: Int\n \n   /**\n-   * This method can be used to construct a [[Row]] with the given values.\n+   * Schema for the row.\n    */\n-  def apply(values: Any*): InternalRow = new GenericRow(values.toArray)\n+  def schema: StructType = null\n \n   /**\n-   * This method can be used to construct a [[Row]] from a [[Seq]] of values.\n+   * Returns the value at position i. If the value is null, null is returned.\n    */\n-  def fromSeq(values: Seq[Any]): InternalRow = new GenericRow(values.toArray)\n+  def apply(i: Int): Any\n+\n+  /**\n+   * Returns the value at position i. If the value is null, null is returned.\n+   */\n+  def get(i: Int): Any = apply(i)\n+\n+  /** Checks whether the value at position i is null. */\n+  def isNullAt(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive boolean.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getBoolean(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive byte.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getByte(i: Int): Byte\n+\n+  /**\n+   * Returns the value at position i as a primitive short.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getShort(i: Int): Short\n+\n+  /**\n+   * Returns the value at position i as a primitive int.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getInt(i: Int): Int\n+\n+  /**\n+   * Returns the value at position i as a primitive long.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getLong(i: Int): Long\n \n-  def fromTuple(tuple: Product): InternalRow = fromSeq(tuple.productIterator.toSeq)\n+  /**\n+   * Returns the value at position i as a primitive float.\n+   * Throws an exception if the type mismatches or if the value is null.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getFloat(i: Int): Float\n \n   /**\n-   * Merge multiple rows into a single row, one after another.\n+   * Returns the value at position i as a primitive double.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n    */\n-  def merge(rows: InternalRow*): InternalRow = {\n-    // TODO: Improve the performance of this if used in performance critical part.\n-    new GenericRow(rows.flatMap(_.toSeq).toArray)\n+  def getDouble(i: Int): Double\n+\n+  /**\n+   * Returns the value at position i as a String object.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getString(i: Int): String = getAs[UTF8String](i).toString\n+\n+  /**\n+   * Returns the value at position i.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   */\n+  def getAs[T](i: Int): T = apply(i).asInstanceOf[T]",
    "line": 140
  }],
  "prId": 6869
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Is it OK to remove the hashCode implementation?\n",
    "commit": "444382ea3a54b1b7f8066b155a2da64cc03775af",
    "createdAt": "2015-06-18T10:44:56Z",
    "diffHunk": "@@ -19,39 +19,193 @@ package org.apache.spark.sql.catalyst\n \n import org.apache.spark.sql.Row\n import org.apache.spark.sql.catalyst.expressions.GenericRow\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.unsafe.types.UTF8String\n \n /**\n  * An abstract class for row used internal in Spark SQL, which only contain the columns as\n  * internal types.\n+ *\n+ * The following is a mapping between Spark SQL types and types of objects in row:\n+ *\n+ *   BooleanType -> java.lang.Boolean\n+ *   ByteType -> java.lang.Byte\n+ *   ShortType -> java.lang.Short\n+ *   IntegerType -> java.lang.Integer\n+ *   FloatType -> java.lang.Float\n+ *   DoubleType -> java.lang.Double\n+ *   StringType -> UTF8String\n+ *   DecimalType -> org.apache.spark.sql.types.Decimal\n+ *\n+ *   DateType -> java.lang.Int\n+ *   TimestampType -> java.lang.Long\n+ *\n+ *   BinaryType -> Array[Byte]\n+ *   ArrayType -> scala.collection.Seq\n+ *   MapType -> scala.collection.Map\n+ *   StructType -> InternalRow\n  */\n-abstract class InternalRow extends Row {\n-  // A default implementation to change the return type\n-  override def copy(): InternalRow = {this}\n-}\n+abstract class InternalRow extends Serializable {\n+  /** Number of elements in the Row. */\n+  def size: Int = length\n \n-object InternalRow {\n-  def unapplySeq(row: InternalRow): Some[Seq[Any]] = Some(row.toSeq)\n+  /** Number of elements in the Row. */\n+  def length: Int\n \n   /**\n-   * This method can be used to construct a [[Row]] with the given values.\n+   * Schema for the row.\n    */\n-  def apply(values: Any*): InternalRow = new GenericRow(values.toArray)\n+  def schema: StructType = null\n \n   /**\n-   * This method can be used to construct a [[Row]] from a [[Seq]] of values.\n+   * Returns the value at position i. If the value is null, null is returned.\n    */\n-  def fromSeq(values: Seq[Any]): InternalRow = new GenericRow(values.toArray)\n+  def apply(i: Int): Any\n+\n+  /**\n+   * Returns the value at position i. If the value is null, null is returned.\n+   */\n+  def get(i: Int): Any = apply(i)\n+\n+  /** Checks whether the value at position i is null. */\n+  def isNullAt(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive boolean.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getBoolean(i: Int): Boolean\n+\n+  /**\n+   * Returns the value at position i as a primitive byte.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getByte(i: Int): Byte\n+\n+  /**\n+   * Returns the value at position i as a primitive short.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getShort(i: Int): Short\n+\n+  /**\n+   * Returns the value at position i as a primitive int.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getInt(i: Int): Int\n+\n+  /**\n+   * Returns the value at position i as a primitive long.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getLong(i: Int): Long\n \n-  def fromTuple(tuple: Product): InternalRow = fromSeq(tuple.productIterator.toSeq)\n+  /**\n+   * Returns the value at position i as a primitive float.\n+   * Throws an exception if the type mismatches or if the value is null.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getFloat(i: Int): Float\n \n   /**\n-   * Merge multiple rows into a single row, one after another.\n+   * Returns the value at position i as a primitive double.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n    */\n-  def merge(rows: InternalRow*): InternalRow = {\n-    // TODO: Improve the performance of this if used in performance critical part.\n-    new GenericRow(rows.flatMap(_.toSeq).toArray)\n+  def getDouble(i: Int): Double\n+\n+  /**\n+   * Returns the value at position i as a String object.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   * @throws NullPointerException when value is null.\n+   */\n+  def getString(i: Int): String = getAs[UTF8String](i).toString\n+\n+  /**\n+   * Returns the value at position i.\n+   *\n+   * @throws ClassCastException when data type does not match.\n+   */\n+  def getAs[T](i: Int): T = apply(i).asInstanceOf[T]\n+\n+  override def toString: String = s\"[${this.mkString(\",\")}]\"\n+\n+  /** Returns true if there are any NULL values in this row. */\n+  def anyNull: Boolean = {\n+    val len = length\n+    var i = 0\n+    while (i < len) {\n+      if (isNullAt(i)) { return true }\n+      i += 1\n+    }\n+    false\n+  }\n+\n+  override def equals(that: Any): Boolean = that match {",
    "line": 155
  }],
  "prId": 6869
}]