[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Sometime the nullability of columns could be propagated in optimizer, could we move this check to SparkStrategy (when picking up a physical plan)?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:30:16Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Yeah, this is possible. It would require us to move the entire rule to the SparkStrategy (it will be messy to pattern match a rewritten NAAJ). The downside of this is, is that SparkStrategy can throw  Analysis error which should have been thrown before.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:53:41Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "This is something we should support eventually, but not now. so throwing a NotImplementedException is slightly better than throwing an AnalysisError.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:58:01Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Note that we should never throw a NotImplementedException to the user.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:02:50Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "We used NotImplementedException a lot in parquet reader, how to prevent that to be in front of user?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:15:14Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Those are not in the planner are they? Do they ever get propagated to the user?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:18:03Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")\n+                }\n+              case _ =>\n+            }\n+            splitConjunctivePredicates(condition).foreach {\n+              case p: PredicateSubquery =>\n+                checkCorrelatedPredicates(p)\n+              case Not(InSubQuery(_, query)) if query.output.exists(_.nullable) =>\n+                failAnalysis(\"NOT IN with nullable subquery is not supported. \" +"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "AttributeSet ?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:33:03Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T21:11:09Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "child.outputSet ?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T22:41:29Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Since we only resolve the subquery inside Filter, how is this possible? Could you have sql test for this case?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:39:23Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "A filter can be below a join, i.e.:\n\n```\nSELECT *\nFROM     l\nWHERE EXISTS(SELECT *\n             FROM   r\n                    LEFT JOIN (SELECT * FROM s WHERE s.id = l.id) t\n                     ON t.id = r.id)\n```\n\nBut sure I'll add a test.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:44:50Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Then `l.id` should be part of right child of join, not part of the join condition, right?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:52:03Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "`l.id` shouldn't be part of the join condition either. It would not make any difference; the join could produce more null values and that is all. There should be WHERE after the join, e.g.:\n\n```\nSELECT *\nFROM     l\nWHERE EXISTS(SELECT *\n             FROM   r\n                    LEFT JOIN (SELECT * FROM s) t\n                     ON t.id = r.id\n             WHERE   t.id = l.id)\n```\n\nIt could be usefull the pull out correlated predicates from an inner join though (I have never seen this in the wild though).\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T05:59:44Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Outer join is not the only one that change the meaning of an attribute (for example, Union), so we can't access the outer attributes below these plan (outer side of outer join, the children of Union (other than the first one). We can create a TODO for these.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:27:16Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I have added more cases here. I think we are good now.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T21:15:36Z",
    "diffHunk": "@@ -110,6 +110,31 @@ trait CheckAnalysis {\n               s\"filter expression '${f.condition.sql}' \" +\n                 s\"of type ${f.condition.dataType.simpleString} is not a boolean.\")\n \n+          case f @ Filter(condition, child) =>\n+            // Make sure no correlated predicate is in an OUTER join, because this could change the\n+            // semantics of the join.\n+            lazy val attributes: Set[Expression] = child.output.toSet\n+            def checkCorrelatedPredicates(p: PredicateSubquery): Unit = p.query.foreach {\n+              case j @ Join(left, right, jt, _) if jt != Inner =>\n+                j.transformAllExpressions {\n+                  case e if attributes.contains(e) =>\n+                    failAnalysis(s\"Accessing outer query column is not allowed in outer joins: $e\")"
  }],
  "prId": 12306
}]