[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "This should work. I'll remove the comment.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-11-18T22:25:32Z",
    "diffHunk": "@@ -328,3 +280,208 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+  * A window function is a function that can only be evaluated in the context of a window operator.\n+  */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  self: Product =>\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+  def offsetValue: Int = offset.eval().asInstanceOf[Int]\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+  * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+  */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** Set the window size expression. */\n+  def withSize(n: Expression): SizeBasedWindowFunction\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist(n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(0))\n+  override def dataType: DataType = DoubleType\n+  override def withSize(n: Expression): CumeDist = CumeDist(n)\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+// TODO check if the updates are correct! This used to be the case!"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Am I being to paranoid here?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-11-23T20:55:04Z",
    "diffHunk": "@@ -328,3 +281,223 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+  * A window function is a function that can only be evaluated in the context of a window operator.\n+  */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+  * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+  */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** The partition size attribute, this is here to prevent us from creating an attribute on the"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "`NoOp` ?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-11-23T20:56:37Z",
    "diffHunk": "@@ -328,3 +281,223 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+  * A window function is a function that can only be evaluated in the context of a window operator.\n+  */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+  * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+  */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** The partition size attribute, this is here to prevent us from creating an attribute on the\n+    * executor side. */\n+  val size = AttributeReference(\"size\", IntegerType, false)()\n+\n+  /** Set the window size expression. */\n+  def withSize(n: Expression): SizeBasedWindowFunction\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist(n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(0))\n+  override def dataType: DataType = DoubleType\n+  override def withSize(n: Expression): CumeDist = CumeDist(n)\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression, n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1), Literal(0))\n+  def this(buckets: Expression) = this(buckets, Literal(0))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n+  }\n+\n+  override def withSize(n: Expression): NTile = NTile(buckets, n)\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, false)()\n+  private val bucketThreshold = AttributeReference(\"bucketThreshold\", IntegerType, false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, false)()\n+  private val bucketsWithPadding = AttributeReference(\"bucketsWithPadding\", IntegerType, false)()\n+  private def bucketOverflow(e: Expression) =\n+    If(GreaterThanOrEqual(rowNumber, bucketThreshold), e, zero)\n+\n+  override val aggBufferAttributes = Seq(\n+    rowNumber,\n+    bucket,\n+    bucketThreshold,\n+    bucketSize,\n+    bucketsWithPadding\n+  )\n+\n+  override val initialValues = Seq(\n+    zero,\n+    zero,\n+    zero,\n+    Cast(Divide(n, buckets), IntegerType),\n+    Cast(Remainder(n, buckets), IntegerType)\n+  )\n+\n+  override val updateExpressions = Seq(\n+    Add(rowNumber, one),\n+    Add(bucket, bucketOverflow(one)),\n+    Add(bucketThreshold, bucketOverflow(\n+      Add(bucketSize, If(LessThan(bucket, bucketsWithPadding), one, zero)))),\n+    bucketSize,"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should default have the same type as input?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T00:19:11Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I think it does, returning any other type would violate the principle of least surprise. It is basically a coalesce of a value `x` in the leading/lagging row, and a `default` value in the current row.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T10:30:03Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Just curious why not `def this() = this(Literal(null))`?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T00:21:29Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "No reason; just didn't think of it. Do you think it is better if I change this?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T10:30:35Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Both `bucketSize` and `bucketsWithPadding` are foldable, do we still need them in the buffer?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T00:43:41Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+ */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** The partition size attribute, this is here to prevent us from creating an attribute on the\n+    * executor side. */\n+  val size = AttributeReference(\"size\", IntegerType, false)()\n+\n+  /** Set the window size expression. */\n+  def withSize(n: Expression): SizeBasedWindowFunction\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist(n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(0))\n+  override def dataType: DataType = DoubleType\n+  override def withSize(n: Expression): CumeDist = CumeDist(n)\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression, n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1), Literal(0))\n+  def this(buckets: Expression) = this(buckets, Literal(0))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n+  }\n+\n+  override def withSize(n: Expression): NTile = NTile(buckets, n)\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, false)()\n+  private val bucketThreshold = AttributeReference(\"bucketThreshold\", IntegerType, false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, false)()\n+  private val bucketsWithPadding = AttributeReference(\"bucketsWithPadding\", IntegerType, false)()"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "They are not, they are only constant (foldable if you will) for a single group. They are both dependent on size of the current group, the `n` expression. The value of the `n` expression (and the dependent `bucketSize` and `bucketsWithPadding`) will be updated when we start to process the new group.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-09T10:12:45Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+ */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** The partition size attribute, this is here to prevent us from creating an attribute on the\n+    * executor side. */\n+  val size = AttributeReference(\"size\", IntegerType, false)()\n+\n+  /** Set the window size expression. */\n+  def withSize(n: Expression): SizeBasedWindowFunction\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist(n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(0))\n+  override def dataType: DataType = DoubleType\n+  override def withSize(n: Expression): CumeDist = CumeDist(n)\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression, n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1), Literal(0))\n+  def this(buckets: Expression) = this(buckets, Literal(0))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n+  }\n+\n+  override def withSize(n: Expression): NTile = NTile(buckets, n)\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, false)()\n+  private val bucketThreshold = AttributeReference(\"bucketThreshold\", IntegerType, false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, false)()\n+  private val bucketsWithPadding = AttributeReference(\"bucketsWithPadding\", IntegerType, false)()"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "I see, thanks!\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T01:40:51Z",
    "diffHunk": "@@ -328,3 +281,222 @@ object FrameBoundaryExtractor {\n     case _ => None\n   }\n }\n+\n+/**\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n+ */\n+trait WindowFunction extends Expression {\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n+\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n+\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n+\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n+\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n+}\n+\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = 1\n+}\n+\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+  extends OffsetWindowFunction {\n+\n+  def this(input: Expression, offset: Expression) =\n+    this(input, offset, Literal(null))\n+\n+  def this(input: Expression) =\n+    this(input, Literal(1), Literal(null))\n+\n+  def this() = this(Literal(null), Literal(1), Literal(null))\n+\n+  val offsetSign = -1\n+}\n+\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n+\n+/**\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+ */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  /** The partition size attribute, this is here to prevent us from creating an attribute on the\n+    * executor side. */\n+  val size = AttributeReference(\"size\", IntegerType, false)()\n+\n+  /** Set the window size expression. */\n+  def withSize(n: Expression): SizeBasedWindowFunction\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist(n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(0))\n+  override def dataType: DataType = DoubleType\n+  override def withSize(n: Expression): CumeDist = CumeDist(n)\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression, n: Expression)\n+    extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1), Literal(0))\n+  def this(buckets: Expression) = this(buckets, Literal(0))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n+  }\n+\n+  override def withSize(n: Expression): NTile = NTile(buckets, n)\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, false)()\n+  private val bucketThreshold = AttributeReference(\"bucketThreshold\", IntegerType, false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, false)()\n+  private val bucketsWithPadding = AttributeReference(\"bucketsWithPadding\", IntegerType, false)()"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "How to tell the difference between `UnboundedPreceding` and `UnboundedFollowing`? \n\nOr this assume that we can't use both of them in same position (start or end)? \n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:18:40Z",
    "diffHunk": "@@ -120,6 +121,19 @@ sealed trait FrameBoundary {\n   def notFollows(other: FrameBoundary): Boolean\n }\n \n+/**\n+ * Extractor for making working with frame boundaries easier.\n+ */\n+object FrameBoundary {\n+  def apply(boundary: FrameBoundary): Option[Int] = unapply(boundary)\n+  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n+    case CurrentRow => Some(0)\n+    case ValuePreceding(offset) => Some(-offset)\n+    case ValueFollowing(offset) => Some(offset)\n+    case _ => None",
    "line": 26
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I don't think there is any reason to have `UnboundedPreceding` and `UnboundedFollowing` in the first place. Their position in the frame specification should imply whether it is `Preceding` or `Following`. I would like to factor this out in a followup PR.\n\nTo answer your question: I current don't care about here position, and I assume they cannot be reversed. I don't think the Hive parser allows this (I'll check later).\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:33:17Z",
    "diffHunk": "@@ -120,6 +121,19 @@ sealed trait FrameBoundary {\n   def notFollows(other: FrameBoundary): Boolean\n }\n \n+/**\n+ * Extractor for making working with frame boundaries easier.\n+ */\n+object FrameBoundary {\n+  def apply(boundary: FrameBoundary): Option[Int] = unapply(boundary)\n+  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n+    case CurrentRow => Some(0)\n+    case ValuePreceding(offset) => Some(-offset)\n+    case ValueFollowing(offset) => Some(offset)\n+    case _ => None",
    "line": 26
  }, {
    "author": {
      "login": "davies"
    },
    "body": "That's fair.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T06:24:08Z",
    "diffHunk": "@@ -120,6 +121,19 @@ sealed trait FrameBoundary {\n   def notFollows(other: FrameBoundary): Boolean\n }\n \n+/**\n+ * Extractor for making working with frame boundaries easier.\n+ */\n+object FrameBoundary {\n+  def apply(boundary: FrameBoundary): Option[Int] = unapply(boundary)\n+  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n+    case CurrentRow => Some(0)\n+    case ValuePreceding(offset) => Some(-offset)\n+    case ValueFollowing(offset) => Some(offset)\n+    case _ => None",
    "line": 26
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should `windowFunction` must be a `AggregationExpression` or WindowFunction?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:20:19Z",
    "diffHunk": "@@ -246,85 +260,244 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,",
    "line": 48
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "`OffsetWindowFunction` is not an `AggregateFunction`, so I cannot make `WindowFunction` an aggregate.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:34:08Z",
    "diffHunk": "@@ -246,85 +260,244 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,",
    "line": 48
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "some docs?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:24:02Z",
    "diffHunk": "@@ -246,85 +260,244 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+abstract class OffsetWindowFunction"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I'll add some. We could also rename these to `ValueWindowFunction`s; which might be a better - more self describing - name.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-11T21:43:30Z",
    "diffHunk": "@@ -246,85 +260,244 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+abstract class OffsetWindowFunction"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Do we expect a `OffsetWindowFunction` be foldable?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T20:22:59Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "It can be foldable, for instance: `LEAD(1, 2) OVER (PARTITION BY ... ORDER BY ...)` should always return `1`.\n\nHowever there is currently no Optimizer rule to eliminate this. Should I add one?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T21:13:10Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "I guess the results still depend on the number of rows of that partition. I tried a few queries in postgres\n\n```\nyhuai=# select lead(1, 2) over();\n lead \n------\n\n(1 row)\n\nyhuai=# select lead(1, 2) over() from (select 100 as k union all select 99 as k) tmp;\n lead \n------\n\n\n(2 rows)\n\nyhuai=# select lead(1, 2) over() from (select 100 as k union all select 99 as k union all select 98 as k) tmp;\n lead \n------\n    1\n\n\n(3 rows)\n```\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T21:47:16Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Ahhh... Yes, you have a point. Without a foldable default value it is definately not foldable. Lets make it non-foldable for now...\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T22:28:14Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Do we need to provide the data type for this `Literal(null)`?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T20:42:59Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))",
    "line": 169
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "This is only a default constructor for serialization purposes. It shouldn't really be used by anyone. The data type of this expression will be `NullType`, `Literal.apply` takes care of that.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T21:15:04Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))",
    "line": 169
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "`override val`?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T20:43:11Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Add scala doc for `default`, `offset`, and `offsetSign`?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T20:44:07Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "There is a `supportsPartial` field in `AggregateFunction`. We can override that and set it as `false`? Also, if `mergeExpressions` is not expected to be called, we can throw an `UnsupportedOperationException`.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T22:53:56Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Do we need to check if `buckets` is a foldable expression?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:05:21Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1))\n+\n+  // Validate buckets.\n+  buckets.eval() match {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Good point. Yes and No. The `buckets` value only has to be constant within a partition, it would also work if the value is part of the partitioning clause. It is - however - quite a bit of work to get that in. For now I'd rather enforce a global constant number of buckets. What do you think?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T06:52:36Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1))\n+\n+  // Validate buckets.\n+  buckets.eval() match {"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "oh, I somehow missed `case x => throw new AnalysisException(`... Sorry.\n\nIt makes sense. Let's keep it as is.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T07:03:26Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1))\n+\n+  // Validate buckets.\n+  buckets.eval() match {"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Add more comments to explain what it is?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:06:27Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n   }\n+\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, nullable = false)()\n+  private val bucketThreshold =\n+    AttributeReference(\"bucketThreshold\", IntegerType, nullable = false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, nullable = false)()\n+  private val bucketsWithPadding =\n+    AttributeReference(\"bucketsWithPadding\", IntegerType, nullable = false)()\n+  private def bucketOverflow(e: Expression) =\n+    If(GreaterThanOrEqual(rowNumber, bucketThreshold), e, zero)\n+\n+  override val aggBufferAttributes = Seq(\n+    rowNumber,\n+    bucket,\n+    bucketThreshold,\n+    bucketSize,\n+    bucketsWithPadding\n+  )\n+\n+  override val initialValues = Seq(\n+    zero,\n+    zero,\n+    zero,\n+    Cast(Divide(n, buckets), IntegerType),\n+    Cast(Remainder(n, buckets), IntegerType)\n+  )\n+\n+  override val updateExpressions = Seq(\n+    Add(rowNumber, one),\n+    Add(bucket, bucketOverflow(one)),\n+    Add(bucketThreshold, bucketOverflow(\n+      Add(bucketSize, If(LessThan(bucket, bucketsWithPadding), one, zero)))),\n+    NoOp,\n+    NoOp\n+  )\n+\n+  override val evaluateExpression = bucket\n+}\n+\n+abstract class RankLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = order\n+  override def inputTypes: Seq[AbstractDataType] = children.map(_ => AnyDataType)\n+\n+  val order: Seq[Expression]\n+  protected val orderAttrs = order.map{ expr =>\n+    AttributeReference(expr.prettyString, expr.dataType)()\n+  }\n+\n+  protected val orderEquals = order.zip(orderAttrs)\n+    .map(EqualNullSafe.tupled)\n+    .reduceOption(And)\n+    .getOrElse(Literal(true))\n+  protected val orderInit = order.map(e => Literal.create(null, e.dataType))\n+  protected val rank = AttributeReference(\"rank\", IntegerType, nullable = false)()\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val increaseRowNumber = Add(rowNumber, one)\n+\n+  /** Source of the rank value. */\n+  protected def rankSource: Expression = rowNumber"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "how about we add more comments to explain how this class works?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:11:40Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {\n+  def this() = this(Literal(1))\n+\n+  // Validate buckets.\n+  buckets.eval() match {\n+    case b: Int if b > 0 => // Ok\n+    case x => throw new AnalysisException(\n+      \"Buckets expression must be a foldable positive integer expression: $x\")\n   }\n+\n+  private val bucket = AttributeReference(\"bucket\", IntegerType, nullable = false)()\n+  private val bucketThreshold =\n+    AttributeReference(\"bucketThreshold\", IntegerType, nullable = false)()\n+  private val bucketSize = AttributeReference(\"bucketSize\", IntegerType, nullable = false)()\n+  private val bucketsWithPadding =\n+    AttributeReference(\"bucketsWithPadding\", IntegerType, nullable = false)()\n+  private def bucketOverflow(e: Expression) =\n+    If(GreaterThanOrEqual(rowNumber, bucketThreshold), e, zero)\n+\n+  override val aggBufferAttributes = Seq(\n+    rowNumber,\n+    bucket,\n+    bucketThreshold,\n+    bucketSize,\n+    bucketsWithPadding\n+  )\n+\n+  override val initialValues = Seq(\n+    zero,\n+    zero,\n+    zero,\n+    Cast(Divide(n, buckets), IntegerType),\n+    Cast(Remainder(n, buckets), IntegerType)\n+  )\n+\n+  override val updateExpressions = Seq(\n+    Add(rowNumber, one),\n+    Add(bucket, bucketOverflow(one)),\n+    Add(bucketThreshold, bucketOverflow(\n+      Add(bucketSize, If(LessThan(bucket, bucketsWithPadding), one, zero)))),\n+    NoOp,\n+    NoOp\n+  )\n+\n+  override val evaluateExpression = bucket\n+}\n+\n+abstract class RankLike extends AggregateWindowFunction {"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "I guess we need to say it is also used as the default frame?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:54:34Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame",
    "line": 69
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "Actually, is it used as the default frame?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:56:00Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame",
    "line": 69
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "It is a bit more strict than that. It is the only frame in which a WindowFunction is supposed to be evaluated.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-14T06:56:43Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame",
    "line": 69
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "ah i see.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-17T22:32:47Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame",
    "line": 69
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Add a comment to explain why it uses RangeFrame?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-13T23:56:22Z",
    "diffHunk": "@@ -246,85 +260,238 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n \n-  def reset(): Unit\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  val input: Expression\n+  val default: Expression\n+  val offset: Expression\n+  val offsetSign: Int\n+\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def update(input: AnyRef): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = ValueFollowing(offsetSign * offsetValue)\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n \n-  def evaluate(): Unit\n+  override def dataType: DataType = input.dataType\n \n-  def get(index: Int): Any\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n \n-  def newInstance(): WindowFunction\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  val offsetSign = 1\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n-}\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+  def this() = this(Literal(null))\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+  val offsetSign = -1\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override val mergeExpressions = Nil // TODO how to deal with this?\n+}\n+\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n }\n \n /**\n- * Extractor for making working with frame boundaries easier.\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n  */\n-object FrameBoundaryExtractor {\n-  def unapply(boundary: FrameBoundary): Option[Int] = boundary match {\n-    case CurrentRow => Some(0)\n-    case ValuePreceding(offset) => Some(-offset)\n-    case ValueFollowing(offset) => Some(offset)\n-    case _ => None\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n+\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = Cast(rowNumber, IntegerType)\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)"
  }],
  "prId": 9819
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Seems we can add some comments to explain how it works in a follow-up PR?\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-17T22:33:45Z",
    "diffHunk": "@@ -246,85 +260,281 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  /**\n+   * Input expression to evaluate against a row which a number of rows below or above (depending on\n+   * the value and sign of the offset) the current row.\n+   */\n+  val input: Expression\n+\n+  /**\n+   * Default result value for the function when the input expression returns NULL. The default will\n+   * evaluated against the current row instead of the offset row.\n+   */\n+  val default: Expression\n \n-  def reset(): Unit\n+  /**\n+   * (Foldable) expression that contains the number of rows between the current row and the row\n+   * where the input expression is evaluated.\n+   */\n+  val offset: Expression\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  /**\n+   * Direction (above = 1/below = -1) of the number of rows between the current row and the row\n+   * where the input expression is evaluated.\n+   */\n+  val direction: SortDirection\n \n-  def update(input: AnyRef): Unit\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  /*\n+   * The result of an OffsetWindowFunction is dependent on the frame in which the\n+   * OffsetWindowFunction is executed, the input expression and the default expression. Even when\n+   * both the input and the default expression are foldable, the result is still not foldable due to\n+   * the frame.\n+   */\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def evaluate(): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def get(index: Int): Any\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = direction match {\n+      case Ascending => ValueFollowing(offsetValue)\n+      case Descending => ValuePreceding(offsetValue)\n+    }\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n \n-  def newInstance(): WindowFunction\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  override val direction = Ascending\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n+\n+  def this(input: Expression) = this(input, Literal(1))\n+\n+  def this() = this(Literal(null))\n+\n+  override val direction = Descending\n }\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override def supportsPartial: Boolean = false\n+  override lazy val mergeExpressions =\n+    throw new UnsupportedOperationException(\"Window Functions do not support merging.\")\n+}\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+/**\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+ */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = rowNumber\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  // The frame for CUME_DIST is Range based instead of Row based, because CUME_DIST must\n+  // return the same value for equal values in the partition.\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {",
    "line": 246
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I'll add some documentation on all the window functions. The inner workings of ntile in particular need some documentation.\n",
    "commit": "c181c8b7dd5625ca8f41f578d16eaae5cf04e0c7",
    "createdAt": "2015-12-17T22:58:25Z",
    "diffHunk": "@@ -246,85 +260,281 @@ object SpecifiedWindowFrame {\n   }\n }\n \n+case class UnresolvedWindowExpression(\n+    child: Expression,\n+    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+\n+  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n+  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n+  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n+  override lazy val resolved = false\n+}\n+\n+case class WindowExpression(\n+    windowFunction: Expression,\n+    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+\n+  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+\n+  override def dataType: DataType = windowFunction.dataType\n+  override def foldable: Boolean = windowFunction.foldable\n+  override def nullable: Boolean = windowFunction.nullable\n+\n+  override def toString: String = s\"$windowFunction $windowSpec\"\n+}\n+\n /**\n- * Every window function needs to maintain a output buffer for its output.\n- * It should expect that for a n-row window frame, it will be called n times\n- * to retrieve value corresponding with these n rows.\n+ * A window function is a function that can only be evaluated in the context of a window operator.\n  */\n trait WindowFunction extends Expression {\n-  def init(): Unit\n+  /** Frame in which the window operator must be executed. */\n+  def frame: WindowFrame = UnspecifiedFrame\n+}\n+\n+/**\n+ * An offset window function is a window function that returns the value of the input column offset\n+ * by a number of rows within the partition. For instance: an OffsetWindowfunction for value x with\n+ * offset -2, will get the value of x 2 rows back in the partition.\n+ */\n+abstract class OffsetWindowFunction\n+  extends Expression with WindowFunction with Unevaluable with ImplicitCastInputTypes {\n+  /**\n+   * Input expression to evaluate against a row which a number of rows below or above (depending on\n+   * the value and sign of the offset) the current row.\n+   */\n+  val input: Expression\n+\n+  /**\n+   * Default result value for the function when the input expression returns NULL. The default will\n+   * evaluated against the current row instead of the offset row.\n+   */\n+  val default: Expression\n \n-  def reset(): Unit\n+  /**\n+   * (Foldable) expression that contains the number of rows between the current row and the row\n+   * where the input expression is evaluated.\n+   */\n+  val offset: Expression\n \n-  def prepareInputParameters(input: InternalRow): AnyRef\n+  /**\n+   * Direction (above = 1/below = -1) of the number of rows between the current row and the row\n+   * where the input expression is evaluated.\n+   */\n+  val direction: SortDirection\n \n-  def update(input: AnyRef): Unit\n+  override def children: Seq[Expression] = Seq(input, offset, default)\n \n-  def batchUpdate(inputs: Array[AnyRef]): Unit\n+  /*\n+   * The result of an OffsetWindowFunction is dependent on the frame in which the\n+   * OffsetWindowFunction is executed, the input expression and the default expression. Even when\n+   * both the input and the default expression are foldable, the result is still not foldable due to\n+   * the frame.\n+   */\n+  override def foldable: Boolean = input.foldable && (default == null || default.foldable)\n \n-  def evaluate(): Unit\n+  override def nullable: Boolean = input.nullable && (default == null || default.nullable)\n \n-  def get(index: Int): Any\n+  override lazy val frame = {\n+    // This will be triggered by the Analyzer.\n+    val offsetValue = offset.eval() match {\n+      case o: Int => o\n+      case x => throw new AnalysisException(\n+        s\"Offset expression must be a foldable integer expression: $x\")\n+    }\n+    val boundary = direction match {\n+      case Ascending => ValueFollowing(offsetValue)\n+      case Descending => ValuePreceding(offsetValue)\n+    }\n+    SpecifiedWindowFrame(RowFrame, boundary, boundary)\n+  }\n+\n+  override def dataType: DataType = input.dataType\n \n-  def newInstance(): WindowFunction\n+  override def inputTypes: Seq[AbstractDataType] =\n+    Seq(AnyDataType, IntegerType, TypeCollection(input.dataType, NullType))\n+\n+  override def toString: String = s\"$prettyName($input, $offset, $default)\"\n }\n \n-case class UnresolvedWindowFunction(\n-    name: String,\n-    children: Seq[Expression])\n-  extends Expression with WindowFunction with Unevaluable {\n+case class Lead(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n \n-  override def init(): Unit = throw new UnresolvedException(this, \"init\")\n-  override def reset(): Unit = throw new UnresolvedException(this, \"reset\")\n-  override def prepareInputParameters(input: InternalRow): AnyRef =\n-    throw new UnresolvedException(this, \"prepareInputParameters\")\n-  override def update(input: AnyRef): Unit = throw new UnresolvedException(this, \"update\")\n-  override def batchUpdate(inputs: Array[AnyRef]): Unit =\n-    throw new UnresolvedException(this, \"batchUpdate\")\n-  override def evaluate(): Unit = throw new UnresolvedException(this, \"evaluate\")\n-  override def get(index: Int): Any = throw new UnresolvedException(this, \"get\")\n+  def this(input: Expression) = this(input, Literal(1))\n \n-  override def toString: String = s\"'$name(${children.mkString(\",\")})\"\n+  def this() = this(Literal(null))\n \n-  override def newInstance(): WindowFunction = throw new UnresolvedException(this, \"newInstance\")\n+  override val direction = Ascending\n }\n \n-case class UnresolvedWindowExpression(\n-    child: UnresolvedWindowFunction,\n-    windowSpec: WindowSpecReference) extends UnaryExpression with Unevaluable {\n+case class Lag(input: Expression, offset: Expression, default: Expression)\n+    extends OffsetWindowFunction {\n \n-  override def dataType: DataType = throw new UnresolvedException(this, \"dataType\")\n-  override def foldable: Boolean = throw new UnresolvedException(this, \"foldable\")\n-  override def nullable: Boolean = throw new UnresolvedException(this, \"nullable\")\n-  override lazy val resolved = false\n+  def this(input: Expression, offset: Expression) = this(input, offset, Literal(null))\n+\n+  def this(input: Expression) = this(input, Literal(1))\n+\n+  def this() = this(Literal(null))\n+\n+  override val direction = Descending\n }\n \n-case class WindowExpression(\n-    windowFunction: WindowFunction,\n-    windowSpec: WindowSpecDefinition) extends Expression with Unevaluable {\n+abstract class AggregateWindowFunction extends DeclarativeAggregate with WindowFunction {\n+  self: Product =>\n+  override val frame = SpecifiedWindowFrame(RowFrame, UnboundedPreceding, CurrentRow)\n+  override def dataType: DataType = IntegerType\n+  override def nullable: Boolean = false\n+  override def supportsPartial: Boolean = false\n+  override lazy val mergeExpressions =\n+    throw new UnsupportedOperationException(\"Window Functions do not support merging.\")\n+}\n \n-  override def children: Seq[Expression] = windowFunction :: windowSpec :: Nil\n+abstract class RowNumberLike extends AggregateWindowFunction {\n+  override def children: Seq[Expression] = Nil\n+  override def inputTypes: Seq[AbstractDataType] = Nil\n+  protected val zero = Literal(0)\n+  protected val one = Literal(1)\n+  protected val rowNumber = AttributeReference(\"rowNumber\", IntegerType, nullable = false)()\n+  override val aggBufferAttributes: Seq[AttributeReference] = rowNumber :: Nil\n+  override val initialValues: Seq[Expression] = zero :: Nil\n+  override val updateExpressions: Seq[Expression] = Add(rowNumber, one) :: Nil\n+}\n \n-  override def dataType: DataType = windowFunction.dataType\n-  override def foldable: Boolean = windowFunction.foldable\n-  override def nullable: Boolean = windowFunction.nullable\n+/**\n+ * A [[SizeBasedWindowFunction]] needs the size of the current window for its calculation.\n+ */\n+trait SizeBasedWindowFunction extends AggregateWindowFunction {\n+  protected def n: AttributeReference = SizeBasedWindowFunction.n\n+}\n \n-  override def toString: String = s\"$windowFunction $windowSpec\"\n+object SizeBasedWindowFunction {\n+  val n = AttributeReference(\"window__partition__size\", IntegerType, nullable = false)()\n+}\n+\n+case class RowNumber() extends RowNumberLike {\n+  override val evaluateExpression = rowNumber\n+}\n+\n+case class CumeDist() extends RowNumberLike with SizeBasedWindowFunction {\n+  override def dataType: DataType = DoubleType\n+  // The frame for CUME_DIST is Range based instead of Row based, because CUME_DIST must\n+  // return the same value for equal values in the partition.\n+  override val frame = SpecifiedWindowFrame(RangeFrame, UnboundedPreceding, CurrentRow)\n+  override val evaluateExpression = Divide(Cast(rowNumber, DoubleType), Cast(n, DoubleType))\n+}\n+\n+case class NTile(buckets: Expression) extends RowNumberLike with SizeBasedWindowFunction {",
    "line": 246
  }],
  "prId": 9819
}]