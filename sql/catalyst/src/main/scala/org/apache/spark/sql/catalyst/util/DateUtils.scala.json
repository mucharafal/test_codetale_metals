[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "ns sounds like nano second.\n\nmaybe do\n\nnum100ns\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-09T23:27:26Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toTimestamp(ns: Long): Timestamp = {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "and rename it toJavaTimestamp\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-09T23:30:25Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toTimestamp(ns: Long): Timestamp = {"
  }],
  "prId": 6733
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "is this correct? I think getTime and getNanos might actually overlap in Timestamp\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-09T23:28:25Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toTimestamp(ns: Long): Timestamp = {\n+    // setNanos() will overwrite the millisecond part, so the milliseconds should be\n+    // cut off at seconds\n+    var seconds = ns / HUNDRED_NANOS_PER_SECOND\n+    var nanos = ns % HUNDRED_NANOS_PER_SECOND\n+    // setNanos() can not accept negative value\n+    if (nanos < 0) {\n+      nanos += HUNDRED_NANOS_PER_SECOND\n+      seconds -= 1\n+    }\n+    val t = new Timestamp(seconds * 1000)\n+    t.setNanos(nanos.toInt * 100)\n+    t\n+  }\n+\n+  /**\n+   * Return the number of 100ns since epoch from java.sql.Timestamp.\n+   */\n+  def fromTimestamp(t: Timestamp): Long = {\n+    if (t != null) {\n+      t.getTime() * 10000L + (t.getNanos().toLong / 100) % 10000L"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "let's add unit test for this file. it is too scary.\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-09T23:28:31Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toTimestamp(ns: Long): Timestamp = {\n+    // setNanos() will overwrite the millisecond part, so the milliseconds should be\n+    // cut off at seconds\n+    var seconds = ns / HUNDRED_NANOS_PER_SECOND\n+    var nanos = ns % HUNDRED_NANOS_PER_SECOND\n+    // setNanos() can not accept negative value\n+    if (nanos < 0) {\n+      nanos += HUNDRED_NANOS_PER_SECOND\n+      seconds -= 1\n+    }\n+    val t = new Timestamp(seconds * 1000)\n+    t.setNanos(nanos.toInt * 100)\n+    t\n+  }\n+\n+  /**\n+   * Return the number of 100ns since epoch from java.sql.Timestamp.\n+   */\n+  def fromTimestamp(t: Timestamp): Long = {\n+    if (t != null) {\n+      t.getTime() * 10000L + (t.getNanos().toLong / 100) % 10000L"
  }],
  "prId": 6733
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe name this fromJavaTimestamp\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-09T23:30:17Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toTimestamp(ns: Long): Timestamp = {\n+    // setNanos() will overwrite the millisecond part, so the milliseconds should be\n+    // cut off at seconds\n+    var seconds = ns / HUNDRED_NANOS_PER_SECOND\n+    var nanos = ns % HUNDRED_NANOS_PER_SECOND\n+    // setNanos() can not accept negative value\n+    if (nanos < 0) {\n+      nanos += HUNDRED_NANOS_PER_SECOND\n+      seconds -= 1\n+    }\n+    val t = new Timestamp(seconds * 1000)\n+    t.setNanos(nanos.toInt * 100)\n+    t\n+  }\n+\n+  /**\n+   * Return the number of 100ns since epoch from java.sql.Timestamp.\n+   */\n+  def fromTimestamp(t: Timestamp): Long = {"
  }],
  "prId": 6733
}, {
  "comments": [{
    "author": {
      "login": "adrian-wang"
    },
    "body": "since we are supporting timestamp here, Maybe we want to rename this object to DateTimeUtils, and also update the javadoc.\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-11T07:04:09Z",
    "diffHunk": "@@ -28,6 +28,7 @@ import org.apache.spark.sql.catalyst.expressions.Cast\n  */\n object DateUtils {",
    "line": 11
  }],
  "prId": 6733
}, {
  "comments": [{
    "author": {
      "login": "adrian-wang"
    },
    "body": "why not use -1L just like the initial value?\n",
    "commit": "d9565fa49c9f26bf38db8f7028c8959b54297954",
    "createdAt": "2015-06-11T07:27:06Z",
    "diffHunk": "@@ -87,4 +88,33 @@ object DateUtils {\n       ISO8601GMT.parse(s)\n     }\n   }\n+\n+  /**\n+   * Return a java.sql.Timestamp from number of 100ns since epoch\n+   */\n+  def toJavaTimestamp(num100ns: Long): Timestamp = {\n+    // setNanos() will overwrite the millisecond part, so the milliseconds should be\n+    // cut off at seconds\n+    var seconds = num100ns / HUNDRED_NANOS_PER_SECOND\n+    var nanos = num100ns % HUNDRED_NANOS_PER_SECOND\n+    // setNanos() can not accept negative value\n+    if (nanos < 0) {\n+      nanos += HUNDRED_NANOS_PER_SECOND\n+      seconds -= 1\n+    }\n+    val t = new Timestamp(seconds * 1000)\n+    t.setNanos(nanos.toInt * 100)\n+    t\n+  }\n+\n+  /**\n+   * Return the number of 100ns since epoch from java.sql.Timestamp.\n+   */\n+  def fromJavaTimestamp(t: Timestamp): Long = {\n+    if (t != null) {\n+      t.getTime() * 10000L + (t.getNanos().toLong / 100) % 10000L\n+    } else {\n+      0L",
    "line": 81
  }],
  "prId": 6733
}]