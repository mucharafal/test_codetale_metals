[{
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "We should move these into companion object?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:09:00Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I think this makes the code easier (more compact). But I can put them in the companion object and import all them if you prefer.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T12:01:01Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "`codePointAt()` instead of `charAt()`?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:35:30Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Hive uses `charAt`. So I kept its implementation in order to be consistent with it. I think this depends on our goal. If we want to reflect Hive's behavior (as I assumed), I think we should not change this. Otherwise we have to decide what to do, ie. how these functions are supposed to behave.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T12:13:59Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "I think we don't need to follow Hive behavior perfectly and we should handle proper way.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-10T06:51:05Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "ditto.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:35:37Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "`codePointCount()` instead of `length()`?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:39:56Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)\n+  }\n+\n+  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n+    nullSafeCodeGen(ctx, ev, (input: String) => {\n+      val sb = ctx.freshName(\"sb\")\n+      val inputString = ctx.freshName(\"inputString\")\n+      s\"\"\"\n+         |String $inputString = $input.toString();\n+         |StringBuilder $sb = new StringBuilder($inputString.length());\n+         |${maskAndAppendToStringBuilderCode(ctx, sb, inputString, \"0\", s\"$inputString.length()\")}"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "same answer as before, Hive does this...",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T12:15:48Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)\n+  }\n+\n+  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n+    nullSafeCodeGen(ctx, ev, (input: String) => {\n+      val sb = ctx.freshName(\"sb\")\n+      val inputString = ctx.freshName(\"inputString\")\n+      s\"\"\"\n+         |String $inputString = $input.toString();\n+         |StringBuilder $sb = new StringBuilder($inputString.length());\n+         |${maskAndAppendToStringBuilderCode(ctx, sb, inputString, \"0\", s\"$inputString.length()\")}"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "Can we handle code points correctly?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:41:45Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "We need `prettyName`?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T10:52:24Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)\n+  }\n+\n+  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n+    nullSafeCodeGen(ctx, ev, (input: String) => {\n+      val sb = ctx.freshName(\"sb\")\n+      val inputString = ctx.freshName(\"inputString\")\n+      s\"\"\"\n+         |String $inputString = $input.toString();\n+         |StringBuilder $sb = new StringBuilder($inputString.length());\n+         |${maskAndAppendToStringBuilderCode(ctx, sb, inputString, \"0\", s\"$inputString.length()\")}\n+         |${ev.value} = UTF8String.fromString($sb.toString());\n+         |\"\"\".stripMargin\n+    })\n+  }\n+\n+  override def dataType: DataType = StringType\n+\n+  override def inputTypes: Seq[AbstractDataType] = Seq(StringType)\n+}",
    "line": 201
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "no, `Mask`'s `prettyName` is `mask` by default.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-09T12:38:54Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)\n+  }\n+\n+  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n+    nullSafeCodeGen(ctx, ev, (input: String) => {\n+      val sb = ctx.freshName(\"sb\")\n+      val inputString = ctx.freshName(\"inputString\")\n+      s\"\"\"\n+         |String $inputString = $input.toString();\n+         |StringBuilder $sb = new StringBuilder($inputString.length());\n+         |${maskAndAppendToStringBuilderCode(ctx, sb, inputString, \"0\", s\"$inputString.length()\")}\n+         |${ev.value} = UTF8String.fromString($sb.toString());\n+         |\"\"\".stripMargin\n+    })\n+  }\n+\n+  override def dataType: DataType = StringType\n+\n+  override def inputTypes: Seq[AbstractDataType] = Seq(StringType)\n+}",
    "line": 201
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "Oops, my bad.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-10T06:51:08Z",
    "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def maskAndAppendToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($inputString.charAt($i),\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      start: String,\n+      end: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = $start; $i < $end; $i ++) {\n+       |  $sb.appendCodePoint($inputString.charAt($i));\n+       |}\n+     \"\"\".stripMargin\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, MaskLike.extractReplacement(upper), MaskLike.extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child,\n+      MaskLike.extractReplacement(upper),\n+      MaskLike.extractReplacement(lower),\n+      MaskLike.extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val res = input.asInstanceOf[UTF8String].toString.map(transformChar(\n+      _, upperReplacement, lowerReplacement, digitReplacement, defaultMaskedOther).toChar)\n+    UTF8String.fromString(res)\n+  }\n+\n+  override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode = {\n+    nullSafeCodeGen(ctx, ev, (input: String) => {\n+      val sb = ctx.freshName(\"sb\")\n+      val inputString = ctx.freshName(\"inputString\")\n+      s\"\"\"\n+         |String $inputString = $input.toString();\n+         |StringBuilder $sb = new StringBuilder($inputString.length());\n+         |${maskAndAppendToStringBuilderCode(ctx, sb, inputString, \"0\", s\"$inputString.length()\")}\n+         |${ev.value} = UTF8String.fromString($sb.toString());\n+         |\"\"\".stripMargin\n+    })\n+  }\n+\n+  override def dataType: DataType = StringType\n+\n+  override def inputTypes: Seq[AbstractDataType] = Seq(StringType)\n+}",
    "line": 201
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "nit: `StringBuilder` looks better since it does not have `sychronized` methods. Other usages are, too.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-11T16:32:55Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "`StringBuilder` doesn't have the `appendCodePoint` method unfortunately...",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-11T16:38:14Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "According to [this](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html#appendCodePoint-int-), IIUC, it has...",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-11T16:50:42Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "that is the java one, which has the method. The scala `StringBuilder` doesn't have this method. You can check it [here](https://www.scala-lang.org/api/2.12.2/scala/collection/mutable/StringBuilder.html).",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-11T17:55:18Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "got it, sorry for my bad",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-12T00:55:45Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "np, thanks for checking this.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-12T09:50:44Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "Let's use `java.lang.StringBuilder`. We don't need to use Scala's one.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-14T04:38:19Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount\n+  }\n+\n+  def extractReplacement(e: Expression): String = e match {\n+    case Literal(s, StringType|NullType) => if (s == null) null else s.toString\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${StringType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => null\n+  }\n+}\n+\n+/**\n+ * Masks the input string. Additional parameters can be set to change the masking chars for\n+ * uppercase letters, lowercase letters and digits.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(str[, upper[, lower[, digit]]]) - Masks str. By default, upper case letters are converted to \\\"X\\\", lower case letters are converted to \\\"x\\\" and numbers are converted to \\\"n\\\". You can override the characters used in the mask by supplying additional arguments: the second argument controls the mask character for upper case letters, the third argument for lower case letters and the fourth argument for numbers.\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(\"abcd-EFGH-8765-4321\", \"U\", \"l\", \"#\");\n+       llll-UUUU-####-####\n+  \"\"\")\n+// scalastyle:on line.size.limit\n+case class Mask(child: Expression, upper: String, lower: String, digit: String)\n+  extends UnaryExpression with ExpectsInputTypes with MaskLike {\n+\n+  def this(child: Expression) = this(child, null.asInstanceOf[String], null, null)\n+\n+  def this(child: Expression, upper: Expression) =\n+    this(child, extractReplacement(upper), null, null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), null)\n+\n+  def this(child: Expression, upper: Expression, lower: Expression, digit: Expression) =\n+    this(child, extractReplacement(upper), extractReplacement(lower), extractReplacement(digit))\n+\n+  override def nullSafeEval(input: Any): Any = {\n+    val str = input.asInstanceOf[UTF8String].toString\n+    val length = str.codePointCount(0, str.length())\n+    val sb = new StringBuffer(length)"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "nit: maybe `IntegerType | NullType`",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-14T04:48:36Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "nit: no need `s` interpolation.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-14T05:03:20Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "This causes unexpected behavior for users?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-14T05:05:19Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I don't think so. Hive behaves in this way: when an expression which is not a `Literal` is provided, then the default value is used.",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-14T12:55:09Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount"
  }, {
    "author": {
      "login": "ueshin"
    },
    "body": "cc @gatorsmile ",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-15T06:56:31Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Ignoring the user inputs looks weird to me. We do not need to follow Hive in the error handling of this case",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-22T17:48:43Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer(\n+      sb: StringBuffer,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(codePoint)\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+}\n+\n+trait MaskLikeWithN extends MaskLike {\n+  def n: Int\n+  protected lazy val charCount: Int = if (n < 0) 0 else n\n+}\n+\n+/**\n+ * Utils for mask operations.\n+ */\n+object MaskLike {\n+  val defaultCharCount = 4\n+  val defaultMaskedUppercase: Int = 'X'\n+  val defaultMaskedLowercase: Int = 'x'\n+  val defaultMaskedDigit: Int = 'n'\n+  val defaultMaskedOther: Int = MaskExpressionsUtils.UNMASKED_VAL\n+\n+  def extractCharCount(e: Expression): Int = e match {\n+    case Literal(i, IntegerType|NullType) =>\n+      if (i == null) defaultCharCount else i.asInstanceOf[Int]\n+    case Literal(_, dt) => throw new AnalysisException(s\"Expected literal expression of type \" +\n+      s\"${IntegerType.simpleString}, but got literal of ${dt.simpleString}\")\n+    case _ => defaultCharCount"
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "`appendMaskedToStringBuilder`?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-15T06:54:17Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer("
  }],
  "prId": 21246
}, {
  "comments": [{
    "author": {
      "login": "ueshin"
    },
    "body": "`appendUnchangedToStringBuilder`?",
    "commit": "6fd8f2fbd37e5193f0ffb1a25a8f4a8c71ab55bd",
    "createdAt": "2018-05-15T06:54:29Z",
    "diffHunk": "@@ -0,0 +1,569 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.commons.codec.digest.DigestUtils\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.MaskExpressionsUtils._\n+import org.apache.spark.sql.catalyst.expressions.MaskLike._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{CodegenContext, CodeGenerator, ExprCode}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+\n+trait MaskLike {\n+  def upper: String\n+  def lower: String\n+  def digit: String\n+\n+  protected lazy val upperReplacement: Int = getReplacementChar(upper, defaultMaskedUppercase)\n+  protected lazy val lowerReplacement: Int = getReplacementChar(lower, defaultMaskedLowercase)\n+  protected lazy val digitReplacement: Int = getReplacementChar(digit, defaultMaskedDigit)\n+\n+  protected val maskUtilsClassName: String = classOf[MaskExpressionsUtils].getName\n+\n+  def inputStringLengthCode(inputString: String, length: String): String = {\n+    s\"${CodeGenerator.JAVA_INT} $length = $inputString.codePointCount(0, $inputString.length());\"\n+  }\n+\n+  def appendMaskedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($maskUtilsClassName.transformChar($codePoint,\n+       |    $upperReplacement, $lowerReplacement,\n+       |    $digitReplacement, $defaultMaskedOther));\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendUnchangedToStringBuilderCode(\n+      ctx: CodegenContext,\n+      sb: String,\n+      inputString: String,\n+      offset: String,\n+      numChars: String): String = {\n+    val i = ctx.freshName(\"i\")\n+    val codePoint = ctx.freshName(\"codePoint\")\n+    s\"\"\"\n+       |for (${CodeGenerator.JAVA_INT} $i = 0; $i < $numChars; $i++) {\n+       |  ${CodeGenerator.JAVA_INT} $codePoint = $inputString.codePointAt($offset);\n+       |  $sb.appendCodePoint($codePoint);\n+       |  $offset += Character.charCount($codePoint);\n+       |}\n+     \"\"\".stripMargin\n+  }\n+\n+  def appendMaskedToStringBuffer(\n+      sb: java.lang.StringBuilder,\n+      inputString: String,\n+      startOffset: Int,\n+      numChars: Int): Int = {\n+    var offset = startOffset\n+    (1 to numChars) foreach { _ =>\n+      val codePoint = inputString.codePointAt(offset)\n+      sb.appendCodePoint(transformChar(\n+        codePoint,\n+        upperReplacement,\n+        lowerReplacement,\n+        digitReplacement,\n+        defaultMaskedOther))\n+      offset += Character.charCount(codePoint)\n+    }\n+    offset\n+  }\n+\n+  def appendUnchangedToStringBuffer("
  }],
  "prId": 21246
}]