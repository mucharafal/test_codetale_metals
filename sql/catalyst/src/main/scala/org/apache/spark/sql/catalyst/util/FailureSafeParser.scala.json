[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "without this change in `FailureSafeParser`, does JSON support returning partial result?",
    "commit": "e09d41704a3f0cd940a1334914f07f5d1794a5d1",
    "createdAt": "2018-11-28T11:37:05Z",
    "diffHunk": "@@ -33,26 +33,21 @@ class FailureSafeParser[IN](\n   private val corruptFieldIndex = schema.getFieldIndex(columnNameOfCorruptRecord)\n   private val actualSchema = StructType(schema.filterNot(_.name == columnNameOfCorruptRecord))\n   private val resultRow = new GenericInternalRow(schema.length)\n-  private val nullResult = new GenericInternalRow(schema.length)\n \n   // This function takes 2 parameters: an optional partial result, and the bad record. If the given\n   // schema doesn't contain a field for corrupted record, we just return the partial result or a\n   // row with all fields null. If the given schema contains a field for corrupted record, we will\n   // set the bad record to this field, and set other fields according to the partial result or null.\n   private val toResultRow: (Option[InternalRow], () => UTF8String) => InternalRow = {\n-    if (corruptFieldIndex.isDefined) {\n-      (row, badRecord) => {\n-        var i = 0\n-        while (i < actualSchema.length) {\n-          val from = actualSchema(i)\n-          resultRow(schema.fieldIndex(from.name)) = row.map(_.get(i, from.dataType)).orNull\n-          i += 1\n-        }\n-        resultRow(corruptFieldIndex.get) = badRecord()\n-        resultRow\n+    (row, badRecord) => {",
    "line": 21
  }, {
    "author": {
      "login": "MaxGekk"
    },
    "body": "For now JSON does not support this. Need additional changes in JacksonParser to return partial results.",
    "commit": "e09d41704a3f0cd940a1334914f07f5d1794a5d1",
    "createdAt": "2018-11-28T12:37:01Z",
    "diffHunk": "@@ -33,26 +33,21 @@ class FailureSafeParser[IN](\n   private val corruptFieldIndex = schema.getFieldIndex(columnNameOfCorruptRecord)\n   private val actualSchema = StructType(schema.filterNot(_.name == columnNameOfCorruptRecord))\n   private val resultRow = new GenericInternalRow(schema.length)\n-  private val nullResult = new GenericInternalRow(schema.length)\n \n   // This function takes 2 parameters: an optional partial result, and the bad record. If the given\n   // schema doesn't contain a field for corrupted record, we just return the partial result or a\n   // row with all fields null. If the given schema contains a field for corrupted record, we will\n   // set the bad record to this field, and set other fields according to the partial result or null.\n   private val toResultRow: (Option[InternalRow], () => UTF8String) => InternalRow = {\n-    if (corruptFieldIndex.isDefined) {\n-      (row, badRecord) => {\n-        var i = 0\n-        while (i < actualSchema.length) {\n-          val from = actualSchema(i)\n-          resultRow(schema.fieldIndex(from.name)) = row.map(_.get(i, from.dataType)).orNull\n-          i += 1\n-        }\n-        resultRow(corruptFieldIndex.get) = badRecord()\n-        resultRow\n+    (row, badRecord) => {",
    "line": 21
  }],
  "prId": 23120
}]