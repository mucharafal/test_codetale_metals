[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Could you add a single space after newline, e.g. '\\n`->`\\n `?\nIn many cases, we do that.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T08:37:53Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")"
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "added\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T18:19:12Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")"
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Minor: `children(0)` -> `children.head`\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T08:38:53Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString",
    "line": 89
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "Why? I don't think head is more clear.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T16:58:48Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString",
    "line": 89
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Could you replace this\n\n``` scala\nvar i = 0\nwhile (i < argExprs.length) {\n  ...\n  i += 1\n}\n```\n\nwith the following?\n\n``` scala\nfor (i <- argExprs.indices) {\n   ...\n}\n```\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T08:41:46Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {",
    "line": 73
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Why? Both seem fine to me?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T13:41:08Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {",
    "line": 73
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`while` is preferred here. The `eval` method is critical path and `for` loop in scala in slow.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T03:49:34Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {",
    "line": 73
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Currently, this is a boolean. Can we use this for `val clazz: Class[_]` instead?\nFor `false`, it could be null.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T09:04:46Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)",
    "line": 92
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "What I mean is the following.\n\n``` scala\n- } else if (!classExists) {\n+ } else if (clazz.getOrElse(null) == null) {\n...\n- @transient private lazy val classExists = Reflect.classExists(className)\n+ @transient private lazy val clazz = Reflect.findClass(className)\n...\n- private def classExists(className: String): Boolean = { ... }\n+ private def findClass(className: String): Try[Class[_]] = Try(Utils.classForName(className))\n...\n- Reflect.findMethod(className, methodName, ...\n+ Reflect.findMethod(clazz.get, methodName, ...\n...\n- Reflect.instantiate(className).orNull.asInstanceOf[Object]\n+ Reflect.instantiate(clazz.get).orNull.asInstanceOf[Object]\n...\n- def findMethod(className: String, methodName: String, ...\n+ def findMethod(clazz: Class[_], methodName: String, ...\n...\n- def instantiate(className: String): Option[Any] = {\n+ def instantiate(clazz: Class[_]): Option[Any] = {\n```\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T09:24:37Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)",
    "line": 92
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "It'd make unit test more annoying to write. I kind of prefer doing it this way, since the cost of creating a class 3 times is very small given it's created only once.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T17:02:11Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)",
    "line": 92
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Let's forget about `Try`. It's not a good style, too.\n\nBTW, do you mean `Utils.classForName` is called once in this PR?\n\n> given it's created only once.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T18:33:29Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)",
    "line": 92
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Hive's reflect allows a method to return anything Hive can serialize. Why do we only return a String?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T13:42:58Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))",
    "line": 83
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oh, it does. I referenced the wrong part of Hive before; (GenericUDFReflect.java).\n\nhttps://github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect.java#L137\n\n```\ntry {\n      return String.valueOf(m.invoke(o, parameterJavaValues));\n```\n\nYou mean GenericUDFReflect2.java, right?\n\nhttps://github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFReflect2.java\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T17:01:50Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))",
    "line": 83
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "Yes Hive only supports string for reflect.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T18:13:07Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))",
    "line": 83
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. `reflect` does. `reflect2` is not related to this PR.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T18:20:55Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))",
    "line": 83
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "What about timestamps, dates, decimals, arrays, maps? I suppose structs are entirely out of the question? If they are please document this.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T13:43:38Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {"
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "Let me add a comment saying only string is supported for now.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-08T16:59:09Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\nc33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion.\n+      if (buffer(i).isInstanceOf[UTF8String]) {"
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`Reflect` is really ambiguous, how about `CallMethod`?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T03:47:24Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "I actually named it JavaMethodReflect before but @dongjoon-hyun asked to use Reflect.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:15:41Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "It is also annoying if we search for reflect (based on the name) and then doesn't find an expression with reflect in the name.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:16:08Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ya. It's my fault. Sorry for that.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:40:50Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "So what's a good name? I am not attached to Reflect, but I think Reflect should be in the name, if the function is called reflect.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:48:25Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "`CallMethodUsingReflect`?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T05:33:35Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])",
    "line": 47
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "So we always create an instance and call method? How do we handle static method?\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:44:03Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]",
    "line": 102
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "java's reflection library actually handles static methods safely, even if something other than \"null\" is passed into invoke.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T05:03:54Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]",
    "line": 102
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "We should at least document it, or other readers will be confused about how we handle static method.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T05:21:29Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]",
    "line": 102
  }],
  "prId": 13969
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "It looks like a premature optimization to me, it's unusual to pass a lot of argument to a method.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:45:18Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]\n+\n+  /** A temporary buffer used to hold intermediate results returned by children. */\n+  @transient private lazy val buffer = new Array[Object](argExprs.length)",
    "line": 105
  }, {
    "author": {
      "login": "petermaxlee"
    },
    "body": "It doesn't matter how many arguments there are, but the array is always created. This is what Hive does too. I don't buy the premature optimization argument, since this is pretty simple to do.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:47:07Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]\n+\n+  /** A temporary buffer used to hold intermediate results returned by children. */\n+  @transient private lazy val buffer = new Array[Object](argExprs.length)",
    "line": 105
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "ok you are right, it's still a lot of cost to create an array everytime, even the array is small.\n",
    "commit": "d24ca97a0ac85b54ea64b017343fe9eb51ecc02e",
    "createdAt": "2016-07-11T04:49:19Z",
    "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.lang.reflect.Method\n+\n+import scala.util.Try\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult.{TypeCheckFailure, TypeCheckSuccess}\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+import org.apache.spark.util.Utils\n+\n+/**\n+ * An expression that invokes a method on a class via reflection.\n+ *\n+ * For now, only types defined in `Reflect.typeMapping` are supported (basically primitives\n+ * and string) as input types, and the output is turned automatically to a string.\n+ *\n+ * @param children the first element should be a literal string for the class name,\n+ *                 and the second element should be a literal string for the method name,\n+ *                 and the remaining are input arguments to the Java method.\n+ */\n+// scalastyle:off line.size.limit\n+@ExpressionDescription(\n+  usage = \"_FUNC_(class,method[,arg1[,arg2..]]) calls method with reflection\",\n+  extended = \"> SELECT _FUNC_('java.util.UUID', 'randomUUID');\\n c33fb387-8500-4bfa-81d2-6e0e3e930df2\")\n+// scalastyle:on line.size.limit\n+case class Reflect(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  override def prettyName: String = \"reflect\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.size < 2) {\n+      TypeCheckFailure(\"requires at least two arguments\")\n+    } else if (!children.take(2).forall(e => e.dataType == StringType && e.foldable)) {\n+      // The first two arguments must be string type.\n+      TypeCheckFailure(\"first two arguments should be string literals\")\n+    } else if (!classExists) {\n+      TypeCheckFailure(s\"class $className not found\")\n+    } else if (method == null) {\n+      TypeCheckFailure(s\"cannot find a method that matches the argument types in $className\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def deterministic: Boolean = false\n+  override def nullable: Boolean = true\n+  override val dataType: DataType = StringType\n+\n+  override def eval(input: InternalRow): Any = {\n+    var i = 0\n+    while (i < argExprs.length) {\n+      buffer(i) = argExprs(i).eval(input).asInstanceOf[Object]\n+      // Convert if necessary. Based on the types defined in typeMapping, string is the only\n+      // type that needs conversion. If we support timestamps, dates, decimals, arrays, or maps\n+      // in the future, proper conversion needs to happen here too.\n+      if (buffer(i).isInstanceOf[UTF8String]) {\n+        buffer(i) = buffer(i).toString\n+      }\n+      i += 1\n+    }\n+    UTF8String.fromString(String.valueOf(method.invoke(obj, buffer : _*)))\n+  }\n+\n+  @transient private lazy val argExprs: Array[Expression] = children.drop(2).toArray\n+\n+  /** Name of the class -- this has to be called after we verify children has at least two exprs. */\n+  @transient private lazy val className = children(0).eval().asInstanceOf[UTF8String].toString\n+\n+  /** True if the class exists and can be loaded. */\n+  @transient private lazy val classExists = Reflect.classExists(className)\n+\n+  /** The reflection method. */\n+  @transient lazy val method: Method = {\n+    val methodName = children(1).eval(null).asInstanceOf[UTF8String].toString\n+    Reflect.findMethod(className, methodName, argExprs.map(_.dataType)).orNull\n+  }\n+\n+  /** If the class has a no-arg ctor, instantiate the object. Otherwise, obj is null. */\n+  @transient private lazy val obj: Object =\n+    Reflect.instantiate(className).orNull.asInstanceOf[Object]\n+\n+  /** A temporary buffer used to hold intermediate results returned by children. */\n+  @transient private lazy val buffer = new Array[Object](argExprs.length)",
    "line": 105
  }],
  "prId": 13969
}]