[{
  "comments": [{
    "author": {
      "login": "gatorsmile"
    },
    "body": "@andrewor14 Let me know if you want me to split it into two separate error messages. That means, we will have an extra checking condition with an extra parameter. Thanks!\n",
    "commit": "f4207e3c185a13a7f2866b0f12fcde5b28b8d948",
    "createdAt": "2016-05-31T23:30:03Z",
    "diffHunk": "@@ -50,6 +50,17 @@ object ParserUtils {\n     }\n   }\n \n+  /** Check if duplicate exist in a set of column names. */\n+  def checkDuplicateNames[T](colNames: Seq[String], ctx: ParserRuleContext): Unit = {\n+    if (colNames.length != colNames.distinct.length) {\n+      val duplicateColumns = colNames.groupBy(identity).collect {\n+        case (x, ys) if ys.length > 1 => \"\\\"\" + x + \"\\\"\"\n+      }\n+      throw new ParseException(s\"Column repeated in partitioning column(s) or duplicate column \" +\n+        s\"name key in the table definition: ${duplicateColumns.mkString(\"[\", \",\", \"]\")}\", ctx)"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "I wouldn't put this in a separate method. It's only used in 1 place. Just leave it inside `visitCreateTable` like you did before\n",
    "commit": "f4207e3c185a13a7f2866b0f12fcde5b28b8d948",
    "createdAt": "2016-06-01T00:20:38Z",
    "diffHunk": "@@ -50,6 +50,17 @@ object ParserUtils {\n     }\n   }\n \n+  /** Check if duplicate exist in a set of column names. */\n+  def checkDuplicateNames[T](colNames: Seq[String], ctx: ParserRuleContext): Unit = {\n+    if (colNames.length != colNames.distinct.length) {\n+      val duplicateColumns = colNames.groupBy(identity).collect {\n+        case (x, ys) if ys.length > 1 => \"\\\"\" + x + \"\\\"\"\n+      }\n+      throw new ParseException(s\"Column repeated in partitioning column(s) or duplicate column \" +\n+        s\"name key in the table definition: ${duplicateColumns.mkString(\"[\", \",\", \"]\")}\", ctx)"
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "also, there you can give a more specific error message; the issue here is that a column is specified in both the schema and in the partitioned by clause\n",
    "commit": "f4207e3c185a13a7f2866b0f12fcde5b28b8d948",
    "createdAt": "2016-06-01T00:22:04Z",
    "diffHunk": "@@ -50,6 +50,17 @@ object ParserUtils {\n     }\n   }\n \n+  /** Check if duplicate exist in a set of column names. */\n+  def checkDuplicateNames[T](colNames: Seq[String], ctx: ParserRuleContext): Unit = {\n+    if (colNames.length != colNames.distinct.length) {\n+      val duplicateColumns = colNames.groupBy(identity).collect {\n+        case (x, ys) if ys.length > 1 => \"\\\"\" + x + \"\\\"\"\n+      }\n+      throw new ParseException(s\"Column repeated in partitioning column(s) or duplicate column \" +\n+        s\"name key in the table definition: ${duplicateColumns.mkString(\"[\", \",\", \"]\")}\", ctx)"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Sure, will do. \n",
    "commit": "f4207e3c185a13a7f2866b0f12fcde5b28b8d948",
    "createdAt": "2016-06-01T00:24:13Z",
    "diffHunk": "@@ -50,6 +50,17 @@ object ParserUtils {\n     }\n   }\n \n+  /** Check if duplicate exist in a set of column names. */\n+  def checkDuplicateNames[T](colNames: Seq[String], ctx: ParserRuleContext): Unit = {\n+    if (colNames.length != colNames.distinct.length) {\n+      val duplicateColumns = colNames.groupBy(identity).collect {\n+        case (x, ys) if ys.length > 1 => \"\\\"\" + x + \"\\\"\"\n+      }\n+      throw new ParseException(s\"Column repeated in partitioning column(s) or duplicate column \" +\n+        s\"name key in the table definition: ${duplicateColumns.mkString(\"[\", \",\", \"]\")}\", ctx)"
  }],
  "prId": 13415
}]