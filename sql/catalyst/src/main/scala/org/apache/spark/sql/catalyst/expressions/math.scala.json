[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "previously Hex was put in the binary section.\n\ncc @davies\n",
    "commit": "a914cc36d39207c2730aafb5708c3feb0cffc3df",
    "createdAt": "2015-06-30T03:04:06Z",
    "diffHunk": "@@ -239,61 +231,13 @@ case class Bin(child: Expression)\n   }\n }\n \n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-// Binary math functions\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-\n-case class Atan2(left: Expression, right: Expression)\n-  extends BinaryMathExpression(math.atan2, \"ATAN2\") {\n-\n-  override def eval(input: InternalRow): Any = {\n-    val evalE1 = left.eval(input)\n-    if (evalE1 == null) {\n-      null\n-    } else {\n-      val evalE2 = right.eval(input)\n-      if (evalE2 == null) {\n-        null\n-      } else {\n-        // With codegen, the values returned by -0.0 and 0.0 are different. Handled with +0.0\n-        val result = math.atan2(evalE1.asInstanceOf[Double] + 0.0,\n-          evalE2.asInstanceOf[Double] + 0.0)\n-        if (result.isNaN) null else result\n-      }\n-    }\n-  }\n-\n-  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n-    defineCodeGen(ctx, ev, (c1, c2) => s\"java.lang.Math.atan2($c1 + 0.0, $c2 + 0.0)\") + s\"\"\"\n-      if (Double.valueOf(${ev.primitive}).isNaN()) {\n-        ${ev.isNull} = true;\n-      }\n-      \"\"\"\n-  }\n-}\n-\n-case class Pow(left: Expression, right: Expression)\n-  extends BinaryMathExpression(math.pow, \"POWER\") {\n-  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n-    defineCodeGen(ctx, ev, (c1, c2) => s\"java.lang.Math.pow($c1, $c2)\") + s\"\"\"\n-      if (Double.valueOf(${ev.primitive}).isNaN()) {\n-        ${ev.isNull} = true;\n-      }\n-      \"\"\"\n-  }\n-}\n \n /**\n  * If the argument is an INT or binary, hex returns the number as a STRING in hexadecimal format.\n- * Otherwise if the number is a STRING,\n- * it converts each character into its hexadecimal representation and returns the resulting STRING.\n- * Negative numbers would be treated as two's complement.\n+ * Otherwise if the number is a STRING, it converts each character into its hex representation\n+ * and returns the resulting STRING. Negative numbers would be treated as two's complement.\n  */\n-case class Hex(child: Expression)\n-  extends UnaryExpression with Serializable  {\n+case class Hex(child: Expression) extends UnaryExpression with Serializable  {",
    "line": 100
  }, {
    "author": {
      "login": "sujkh85"
    },
    "body": "## NAVER - http://www.naver.com/\n\nsujkh@naver.com 님께 보내신 메일 <Re: [spark] [SPARK-8721][SQL] Rename ExpectsInputTypes => AutoCastInputTypes. (#7109)> 이 다음과 같은 이유로 전송 실패했습니다.\n\n---\n\n받는 사람이 회원님의 메일을 수신차단 하였습니다. \n\n---\n",
    "commit": "a914cc36d39207c2730aafb5708c3feb0cffc3df",
    "createdAt": "2015-06-30T03:27:15Z",
    "diffHunk": "@@ -239,61 +231,13 @@ case class Bin(child: Expression)\n   }\n }\n \n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-// Binary math functions\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-////////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-\n-case class Atan2(left: Expression, right: Expression)\n-  extends BinaryMathExpression(math.atan2, \"ATAN2\") {\n-\n-  override def eval(input: InternalRow): Any = {\n-    val evalE1 = left.eval(input)\n-    if (evalE1 == null) {\n-      null\n-    } else {\n-      val evalE2 = right.eval(input)\n-      if (evalE2 == null) {\n-        null\n-      } else {\n-        // With codegen, the values returned by -0.0 and 0.0 are different. Handled with +0.0\n-        val result = math.atan2(evalE1.asInstanceOf[Double] + 0.0,\n-          evalE2.asInstanceOf[Double] + 0.0)\n-        if (result.isNaN) null else result\n-      }\n-    }\n-  }\n-\n-  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n-    defineCodeGen(ctx, ev, (c1, c2) => s\"java.lang.Math.atan2($c1 + 0.0, $c2 + 0.0)\") + s\"\"\"\n-      if (Double.valueOf(${ev.primitive}).isNaN()) {\n-        ${ev.isNull} = true;\n-      }\n-      \"\"\"\n-  }\n-}\n-\n-case class Pow(left: Expression, right: Expression)\n-  extends BinaryMathExpression(math.pow, \"POWER\") {\n-  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n-    defineCodeGen(ctx, ev, (c1, c2) => s\"java.lang.Math.pow($c1, $c2)\") + s\"\"\"\n-      if (Double.valueOf(${ev.primitive}).isNaN()) {\n-        ${ev.isNull} = true;\n-      }\n-      \"\"\"\n-  }\n-}\n \n /**\n  * If the argument is an INT or binary, hex returns the number as a STRING in hexadecimal format.\n- * Otherwise if the number is a STRING,\n- * it converts each character into its hexadecimal representation and returns the resulting STRING.\n- * Negative numbers would be treated as two's complement.\n+ * Otherwise if the number is a STRING, it converts each character into its hex representation\n+ * and returns the resulting STRING. Negative numbers would be treated as two's complement.\n  */\n-case class Hex(child: Expression)\n-  extends UnaryExpression with Serializable  {\n+case class Hex(child: Expression) extends UnaryExpression with Serializable  {",
    "line": 100
  }],
  "prId": 7109
}]