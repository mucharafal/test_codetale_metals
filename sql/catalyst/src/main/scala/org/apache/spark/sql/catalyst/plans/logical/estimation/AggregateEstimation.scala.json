[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i don't get what this note means. ",
    "commit": "c95067f0469ec1ccef9140988ded27cea882edbf",
    "createdAt": "2017-01-06T06:52:46Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical.estimation\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, Statistics}\n+\n+\n+object AggregateEstimation {\n+  import EstimationUtils._\n+\n+  def estimate(agg: Aggregate): Option[Statistics] = {\n+    val childStats = agg.child.statistics\n+    // Check if we have column stats for all group-by columns.\n+    val colStatsExist = agg.groupingExpressions.forall { e =>\n+      e.isInstanceOf[Attribute] && childStats.attributeStats.contains(e.asInstanceOf[Attribute])\n+    }\n+    if (rowCountsExist(agg.child) && colStatsExist) {\n+      // Initial value for agg without group expressions\n+      var outputRows: BigInt = 1\n+      agg.groupingExpressions.map(_.asInstanceOf[Attribute]).foreach { attr =>\n+        val colStat = childStats.attributeStats(attr)\n+        // Multiply distinct counts of group by columns. This is an upper bound, which assumes\n+        // the data contains all combinations of distinct values of group by columns.\n+        outputRows *= colStat.distinctCount\n+      }\n+\n+      // The number of output rows must not be larger than child's number of rows.\n+      // Note that this also covers the case of uniqueness of column. If one of the group-by columns"
  }, {
    "author": {
      "login": "wzhfy"
    },
    "body": "If the aggregate has three group-by columns, e.g. group by a, b, c,  the number of output rows is estimated by `ndv(a) * ndv(b) * ndv(c)`. It's an upper bound by assuming the data has every combination of values of a, b and c. But this product can become very large. So previously, I had two methods to set tighter bounds.\r\n1. #row of the aggregate must be <= #row of child.\r\n2. if one of the group-by columns is a primary key (e.g. column a), each distinct value of a can appear only once in records, then the number of possible combinations of a, b, c is equal to ndv(a),  thus #row of the aggregate with group by a, b, c is equal to ndv(a).\r\n\r\nBut later, I noticed that since a is a primary key, ndv(a) is actually equal to #row of child. So case 2 is covered by case 1.",
    "commit": "c95067f0469ec1ccef9140988ded27cea882edbf",
    "createdAt": "2017-01-06T14:37:16Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical.estimation\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, Statistics}\n+\n+\n+object AggregateEstimation {\n+  import EstimationUtils._\n+\n+  def estimate(agg: Aggregate): Option[Statistics] = {\n+    val childStats = agg.child.statistics\n+    // Check if we have column stats for all group-by columns.\n+    val colStatsExist = agg.groupingExpressions.forall { e =>\n+      e.isInstanceOf[Attribute] && childStats.attributeStats.contains(e.asInstanceOf[Attribute])\n+    }\n+    if (rowCountsExist(agg.child) && colStatsExist) {\n+      // Initial value for agg without group expressions\n+      var outputRows: BigInt = 1\n+      agg.groupingExpressions.map(_.asInstanceOf[Attribute]).foreach { attr =>\n+        val colStat = childStats.attributeStats(attr)\n+        // Multiply distinct counts of group by columns. This is an upper bound, which assumes\n+        // the data contains all combinations of distinct values of group by columns.\n+        outputRows *= colStat.distinctCount\n+      }\n+\n+      // The number of output rows must not be larger than child's number of rows.\n+      // Note that this also covers the case of uniqueness of column. If one of the group-by columns"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "OK I don't think you need this explanation here -- it simply makes it more confusing. You are just putting an upper bound on cardinality, and that explains everything.",
    "commit": "c95067f0469ec1ccef9140988ded27cea882edbf",
    "createdAt": "2017-01-09T05:18:00Z",
    "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical.estimation\n+\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, Statistics}\n+\n+\n+object AggregateEstimation {\n+  import EstimationUtils._\n+\n+  def estimate(agg: Aggregate): Option[Statistics] = {\n+    val childStats = agg.child.statistics\n+    // Check if we have column stats for all group-by columns.\n+    val colStatsExist = agg.groupingExpressions.forall { e =>\n+      e.isInstanceOf[Attribute] && childStats.attributeStats.contains(e.asInstanceOf[Attribute])\n+    }\n+    if (rowCountsExist(agg.child) && colStatsExist) {\n+      // Initial value for agg without group expressions\n+      var outputRows: BigInt = 1\n+      agg.groupingExpressions.map(_.asInstanceOf[Attribute]).foreach { attr =>\n+        val colStat = childStats.attributeStats(attr)\n+        // Multiply distinct counts of group by columns. This is an upper bound, which assumes\n+        // the data contains all combinations of distinct values of group by columns.\n+        outputRows *= colStat.distinctCount\n+      }\n+\n+      // The number of output rows must not be larger than child's number of rows.\n+      // Note that this also covers the case of uniqueness of column. If one of the group-by columns"
  }],
  "prId": 16431
}]