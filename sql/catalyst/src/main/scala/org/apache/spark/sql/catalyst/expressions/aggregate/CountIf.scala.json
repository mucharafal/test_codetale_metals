[{
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "This example is the exact copy of the previous one.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-10T10:31:21Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);"
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "Thanks! I’ll remove duplicated one.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-10T12:44:53Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "attilapiros"
    },
    "body": "The master branch is 3.0.0 so there will be no 2.5.0 version.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-10T10:39:19Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"2.5.0\")"
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "Thanks for information. I’ll fix it!",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-10T12:45:22Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.dsl.expressions._\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"2.5.0\")"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "instead of creating a new expression, can't we just rewrite it in the analyzer/optimizer?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-23T10:52:51Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }, {
    "author": {
      "login": "francis0407"
    },
    "body": "I think if we are going to add this function, rewrite it in analyzer would be better. As @HyukjinKwon suggested, we can also add sum_if, avg_if... And they will be easy to rewrite in analyzer, where the same logic can be easily reused. \r\n\r\n",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-26T02:50:43Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I didn't suggest but I asked if there are multiple stuff like `sum_of`, `avg_if`. \r\n\r\nIt's different to add one function vs a set of multiple functions. If it needs a bunch of huge codes to add those multiple functions, it's a different story, than adding a single function to match.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-04-26T03:14:10Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Can we do `RuntimeReplaceable` like `Every` or `Any`?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-05-24T03:21:58Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "Sorry, I don't understand your intention. Is there necessary to use `RuntimeReplaceable` in this case?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-05-27T05:04:39Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }, {
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Not necessary but in that way we can just rewrite and reuse the expressions (take a look for them). `Every`, `Any`, `Some` are similar instances like this case but they were rewritten as `Max` and `Min` . Let's follow that way.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-05-27T12:33:49Z",
    "diffHunk": "@@ -0,0 +1,73 @@\n+/*",
    "line": 1
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "what about making this a `val` in order to avoid creating several instances of it?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-03T16:05:35Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count("
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "I removed `child` from `CountIf` with writing the expression which should be replaced in `ReplaceExpressions` for following reasons. \r\n\r\n- To use `ImplicitCastInputTypes`\r\n- To fix unintuitive alias. e.g) `count_if(count(nullif(CAST(((tempview.`y` % 2) = 0) AS BOOLEAN), false)))` -> `count_if(((y % 2) = 0))`",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-04T10:18:33Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count("
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I don't really agree with this. I think it is better to be consistent with the other expressions.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-04T12:05:43Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count("
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "This approach is also used in `UnevaluableAggs` e.g. Every(EveryAgg), Any(AnyAgg), Some(SomeAgg).",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-06T04:37:20Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count("
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "only child is more than enough, right?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-03T16:05:51Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count(\n+    new NullIf(Cast(predicate, BooleanType), Literal(false, BooleanType)))\n+\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: child :: Nil"
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "You're right. Thanks!",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-04T05:24:57Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count(\n+    new NullIf(Cast(predicate, BooleanType), Literal(false, BooleanType)))\n+\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: child :: Nil"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "if we don't make child a val, we can put `false` here...",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-03T16:06:16Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count(\n+    new NullIf(Cast(predicate, BooleanType), Literal(false, BooleanType)))\n+\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: child :: Nil\n+\n+  override def nullable: Boolean = child.nullable"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "just curious, why did you make it like this and not `Sum(CaseWhen(..))`?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-03T17:20:00Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count(\n+    new NullIf(Cast(predicate, BooleanType), Literal(false, BooleanType)))"
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "First, I just wanna emphasize that `count_if` is a kind of `count`, so I choose an expression based on `count`, not `sum`.\r\n\r\nThen, I considered the following expressions and choose a simple one.\r\n```scala\r\n  Count(\r\n    new NullIf(Cast(predicate, BooleanType), Literal.FalseLiteral)\r\n  )\r\n  Count(\r\n    CaseKeyWhen(Cast(predicate, BooleanType), Literal.TrueLiteral :: Literal.TrueLiteral :: Nil)\r\n  )\r\n  Count(\r\n    CaseWhen((EqualTo(Cast(predicate, BooleanType), Literal.TrueLiteral), Literal.TrueLiteral) :: Nil)\r\n  )\r\n  Count(\r\n    If(Cast(predicate, BooleanType), Literal.TrueLiteral, Literal(null, BooleanType))\r\n  )\r\n```",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-04T05:27:24Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate {\n+  def child: Expression = Count(\n+    new NullIf(Cast(predicate, BooleanType), Literal(false, BooleanType)))"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Shall we import explicitly?\r\n```scala\r\nimport org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, UnevaluableAggregate}\r\nimport org.apache.spark.sql.types.{AbstractDataType, BooleanType, DataType, LongType}\r\n```",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T02:04:27Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`${prettyName}` -> `$prettyName`?",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T02:11:19Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate with ImplicitCastInputTypes {\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: Nil\n+\n+  override def nullable: Boolean = false\n+\n+  override def dataType: DataType = LongType\n+\n+  override def inputTypes: Seq[AbstractDataType] = BooleanType :: Nil\n+\n+  override def checkInputDataTypes(): TypeCheckResult = predicate.dataType match {\n+    case BooleanType =>\n+      TypeCheckResult.TypeCheckSuccess\n+    case _ =>\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"function ${prettyName} requires boolean type, not ${predicate.dataType.catalogString}\""
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "nit.\r\n```scala\r\noverride def inputTypes: Seq[AbstractDataType] = Seq(BooleanType)\r\n```",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T02:43:18Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate with ImplicitCastInputTypes {\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: Nil\n+\n+  override def nullable: Boolean = false\n+\n+  override def dataType: DataType = LongType\n+\n+  override def inputTypes: Seq[AbstractDataType] = BooleanType :: Nil"
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "Is it better to change `children` together?\r\n```scala\r\noverride def children: Seq[Expression] = Seq(predicate)\r\n```",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T03:47:23Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true.\n+  \"\"\",\n+  examples = \"\"\"\n+    Examples:\n+      > SELECT _FUNC_(col % 2 = 0) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       2\n+      > SELECT _FUNC_(col IS NULL) FROM VALUES (NULL), (0), (1), (2), (3) AS tab(col);\n+       1\n+  \"\"\",\n+  since = \"3.0.0\")\n+case class CountIf(predicate: Expression) extends UnevaluableAggregate with ImplicitCastInputTypes {\n+  override def prettyName: String = \"count_if\"\n+\n+  override def children: Seq[Expression] = predicate :: Nil\n+\n+  override def nullable: Boolean = false\n+\n+  override def dataType: DataType = LongType\n+\n+  override def inputTypes: Seq[AbstractDataType] = BooleanType :: Nil"
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I know this follows the description of `Count`, but it looks a little bit weird at `non-null and true`? `True` is already not a null.\r\n\r\nCan we say like Presto/BigQuery? Also, we can give the alternative for Spark 2.4 and older together like the following.\r\n```\r\nReturns the number of TRUE values for the expression. This function is equivalent to count(CASE WHEN x THEN 1 END).\r\n```\r\n\r\n",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T03:02:22Z",
    "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.types._\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of rows that the supplied expression is non-null and true."
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oops, `expr` instead of `x`.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-07T16:53:51Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, UnevaluableAggregate}\n+import org.apache.spark.sql.types.{AbstractDataType, BooleanType, DataType, LongType}\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of `TRUE` values for the expression.\n+      This function is equivalent to `count(CASE WHEN x THEN 1 END)`."
  }],
  "prId": 24335
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Initially, I recommended this to give a hint to the users like the other SQL engines. The reason why I chose this expression instead of `Count(NullIf(...))` which is used in this PR with `RuntimeReplaceable` is that `Count(NullIf(...))` doesn't work like new `count_if` due to the type casting.\r\n\r\nFor the following case, `Count(NullIf(...))` works while `count_if` doesn't.\r\n```sql\r\nspark-sql> select count(nullif(a, false)) from values (1) T(a);\r\n1\r\n\r\nspark-sql> select count_if(a) from values (1) T(a);\r\nError in query: cannot resolve 'count_if(T.a)' due to data type mismatch: function count_if requires boolean type,\r\n\r\nspark-sql> select count(case when a then 1 end) from values (1) T(a);\r\nError in query: cannot resolve 'CASE WHEN T.`a` THEN 1 END' due to data type mismatch: WHEN expressions in CaseWhen\r\n```\r\n\r\nIn short, new `count_if`'s behavior is the same with `count(CASE WHEN expr THEN 1 END)`. However, while reviewing this PR again, I notice that this might mislead the **developers** because we are using `count(nullif(...))` technically.\r\n\r\nTo sum up, we cannot give the simple fallback example here. Both ones are inadequate. We had better remove this line. So, could you remove this line again, @cryeo ? Sorry, it's my bad.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-08T02:44:43Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, UnevaluableAggregate}\n+import org.apache.spark.sql.types.{AbstractDataType, BooleanType, DataType, LongType}\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of `TRUE` values for the expression.\n+      This function is equivalent to `count(CASE WHEN expr THEN 1 END)`."
  }, {
    "author": {
      "login": "cryeo"
    },
    "body": "Okay, thanks for your advice.",
    "commit": "c0a32897b108c2a0c90e6f32e0dd5bee8509e3be",
    "createdAt": "2019-06-10T04:25:07Z",
    "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, UnevaluableAggregate}\n+import org.apache.spark.sql.types.{AbstractDataType, BooleanType, DataType, LongType}\n+\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr) - Returns the number of `TRUE` values for the expression.\n+      This function is equivalent to `count(CASE WHEN expr THEN 1 END)`."
  }],
  "prId": 24335
}]