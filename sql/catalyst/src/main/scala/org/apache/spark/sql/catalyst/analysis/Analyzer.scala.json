[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "which?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-11T21:43:22Z",
    "diffHunk": "@@ -665,7 +665,7 @@ class Analyzer(\n     def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators {\n       case p if !p.childrenResolved => p\n       // Replace the index with the related attribute for ORDER BY,\n-      // which is a 1-base position of the projection list.\n+      // cwhich is a 1-base position of the projection list."
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Whoops... I'll revert\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-11T21:58:15Z",
    "diffHunk": "@@ -665,7 +665,7 @@ class Analyzer(\n     def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators {\n       case p if !p.childrenResolved => p\n       // Replace the index with the related attribute for ORDER BY,\n-      // which is a 1-base position of the projection list.\n+      // cwhich is a 1-base position of the projection list."
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "explain the return type (e.g. \"tuple of ...\")\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-11T21:52:44Z",
    "diffHunk": "@@ -852,26 +852,150 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions, rewrites correlated subqueries or\n+   * scalar subqueries.\n+   *\n+   * It works as following:\n+   * 1. For each logical plan, find out the subqueries from expressions, try to resolve them,\n+   *   update the SubQueryExpression with resolved logical plan.\n+   * 2. For Filter, the condition will be splitted by AND, each sub-condition that has subqueries\n+   *   will be rewritten as following:\n+   *   a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved condition in Filter\n+   *     will be pulled out as join conditions.\n+   *   b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will be\n+   *     pulled out as join conditions, value = selected column will also be used as join condition.\n    *\n    * Note: CTE are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val unresolvedConditions = ArrayBuffer[Expression]()\n+      var hasOuterJoin = false\n+      val removed = q transform {\n+        case j: Join if j.joinType != Inner =>\n+          hasOuterJoin = true\n+          j\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          if (hasOuterJoin) {\n+            // The predicates inside a outer/semi join can't be pulled over join safely.\n+            throw new AnalysisException(\"accessing columns of outer query inside join is not\" +\n+              \" supported\")\n+          } else {\n+            val (resolved, unresolved) = splitConjunctivePredicates(cond).partition(_.resolved)\n+            unresolvedConditions ++= unresolved\n+            if (resolved.nonEmpty) {\n+              Filter(resolved.reduceLeft(And), child)\n+            } else {\n+              child\n+            }\n+          }\n+      }\n+      if (unresolvedConditions.nonEmpty) {\n+        // try to resolve new logical plan and remove unresolved predicated again\n+        val (removedAgain, moreConditions) = removeUnresolvedPredicates(execute(removed))\n+        (removedAgain, (unresolvedConditions ++ moreConditions.toSeq).reduceLeftOption(And))\n+      } else {\n+        if (!q.resolved) {\n+          throw new AnalysisException(s\"subquery can't be resolved: ${q.treeString}\")\n+        }\n+        (q, None)\n+      }\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition)."
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Will do - forgot to add it.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-14T21:51:14Z",
    "diffHunk": "@@ -852,26 +852,150 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions, rewrites correlated subqueries or\n+   * scalar subqueries.\n+   *\n+   * It works as following:\n+   * 1. For each logical plan, find out the subqueries from expressions, try to resolve them,\n+   *   update the SubQueryExpression with resolved logical plan.\n+   * 2. For Filter, the condition will be splitted by AND, each sub-condition that has subqueries\n+   *   will be rewritten as following:\n+   *   a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved condition in Filter\n+   *     will be pulled out as join conditions.\n+   *   b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will be\n+   *     pulled out as join conditions, value = selected column will also be used as join condition.\n    *\n    * Note: CTE are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val unresolvedConditions = ArrayBuffer[Expression]()\n+      var hasOuterJoin = false\n+      val removed = q transform {\n+        case j: Join if j.joinType != Inner =>\n+          hasOuterJoin = true\n+          j\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          if (hasOuterJoin) {\n+            // The predicates inside a outer/semi join can't be pulled over join safely.\n+            throw new AnalysisException(\"accessing columns of outer query inside join is not\" +\n+              \" supported\")\n+          } else {\n+            val (resolved, unresolved) = splitConjunctivePredicates(cond).partition(_.resolved)\n+            unresolvedConditions ++= unresolved\n+            if (resolved.nonEmpty) {\n+              Filter(resolved.reduceLeft(And), child)\n+            } else {\n+              child\n+            }\n+          }\n+      }\n+      if (unresolvedConditions.nonEmpty) {\n+        // try to resolve new logical plan and remove unresolved predicated again\n+        val (removedAgain, moreConditions) = removeUnresolvedPredicates(execute(removed))\n+        (removedAgain, (unresolvedConditions ++ moreConditions.toSeq).reduceLeftOption(And))\n+      } else {\n+        if (!q.resolved) {\n+          throw new AnalysisException(s\"subquery can't be resolved: ${q.treeString}\")\n+        }\n+        (q, None)\n+      }\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition)."
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "as follows?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-11T21:53:46Z",
    "diffHunk": "@@ -852,26 +852,150 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions, rewrites correlated subqueries or\n+   * scalar subqueries.\n+   *\n+   * It works as following:"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "I am still working on this rule. It is quite hard to follow, and I feel this can be improved.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-14T21:51:02Z",
    "diffHunk": "@@ -852,26 +852,142 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions and it rewrites correlated & scalar\n+   * subqueries.\n    *\n-   * Note: CTE are handled in CTESubstitution.\n+   * It works as follows:\n+   * 1. Find all subquery expressions in a logical plan. Try to resolve them and update the\n+   *    SubQueryExpression with the resolved logical plan.\n+   * 2. For Filter (i.e. WHERE/HAVING clauses) the condition will be split by AND. Each part of the\n+   *    condition that contains a [[CorrelatedSubqueryExpression]] will be rewritten:\n+   *    a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+   *       will be pulled out as the join conditions.\n+   *    b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+   *       be pulled out as join conditions, value = selected column will also be used as join\n+   *       condition.\n+   *\n+   * Note: CTEs are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Has anyone ever used a Correlated In Subquery? E.G:\n\n```\nSELECT   *\nFROM      a\nWHERE   a.id IN (SELECT id FROM b WHERE b.value < a.value)\n```\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-14T21:52:34Z",
    "diffHunk": "@@ -852,26 +852,142 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions and it rewrites correlated & scalar\n+   * subqueries.\n    *\n-   * Note: CTE are handled in CTESubstitution.\n+   * It works as follows:\n+   * 1. Find all subquery expressions in a logical plan. Try to resolve them and update the\n+   *    SubQueryExpression with the resolved logical plan.\n+   * 2. For Filter (i.e. WHERE/HAVING clauses) the condition will be split by AND. Each part of the\n+   *    condition that contains a [[CorrelatedSubqueryExpression]] will be rewritten:\n+   *    a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+   *       will be pulled out as the join conditions.\n+   *    b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+   *       be pulled out as join conditions, value = selected column will also be used as join\n+   *       condition.\n+   *\n+   * Note: CTEs are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val unresolvedConditions = ArrayBuffer[Expression]()\n+      var hasOuterJoin = false\n+      val removed = q transform {\n+        case j: Join if j.joinType != Inner =>\n+          hasOuterJoin = true\n+          j\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          if (hasOuterJoin) {\n+            // The predicates inside a outer/semi join can't be pulled over join safely.\n+            throw new AnalysisException(\"accessing columns of outer query inside join is not\" +\n+              \" supported\")\n+          } else {\n+            val (resolved, unresolved) = splitConjunctivePredicates(cond).partition(_.resolved)\n+            unresolvedConditions ++= unresolved\n+            if (resolved.nonEmpty) {\n+              Filter(resolved.reduceLeft(And), child)\n+            } else {\n+              child\n+            }\n+          }\n+      }\n+      if (unresolvedConditions.nonEmpty) {\n+        // try to resolve new logical plan and remove unresolved predicated again\n+        val (removedAgain, moreConditions) = removeUnresolvedPredicates(execute(removed))\n+        (removedAgain, (unresolvedConditions ++ moreConditions.toSeq).reduceLeftOption(And))\n+      } else {\n+        if (!q.resolved) {\n+          throw new AnalysisException(s\"subquery can't be resolved: ${q.treeString}\")\n+        }\n+        (q, None)\n+      }\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition).\n+     */\n+    private def rewriteInSubquery(\n+        value: Expression,\n+        subquery: LogicalPlan): (LogicalPlan, Expression) = {\n+      val (resolved, joinCondition) = removeUnresolvedPredicates(execute(subquery))"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "It's used by TPCDS queries, see https://github.com/databricks/spark-sql-perf/blob/master/src/main/scala/com/databricks/spark/sql/perf/tpcds/TPCDS_1_4_Queries.scala\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-14T21:59:23Z",
    "diffHunk": "@@ -852,26 +852,142 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions and it rewrites correlated & scalar\n+   * subqueries.\n    *\n-   * Note: CTE are handled in CTESubstitution.\n+   * It works as follows:\n+   * 1. Find all subquery expressions in a logical plan. Try to resolve them and update the\n+   *    SubQueryExpression with the resolved logical plan.\n+   * 2. For Filter (i.e. WHERE/HAVING clauses) the condition will be split by AND. Each part of the\n+   *    condition that contains a [[CorrelatedSubqueryExpression]] will be rewritten:\n+   *    a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+   *       will be pulled out as the join conditions.\n+   *    b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+   *       be pulled out as join conditions, value = selected column will also be used as join\n+   *       condition.\n+   *\n+   * Note: CTEs are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val unresolvedConditions = ArrayBuffer[Expression]()\n+      var hasOuterJoin = false\n+      val removed = q transform {\n+        case j: Join if j.joinType != Inner =>\n+          hasOuterJoin = true\n+          j\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          if (hasOuterJoin) {\n+            // The predicates inside a outer/semi join can't be pulled over join safely.\n+            throw new AnalysisException(\"accessing columns of outer query inside join is not\" +\n+              \" supported\")\n+          } else {\n+            val (resolved, unresolved) = splitConjunctivePredicates(cond).partition(_.resolved)\n+            unresolvedConditions ++= unresolved\n+            if (resolved.nonEmpty) {\n+              Filter(resolved.reduceLeft(And), child)\n+            } else {\n+              child\n+            }\n+          }\n+      }\n+      if (unresolvedConditions.nonEmpty) {\n+        // try to resolve new logical plan and remove unresolved predicated again\n+        val (removedAgain, moreConditions) = removeUnresolvedPredicates(execute(removed))\n+        (removedAgain, (unresolvedConditions ++ moreConditions.toSeq).reduceLeftOption(And))\n+      } else {\n+        if (!q.resolved) {\n+          throw new AnalysisException(s\"subquery can't be resolved: ${q.treeString}\")\n+        }\n+        (q, None)\n+      }\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition).\n+     */\n+    private def rewriteInSubquery(\n+        value: Expression,\n+        subquery: LogicalPlan): (LogicalPlan, Expression) = {\n+      val (resolved, joinCondition) = removeUnresolvedPredicates(execute(subquery))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Thanks. I didn't know that.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-14T22:02:50Z",
    "diffHunk": "@@ -852,26 +852,142 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves subqueries inside expressions and it rewrites correlated & scalar\n+   * subqueries.\n    *\n-   * Note: CTE are handled in CTESubstitution.\n+   * It works as follows:\n+   * 1. Find all subquery expressions in a logical plan. Try to resolve them and update the\n+   *    SubQueryExpression with the resolved logical plan.\n+   * 2. For Filter (i.e. WHERE/HAVING clauses) the condition will be split by AND. Each part of the\n+   *    condition that contains a [[CorrelatedSubqueryExpression]] will be rewritten:\n+   *    a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+   *       will be pulled out as the join conditions.\n+   *    b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+   *       be pulled out as join conditions, value = selected column will also be used as join\n+   *       condition.\n+   *\n+   * Note: CTEs are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n     }\n \n     private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+      q.expressions.exists(_.find(_.isInstanceOf[SubqueryExpression]).isDefined)\n+    }\n+\n+    /**\n+     * Removes the conjunctive predicates of Filter that can't be resolved in this logical plan,\n+     * returns the resolved new logical plan and removed predicates.\n+     */\n+    private def removeUnresolvedPredicates(q: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val unresolvedConditions = ArrayBuffer[Expression]()\n+      var hasOuterJoin = false\n+      val removed = q transform {\n+        case j: Join if j.joinType != Inner =>\n+          hasOuterJoin = true\n+          j\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          if (hasOuterJoin) {\n+            // The predicates inside a outer/semi join can't be pulled over join safely.\n+            throw new AnalysisException(\"accessing columns of outer query inside join is not\" +\n+              \" supported\")\n+          } else {\n+            val (resolved, unresolved) = splitConjunctivePredicates(cond).partition(_.resolved)\n+            unresolvedConditions ++= unresolved\n+            if (resolved.nonEmpty) {\n+              Filter(resolved.reduceLeft(And), child)\n+            } else {\n+              child\n+            }\n+          }\n+      }\n+      if (unresolvedConditions.nonEmpty) {\n+        // try to resolve new logical plan and remove unresolved predicated again\n+        val (removedAgain, moreConditions) = removeUnresolvedPredicates(execute(removed))\n+        (removedAgain, (unresolvedConditions ++ moreConditions.toSeq).reduceLeftOption(And))\n+      } else {\n+        if (!q.resolved) {\n+          throw new AnalysisException(s\"subquery can't be resolved: ${q.treeString}\")\n+        }\n+        (q, None)\n+      }\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition).\n+     */\n+    private def rewriteInSubquery(\n+        value: Expression,\n+        subquery: LogicalPlan): (LogicalPlan, Expression) = {\n+      val (resolved, joinCondition) = removeUnresolvedPredicates(execute(subquery))"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "For `A not IN (B, C)`, we need to consider the nullability of A and B. For example, if B or C is null, `A IN (B, null)` will be null, `A not in (B, null)` should also be null. This requires a special join (it's usually called NullAwareAntiJoin).\n\nWe could not support that in this PR.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-15T21:11:21Z",
    "diffHunk": "@@ -852,25 +855,148 @@ class Analyzer(\n   }\n \n   /**\n-   * This rule resolve subqueries inside expressions.\n+   * This rule resolves sub-queries inside expressions.\n    *\n-   * Note: CTE are handled in CTESubstitution.\n+   * Note: CTEs are handled in CTESubstitution.\n    */\n   object ResolveSubquery extends Rule[LogicalPlan] with PredicateHelper {\n \n-    private def hasSubquery(e: Expression): Boolean = {\n-      e.find(_.isInstanceOf[SubqueryExpression]).isDefined\n-    }\n-\n-    private def hasSubquery(q: LogicalPlan): Boolean = {\n-      q.expressions.exists(hasSubquery)\n+    /**\n+     * Resolve the correlated predicates in a sub-queries [[Filter]]s (WHERE or HAVING) by using the\n+     * plan the predicates should be correlated to.\n+     */\n+    private def resolveCorrelatedPredicates(q: LogicalPlan, p: LogicalPlan): LogicalPlan = {\n+      q transformUp {\n+        case f @ Filter(cond, child) if child.resolved && !f.resolved =>\n+          val newCond = resolveExpression(cond, p, throws = false)\n+          if (!cond.fastEquals(newCond)) {\n+            Filter(newCond, child)\n+          } else {\n+            f\n+          }\n+      }\n     }\n \n     def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators {\n-      case q: LogicalPlan if q.childrenResolved && hasSubquery(q) =>\n+      case q: LogicalPlan if q.childrenResolved =>\n         q transformExpressions {\n           case e: SubqueryExpression if !e.query.resolved =>\n-            e.withNewPlan(execute(e.query))\n+            // First resolve as much of the sub-query as possible. After that we use the children of\n+            // this plan to resolve the remaining correlated predicates.\n+            e.withNewPlan(q.children.foldLeft(execute(e.query))(resolveCorrelatedPredicates))\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This rule rewrites filtering sub-queries into left semi/anti joins. The following predicates\n+   * are supported:\n+   * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+   *    will be pulled out as the join conditions.\n+   * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+   *    be pulled out as join conditions, value = selected column will also be used as join\n+   *    condition.\n+   */\n+  object RewriteSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+    private def hasCorrelatedSubquery(e: Expression): Boolean = {\n+      e.find(_.isInstanceOf[CorrelatedSubqueryExpression]).isDefined\n+    }\n+\n+    /**\n+     * Extract all correlated predicates from a given sub-query. The sub-query will be rewritten\n+     * without the correlated predicates. The predicates will be combined using AND. This method\n+     * returns the rewritten sub-query and the resulting extracted predicate.\n+     */\n+    private def extractCorrelatedPredicates(\n+        q: LogicalPlan,\n+        p: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+      val fs = mutable.Set.empty[LogicalPlan]\n+      val references: Set[Expression] = p.output.toSet\n+      val predicates = ArrayBuffer[Expression]()\n+      val transformed = q transform {\n+        case f @ Filter(cond, child) =>\n+          val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+            e.find(references.contains).isDefined\n+          }\n+          predicates ++= correlated\n+          correlated match {\n+            case Nil =>\n+              f\n+            case xs if local.nonEmpty =>\n+              val newFilter = Filter(local.reduce(And), child)\n+              fs += newFilter\n+              newFilter\n+            case xs =>\n+              fs += child\n+              child\n+          }\n+        case j: Join if j.joinType != Inner && fs.nonEmpty && j.find(fs.contains).isDefined =>\n+          failAnalysis(\"accessing columns of outer query inside join is not supported\")\n+      }\n+      (transformed, predicates.reduceOption(And))\n+    }\n+\n+    /**\n+     * Returns a resolved subquery and predicate that will be used to rewrite the IN subquery as\n+     * semi join (predicate will be used as join condition).\n+     */\n+    private def rewriteInSubquery(\n+        value: Expression,\n+        subquery: LogicalPlan,\n+        query: LogicalPlan): (LogicalPlan, Expression) = {\n+      val (resolved, joinCondition) = extractCorrelatedPredicates(subquery, query)\n+\n+      // Extract the columns on the expression side.\n+      val columns = value match {\n+        case CreateStruct(cs) => cs\n+        case c => Seq(c)\n+      }\n+\n+      // The number of left and right expressions must be equal.\n+      if (columns.length != resolved.output.length) {\n+        throw new AnalysisException(s\"the number of fields in value (${columns.length}) does\" +\n+          s\" not match with the number of columns in subquery (${resolved.output.length})\")\n+      }\n+      val conditions = joinCondition.toSeq ++ columns.zip(resolved.output).map {\n+        case (e, a) =>\n+          // Check the left and right dataTypes.\n+          if (e.dataType != a.dataType) {\n+            throw new AnalysisException(\n+              s\"data type of value (${e.dataType}) does not match with subquery (${a.dataType})\")\n+          }\n+          EqualTo(e, a)\n+      }\n+\n+      (resolved, conditions.reduceLeft(And))\n+    }\n+\n+    def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators {\n+      case f @ Filter(condition, child) if f.resolved =>\n+        val (withSubquery, withoutSubquery) =\n+          splitConjunctivePredicates(condition).partition(hasCorrelatedSubquery)\n+\n+        // Construct the pruned filter condition.\n+        val newFilter: LogicalPlan = withoutSubquery match {\n+          case Nil => child\n+          case conditions => Filter(conditions.reduce(And), child)\n+        }\n+\n+        // Filter the plan by applying left semi and left anti joins.\n+        withSubquery.foldLeft(newFilter) {\n+          case (p, Exists(sub)) =>\n+            val (resolved, joinCondition) = extractCorrelatedPredicates(sub, p)\n+            Join(p, resolved, LeftSemi, joinCondition)\n+          case (p, Not(Exists(sub))) =>\n+            val (resolved, joinCondition) = extractCorrelatedPredicates(sub, p)\n+            Join(p, resolved, LeftAnti, joinCondition)\n+          case (p, InSubQuery(value, sub)) =>\n+            val (resolved, cond) = rewriteInSubquery(value, sub, p)\n+            Join(p, resolved, LeftSemi, Some(cond))\n+          case (p, Not(InSubQuery(value, sub))) =>"
  }],
  "prId": 12306
}]