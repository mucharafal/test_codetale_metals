[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "hmm, doesn't \"abc\" show 3 times?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:03:47Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array('abc', 'abc', 'bcd', 'abc', 'bcd'), 2, 4);\n+       [[\"abc\",\"bcd\"]:2.0},"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "oh. i see. your unit of unigram is each element in the array, not a character.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:07:00Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array('abc', 'abc', 'bcd', 'abc', 'bcd'), 2, 4);\n+       [[\"abc\",\"bcd\"]:2.0},"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "Yeah, and actually it's 'bigram' because n equals to 2 here. I just further the explanation, hope you like it. : )",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:25:22Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array('abc', 'abc', 'bcd', 'abc', 'bcd'), 2, 4);\n+       [[\"abc\",\"bcd\"]:2.0},"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "does Hive also support `arrays of arrays of strings`?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:16:39Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an",
    "line": 40
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "Yes, please refer to https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF and https://cwiki.apache.org/confluence/display/Hive/StatisticsAndDataMining#StatisticsAndDataMining-Usage",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:43:57Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an",
    "line": 40
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "`must be a foldable integer expression`.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:42:02Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This is not type check and failure. Shall we check `accuracy` when initialized `NGrams` and throw analysis error?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:43:55Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Check existence by `HashMap`'s API.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:46:56Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "frequencyMap.put(ng, frequencyMap.getOrElse(ng, 0.0D) + 1)",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:49:21Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "Good way!",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T13:50:17Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "frequencyMap.put(key,  frequencyMap.getOrElse(key, 0.0D) + value)",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:51:50Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Oh. you use java's HashMap.\r\n\r\nBut `getOrDefault` is only supported in Java8. I think we haven't drop Java7 support for now.\r\n",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:10:21Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "The doc says `Note that support for Java 7 is deprecated as of Spark 2.0.0 and may be removed in Spark 2.2.0.`, maybe I changed the code first and wait for others to comment.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T13:55:32Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "`ArrayType(StringType, true)` is not included in `inputTypes`?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T07:56:02Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)",
    "line": 86
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "Yes, actually I want to refuse users' input with Array of String with null so I didn't include it in `inputTypes`, but the tests I have done showed me that some Array without null will be of type `ArrayType(StringType, true)`. Do you know how to do that?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T14:36:11Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)",
    "line": 86
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "To add, Array of String with null will cause runtime exceptions.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T14:36:54Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)",
    "line": 86
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "what's the behavior of hive? The `ArrayType.containsNull` is just a hint, there may be no null values even the `containsNull` is true.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-10T04:02:27Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)",
    "line": 86
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "To be honest, I don't think there is a way to guarantee no null values at plan compile time.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-10T04:09:31Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)",
    "line": 86
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "n can't be <= 0.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:00:31Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]",
    "line": 76
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "also k.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:27:26Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]",
    "line": 76
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "Right, thanks",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T14:32:35Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]",
    "line": 76
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "style:\r\n\r\nif {\r\n  ...\r\n} else {\r\n   ...\r\n}",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:01:49Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "wrong ident.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:03:46Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "style. `} else {`",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:04:06Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend\n+      }\n+      else {"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Do we really need to `newInstance` every time `serialize` and `deserialize`?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:14:35Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend\n+      }\n+      else {\n+        val keyVector = keyWithFrequency._1\n+        val keyVector2 = keyWithFrequency2._1\n+        for (i <- 0 until keyVector.length) {\n+          if (keyVector(i) != keyVector2(i)) {\n+            return (keyVector(i).compare(keyVector2(i))) < 0\n+          }\n+        }\n+        true\n+      }\n+    }\n+\n+    def trim(): Unit = {\n+      if (frequencyMap.size() > 2 * k * precisionFactor) {\n+        val orderedWithIndex = frequencyMap.asScala.iterator.toVector.\n+          sortWith(sortWithTwoFields(frequencyDescend = false)).zipWithIndex\n+        orderedWithIndex.takeWhile(_._2 < frequencyMap.size() - k * precisionFactor).map(_._1).\n+          foreach(keyValuePair => frequencyMap.remove(keyValuePair._1))\n+      }\n+    }\n+\n+    def getTopKNGrams(): Seq[(Vector[UTF8String], Double)] = {\n+      frequencyMap.asScala.iterator.toVector.sortWith(sortWithTwoFields(frequencyDescend = true)).\n+        zipWithIndex.takeWhile(_._2 < k).map(_._1)\n+    }\n+\n+  }\n+\n+  class NGramBufferSerializer {\n+\n+    final def serialize(obj: NGramBuffer): Array[Byte] = {\n+      NGrams.kryoSerializer.newInstance().serialize[NGramBuffer](obj).array()",
    "line": 242
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "I tried to reuse the instance `val kryoSerializerInstance = new KryoSerializer(new SparkConf()).newInstance()` but failed, even if I registered the `NGramBuffer` class, still working on this.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T15:24:34Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend\n+      }\n+      else {\n+        val keyVector = keyWithFrequency._1\n+        val keyVector2 = keyWithFrequency2._1\n+        for (i <- 0 until keyVector.length) {\n+          if (keyVector(i) != keyVector2(i)) {\n+            return (keyVector(i).compare(keyVector2(i))) < 0\n+          }\n+        }\n+        true\n+      }\n+    }\n+\n+    def trim(): Unit = {\n+      if (frequencyMap.size() > 2 * k * precisionFactor) {\n+        val orderedWithIndex = frequencyMap.asScala.iterator.toVector.\n+          sortWith(sortWithTwoFields(frequencyDescend = false)).zipWithIndex\n+        orderedWithIndex.takeWhile(_._2 < frequencyMap.size() - k * precisionFactor).map(_._1).\n+          foreach(keyValuePair => frequencyMap.remove(keyValuePair._1))\n+      }\n+    }\n+\n+    def getTopKNGrams(): Seq[(Vector[UTF8String], Double)] = {\n+      frequencyMap.asScala.iterator.toVector.sortWith(sortWithTwoFields(frequencyDescend = true)).\n+        zipWithIndex.takeWhile(_._2 < k).map(_._1)\n+    }\n+\n+  }\n+\n+  class NGramBufferSerializer {\n+\n+    final def serialize(obj: NGramBuffer): Array[Byte] = {\n+      NGrams.kryoSerializer.newInstance().serialize[NGramBuffer](obj).array()",
    "line": 242
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "You can simply do:\r\n \r\n    frequencyMap.asScala.iterator.toVector.sortWith(sortWithTwoFields(frequencyDescend = true)).take(k)",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:23:02Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend\n+      }\n+      else {\n+        val keyVector = keyWithFrequency._1\n+        val keyVector2 = keyWithFrequency2._1\n+        for (i <- 0 until keyVector.length) {\n+          if (keyVector(i) != keyVector2(i)) {\n+            return (keyVector(i).compare(keyVector2(i))) < 0\n+          }\n+        }\n+        true\n+      }\n+    }\n+\n+    def trim(): Unit = {\n+      if (frequencyMap.size() > 2 * k * precisionFactor) {\n+        val orderedWithIndex = frequencyMap.asScala.iterator.toVector.\n+          sortWith(sortWithTwoFields(frequencyDescend = false)).zipWithIndex\n+        orderedWithIndex.takeWhile(_._2 < frequencyMap.size() - k * precisionFactor).map(_._1).\n+          foreach(keyValuePair => frequencyMap.remove(keyValuePair._1))\n+      }\n+    }\n+\n+    def getTopKNGrams(): Seq[(Vector[UTF8String], Double)] = {\n+      frequencyMap.asScala.iterator.toVector.sortWith(sortWithTwoFields(frequencyDescend = true)).\n+        zipWithIndex.takeWhile(_._2 < k).map(_._1)"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "    frequencyMap.asScala.iterator.toVector.sortWith(sortWithTwoFields(frequencyDescend = false)).take(frequencyMap.size() - k * precisionFactor).foreach(...)",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:25:24Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    }\n+    else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {\n+    def add(ng: Vector[UTF8String]): Unit = {\n+      var currentFrequency: Double = frequencyMap.get(ng)\n+      if (currentFrequency == null.asInstanceOf[Double]) {\n+        currentFrequency = 1.0D\n+      } else {\n+        currentFrequency += 1\n+      }\n+      frequencyMap.put(ng, currentFrequency)\n+    }\n+\n+    def merge(other: NGramBuffer): Unit = {\n+      other.frequencyMap.asScala.foreach((keyValuePair: (Vector[UTF8String], Double)) => {\n+        val key = keyValuePair._1\n+        val value = keyValuePair._2\n+        val originalValue = frequencyMap.getOrDefault(key, 0.0D)\n+        frequencyMap.put(key, originalValue + value)\n+      })\n+    }\n+\n+    def sortWithTwoFields(frequencyDescend: Boolean)\n+                         (keyWithFrequency: Tuple2[Vector[UTF8String], Double],\n+                          keyWithFrequency2: Tuple2[Vector[UTF8String], Double]): Boolean = {\n+      if (keyWithFrequency._2 != keyWithFrequency2._2) {\n+      (keyWithFrequency._2 < keyWithFrequency2._2) ^ frequencyDescend\n+      }\n+      else {\n+        val keyVector = keyWithFrequency._1\n+        val keyVector2 = keyWithFrequency2._1\n+        for (i <- 0 until keyVector.length) {\n+          if (keyVector(i) != keyVector2(i)) {\n+            return (keyVector(i).compare(keyVector2(i))) < 0\n+          }\n+        }\n+        true\n+      }\n+    }\n+\n+    def trim(): Unit = {\n+      if (frequencyMap.size() > 2 * k * precisionFactor) {\n+        val orderedWithIndex = frequencyMap.asScala.iterator.toVector.\n+          sortWith(sortWithTwoFields(frequencyDescend = false)).zipWithIndex\n+        orderedWithIndex.takeWhile(_._2 < frequencyMap.size() - k * precisionFactor).map(_._1)."
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "wrong ident. There are many style issues. Can you run style check locally and fix them?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T08:29:38Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "My fault, it's weird, I run it and it tells me `Scalastyle checks passed.`",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-03-22T13:42:54Z",
    "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a constant literal\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer literal (current value = $accuracy)\")\n+    }\n+    else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    }\n+    else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+   new GenericArrayData(topKNGrams)"
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why do we have special requirement about nullability?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-10T04:00:15Z",
    "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),",
    "line": 81
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "If the array contains null, n-gram of that array will be ambiguous to evaluate. Should we just ignore the null value? For example regard n-gram of `array(a, null, 'b')` the same as `array(a, 'b')`? Maybe we should refuse the array containing null for that.",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-11T06:03:49Z",
    "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),",
    "line": 81
  }],
  "prId": 17359
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why `frequencyMap` need to be a constructor parameter?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-10T04:04:17Z",
    "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a foldable integer expression\")\n+    } else if (n <= 0) {\n+      TypeCheckFailure(s\"The n provided must be a positive integer (current value = $n)\")\n+    } else if (k <= 0) {\n+      TypeCheckFailure(s\"The k provided must be a positive integer (current value = $k)\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer (current value = $accuracy)\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    } else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+    new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    } else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {"
  }, {
    "author": {
      "login": "gczsjdy"
    },
    "body": "You are right, it doesn't need to be. By the way, what's the community's major concerns about merging the [expression](https://github.com/apache/spark/pull/16476)/aggregate expression PRs? The performance?",
    "commit": "3bd8897b04b043de208181b29164a536edbec22a",
    "createdAt": "2017-04-11T06:26:47Z",
    "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.aggregate\n+\n+import java.nio.ByteBuffer\n+import java.util.HashMap\n+\n+import org.apache.spark.serializer.KryoSerializer\n+import org.apache.spark.SparkConf\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult._\n+import org.apache.spark.sql.catalyst.expressions.{Expression, ExpressionDescription, ImplicitCastInputTypes, Literal}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NGrams.NGramBuffer\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.util.{ArrayBasedMapData, GenericArrayData}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+/**\n+ * Return the top-k n-grams in rows that consist of sequences of strings.\n+ */\n+@ExpressionDescription(\n+  usage = \"\"\"\n+    _FUNC_(expr, n, k, accuracy) - Estimates the top-k n-grams in rows that consist of sequences\n+      of strings, represented as arrays of strings, or arrays of arrays of strings. 'accuracy' is an\n+      optional precision factor that controls memory usage.\n+      The parameter 'n' specifies what type of n-grams are being estimated. Unigrams are n = 1, and\n+      bigrams are n = 2. Generally, n will not be greater than about 5. The 'k' parameter specifies\n+      how many of the highest-frequency n-grams will be returned by the UDAF. The optional precision\n+      factor 'accuracy' specifies how much memory to use for estimation; more memory will give\n+      more accurate frequency counts, but could crash the JVM. The value will be the max between\n+      'accuracy'(0 if it's not specified) and 1000/k, which indicates the max number of n-grams\n+      which are kept in the internal HashMap.\n+      The output is an array of maps with the top-k n-grams and corresponding frequency.\n+  \"\"\",\n+  extended = \"\"\"\n+    Examples:\n+      > SELECT ngrams(array(\"abc\", \"abc\", \"bcd\", \"abc\", \"bcd\"), 2, 4);\n+       [{[\"abc\",\"bcd\"]:2.0},\n+       {[\"abc\",\"abc\"]:1.0},\n+       {[\"bcd\",\"abc\"]:1.0}]\n+  \"\"\")\n+case class NGrams(\n+    child: Expression,\n+    nExpression: Expression,\n+    kExpression: Expression,\n+    accuracyExpression: Expression,\n+    override val mutableAggBufferOffset: Int,\n+    override val inputAggBufferOffset: Int)\n+  extends TypedImperativeAggregate[NGramBuffer] with ImplicitCastInputTypes  {\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression,\n+           accuracyExpression: Expression) = {\n+    this(child, nExpression, kExpression, NGrams.getAccuracy(kExpression, accuracyExpression), 0, 0)\n+  }\n+\n+  def this(child: Expression, nExpression: Expression, kExpression: Expression) = {\n+    this(child, nExpression, kExpression, Literal(0))\n+  }\n+\n+  private lazy val n: Int = nExpression.eval().asInstanceOf[Int]\n+  private lazy val k: Int = kExpression.eval().asInstanceOf[Int]\n+  private lazy val accuracy: Int = accuracyExpression.eval().asInstanceOf[Int]\n+\n+  override def inputTypes: Seq[AbstractDataType] = {\n+    Seq(TypeCollection(ArrayType(StringType, false), ArrayType(ArrayType(StringType, false))),\n+      IntegerType, IntegerType, IntegerType)\n+  }\n+\n+  val isArrayOfString = child.dataType == ArrayType(StringType, false) ||\n+    child.dataType == ArrayType(StringType, true)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    val defaultCheck = super.checkInputDataTypes()\n+    if (defaultCheck.isFailure) {\n+      defaultCheck\n+    } else if (!nExpression.foldable || !kExpression.foldable || !accuracyExpression.foldable) {\n+      TypeCheckFailure(s\"The accuracy or percentage provided must be a foldable integer expression\")\n+    } else if (n <= 0) {\n+      TypeCheckFailure(s\"The n provided must be a positive integer (current value = $n)\")\n+    } else if (k <= 0) {\n+      TypeCheckFailure(s\"The k provided must be a positive integer (current value = $k)\")\n+    } else if (accuracy <= 0) {\n+      TypeCheckFailure(\n+        s\"The accuracy provided must be a positive integer (current value = $accuracy)\")\n+    } else {\n+      TypeCheckSuccess\n+    }\n+  }\n+\n+  override def createAggregationBuffer(): NGramBuffer = {\n+    new NGramBuffer(n, k, accuracy, new HashMap[Vector[UTF8String], Double]())\n+  }\n+\n+  def updateArray(genericArrayData: GenericArrayData, buffer: NGramBuffer, inputRow: InternalRow) {\n+    val values = (0 until genericArrayData.numElements()).map(genericArrayData.get(_, StringType).\n+      asInstanceOf[UTF8String]).toVector\n+    val nGrams = getNGrams(values, n)\n+    nGrams.foreach(buffer.add(_))\n+    buffer.trim()\n+  }\n+  override def update(buffer: NGramBuffer, inputRow: InternalRow): NGramBuffer = {\n+    if (isArrayOfString) {\n+      updateArray(child.eval(inputRow).asInstanceOf[GenericArrayData], buffer, inputRow)\n+    } else {\n+      val arrayOfArray = child.eval(inputRow).asInstanceOf[GenericArrayData]\n+      for (i <- 0 until arrayOfArray.numElements()) {\n+        updateArray(arrayOfArray.getArray(i).asInstanceOf[GenericArrayData], buffer, inputRow)\n+      }\n+    }\n+    buffer\n+  }\n+\n+  override def merge(buffer: NGramBuffer, input: NGramBuffer): NGramBuffer = {\n+    buffer.merge(input)\n+    buffer.trim()\n+    buffer\n+  }\n+\n+  override def eval(buffer: NGramBuffer): Any = {\n+    val topKNGrams = buffer.getTopKNGrams().map((keyValuePair: (Vector[UTF8String], Double)) => {\n+      val arrayKey = new GenericArrayData(Vector(new GenericArrayData(keyValuePair._1)))\n+      val arrayValue = new GenericArrayData(Vector(keyValuePair._2))\n+      new ArrayBasedMapData(arrayKey, arrayValue)\n+    }).toVector\n+    new GenericArrayData(topKNGrams)\n+  }\n+\n+  private def getNGrams(values: Vector[UTF8String], n: Int): Vector[Vector[UTF8String]] = {\n+    if (values.length >= n) {\n+      values.sliding(n).toVector\n+    } else {\n+      Vector()\n+    }\n+  }\n+\n+  override def withNewMutableAggBufferOffset(newOffset: Int): NGrams =\n+    copy(mutableAggBufferOffset = newOffset)\n+\n+  override def withNewInputAggBufferOffset(newOffset: Int): NGrams =\n+    copy(inputAggBufferOffset = newOffset)\n+\n+  override def children: Seq[Expression] = Seq(child, nExpression, kExpression, accuracyExpression)\n+\n+  // Returns null for empty inputs\n+  override def nullable: Boolean = true\n+\n+  override def dataType: DataType = ArrayType(MapType(ArrayType(StringType), DoubleType))\n+\n+  override def prettyName: String = \"ngrams\"\n+\n+  override def serialize(obj: NGramBuffer): Array[Byte] = {\n+    NGrams.serializer.serialize(obj)\n+  }\n+\n+  override def deserialize(bytes: Array[Byte]): NGramBuffer = {\n+    NGrams.serializer.deserialize(bytes)\n+  }\n+}\n+\n+object NGrams {\n+\n+  val DEFAULT_ACCURACY: Int = 1000\n+\n+  private def getAccuracy(kExpression: Expression, accuracyExpression: Expression): Expression = {\n+    val accuracy = accuracyExpression.eval().asInstanceOf[Int]\n+    val k = kExpression.eval().asInstanceOf[Int]\n+    Literal(accuracy.max(DEFAULT_ACCURACY / k))\n+  }\n+\n+  val kryoSerializer: KryoSerializer = new KryoSerializer(new SparkConf())\n+\n+  import collection.JavaConverters._\n+\n+  class NGramBuffer(val n: Int,\n+                    val k: Int,\n+                    val precisionFactor: Int,\n+                    val frequencyMap: HashMap[Vector[UTF8String], Double]) {"
  }],
  "prId": 17359
}]