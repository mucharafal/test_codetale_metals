[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "Why is this different from float type? https://github.com/apache/spark/pull/25461/files#diff-6ec5d3b439d05ac7211c6c8f38d94f54R126",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-16T14:24:58Z",
    "diffHunk": "@@ -107,4 +109,82 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  override def toInt(x: Float): Int = {\n+    if (x <= Int.MaxValue && x >= Int.MinValue) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Float): Long = {\n+    if (x <= Long.MaxValue && x >= Long.MinValue) {\n+      x.toLong\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Long\"))\n+    }\n+  }\n+}\n+\n+object DoubleExactNumeric extends DoubleIsFractional with Ordering.DoubleOrdering {\n+  private def exceptionMessage(x: Double, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+\n+  override def toInt(x: Double): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {"
  }],
  "prId": 25461
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "some places we use `< Min  - 1 && > Max + 1`, some places we use `<= Min && >= Max`. Why? Can you add comments to explain it?",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-19T07:53:02Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+\n+  override def toInt(x: Float): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Float): Long = {\n+    if (x <= Long.MaxValue && x >= Long.MinValue) {\n+      x.toLong\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Long\"))\n+    }\n+  }\n+}\n+\n+object DoubleExactNumeric extends DoubleIsFractional with Ordering.DoubleOrdering {\n+  private def exceptionMessage(x: Double, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+\n+  override def toInt(x: Double): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Double): Long = {\n+    if (x <= Long.MaxValue && x >= Long.MinValue) {"
  }],
  "prId": 25461
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "nit: what about throwing the exception here?",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-19T12:03:50Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String ="
  }, {
    "author": {
      "login": "gengliangwang"
    },
    "body": "I thought about it, but then it won't match the return type of `toInt` and `toLong`",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-20T15:04:17Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String ="
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I am not sure I get your comment. If we create the exception in this method and return it, what does it change to `toLong` and `toInt`?",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-20T15:21:37Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String ="
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "one way to do it\r\n```\r\ndef fail[T](): T = {\r\n  throw ...\r\n}\r\n```",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-20T15:27:33Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String ="
  }, {
    "author": {
      "login": "gengliangwang"
    },
    "body": "OK, I see. We can write it like this:\r\n```\r\n  private def throwException(x: Float, dataType: String) =\r\n    throw new ArithmeticException(s\"Casting $x to $dataType causes overflow.\")\r\n```\r\n\r\nWe don't need to specify the returned type, which is `Nothing`.\r\n",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-20T15:34:20Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String ="
  }],
  "prId": 25461
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "shall we rather add a flag to the `toLong` method in order to control this? I think it would be more efficient",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-19T12:09:11Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to Int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def exceptionMessage(x: Float, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+\n+  override def toInt(x: Float): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Float): Long = {\n+    if (x <= Long.MaxValue && x >= Long.MinValue) {\n+      x.toLong\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Long\"))\n+    }\n+  }\n+}\n+\n+object DoubleExactNumeric extends DoubleIsFractional with Ordering.DoubleOrdering {\n+  private def exceptionMessage(x: Double, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+\n+  override def toInt(x: Double): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Double): Long = {\n+    if (x <= Long.MaxValue && x >= Long.MinValue) {\n+      x.toLong\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Long\"))\n+    }\n+  }\n+}\n+\n+object DecimalExactNumeric extends DecimalIsConflicted {\n+  private def exceptionMessage(x: Decimal, dataType: String): String =\n+    s\"Casting $x to $dataType causes overflow.\"\n+\n+  private val intUpperBound = Decimal(Int.MaxValue + 1L)\n+  private val intLowerBound = Decimal(Int.MinValue - 1L)\n+  private val longUpperBound = Decimal(Long.MaxValue) + Decimal(1L)\n+  private val longLowerBound = Decimal(Long.MinValue) - Decimal(1L)\n+\n+  override def toInt(x: Decimal): Int = {\n+    if (x < intUpperBound && x > intLowerBound) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(exceptionMessage(x, \"Int\"))\n+    }\n+  }\n+\n+  override def toLong(x: Decimal): Long = {\n+    if (x < longUpperBound && x > longLowerBound) {\n+      x.toLong"
  }],
  "prId": 25461
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we can probably merge the comments of `longUpperBound` and `longLowerBound`",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-21T14:27:19Z",
    "diffHunk": "@@ -107,4 +109,85 @@ object LongExactNumeric extends LongIsIntegral with Ordering.LongOrdering {\n   override def times(x: Long, y: Long): Long = Math.multiplyExact(x, y)\n \n   override def negate(x: Long): Long = Math.negateExact(x)\n+\n+  override def toInt(x: Long): Int =\n+    if (x == x.toInt) {\n+      x.toInt\n+    } else {\n+      throw new ArithmeticException(s\"Casting $x to int causes overflow.\")\n+    }\n+}\n+\n+object FloatExactNumeric extends FloatIsFractional with Ordering.FloatOrdering {\n+  private def overflowException(x: Float, dataType: String) =\n+    throw new ArithmeticException(s\"Casting $x to $dataType causes overflow.\")\n+\n+  private val intUpperBound = Int.MaxValue + 1L\n+  private val intLowerBound = Int.MinValue - 1L\n+  // We cannot compare `Long.MAX_VALUE` to a float without losing precision.\n+  // In fact, the difference between `Math.nextUp(Long.MAX_VALUE.toFloat)` and\n+  // `Long.MAX_VALUE.toFloat` is 1.09951163E12.\n+  // To make it simple, we compare the input value with `Long.MaxValue.toFloat` directly.\n+  private val longUpperBound = Long.MaxValue.toFloat\n+  // We cannot compare `Long.MIN_VALUE` to a float without losing precision.\n+  // In fact, the difference between `Math.nextDown(Long.MIN_VALUE.toFloat)` and\n+  // `Long.MIN_VALUE.toFloat` is -1.09951163E12.\n+  // To make it simple, we compare the input value with `Long.MIN_VALUE.toFloat` directly."
  }],
  "prId": 25461
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "nit: I am wondering about moving it here...",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-22T14:02:58Z",
    "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.apache.spark.sql.types\n \n-import scala.math.Numeric.{ByteIsIntegral, IntIsIntegral, LongIsIntegral, ShortIsIntegral}\n+import scala.math.Numeric._\n import scala.math.Ordering\n \n+import org.apache.spark.sql.types.Decimal.DecimalIsConflicted",
    "line": 8
  }, {
    "author": {
      "login": "gengliangwang"
    },
    "body": "Do you mean moving `DecimalIsConflicted` into `numerics.scala`? I think it is fine keeping it in `Decimal.scala` for now.",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-22T22:56:03Z",
    "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.apache.spark.sql.types\n \n-import scala.math.Numeric.{ByteIsIntegral, IntIsIntegral, LongIsIntegral, ShortIsIntegral}\n+import scala.math.Numeric._\n import scala.math.Ordering\n \n+import org.apache.spark.sql.types.Decimal.DecimalIsConflicted",
    "line": 8
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "Yes, I meant that. Not a big deal, just to have everything colocated. We can also do in another PR",
    "commit": "9f4002c30bb44c120ccf5489874c86d1061f216f",
    "createdAt": "2019-08-23T07:04:41Z",
    "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.apache.spark.sql.types\n \n-import scala.math.Numeric.{ByteIsIntegral, IntIsIntegral, LongIsIntegral, ShortIsIntegral}\n+import scala.math.Numeric._\n import scala.math.Ordering\n \n+import org.apache.spark.sql.types.Decimal.DecimalIsConflicted",
    "line": 8
  }],
  "prId": 25461
}]