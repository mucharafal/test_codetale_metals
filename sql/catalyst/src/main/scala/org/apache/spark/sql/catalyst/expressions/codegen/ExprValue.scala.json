[{
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "why is this `isPrimitive` needed?  I think we can get rid of this and use the `isPrimitive` method when needed.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-02-28T14:37:19Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = variableName\n+}\n+\n+// A statement evaluation of [[ExprCode]].\n+case class StatementValue(\n+    val statement: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = statement\n+}\n+\n+// A global variable evaluation of [[ExprCode]].\n+case class GlobalValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\", true))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\", true))\n+\n+// Represents the java type of an evaluation.\n+case class ExprType(val typeName: String, val isPrimitive: Boolean)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Here the idea is to include java type information for an evaluation. Then we don't need to consult `CodegenContext`.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T01:51:02Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = variableName\n+}\n+\n+// A statement evaluation of [[ExprCode]].\n+case class StatementValue(\n+    val statement: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = statement\n+}\n+\n+// A global variable evaluation of [[ExprCode]].\n+case class GlobalValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\", true))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\", true))\n+\n+// Represents the java type of an evaluation.\n+case class ExprType(val typeName: String, val isPrimitive: Boolean)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "than can't we move the method from `CodegenContext` to a static method and use that? Currently this information is never used, and I feel this is hard to maintain (even though I don't expect it to change frequently).\r\n\r\nWe can add a method like\r\n```\r\ndef isPrimitive: Boolean = CodegenContext.isPrimitive(typeName)\r\n```",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T10:27:17Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = variableName\n+}\n+\n+// A statement evaluation of [[ExprCode]].\n+case class StatementValue(\n+    val statement: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = statement\n+}\n+\n+// A global variable evaluation of [[ExprCode]].\n+case class GlobalValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\", true))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\", true))\n+\n+// Represents the java type of an evaluation.\n+case class ExprType(val typeName: String, val isPrimitive: Boolean)"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "why isn't this fixed like for `GlobalValue`?",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-02-28T14:38:33Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I want to give it a bit flexibility for something like static variable.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T02:22:10Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "a static variable is a `GlobalValue`, isn't it? Considering that we should be able to access also from methods in other internal classes I don't see any use case where this flexibility is required, honestly...",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T10:30:11Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. I'd let it as fixed.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T11:54:02Z",
    "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "I am not sure this is useful. `ctx.javaType(dataType)` can be done by the caller",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T13:23:58Z",
    "diffHunk": "@@ -70,13 +72,14 @@ case class GlobalValue(val value: String, val javaType: ExprType) extends ExprVa\n   override val canDirectAccess: Boolean = true\n }\n \n-case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\", true))\n-case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\", true))\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\"))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\"))\n \n // Represents the java type of an evaluation.\n-case class ExprType(val typeName: String, val isPrimitive: Boolean)\n+case class ExprType(val typeName: String) {\n+  def isPrimitive(ctx: CodegenContext): Boolean = ctx.isPrimitiveType(typeName)\n+}\n \n object ExprType {\n-  def apply(ctx: CodegenContext, dataType: DataType): ExprType = ExprType(ctx.javaType(dataType),\n-    ctx.isPrimitiveType(dataType))\n+  def apply(ctx: CodegenContext, dataType: DataType): ExprType = ExprType(ctx.javaType(dataType))"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "I see that @kiszk created a PR to move all the \"static\" methods to `CodeGenerator`. Using that approach here we do not need to pass `ctx` as an argument.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T13:25:07Z",
    "diffHunk": "@@ -70,13 +72,14 @@ case class GlobalValue(val value: String, val javaType: ExprType) extends ExprVa\n   override val canDirectAccess: Boolean = true\n }\n \n-case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\", true))\n-case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\", true))\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\"))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\"))\n \n // Represents the java type of an evaluation.\n-case class ExprType(val typeName: String, val isPrimitive: Boolean)\n+case class ExprType(val typeName: String) {\n+  def isPrimitive(ctx: CodegenContext): Boolean = ctx.isPrimitiveType(typeName)"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "here following the approach in #20700 we can avoid to pass `CodegenContext` as a parameter. We can move the method to `CodeGenerator`, cc @kiszk ",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T13:27:44Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+\n+  def isPrimitive(ctx: CodegenContext): Boolean = javaType.isPrimitive(ctx)\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType) extends ExprValue {\n+  override def toString: String = variableName\n+  override val canDirectAccess: Boolean = false\n+}\n+\n+// A statement evaluation of [[ExprCode]].\n+case class StatementValue(\n+    val statement: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = statement\n+}\n+\n+// A global variable evaluation of [[ExprCode]].\n+case class GlobalValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\"))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\"))\n+\n+// Represents the java type of an evaluation.\n+case class ExprType(val typeName: String) {\n+  def isPrimitive(ctx: CodegenContext): Boolean = ctx.isPrimitiveType(typeName)"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "I don't think this method is very useful. If needed, the caller can do `ctx.javaType(dataType)` I think",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-03-01T13:28:40Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: ExprType\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+\n+  def isPrimitive(ctx: CodegenContext): Boolean = javaType.isPrimitive(ctx)\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+object LiteralValue {\n+  def apply(value: String, javaType: ExprType): LiteralValue = new LiteralValue(value, javaType)\n+  def unapply(literal: LiteralValue): Option[(String, ExprType)] =\n+    Some((literal.value, literal.javaType))\n+}\n+\n+// A variable evaluation of [[ExprCode]].\n+case class VariableValue(\n+    val variableName: String,\n+    val javaType: ExprType) extends ExprValue {\n+  override def toString: String = variableName\n+  override val canDirectAccess: Boolean = false\n+}\n+\n+// A statement evaluation of [[ExprCode]].\n+case class StatementValue(\n+    val statement: String,\n+    val javaType: ExprType,\n+    val canDirectAccess: Boolean = false) extends ExprValue {\n+  override def toString: String = statement\n+}\n+\n+// A global variable evaluation of [[ExprCode]].\n+case class GlobalValue(val value: String, val javaType: ExprType) extends ExprValue {\n+  override def toString: String = value\n+  override val canDirectAccess: Boolean = true\n+}\n+\n+case object TrueLiteral extends LiteralValue(\"true\", ExprType(\"boolean\"))\n+case object FalseLiteral extends LiteralValue(\"false\", ExprType(\"boolean\"))\n+\n+// Represents the java type of an evaluation.\n+case class ExprType(val typeName: String) {\n+  def isPrimitive(ctx: CodegenContext): Boolean = ctx.isPrimitiveType(typeName)\n+}\n+\n+object ExprType {\n+  def apply(ctx: CodegenContext, dataType: DataType): ExprType = ExprType(ctx.javaType(dataType))"
  }],
  "prId": 20043
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why not a case class?",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-04-11T11:47:50Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: String\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+\n+  def isPrimitive: Boolean = CodeGenerator.isPrimitiveType(javaType)\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: String) extends ExprValue {",
    "line": 42
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "We currently have case objects for `TrueLiteral` and `FalseLiteral` which extends `LiteralValue`.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-04-11T11:50:47Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: String\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+\n+  def isPrimitive: Boolean = CodeGenerator.isPrimitiveType(javaType)\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: String) extends ExprValue {",
    "line": 42
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yes.",
    "commit": "ac2e5959f204bde0ccd418479482f6f62b51a6f5",
    "createdAt": "2018-04-11T14:40:51Z",
    "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.codegen\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.sql.types.DataType\n+\n+// An abstraction that represents the evaluation result of [[ExprCode]].\n+abstract class ExprValue {\n+\n+  val javaType: String\n+\n+  // Whether we can directly access the evaluation value anywhere.\n+  // For example, a variable created outside a method can not be accessed inside the method.\n+  // For such cases, we may need to pass the evaluation as parameter.\n+  val canDirectAccess: Boolean\n+\n+  def isPrimitive: Boolean = CodeGenerator.isPrimitiveType(javaType)\n+}\n+\n+object ExprValue {\n+  implicit def exprValueToString(exprValue: ExprValue): String = exprValue.toString\n+}\n+\n+// A literal evaluation of [[ExprCode]].\n+class LiteralValue(val value: String, val javaType: String) extends ExprValue {",
    "line": 42
  }],
  "prId": 20043
}]