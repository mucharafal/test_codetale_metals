[{
  "comments": [{
    "author": {
      "login": "tarekbecker"
    },
    "body": "Is it okay to call `DateFormat(child, Literal(\"y\")).eval(input)` or is there a more elegant way.\n\nIs there a way to call `genCode` of `DataFormat`?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-24T08:54:55Z",
    "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+case class DateFormat(left: Expression, right: Expression)\n+  extends BinaryExpression with ExpectsInputTypes {\n+\n+  override def dataType: DataType = StringType\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType, StringType)\n+\n+  override def foldable: Boolean = left.foldable && right.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = left.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = right.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        left.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  override def toString: String = s\"DateFormat($left, $right)\"\n+\n+  override protected def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val sdf = \"java.text.SimpleDateFormat\"\n+    val utf8 = \"org.apache.spark.unsafe.types.UTF8String\"\n+    val dtUtils = \"org.apache.spark.sql.catalyst.util.DateTimeUtils\"\n+\n+    val eval1 = left.gen(ctx)\n+    val eval2 = right.gen(ctx)\n+\n+    val calc = left.dataType match {\n+      case TimestampType =>\n+        s\"\"\"$utf8.fromString(sdf.format(new java.sql.Date(${eval1.primitive} / 10000)));\"\"\"\n+      case DateType =>\n+        s\"\"\"$utf8.fromString(\n+          sdf.format($dtUtils.toJavaDate(${eval1.primitive})));\"\"\"\n+      case StringType =>\n+        s\"\"\"\n+           $utf8.fromString(sdf.format(new java.sql.Date($dtUtils.stringToTime(${eval1.primitive}.toString()).getTime())));\n+         \"\"\"\n+    }\n+\n+    s\"\"\"\n+      ${eval1.code}\n+      boolean ${ev.isNull} = ${eval1.isNull};\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      if (!${ev.isNull}) {\n+        ${eval2.code}\n+        if (!${eval2.isNull}) {\n+          $sdf sdf = new $sdf(${eval2.primitive}.toString());\n+          ${ev.primitive} = $calc\n+        } else {\n+          ${ev.isNull} = true;\n+        }\n+      }\n+    \"\"\"\n+  }\n+}\n+\n+case class Year(child: Expression) extends UnaryExpression with ExpectsInputTypes {\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(DateType, StringType, TimestampType)\n+\n+  override def foldable: Boolean = child.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def eval(input: InternalRow): Any = {\n+    DateFormat(child, Literal(\"y\")).eval(input) match {"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "tarekbecker"
    },
    "body": "If name is `DateFormat` build failes in line https://github.com/apache/spark/blob/6b7f2ceafdcbb014791909747c2210b527305df9/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/util/DateTimeUtils.scala#L72\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-24T09:58:03Z",
    "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+case class DateFormatClass(left: Expression, right: Expression)"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "just `valueLeft.toString` \n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T09:56:00Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))"
  }, {
    "author": {
      "login": "sujkh85"
    },
    "body": "## NAVER - http://www.naver.com/\n\nsujkh@naver.com 님께 보내신 메일 <Re: [spark] [SPARK-8199][SPARK-8184][SPARK-8183][SPARK-8182][SPARK-8181][SPARK-8180][SPARK-8179][SPARK-8177][SPARK-8178][SQL] date functions (#6981)> 이 다음과 같은 이유로 전송 실패했습니다.\n\n---\n\n받는 사람이 회원님의 메일을 수신차단 하였습니다. \n\n---\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T09:56:46Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "`ctx.stringType`\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T09:57:22Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by date format expressions to generate a code block that returns the result\n+   *\n+   * As an example, the following parse the result to int\n+   * {{{\n+   *   defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")\n+   * }}}\n+   *\n+   * @param f function that accepts a variable name and returns Java code to parse an\n+   *          [[UTF8String]] to the expected output type\n+   */\n+\n+  protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = \"java.text.SimpleDateFormat\"\n+    val utf8 = \"org.apache.spark.unsafe.types.UTF8String\""
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "`classOf[].getName`\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T10:05:15Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by date format expressions to generate a code block that returns the result\n+   *\n+   * As an example, the following parse the result to int\n+   * {{{\n+   *   defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")\n+   * }}}\n+   *\n+   * @param f function that accepts a variable name and returns Java code to parse an\n+   *          [[UTF8String]] to the expected output type\n+   */\n+\n+  protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = \"java.text.SimpleDateFormat\""
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "Seems many checks follow the same pattern, refactor to eliminate duplication?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T10:14:56Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by date format expressions to generate a code block that returns the result\n+   *\n+   * As an example, the following parse the result to int\n+   * {{{\n+   *   defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")\n+   * }}}\n+   *\n+   * @param f function that accepts a variable name and returns Java code to parse an\n+   *          [[UTF8String]] to the expected output type\n+   */\n+\n+  protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = \"java.text.SimpleDateFormat\"\n+    val utf8 = \"org.apache.spark.unsafe.types.UTF8String\"\n+    val dtUtils = \"org.apache.spark.sql.catalyst.util.DateTimeUtils\"\n+\n+    val eval1 = date.gen(ctx)\n+    val eval2 = format.gen(ctx)\n+\n+    val varName = ctx.freshName(\"resultVar\")\n+\n+    s\"\"\"\n+      ${eval1.code}\n+      boolean ${ev.isNull} = ${eval1.isNull};\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      if (!${ev.isNull}) {\n+        ${eval2.code}\n+        if (!${eval2.isNull}) {\n+          $sdf sdf = new $sdf(${eval2.primitive}.toString());\n+          Object o = ${eval1.primitive};\n+          $utf8 $varName;\n+          if (o instanceof ${ctx.boxedType(TimestampType)}) {\n+            $varName = $utf8.fromString(sdf.format(new java.sql.Date(Long.parseLong(o.toString()) / 10000)));\n+          } else if (o instanceof ${ctx.boxedType(DateType)}) {\n+            $varName = $utf8.fromString(sdf.format($dtUtils.toJavaDate(Integer.parseInt(o.toString()))));\n+          } else {\n+            $varName = $utf8.fromString(sdf.format(new java.sql.Date($dtUtils.stringToTime(o.toString()).getTime())));\n+          }\n+          ${ev.primitive} = ${f(varName)};\n+        } else {\n+          ${ev.isNull} = true;\n+        }\n+      }\n+    \"\"\"\n+  }\n+  \n+}\n+\n+case class DateFormatClass(date: Expression, format: Expression) extends DateFormatExpression {\n+\n+  override def dataType: DataType = StringType\n+\n+  override def checkInputDataTypes(): TypeCheckResult =\n+    (date.dataType, format.dataType) match {\n+      case (null, _) => TypeCheckResult.TypeCheckSuccess\n+      case (_, null) => TypeCheckResult.TypeCheckSuccess\n+      case (_: DateType, _: StringType) => TypeCheckResult.TypeCheckSuccess\n+      case (_: TimestampType, _: StringType) => TypeCheckResult.TypeCheckSuccess\n+      case (_: StringType, _: StringType) => TypeCheckResult.TypeCheckSuccess\n+      case _ =>\n+        TypeCheckResult.TypeCheckFailure(s\"DateFormat accepts date types as first argument, \" +\n+          s\"and string types as second, not ${date.dataType} and ${format.dataType}\")\n+    }\n+\n+  override def toString: String = s\"DateFormat($date, $format)\"\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    defineCodeGen(ctx, ev, c => s\"$c\")\n+  }\n+\n+}\n+\n+case class Year(date: Expression) extends DateFormatExpression {\n+\n+  override protected val format: Expression = Literal(\"y\")\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def checkInputDataTypes(): TypeCheckResult ="
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "Can we move the branching code out and get a specific version during code generation, for performance sake?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T10:26:39Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by date format expressions to generate a code block that returns the result\n+   *\n+   * As an example, the following parse the result to int\n+   * {{{\n+   *   defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")\n+   * }}}\n+   *\n+   * @param f function that accepts a variable name and returns Java code to parse an\n+   *          [[UTF8String]] to the expected output type\n+   */\n+\n+  protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = \"java.text.SimpleDateFormat\"\n+    val utf8 = \"org.apache.spark.unsafe.types.UTF8String\"\n+    val dtUtils = \"org.apache.spark.sql.catalyst.util.DateTimeUtils\"\n+\n+    val eval1 = date.gen(ctx)\n+    val eval2 = format.gen(ctx)\n+\n+    val varName = ctx.freshName(\"resultVar\")\n+\n+    s\"\"\"\n+      ${eval1.code}\n+      boolean ${ev.isNull} = ${eval1.isNull};\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      if (!${ev.isNull}) {\n+        ${eval2.code}\n+        if (!${eval2.isNull}) {\n+          $sdf sdf = new $sdf(${eval2.primitive}.toString());\n+          Object o = ${eval1.primitive};\n+          $utf8 $varName;\n+          if (o instanceof ${ctx.boxedType(TimestampType)}) {"
  }, {
    "author": {
      "login": "tarekbecker"
    },
    "body": "Yes this would be possible, if the type of the left parameter type never changes. For dataframe this is true, for Spark SQL I'm not sure. Can I just use pattern Scala matching to decide which transformation is correct, like\n\n```\neval2 match {\n  case StringType => ...\n  case ....\n}\n```\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T19:07:11Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression\n+\n+  override def foldable: Boolean = date.foldable && format.foldable\n+\n+  override def nullable: Boolean = true\n+\n+  override def children: Seq[Expression] = Seq(date, format)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = date.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = format.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.asInstanceOf[UTF8String].toString)\n+        date.dataType match {\n+          case TimestampType =>\n+            UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+          case DateType =>\n+            UTF8String.fromString(sdf.format(DateTimeUtils.toJavaDate(valueLeft.asInstanceOf[Int])))\n+          case StringType =>\n+            UTF8String.fromString(\n+              sdf.format(DateTimeUtils.stringToTime(valueLeft.asInstanceOf[UTF8String].toString)))\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called by date format expressions to generate a code block that returns the result\n+   *\n+   * As an example, the following parse the result to int\n+   * {{{\n+   *   defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")\n+   * }}}\n+   *\n+   * @param f function that accepts a variable name and returns Java code to parse an\n+   *          [[UTF8String]] to the expected output type\n+   */\n+\n+  protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = \"java.text.SimpleDateFormat\"\n+    val utf8 = \"org.apache.spark.unsafe.types.UTF8String\"\n+    val dtUtils = \"org.apache.spark.sql.catalyst.util.DateTimeUtils\"\n+\n+    val eval1 = date.gen(ctx)\n+    val eval2 = format.gen(ctx)\n+\n+    val varName = ctx.freshName(\"resultVar\")\n+\n+    s\"\"\"\n+      ${eval1.code}\n+      boolean ${ev.isNull} = ${eval1.isNull};\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      if (!${ev.isNull}) {\n+        ${eval2.code}\n+        if (!${eval2.isNull}) {\n+          $sdf sdf = new $sdf(${eval2.primitive}.toString());\n+          Object o = ${eval1.primitive};\n+          $utf8 $varName;\n+          if (o instanceof ${ctx.boxedType(TimestampType)}) {"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "Can we just make `format` a String and left `DateFormatClass` as a special case? seems we have to `eval` this constant value again and again.\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T10:36:26Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression"
  }, {
    "author": {
      "login": "tarekbecker"
    },
    "body": "That's a good hint. I am going to change it.\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-26T19:08:13Z",
    "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends Expression { self: Product =>\n+  \n+  protected val date: Expression\n+  \n+  protected val format: Expression"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "This is pretty expensive, at least we should have a fast path as `year = 1970 + seconds / 3600 / 24 / 365.24 /`\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-29T19:39:31Z",
    "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends UnaryExpression with ExpectsInputTypes {\n+  self: Product =>\n+\n+  protected val format: String\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = child.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      if (format == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(format)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = classOf[SimpleDateFormat].getName\n+    super.defineCodeGen(ctx, ev, (x) => {\n+      f(s\"\"\"${ctx.stringType}.fromString((new $sdf(\"$format\"))\n+            .format(new java.sql.Date($x / 10000)))\"\"\")\n+    })\n+  }\n+\n+}\n+\n+case class DateFormatClass(left: Expression, right: Expression) extends BinaryExpression\n+    with ExpectsInputTypes {\n+\n+  override def dataType: DataType = StringType\n+\n+  override def toString: String = s\"DateFormat($left, $right)\"\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType, StringType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = left.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = right.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.toString)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val sdf = classOf[SimpleDateFormat].getName\n+    defineCodeGen(ctx, ev, (x, y) => {\n+      s\"\"\"${ctx.stringType}.fromString((new $sdf($y.toString()))\n+          .format(new java.sql.Date($x / 10000)))\"\"\"\n+    })\n+  }\n+}\n+\n+case class Year(child: Expression) extends DateFormatExpression with ExpectsInputTypes {\n+\n+  override protected val format: String = \"y\"\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")"
  }, {
    "author": {
      "login": "tarekbecker"
    },
    "body": "Thanks for the feedback. I am going to work on this for all functions\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-29T21:11:07Z",
    "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends UnaryExpression with ExpectsInputTypes {\n+  self: Product =>\n+\n+  protected val format: String\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = child.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      if (format == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(format)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = classOf[SimpleDateFormat].getName\n+    super.defineCodeGen(ctx, ev, (x) => {\n+      f(s\"\"\"${ctx.stringType}.fromString((new $sdf(\"$format\"))\n+            .format(new java.sql.Date($x / 10000)))\"\"\")\n+    })\n+  }\n+\n+}\n+\n+case class DateFormatClass(left: Expression, right: Expression) extends BinaryExpression\n+    with ExpectsInputTypes {\n+\n+  override def dataType: DataType = StringType\n+\n+  override def toString: String = s\"DateFormat($left, $right)\"\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType, StringType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = left.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = right.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.toString)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val sdf = classOf[SimpleDateFormat].getName\n+    defineCodeGen(ctx, ev, (x, y) => {\n+      s\"\"\"${ctx.stringType}.fromString((new $sdf($y.toString()))\n+          .format(new java.sql.Date($x / 10000)))\"\"\"\n+    })\n+  }\n+}\n+\n+case class Year(child: Expression) extends DateFormatExpression with ExpectsInputTypes {\n+\n+  override protected val format: String = \"y\"\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Since @adrian-wang also work on datetime functions, can you two work together to avoid duplicates?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-29T21:14:08Z",
    "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+\n+import org.apache.spark.sql.catalyst.analysis.TypeCheckResult\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.catalyst.util.DateTimeUtils\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class DateFormatExpression extends UnaryExpression with ExpectsInputTypes {\n+  self: Product =>\n+\n+  protected val format: String\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = child.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      if (format == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(format)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override protected def defineCodeGen(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode,\n+      f: String => String): String = {\n+\n+    val sdf = classOf[SimpleDateFormat].getName\n+    super.defineCodeGen(ctx, ev, (x) => {\n+      f(s\"\"\"${ctx.stringType}.fromString((new $sdf(\"$format\"))\n+            .format(new java.sql.Date($x / 10000)))\"\"\")\n+    })\n+  }\n+\n+}\n+\n+case class DateFormatClass(left: Expression, right: Expression) extends BinaryExpression\n+    with ExpectsInputTypes {\n+\n+  override def dataType: DataType = StringType\n+\n+  override def toString: String = s\"DateFormat($left, $right)\"\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType, StringType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = left.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val valueRight = right.eval(input)\n+      if (valueRight == null) {\n+        null\n+      } else {\n+        val sdf = new SimpleDateFormat(valueRight.toString)\n+        UTF8String.fromString(sdf.format(new Date(valueLeft.asInstanceOf[Long] / 10000)))\n+      }\n+    }\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val sdf = classOf[SimpleDateFormat].getName\n+    defineCodeGen(ctx, ev, (x, y) => {\n+      s\"\"\"${ctx.stringType}.fromString((new $sdf($y.toString()))\n+          .format(new java.sql.Date($x / 10000)))\"\"\"\n+    })\n+  }\n+}\n+\n+case class Year(child: Expression) extends DateFormatExpression with ExpectsInputTypes {\n+\n+  override protected val format: String = \"y\"\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    defineCodeGen(ctx, ev, c => s\"Integer.parseInt($c.toString())\")"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "tarekbecker"
    },
    "body": "Can I make this class to a private class, because it shouldn't be used somewhere else?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-30T05:16:09Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+import java.util.{Calendar, TimeZone}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class TimeFormatExpression extends UnaryExpression with ExpectsInputTypes {"
  }],
  "prId": 6981
}, {
  "comments": [{
    "author": {
      "login": "tarekbecker"
    },
    "body": "Is it okay to recalculate the result or should `Year` be independent of `DateFormatExpression`?\n",
    "commit": "f7b4c8ca3b4258fffb83db79571f8cefe16883a7",
    "createdAt": "2015-06-30T05:17:19Z",
    "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.sql.Date\n+import java.text.SimpleDateFormat\n+import java.util.{Calendar, TimeZone}\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GeneratedExpressionCode, CodeGenContext}\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+abstract class TimeFormatExpression extends UnaryExpression with ExpectsInputTypes {\n+  self: Product =>\n+\n+  protected val format: Int\n+\n+  protected val cntPerInterval: Int\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType)\n+\n+  override def eval(input: InternalRow): Any = {\n+    val valueLeft = child.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val time = valueLeft.asInstanceOf[Long] / 10000\n+      val utcTime: Long = time + TimeZone.getDefault.getOffset(time)\n+      ((utcTime / format) % cntPerInterval).toInt\n+    }\n+  }\n+\n+  override def genCode(\n+      ctx: CodeGenContext,\n+      ev: GeneratedExpressionCode): String = {\n+\n+    val tz = classOf[TimeZone].getName\n+\n+    defineCodeGen(ctx, ev, (c) =>\n+      s\"\"\"(${ctx.javaType(dataType)})\n+            ((($c / 10000) + $tz.getDefault().getOffset($c / 10000)) / $format % $cntPerInterval)\"\"\"\n+    )\n+  }\n+}\n+\n+case class Hour(child: Expression) extends TimeFormatExpression {\n+\n+  override protected val format: Int = 1000 * 3600\n+\n+  override protected val cntPerInterval: Int = 24\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def toString: String = s\"Hour($child)\"\n+}\n+\n+case class Minute(child: Expression) extends TimeFormatExpression {\n+\n+  override protected val format: Int = 1000 * 60\n+\n+  override protected val cntPerInterval: Int = 60\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def toString: String = s\"Minute($child)\"\n+}\n+\n+case class Second(child: Expression) extends TimeFormatExpression {\n+\n+  override protected val format: Int = 1000\n+\n+  override protected val cntPerInterval: Int = 60\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def toString: String = s\"Second($child)\"\n+}\n+\n+abstract class DateFormatExpression extends UnaryExpression with ExpectsInputTypes {\n+  self: Product =>\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def expectedChildTypes: Seq[DataType] = Seq(TimestampType)\n+\n+  protected def defineCodeGen(\n+    ctx: CodeGenContext,\n+    ev: GeneratedExpressionCode,\n+    f: (String, String) => String): String = {\n+\n+    val tz = classOf[TimeZone].getName\n+\n+    val utcTime = ctx.freshName(\"utcTime\")\n+    val dayInYear = ctx.freshName(\"dayInYear\")\n+    val days = ctx.freshName(\"days\")\n+    val year = ctx.freshName(\"year\")\n+\n+    val eval = child.gen(ctx)\n+    ev.isNull = eval.isNull\n+    eval.code + s\"\"\"\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      if (!${ev.isNull}) {\n+        long $utcTime = ${eval.primitive} / 10000;\n+        long $days = $utcTime / 1000 / 3600 / 24;\n+        int $year = (int) ($days / 365.24);\n+        int $dayInYear = (int) ($days - $year * 365.24);\n+        ${f(dayInYear, utcTime)}\n+      }\n+    \"\"\"\n+  }\n+\n+  def eval(input: InternalRow, f: (Int, Long) => Int): Any = {\n+    val valueLeft = child.eval(input)\n+    if (valueLeft == null) {\n+      null\n+    } else {\n+      val utcTime: Long = valueLeft.asInstanceOf[Long] / 10000\n+      val days = utcTime / 1000 / 3600 / 24\n+      val year = days / 365.24\n+      val dayInYear = days - year.toInt * 365.24\n+      f(dayInYear.toInt, utcTime)\n+    }\n+  }\n+\n+  override def toString: String = s\"Year($child)\"\n+}\n+\n+\n+case class Year(child: Expression) extends DateFormatExpression {\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+\n+    val cal = classOf[Calendar].getName\n+    defineCodeGen(ctx, ev, (day, utc) =>\n+      s\"\"\"\n+         if ($day > 1 && $day < 360) {\n+           ${ev.primitive} = (int) (1970 + ($utc / 1000 / 3600 / 24 / 365.24));\n+         } else {\n+           $cal c = $cal.getInstance();\n+           c.setTimeInMillis($utc);\n+           ${ev.primitive} = c.get($cal.YEAR);\n+         }\n+       \"\"\")\n+  }\n+\n+  override def eval(input: InternalRow): Any = {\n+    eval(input, (dayInYear, utcTime) =>\n+      if (dayInYear > 1 && dayInYear < 360) {\n+        1970 + (utcTime / 1000 / 3600 / 24 / 365.24).toInt"
  }],
  "prId": 6981
}]