[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "remove 2 extra lines",
    "commit": "6d063745a1501277018b04ef264e1e72949dc107",
    "createdAt": "2017-09-28T18:22:33Z",
    "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import scala.util.control.NonFatal\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions.{Add, AttributeReference, AttributeSet, Cast, CheckOverflow, Expression, ExpressionSet, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual, Literal, Multiply, PreciseTimestampConversion, PredicateHelper, Subtract, TimeAdd, TimeSub, UnaryMinus}\n+import org.apache.spark.sql.catalyst.plans.logical.EventTimeWatermark._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.unsafe.types.CalendarInterval\n+\n+\n+/**\n+ * Helper object for stream joins. See [[StreamingSymmetricHashJoinExec]] in SQL for more details.\n+ */\n+object StreamingJoinHelper extends PredicateHelper with Logging {\n+  /**\n+   * Get state value watermark (see [[StreamingSymmetricHashJoinExec]] for context about it)\n+   * given the join condition and the event time watermark. This is how it works.\n+   * - The condition is split into conjunctive predicates, and we find the predicates of the\n+   *   form `leftTime + c1 < rightTime + c2`   (or <=, >, >=).\n+   * - We canoncalize the predicate and solve it with the event time watermark value to find the\n+   *  value of the state watermark.\n+   * This function is supposed to make best-effort attempt to get the state watermark. If there is\n+   * any error, it will return None.\n+   *\n+   * @param attributesToFindStateWatermarkFor attributes of the side whose state watermark\n+   *                                         is to be calculated\n+   * @param attributesWithEventWatermark  attributes of the other side which has a watermark column\n+   * @param joinCondition                 join condition\n+   * @param eventWatermark                watermark defined on the input event data\n+   * @return state value watermark in milliseconds, is possible.\n+   */\n+  def getStateValueWatermark(\n+      attributesToFindStateWatermarkFor: AttributeSet,\n+      attributesWithEventWatermark: AttributeSet,\n+      joinCondition: Option[Expression],\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    // If condition or event time watermark is not provided, then cannot calculate state watermark\n+    if (joinCondition.isEmpty || eventWatermark.isEmpty) return None\n+\n+    // If there is not watermark attribute, then cannot define state watermark\n+    if (!attributesWithEventWatermark.exists(_.metadata.contains(delayKey))) return None\n+\n+    def getStateWatermarkSafely(l: Expression, r: Expression): Option[Long] = {\n+      try {\n+        getStateWatermarkFromLessThenPredicate(\n+          l, r, attributesToFindStateWatermarkFor, attributesWithEventWatermark, eventWatermark)\n+      } catch {\n+        case NonFatal(e) =>\n+          logWarning(s\"Error trying to extract state constraint from condition $joinCondition\", e)\n+          None\n+      }\n+    }\n+\n+    val allStateWatermarks = splitConjunctivePredicates(joinCondition.get).flatMap { predicate =>\n+\n+      // The generated the state watermark cleanup expression is inclusive of the state watermark.\n+      // If state watermark is W, all state where timestamp <= W will be cleaned up.\n+      // Now when the canonicalized join condition solves to leftTime >= W, we dont want to clean\n+      // up leftTime <= W. Rather we should clean up leftTime <= W - 1. Hence the -1 below.\n+      val stateWatermark = predicate match {\n+        case LessThan(l, r) => getStateWatermarkSafely(l, r)\n+        case LessThanOrEqual(l, r) => getStateWatermarkSafely(l, r).map(_ - 1)\n+        case GreaterThan(l, r) => getStateWatermarkSafely(r, l)\n+        case GreaterThanOrEqual(l, r) => getStateWatermarkSafely(r, l).map(_ - 1)\n+        case _ => None\n+      }\n+      if (stateWatermark.nonEmpty) {\n+        logInfo(s\"Condition $joinCondition generated watermark constraint = ${stateWatermark.get}\")\n+      }\n+      stateWatermark\n+    }\n+    allStateWatermarks.reduceOption((x, y) => Math.min(x, y))\n+  }\n+\n+  /**\n+   * Extract the state value watermark (milliseconds) from the condition\n+   * `LessThan(leftExpr, rightExpr)` where . For example: if we want to find the constraint for\n+   * leftTime using the watermark on the rightTime. Example:\n+   *\n+   * Input:                 rightTime-with-watermark + c1 < leftTime + c2\n+   * Canonical form:        rightTime-with-watermark + c1 + (-c2) + (-leftTime) < 0\n+   * Solving for rightTime: rightTime-with-watermark + c1 + (-c2) < leftTime\n+   * With watermark value:  watermark-value + c1 + (-c2) < leftTime\n+   */\n+  private def getStateWatermarkFromLessThenPredicate(\n+      leftExpr: Expression,\n+      rightExpr: Expression,\n+      attributesToFindStateWatermarkFor: AttributeSet,\n+      attributesWithEventWatermark: AttributeSet,\n+      eventWatermark: Option[Long]): Option[Long] = {\n+\n+    val attributesInCondition = AttributeSet(\n+      leftExpr.collect { case a: AttributeReference => a } ++\n+      rightExpr.collect { case a: AttributeReference => a }\n+    )\n+    if (attributesInCondition.filter { attributesToFindStateWatermarkFor.contains(_) }.size > 1 ||\n+        attributesInCondition.filter { attributesWithEventWatermark.contains(_) }.size > 1) {\n+      // If more than attributes present in condition from one side, then it cannot be solved\n+      return None\n+    }\n+\n+    def containsAttributeToFindStateConstraintFor(e: Expression): Boolean = {\n+      e.collectLeaves().collectFirst {\n+        case a @ AttributeReference(_, _, _, _)\n+          if attributesToFindStateWatermarkFor.contains(a) => a\n+      }.nonEmpty\n+    }\n+\n+    // Canonicalization step 1: convert to (rightTime-with-watermark + c1) - (leftTime + c2) < 0\n+    val allOnLeftExpr = Subtract(leftExpr, rightExpr)\n+    logDebug(s\"All on Left:\\n${allOnLeftExpr.treeString(true)}\\n${allOnLeftExpr.asCode}\")\n+\n+    // Canonicalization step 2: extract commutative terms\n+    //    rightTime-with-watermark, c1, -leftTime, -c2\n+    val terms = ExpressionSet(collectTerms(allOnLeftExpr))\n+    logDebug(\"Terms extracted from join condition:\\n\\t\" + terms.mkString(\"\\n\\t\"))\n+\n+\n+"
  }],
  "prId": 19327
}]