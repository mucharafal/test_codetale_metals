[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "I can see that this is a clean refactoring and this line is the additional style fix.",
    "commit": "bf8f1b9a03d48f1feaec1f3ece33b616d29ce074",
    "createdAt": "2018-12-21T00:14:18Z",
    "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.AttributeSet\n+import org.apache.spark.sql.catalyst.plans.LeftExistence\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+\n+/**\n+ * Attempts to eliminate the reading of unneeded columns from the query plan.\n+ *\n+ * Since adding Project before Filter conflicts with PushPredicatesThroughProject, this rule will\n+ * remove the Project p2 in the following pattern:\n+ *\n+ *   p1 @ Project(_, Filter(_, p2 @ Project(_, child))) if p2.outputSet.subsetOf(p2.inputSet)\n+ *\n+ * p2 is usually inserted by this rule and useless, p1 could prune the columns anyway.\n+ */\n+object ColumnPruning extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = removeProjectBeforeFilter(plan transform {\n+    // Prunes the unused columns from project list of Project/Aggregate/Expand\n+    case p @ Project(_, p2: Project) if !p2.outputSet.subsetOf(p.references) =>\n+      p.copy(child = p2.copy(projectList = p2.projectList.filter(p.references.contains)))\n+    case p @ Project(_, a: Aggregate) if !a.outputSet.subsetOf(p.references) =>\n+      p.copy(\n+        child = a.copy(aggregateExpressions = a.aggregateExpressions.filter(p.references.contains)))\n+    case a @ Project(_, e @ Expand(_, _, grandChild)) if !e.outputSet.subsetOf(a.references) =>\n+      val newOutput = e.output.filter(a.references.contains(_))\n+      val newProjects = e.projections.map { proj =>\n+        proj.zip(e.output).filter { case (_, a) =>\n+          newOutput.contains(a)\n+        }.unzip._1\n+      }\n+      a.copy(child = Expand(newProjects, newOutput, grandChild))\n+\n+    // Prunes the unused columns from child of `DeserializeToObject`\n+    case d @ DeserializeToObject(_, _, child) if !child.outputSet.subsetOf(d.references) =>\n+      d.copy(child = prunedChild(child, d.references))\n+\n+    // Prunes the unused columns from child of Aggregate/Expand/Generate/ScriptTransformation\n+    case a @ Aggregate(_, _, child) if !child.outputSet.subsetOf(a.references) =>\n+      a.copy(child = prunedChild(child, a.references))\n+    case f @ FlatMapGroupsInPandas(_, _, _, child) if !child.outputSet.subsetOf(f.references) =>\n+      f.copy(child = prunedChild(child, f.references))\n+    case e @ Expand(_, _, child) if !child.outputSet.subsetOf(e.references) =>\n+      e.copy(child = prunedChild(child, e.references))\n+    case s @ ScriptTransformation(_, _, _, child, _)\n+        if !child.outputSet.subsetOf(s.references) =>\n+      s.copy(child = prunedChild(child, s.references))\n+\n+    // prune unrequired references\n+    case p @ Project(_, g: Generate) if p.references != g.outputSet =>\n+      val requiredAttrs = p.references -- g.producedAttributes ++ g.generator.references\n+      val newChild = prunedChild(g.child, requiredAttrs)\n+      val unrequired = g.generator.references -- p.references\n+      val unrequiredIndices = newChild.output.zipWithIndex.filter(t => unrequired.contains(t._1))\n+        .map(_._2)\n+      p.copy(child = g.copy(child = newChild, unrequiredChildIndex = unrequiredIndices))\n+\n+    // Eliminate unneeded attributes from right side of a Left Existence Join.\n+    case j @ Join(_, right, LeftExistence(_), _) =>\n+      j.copy(right = prunedChild(right, j.references))\n+\n+    // all the columns will be used to compare, so we can't prune them\n+    case p @ Project(_, _: SetOperation) => p\n+    case p @ Project(_, _: Distinct) => p\n+    // Eliminate unneeded attributes from children of Union.\n+    case p @ Project(_, u: Union) =>\n+      if (!u.outputSet.subsetOf(p.references)) {\n+        val firstChild = u.children.head\n+        val newOutput = prunedChild(firstChild, p.references).output\n+        // pruning the columns of all children based on the pruned first child.\n+        val newChildren = u.children.map { p =>\n+          val selected = p.output.zipWithIndex.filter { case (a, i) =>\n+            newOutput.contains(firstChild.output(i))\n+          }.map(_._1)\n+          Project(selected, p)\n+        }\n+        p.copy(child = u.withNewChildren(newChildren))\n+      } else {\n+        p\n+      }\n+\n+    // Prune unnecessary window expressions\n+    case p @ Project(_, w: Window) if !w.windowOutputSet.subsetOf(p.references) =>\n+      p.copy(child = w.copy(\n+        windowExpressions = w.windowExpressions.filter(p.references.contains)))\n+\n+    // Can't prune the columns on LeafNode\n+    case p @ Project(_, _: LeafNode) => p\n+\n+    // for all other logical plans that inherits the output from it's children\n+    // Project over project is handled by the first case, skip it here.\n+    case p @ Project(_, child) if !child.isInstanceOf[Project] =>\n+      val required = child.references ++ p.references\n+      if (!child.inputSet.subsetOf(required)) {\n+        val newChildren = child.children.map(c => prunedChild(c, required))\n+        p.copy(child = child.withNewChildren(newChildren))\n+      } else {\n+        p\n+      }\n+  })\n+\n+  /** Applies a projection only when the child is producing unnecessary attributes */\n+  private def prunedChild(c: LogicalPlan, allReferences: AttributeSet) =\n+    if (!c.outputSet.subsetOf(allReferences)) {\n+      Project(c.output.filter(allReferences.contains), c)\n+    } else {\n+      c\n+    }\n+\n+  /**\n+   * The Project before Filter is not necessary but conflict with PushPredicatesThroughProject,\n+   * so remove it. Since the Projects have been added top-down, we need to remove in bottom-up\n+   * order, otherwise lower Projects can be missed.\n+   */\n+  private def removeProjectBeforeFilter(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p1 @ Project(_, f @ Filter(_, p2 @ Project(_, child)))\n+        if p2.outputSet.subsetOf(child.outputSet) =>",
    "line": 136
  }],
  "prId": 23359
}]