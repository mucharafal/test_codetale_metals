[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "now we have both `Once` and `Idempotent`, we should pick which one in which cases?",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T06:51:32Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "I would suggest to use `Once` in the test suites only. \r\n \r\nIn the unit tests of optimizer rules, we have many batches that are using `Once`. The expected result of the optimized plan is based on the Once policy. These batches are not expected to be idempotent. ",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T07:05:54Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "yeshengm"
    },
    "body": "To be clear, `Once` means a batch should be run only once, but does not guarantee anything for multiple runs. On the other hand, `Idempotent` means that a batch should be run once, but multiple runs should yield the same result of a single run.",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T07:10:03Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "yeshengm"
    },
    "body": "Basically if a batch is marked as `Idempotent`, the idempotence contract is enforced by running an additional checker.",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T07:11:55Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "maryannxue"
    },
    "body": "After we make sure all rules are idempotent, `Once` would be for test only and the names would all seem weird and confusing.\r\nOne way is to use `Once` for the semantics of idempotent, and add a test-only `OnceUnchecked` for all the catalyst rule tests (I don't suppose we should use this anywhere else).\r\nAnother option is to add another ENV variable, similar to `SPARK_TESTING` (sth. like `SPARK_RULE_TESTING`) for the `RuleExecutor` to skip the check.\r\n",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T16:29:15Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "yeshengm"
    },
    "body": "See `RuleExecutorSuite`, `Once` *was* supposed to run only once (and does not necessarily have to  pass the sanity check).",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T16:33:23Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "maryannxue"
    },
    "body": "I know what you are saying, @yeshengm. All I meant was all we need is `Idempotent` and `FixedPoint` except for the occasions that @gatorsmile worried about in our catalyst rule tests where really `FixedPoint` should be used but it was mistakenly put as `Once`.\r\n\r\nNow I remember last time I worked the experimental branch, there wasn't a whole lot of such places, so let's just change those false `Once` to `FixedPoint` in our tests, and we'll need `Once` only (which is checked under testing mode).",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T16:48:02Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "yeshengm"
    },
    "body": "@maryannxue We can definitely change that. But that means we also have to change tests in `RuleExecutorSuite`. So you are suggesting that we only have `Once` with idempotence semantics & `FixedPoint` right?",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T17:01:51Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }, {
    "author": {
      "login": "maryannxue"
    },
    "body": "Yep.",
    "commit": "304b2c23d6edfea6860a091bd19391d27a8ccbf9",
    "createdAt": "2019-07-03T18:31:47Z",
    "diffHunk": "@@ -47,6 +47,9 @@ abstract class RuleExecutor[TreeType <: TreeNode[_]] extends Logging {\n    */\n   abstract class Strategy { def maxIterations: Int }\n \n+  /** A strategy that is idempotent, i.e. additional runs should not change query plans */\n+  case object Idempotent extends Strategy { val maxIterations = 1 }\n+\n   /** A strategy that only runs once. */\n   case object Once extends Strategy { val maxIterations = 1 }",
    "line": 8
  }],
  "prId": 25039
}]