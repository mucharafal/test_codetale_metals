[{
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "Why is this guaranteed? What about Hive tables, will those have provider defined?",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-09-25T20:30:40Z",
    "diffHunk": "@@ -31,14 +31,15 @@ import org.apache.spark.sql.types.StructType\n  * An implementation of catalog v2 `Table` to expose v1 table metadata.\n  */\n private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n+  assert(v1Table.provider.isDefined)"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Only view has no provider. So this is guaranteed. Please see the parameter doc of `CatalogTable#provider`.",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-09-26T13:45:59Z",
    "diffHunk": "@@ -31,14 +31,15 @@ import org.apache.spark.sql.types.StructType\n  * An implementation of catalog v2 `Table` to expose v1 table metadata.\n  */\n private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n+  assert(v1Table.provider.isDefined)"
  }],
  "prId": 25651
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "If options are to be included in properties, I think that we should prefix them with `option.` so that we can recover them. I suggested this to Xin, who opened SPARK-28555 and was going to work on it, but I haven't seen a PR for it yet.\r\n\r\nThe idea is basically to be able to keep options and properties separate when passing through the v2 interface that only supports properties.\r\n\r\nSince this PR updates V1Table to combine them, maybe we should include the change in this PR. What do you think?",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-09-25T20:45:22Z",
    "diffHunk": "@@ -51,20 +52,18 @@ private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n     }\n   }\n \n-  def catalogTable: CatalogTable = v1Table\n-\n-  lazy val options: Map[String, String] = {\n-    v1Table.storage.locationUri match {\n+  override lazy val properties: util.Map[String, String] = {"
  }],
  "prId": 25651
}, {
  "comments": [{
    "author": {
      "login": "rdblue"
    },
    "body": "+1\r\n\r\nGood catch, this would have been confusing.",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-09-25T20:45:47Z",
    "diffHunk": "@@ -84,5 +83,5 @@ private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n \n   override def capabilities: util.Set[TableCapability] = new util.HashSet[TableCapability]()\n \n-  override def toString: String = s\"UnresolvedTable($name)\"\n+  override def toString: String = s\"V1Table($name)\"",
    "line": 65
  }],
  "prId": 25651
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I leave the options/properties unchanged here, but we need to figure it out later. Currently there are 2 directions:\r\n1. We have table options and table properties. Table options are special table properties with \"option.\" prefix in its name. Table options will be extracted and used as scan/write options.\r\n2. We only have table properties. The OPTIONS clause in CREATE TABLE should be the same as the TBLPROPERTIES clause.\r\n\r\nWe can have more discussion about it later.",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-10-08T16:32:33Z",
    "diffHunk": "@@ -51,38 +52,36 @@ private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n     }\n   }\n \n-  def catalogTable: CatalogTable = v1Table\n-\n   lazy val options: Map[String, String] = {\n-    v1Table.storage.locationUri match {\n+    catalogTable.storage.locationUri match {\n       case Some(uri) =>\n-        v1Table.storage.properties + (\"path\" -> uri.toString)\n+        catalogTable.storage.properties + (\"path\" -> uri.toString)\n       case _ =>\n-        v1Table.storage.properties\n+        catalogTable.storage.properties\n     }\n   }\n \n-  override lazy val properties: util.Map[String, String] = v1Table.properties.asJava\n+  override lazy val properties: util.Map[String, String] = catalogTable.properties.asJava",
    "line": 38
  }, {
    "author": {
      "login": "rdblue"
    },
    "body": "V2 has only table properties, so I think the question is whether we want to mix options into those table properties directly, or whether we want to prefix them so they can be recovered. I'm in favor of being able to recover them so we can constract the catalog table as it would be in the v1 path.",
    "commit": "cfbe0a75f80e88d4a5831785d05fb9b708c5ada3",
    "createdAt": "2019-10-15T23:46:34Z",
    "diffHunk": "@@ -51,38 +52,36 @@ private[sql] case class V1Table(v1Table: CatalogTable) extends Table {\n     }\n   }\n \n-  def catalogTable: CatalogTable = v1Table\n-\n   lazy val options: Map[String, String] = {\n-    v1Table.storage.locationUri match {\n+    catalogTable.storage.locationUri match {\n       case Some(uri) =>\n-        v1Table.storage.properties + (\"path\" -> uri.toString)\n+        catalogTable.storage.properties + (\"path\" -> uri.toString)\n       case _ =>\n-        v1Table.storage.properties\n+        catalogTable.storage.properties\n     }\n   }\n \n-  override lazy val properties: util.Map[String, String] = v1Table.properties.asJava\n+  override lazy val properties: util.Map[String, String] = catalogTable.properties.asJava",
    "line": 38
  }],
  "prId": 25651
}]