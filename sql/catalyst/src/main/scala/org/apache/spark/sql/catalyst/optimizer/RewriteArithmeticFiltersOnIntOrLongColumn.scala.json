[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Is this restrictive to Filter only? Looks like it rewrites all qualified expressions in all logical plan.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-05T08:43:02Z",
    "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "yes, it is filter only. I've changed it to only work on `Filter`",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-05T10:22:15Z",
    "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {"
  }],
  "prId": 23942
}, {
  "comments": [{
    "author": {
      "login": "SongYadong"
    },
    "body": "It will be good to doc supported comparison operators here.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T09:45:38Z",
    "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ */"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "Thanks for your advice. I have updated the comments here",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T11:45:23Z",
    "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ */"
  }],
  "prId": 23942
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "what about checking if it is foldable instead of a Literal?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T11:46:02Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Literal)"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "yes, foldable is better to accelerate convergence, I'll change it ",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T15:21:04Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Literal)"
  }],
  "prId": 23942
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "why only integer and longs are accepted?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T16:24:21Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "`Float` and `Double` has precision issues. For example, `a + 3.2 < 4.0` will be convert to `a  < 0.7999999999999998`.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T00:31:06Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "How about the other integral types, e.g., short?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T12:55:44Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "yes, integral types(byte, short, int, long) are all ok. I'll add support for byte and short type as well.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T16:01:53Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "I think the precision issue would be there anyway, when executed at runtime, am I wrong?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T16:51:18Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "> I think the precision issue would be there anyway, when executed at runtime, am I wrong?\r\n\r\nI have a simple test on a table with a Double type column `a`, it has two records: 0.7999999999999998 and 0.8\r\n![image](https://user-images.githubusercontent.com/1312321/54008703-d07ef780-41a2-11e9-96cd-136764253b25.png)\r\n\r\nwith `a + 3.2 = 4.0`, it returns both two records. But if we optimized it to `a = 0.7999999999999998`, the result will be wrong",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T05:07:55Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "francis0407"
    },
    "body": "Here is an example:\r\n```\r\nscala> spark.sql(\"select float(1E-8) + float(1E+10) <= float(1E+10)\").show()\r\n+----------------------------------------------------------------------+\r\n|((CAST(1E-8 AS FLOAT) + CAST(1E+10 AS FLOAT)) <= CAST(1E+10 AS FLOAT))|\r\n+----------------------------------------------------------------------+\r\n|                                                                  true|\r\n+----------------------------------------------------------------------+\r\n\r\n\r\nscala> spark.sql(\"select float(1E-8) <= float(1E+10) - float(1E+10)\").show()\r\n+----------------------------------------------------------------------+\r\n|(CAST(1E-8 AS FLOAT) <= (CAST(1E+10 AS FLOAT) - CAST(1E+10 AS FLOAT)))|\r\n+----------------------------------------------------------------------+\r\n|                                                                 false|\r\n+----------------------------------------------------------------------+\r\n\r\n```\r\nAlthough `float(1E-8) + float(1E+10) <= float(1E+10)` should return false. This may lead to inconsistency.\r\n",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T05:16:01Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "thanks for the explanation",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T09:36:31Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)\n+            if right.foldable && isDataTypeSafe(left.dataType) =>\n+          transformLeft(e, left, right)\n+        case e @ BinaryComparison(left: Expression, right: BinaryArithmetic)\n+            if left.foldable && isDataTypeSafe(right.dataType) =>\n+          transformRight(e, left, right)\n+      }\n+  }\n+\n+  private def transformLeft(\n+      bc: BinaryComparison,\n+      left: BinaryArithmetic,\n+      right: Expression): Expression = {\n+    left match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(right, e)) =>\n+        bc.makeCopy(Array(ar, Subtract(right, e)))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(right, e)) =>\n+        bc.makeCopy(Array(ar, Add(right, e)))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, right)) =>\n+        bc.makeCopy(Array(Subtract(e, right), ar))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def transformRight(\n+      bc: BinaryComparison,\n+      left: Expression,\n+      right: BinaryArithmetic): Expression = {\n+    right match {\n+      case Add(ar: AttributeReference, e) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Add(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(left, e)) =>\n+        bc.makeCopy(Array(Subtract(left, e), ar))\n+      case Subtract(ar: AttributeReference, e) if e.foldable && isOptSafe(Add(left, e)) =>\n+        bc.makeCopy(Array(Add(left, e), ar))\n+      case Subtract(e, ar: AttributeReference) if e.foldable && isOptSafe(Subtract(e, left)) =>\n+        bc.makeCopy(Array(ar, Subtract(e, left)))\n+      case _ => bc\n+    }\n+  }\n+\n+  private def isDataTypeSafe(dataType: DataType): Boolean = dataType match {"
  }],
  "prId": 23942
}, {
  "comments": [{
    "author": {
      "login": "mgaido91"
    },
    "body": "is it safe to do it also for non-deterministic expressions?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-06T16:25:06Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "`foldable` is enough because in `ConstantFolding` it will **convert all folding expressions** to `Literal`.  And in fact `non-deterministic` is not `foldable`",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T00:20:30Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "yes but what if the remaining part of left is non-determistic?",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T16:50:37Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)"
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "There is a check in `transformRight` and `transformLeft` to make sure the other part of `BinaryArithmetic` is `foldable`",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T05:12:46Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)"
  }, {
    "author": {
      "login": "mgaido91"
    },
    "body": "yes, I was thinking about the `AttributeReference`, but it is always deterministic. So I think it is fine, thanks.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T09:51:50Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format.\n+ * For example, this rule can optimize\n+ * {{{\n+ *   SELECT * FROM table WHERE i + 3 = 5\n+ * }}}\n+ * to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 5 - 3\n+ * }}}\n+ * when i is Int or Long, and then other rules will further optimize it to\n+ * {{{\n+ *   SELECT * FROM table WHERE i = 2\n+ * }}}\n+ * The arithmetic operation supports `Add` and `Subtract`. The comparision supports\n+ * '=', '>=', '<=', '>', '<', '!='. It only supports type of `INT` and `LONG`,\n+ * it doesn't support `FLOAT` or `DOUBLE` for precision issues.\n+ */\n+object RewriteArithmeticFiltersOnIntOrLongColumn extends Rule[LogicalPlan] with PredicateHelper {\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f: Filter =>\n+      f transformExpressionsUp {\n+        case e @ BinaryComparison(left: BinaryArithmetic, right: Expression)"
  }],
  "prId": 23942
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "nit: how about this?\r\n```\r\n/**\r\n * Rewrite arithmetic filters on an integral-type (e.g., int and long) column to its equivalent\r\n * form, leaving attribute alone in a left side, so that we can push it down to\r\n * datasources (e.g., Parquet and ORC).\r\n *\r\n * For example, this rule can optimize a query as follows:\r\n * {{{\r\n *   SELECT * FROM table WHERE i + 3 = 5\r\n *   ==> SELECT * FROM table WHERE i = 5 - 3\r\n * }}}\r\n *\r\n * Then, the [[ConstantFolding]] rule will further optimize it as follows:\r\n * {{{\r\n *   SELECT * FROM table WHERE i = 2\r\n * }}}\r\n *\r\n * Note:\r\n * 1. This rule supports `Add` and `Subtract` in arithmetic expressions.\r\n * 2. This rule supports `=`, `>=`, `<=`, `>`, `<`, and `!=` in comparators.\r\n * 3. This rule supports `INT` and `LONG` types only. It doesn't support `FLOAT` or `DOUBLE`\r\n *    because of precision issues.\r\n */\r\n```",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-07T13:15:48Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format."
  }, {
    "author": {
      "login": "WangGuangxin"
    },
    "body": "It's more clearly. I've updated it.",
    "commit": "43892acab8a3508cbb55ce2012ff5a6487fab181",
    "createdAt": "2019-03-08T05:10:35Z",
    "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.{DataType, IntegerType, LongType}\n+\n+/**\n+ * Rewrite arithmetic filters on int or long column to its equivalent form,\n+ * leaving attribute alone in one side, so that we can push it down to\n+ * parquet or other file format."
  }],
  "prId": 23942
}]