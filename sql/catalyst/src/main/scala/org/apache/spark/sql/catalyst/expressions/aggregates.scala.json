[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Nit: I don't think this needs to be `@transient` (this function will never be serialized), and it could also be a `val`.\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2014-08-26T00:28:55Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  @transient var currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Oh, yes, you're right, I will update this.\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2014-08-26T16:00:03Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  @transient var currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)"
  }],
  "prId": 2113
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "@chenghao-intel , will this cause twice evaluation of expr on the same input line? why not eval once and store in a tmp val? Did I miss something?\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2015-07-23T14:26:09Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  val currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)\n+  val cmp = GreaterThan(currentMin, expr)\n \n   override def update(input: Row): Unit = {\n-    if (currentMin == null) {\n-      currentMin = expr.eval(input)\n-    } else if(GreaterThan(Literal(currentMin, expr.dataType), expr).eval(input) == true) {\n-      currentMin = expr.eval(input)\n+    if (currentMin.value == null) {\n+      currentMin.value = expr.eval(input)\n+    } else if(cmp.eval(input) == true) {\n+      currentMin.value = expr.eval(input)",
    "line": 16
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Yes, you're right! I think now it can be replaced by `MinOf`.\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2015-07-23T14:42:17Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  val currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)\n+  val cmp = GreaterThan(currentMin, expr)\n \n   override def update(input: Row): Unit = {\n-    if (currentMin == null) {\n-      currentMin = expr.eval(input)\n-    } else if(GreaterThan(Literal(currentMin, expr.dataType), expr).eval(input) == true) {\n-      currentMin = expr.eval(input)\n+    if (currentMin.value == null) {\n+      currentMin.value = expr.eval(input)\n+    } else if(cmp.eval(input) == true) {\n+      currentMin.value = expr.eval(input)",
    "line": 16
  }, {
    "author": {
      "login": "yjshen"
    },
    "body": "thanks, just start to read aggregate code :)\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2015-07-23T15:02:29Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  val currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)\n+  val cmp = GreaterThan(currentMin, expr)\n \n   override def update(input: Row): Unit = {\n-    if (currentMin == null) {\n-      currentMin = expr.eval(input)\n-    } else if(GreaterThan(Literal(currentMin, expr.dataType), expr).eval(input) == true) {\n-      currentMin = expr.eval(input)\n+    if (currentMin.value == null) {\n+      currentMin.value = expr.eval(input)\n+    } else if(cmp.eval(input) == true) {\n+      currentMin.value = expr.eval(input)",
    "line": 16
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "@yjshen , the new aggregation has been merged, you have a lot more to read now :)\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2015-07-23T15:05:17Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  val currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)\n+  val cmp = GreaterThan(currentMin, expr)\n \n   override def update(input: Row): Unit = {\n-    if (currentMin == null) {\n-      currentMin = expr.eval(input)\n-    } else if(GreaterThan(Literal(currentMin, expr.dataType), expr).eval(input) == true) {\n-      currentMin = expr.eval(input)\n+    if (currentMin.value == null) {\n+      currentMin.value = expr.eval(input)\n+    } else if(cmp.eval(input) == true) {\n+      currentMin.value = expr.eval(input)",
    "line": 16
  }, {
    "author": {
      "login": "yjshen"
    },
    "body": "yes, it would be a long journey, but I could ask the author whenever I have a question ;)\n",
    "commit": "db403957cd58406fa208726fb7d97889b2287b3f",
    "createdAt": "2015-07-23T15:10:09Z",
    "diffHunk": "@@ -105,17 +105,18 @@ case class Min(child: Expression) extends PartialAggregate with trees.UnaryNode[\n case class MinFunction(expr: Expression, base: AggregateExpression) extends AggregateFunction {\n   def this() = this(null, null) // Required for serialization.\n \n-  var currentMin: Any = _\n+  val currentMin: MutableLiteral = MutableLiteral(null, expr.dataType)\n+  val cmp = GreaterThan(currentMin, expr)\n \n   override def update(input: Row): Unit = {\n-    if (currentMin == null) {\n-      currentMin = expr.eval(input)\n-    } else if(GreaterThan(Literal(currentMin, expr.dataType), expr).eval(input) == true) {\n-      currentMin = expr.eval(input)\n+    if (currentMin.value == null) {\n+      currentMin.value = expr.eval(input)\n+    } else if(cmp.eval(input) == true) {\n+      currentMin.value = expr.eval(input)",
    "line": 16
  }],
  "prId": 2113
}]