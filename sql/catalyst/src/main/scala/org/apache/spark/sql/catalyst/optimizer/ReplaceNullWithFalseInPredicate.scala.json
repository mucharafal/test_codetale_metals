[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we need this? `And`, `Or`, `If` all return boolean, and we already requires boolean type for literal case.",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T04:26:23Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is\n+ * semantically equivalent to `FalseLiteral` when evaluating the whole search condition.\n+ *\n+ * Please note that FALSE and NULL are not exchangeable in most cases, when the search condition\n+ * contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable\n+ * in very limited cases.\n+ *\n+ * For example, `Filter(Literal(null, BooleanType))` is equal to `Filter(FalseLiteral)`.\n+ *\n+ * Another example containing branches is `Filter(If(cond, FalseLiteral, Literal(null, _)))`;\n+ * this can be optimized to `Filter(If(cond, FalseLiteral, FalseLiteral))`, and eventually\n+ * `Filter(FalseLiteral)`.\n+ *\n+ * Moreover, this rule also transforms predicates in all [[If]] expressions as well as branch\n+ * conditions in all [[CaseWhen]] expressions, even if they are not part of the search conditions.\n+ *\n+ * For example, `Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))` can be simplified\n+ * into `Project(Literal(2))`.\n+ */\n+object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(cond, _) => f.copy(condition = replaceNullWithFalse(cond))\n+    case j @ Join(_, _, _, Some(cond)) => j.copy(condition = Some(replaceNullWithFalse(cond)))\n+    case p: LogicalPlan => p transformExpressions {\n+      case i @ If(pred, _, _) => i.copy(predicate = replaceNullWithFalse(pred))\n+      case cw @ CaseWhen(branches, _) =>\n+        val newBranches = branches.map { case (cond, value) =>\n+          replaceNullWithFalse(cond) -> value\n+        }\n+        cw.copy(branches = newBranches)\n+      case af @ ArrayFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        af.copy(function = newLambda)\n+      case ae @ ArrayExists(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        ae.copy(function = newLambda)\n+      case mf @ MapFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        mf.copy(function = newLambda)\n+    }\n+  }\n+\n+  /**\n+   * Recursively traverse the Boolean-type expression to replace\n+   * `Literal(null, BooleanType)` with `FalseLiteral`, if possible.\n+   *\n+   * Note that `transformExpressionsDown` can not be used here as we must stop as soon as we hit\n+   * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n+   * `Literal(null, BooleanType)`.\n+   */\n+  private def replaceNullWithFalse(e: Expression): Expression = {\n+    if (e.dataType != BooleanType) {"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "How about the LambdaFunction? My major concern is the future changes might forget to add it?",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T04:45:26Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is\n+ * semantically equivalent to `FalseLiteral` when evaluating the whole search condition.\n+ *\n+ * Please note that FALSE and NULL are not exchangeable in most cases, when the search condition\n+ * contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable\n+ * in very limited cases.\n+ *\n+ * For example, `Filter(Literal(null, BooleanType))` is equal to `Filter(FalseLiteral)`.\n+ *\n+ * Another example containing branches is `Filter(If(cond, FalseLiteral, Literal(null, _)))`;\n+ * this can be optimized to `Filter(If(cond, FalseLiteral, FalseLiteral))`, and eventually\n+ * `Filter(FalseLiteral)`.\n+ *\n+ * Moreover, this rule also transforms predicates in all [[If]] expressions as well as branch\n+ * conditions in all [[CaseWhen]] expressions, even if they are not part of the search conditions.\n+ *\n+ * For example, `Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))` can be simplified\n+ * into `Project(Literal(2))`.\n+ */\n+object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(cond, _) => f.copy(condition = replaceNullWithFalse(cond))\n+    case j @ Join(_, _, _, Some(cond)) => j.copy(condition = Some(replaceNullWithFalse(cond)))\n+    case p: LogicalPlan => p transformExpressions {\n+      case i @ If(pred, _, _) => i.copy(predicate = replaceNullWithFalse(pred))\n+      case cw @ CaseWhen(branches, _) =>\n+        val newBranches = branches.map { case (cond, value) =>\n+          replaceNullWithFalse(cond) -> value\n+        }\n+        cw.copy(branches = newBranches)\n+      case af @ ArrayFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        af.copy(function = newLambda)\n+      case ae @ ArrayExists(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        ae.copy(function = newLambda)\n+      case mf @ MapFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        mf.copy(function = newLambda)\n+    }\n+  }\n+\n+  /**\n+   * Recursively traverse the Boolean-type expression to replace\n+   * `Literal(null, BooleanType)` with `FalseLiteral`, if possible.\n+   *\n+   * Note that `transformExpressionsDown` can not be used here as we must stop as soon as we hit\n+   * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n+   * `Literal(null, BooleanType)`.\n+   */\n+  private def replaceNullWithFalse(e: Expression): Expression = {\n+    if (e.dataType != BooleanType) {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "We don't handle `LambdaFunction` inside this method, it's caller side.\r\n\r\nThis method is to deal with optimizable boolean expressions, and return the original expression if it's not: https://github.com/apache/spark/pull/23139/files#diff-0bb4fc0a3c867b855f84dd1db8867139R103",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T07:59:01Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is\n+ * semantically equivalent to `FalseLiteral` when evaluating the whole search condition.\n+ *\n+ * Please note that FALSE and NULL are not exchangeable in most cases, when the search condition\n+ * contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable\n+ * in very limited cases.\n+ *\n+ * For example, `Filter(Literal(null, BooleanType))` is equal to `Filter(FalseLiteral)`.\n+ *\n+ * Another example containing branches is `Filter(If(cond, FalseLiteral, Literal(null, _)))`;\n+ * this can be optimized to `Filter(If(cond, FalseLiteral, FalseLiteral))`, and eventually\n+ * `Filter(FalseLiteral)`.\n+ *\n+ * Moreover, this rule also transforms predicates in all [[If]] expressions as well as branch\n+ * conditions in all [[CaseWhen]] expressions, even if they are not part of the search conditions.\n+ *\n+ * For example, `Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))` can be simplified\n+ * into `Project(Literal(2))`.\n+ */\n+object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(cond, _) => f.copy(condition = replaceNullWithFalse(cond))\n+    case j @ Join(_, _, _, Some(cond)) => j.copy(condition = Some(replaceNullWithFalse(cond)))\n+    case p: LogicalPlan => p transformExpressions {\n+      case i @ If(pred, _, _) => i.copy(predicate = replaceNullWithFalse(pred))\n+      case cw @ CaseWhen(branches, _) =>\n+        val newBranches = branches.map { case (cond, value) =>\n+          replaceNullWithFalse(cond) -> value\n+        }\n+        cw.copy(branches = newBranches)\n+      case af @ ArrayFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        af.copy(function = newLambda)\n+      case ae @ ArrayExists(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        ae.copy(function = newLambda)\n+      case mf @ MapFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        mf.copy(function = newLambda)\n+    }\n+  }\n+\n+  /**\n+   * Recursively traverse the Boolean-type expression to replace\n+   * `Literal(null, BooleanType)` with `FalseLiteral`, if possible.\n+   *\n+   * Note that `transformExpressionsDown` can not be used here as we must stop as soon as we hit\n+   * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n+   * `Literal(null, BooleanType)`.\n+   */\n+  private def replaceNullWithFalse(e: Expression): Expression = {\n+    if (e.dataType != BooleanType) {"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "See this line https://github.com/apache/spark/pull/23139/files/e41681096867cbc6d2556da83ce733092d6df841#diff-a1acb054bc8888376603ef510e6d0ee0\r\n\r\nMy major concern is we should not completely rely on the caller to ensure the data type is Boolean. In the future, the new code changes might not completely follow our current assumption. ",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T08:30:30Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is\n+ * semantically equivalent to `FalseLiteral` when evaluating the whole search condition.\n+ *\n+ * Please note that FALSE and NULL are not exchangeable in most cases, when the search condition\n+ * contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable\n+ * in very limited cases.\n+ *\n+ * For example, `Filter(Literal(null, BooleanType))` is equal to `Filter(FalseLiteral)`.\n+ *\n+ * Another example containing branches is `Filter(If(cond, FalseLiteral, Literal(null, _)))`;\n+ * this can be optimized to `Filter(If(cond, FalseLiteral, FalseLiteral))`, and eventually\n+ * `Filter(FalseLiteral)`.\n+ *\n+ * Moreover, this rule also transforms predicates in all [[If]] expressions as well as branch\n+ * conditions in all [[CaseWhen]] expressions, even if they are not part of the search conditions.\n+ *\n+ * For example, `Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))` can be simplified\n+ * into `Project(Literal(2))`.\n+ */\n+object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(cond, _) => f.copy(condition = replaceNullWithFalse(cond))\n+    case j @ Join(_, _, _, Some(cond)) => j.copy(condition = Some(replaceNullWithFalse(cond)))\n+    case p: LogicalPlan => p transformExpressions {\n+      case i @ If(pred, _, _) => i.copy(predicate = replaceNullWithFalse(pred))\n+      case cw @ CaseWhen(branches, _) =>\n+        val newBranches = branches.map { case (cond, value) =>\n+          replaceNullWithFalse(cond) -> value\n+        }\n+        cw.copy(branches = newBranches)\n+      case af @ ArrayFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        af.copy(function = newLambda)\n+      case ae @ ArrayExists(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        ae.copy(function = newLambda)\n+      case mf @ MapFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        mf.copy(function = newLambda)\n+    }\n+  }\n+\n+  /**\n+   * Recursively traverse the Boolean-type expression to replace\n+   * `Literal(null, BooleanType)` with `FalseLiteral`, if possible.\n+   *\n+   * Note that `transformExpressionsDown` can not be used here as we must stop as soon as we hit\n+   * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n+   * `Literal(null, BooleanType)`.\n+   */\n+  private def replaceNullWithFalse(e: Expression): Expression = {\n+    if (e.dataType != BooleanType) {"
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Had an offline discussion with @rednaxelafx . We can issue an exception instead of silently bypass it. ",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T18:38:43Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is\n+ * semantically equivalent to `FalseLiteral` when evaluating the whole search condition.\n+ *\n+ * Please note that FALSE and NULL are not exchangeable in most cases, when the search condition\n+ * contains NOT and NULL-tolerant expressions. Thus, the rule is very conservative and applicable\n+ * in very limited cases.\n+ *\n+ * For example, `Filter(Literal(null, BooleanType))` is equal to `Filter(FalseLiteral)`.\n+ *\n+ * Another example containing branches is `Filter(If(cond, FalseLiteral, Literal(null, _)))`;\n+ * this can be optimized to `Filter(If(cond, FalseLiteral, FalseLiteral))`, and eventually\n+ * `Filter(FalseLiteral)`.\n+ *\n+ * Moreover, this rule also transforms predicates in all [[If]] expressions as well as branch\n+ * conditions in all [[CaseWhen]] expressions, even if they are not part of the search conditions.\n+ *\n+ * For example, `Project(If(And(cond, Literal(null)), Literal(1), Literal(2)))` can be simplified\n+ * into `Project(Literal(2))`.\n+ */\n+object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(cond, _) => f.copy(condition = replaceNullWithFalse(cond))\n+    case j @ Join(_, _, _, Some(cond)) => j.copy(condition = Some(replaceNullWithFalse(cond)))\n+    case p: LogicalPlan => p transformExpressions {\n+      case i @ If(pred, _, _) => i.copy(predicate = replaceNullWithFalse(pred))\n+      case cw @ CaseWhen(branches, _) =>\n+        val newBranches = branches.map { case (cond, value) =>\n+          replaceNullWithFalse(cond) -> value\n+        }\n+        cw.copy(branches = newBranches)\n+      case af @ ArrayFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        af.copy(function = newLambda)\n+      case ae @ ArrayExists(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        ae.copy(function = newLambda)\n+      case mf @ MapFilter(_, lf @ LambdaFunction(func, _, _)) =>\n+        val newLambda = lf.copy(function = replaceNullWithFalse(func))\n+        mf.copy(function = newLambda)\n+    }\n+  }\n+\n+  /**\n+   * Recursively traverse the Boolean-type expression to replace\n+   * `Literal(null, BooleanType)` with `FalseLiteral`, if possible.\n+   *\n+   * Note that `transformExpressionsDown` can not be used here as we must stop as soon as we hit\n+   * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n+   * `Literal(null, BooleanType)`.\n+   */\n+  private def replaceNullWithFalse(e: Expression): Expression = {\n+    if (e.dataType != BooleanType) {"
  }],
  "prId": 23139
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Test for this? Why not also throw exception in runtime since this should never be hit? ",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T19:29:23Z",
    "diffHunk": "@@ -79,29 +80,31 @@ object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n    * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n    * `Literal(null, BooleanType)`.\n    */\n-  private def replaceNullWithFalse(e: Expression): Expression = {\n-    if (e.dataType != BooleanType) {\n+  private def replaceNullWithFalse(e: Expression): Expression = e match {\n+    case Literal(null, BooleanType) =>\n+      FalseLiteral\n+    case And(left, right) =>\n+      And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case Or(left, right) =>\n+      Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case cw: CaseWhen if cw.dataType == BooleanType =>\n+      val newBranches = cw.branches.map { case (cond, value) =>\n+        replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n+      }\n+      val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n+      CaseWhen(newBranches, newElseValue)\n+    case i @ If(pred, trueVal, falseVal) if i.dataType == BooleanType =>\n+      If(replaceNullWithFalse(pred), replaceNullWithFalse(trueVal), replaceNullWithFalse(falseVal))\n+    case e if e.dataType == BooleanType =>\n       e\n-    } else {\n-      e match {\n-        case Literal(null, BooleanType) =>\n-          FalseLiteral\n-        case And(left, right) =>\n-          And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case Or(left, right) =>\n-          Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case cw: CaseWhen =>\n-          val newBranches = cw.branches.map { case (cond, value) =>\n-            replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n-          }\n-          val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n-          CaseWhen(newBranches, newElseValue)\n-        case If(pred, trueVal, falseVal) =>\n-          If(replaceNullWithFalse(pred),\n-            replaceNullWithFalse(trueVal),\n-            replaceNullWithFalse(falseVal))\n-        case _ => e\n+    case e =>\n+      val message = \"Expected a Boolean type expression in replaceNullWithFalse, \" +\n+        s\"but got the type `${e.dataType.catalogString}` in `${e.sql}`.\"\n+      if (Utils.isTesting) {\n+        throw new IllegalArgumentException(message)",
    "line": 104
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "The tests might not catch all the cases if the test coverage is not complete. Such an exception should not block the query execution. Thus, we just throw an exception in our testing mode instead of the production mode. ",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T22:19:46Z",
    "diffHunk": "@@ -79,29 +80,31 @@ object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n    * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n    * `Literal(null, BooleanType)`.\n    */\n-  private def replaceNullWithFalse(e: Expression): Expression = {\n-    if (e.dataType != BooleanType) {\n+  private def replaceNullWithFalse(e: Expression): Expression = e match {\n+    case Literal(null, BooleanType) =>\n+      FalseLiteral\n+    case And(left, right) =>\n+      And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case Or(left, right) =>\n+      Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case cw: CaseWhen if cw.dataType == BooleanType =>\n+      val newBranches = cw.branches.map { case (cond, value) =>\n+        replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n+      }\n+      val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n+      CaseWhen(newBranches, newElseValue)\n+    case i @ If(pred, trueVal, falseVal) if i.dataType == BooleanType =>\n+      If(replaceNullWithFalse(pred), replaceNullWithFalse(trueVal), replaceNullWithFalse(falseVal))\n+    case e if e.dataType == BooleanType =>\n       e\n-    } else {\n-      e match {\n-        case Literal(null, BooleanType) =>\n-          FalseLiteral\n-        case And(left, right) =>\n-          And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case Or(left, right) =>\n-          Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case cw: CaseWhen =>\n-          val newBranches = cw.branches.map { case (cond, value) =>\n-            replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n-          }\n-          val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n-          CaseWhen(newBranches, newElseValue)\n-        case If(pred, trueVal, falseVal) =>\n-          If(replaceNullWithFalse(pred),\n-            replaceNullWithFalse(trueVal),\n-            replaceNullWithFalse(falseVal))\n-        case _ => e\n+    case e =>\n+      val message = \"Expected a Boolean type expression in replaceNullWithFalse, \" +\n+        s\"but got the type `${e.dataType.catalogString}` in `${e.sql}`.\"\n+      if (Utils.isTesting) {\n+        throw new IllegalArgumentException(message)",
    "line": 104
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "Added a test case.",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T22:42:30Z",
    "diffHunk": "@@ -79,29 +80,31 @@ object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n    * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n    * `Literal(null, BooleanType)`.\n    */\n-  private def replaceNullWithFalse(e: Expression): Expression = {\n-    if (e.dataType != BooleanType) {\n+  private def replaceNullWithFalse(e: Expression): Expression = e match {\n+    case Literal(null, BooleanType) =>\n+      FalseLiteral\n+    case And(left, right) =>\n+      And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case Or(left, right) =>\n+      Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case cw: CaseWhen if cw.dataType == BooleanType =>\n+      val newBranches = cw.branches.map { case (cond, value) =>\n+        replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n+      }\n+      val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n+      CaseWhen(newBranches, newElseValue)\n+    case i @ If(pred, trueVal, falseVal) if i.dataType == BooleanType =>\n+      If(replaceNullWithFalse(pred), replaceNullWithFalse(trueVal), replaceNullWithFalse(falseVal))\n+    case e if e.dataType == BooleanType =>\n       e\n-    } else {\n-      e match {\n-        case Literal(null, BooleanType) =>\n-          FalseLiteral\n-        case And(left, right) =>\n-          And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case Or(left, right) =>\n-          Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case cw: CaseWhen =>\n-          val newBranches = cw.branches.map { case (cond, value) =>\n-            replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n-          }\n-          val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n-          CaseWhen(newBranches, newElseValue)\n-        case If(pred, trueVal, falseVal) =>\n-          If(replaceNullWithFalse(pred),\n-            replaceNullWithFalse(trueVal),\n-            replaceNullWithFalse(falseVal))\n-        case _ => e\n+    case e =>\n+      val message = \"Expected a Boolean type expression in replaceNullWithFalse, \" +\n+        s\"but got the type `${e.dataType.catalogString}` in `${e.sql}`.\"\n+      if (Utils.isTesting) {\n+        throw new IllegalArgumentException(message)",
    "line": 104
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "Sounds fair.",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T23:10:04Z",
    "diffHunk": "@@ -79,29 +80,31 @@ object ReplaceNullWithFalseInPredicate extends Rule[LogicalPlan] {\n    * an expression that is not [[CaseWhen]], [[If]], [[And]], [[Or]] or\n    * `Literal(null, BooleanType)`.\n    */\n-  private def replaceNullWithFalse(e: Expression): Expression = {\n-    if (e.dataType != BooleanType) {\n+  private def replaceNullWithFalse(e: Expression): Expression = e match {\n+    case Literal(null, BooleanType) =>\n+      FalseLiteral\n+    case And(left, right) =>\n+      And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case Or(left, right) =>\n+      Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n+    case cw: CaseWhen if cw.dataType == BooleanType =>\n+      val newBranches = cw.branches.map { case (cond, value) =>\n+        replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n+      }\n+      val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n+      CaseWhen(newBranches, newElseValue)\n+    case i @ If(pred, trueVal, falseVal) if i.dataType == BooleanType =>\n+      If(replaceNullWithFalse(pred), replaceNullWithFalse(trueVal), replaceNullWithFalse(falseVal))\n+    case e if e.dataType == BooleanType =>\n       e\n-    } else {\n-      e match {\n-        case Literal(null, BooleanType) =>\n-          FalseLiteral\n-        case And(left, right) =>\n-          And(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case Or(left, right) =>\n-          Or(replaceNullWithFalse(left), replaceNullWithFalse(right))\n-        case cw: CaseWhen =>\n-          val newBranches = cw.branches.map { case (cond, value) =>\n-            replaceNullWithFalse(cond) -> replaceNullWithFalse(value)\n-          }\n-          val newElseValue = cw.elseValue.map(replaceNullWithFalse)\n-          CaseWhen(newBranches, newElseValue)\n-        case If(pred, trueVal, falseVal) =>\n-          If(replaceNullWithFalse(pred),\n-            replaceNullWithFalse(trueVal),\n-            replaceNullWithFalse(falseVal))\n-        case _ => e\n+    case e =>\n+      val message = \"Expected a Boolean type expression in replaceNullWithFalse, \" +\n+        s\"but got the type `${e.dataType.catalogString}` in `${e.sql}`.\"\n+      if (Utils.isTesting) {\n+        throw new IllegalArgumentException(message)",
    "line": 104
  }],
  "prId": 23139
}, {
  "comments": [{
    "author": {
      "login": "aokolnychyi"
    },
    "body": "I think the scope of this rule is a bit bigger. For example, some higher-order functions, conditions of all `If` and `CaseWhen` expressions. Would it make sense to replace `\"in the search condition of the WHERE/HAVING/ON(JOIN) clauses\"` with `\"in predicates\"`?",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T23:23:25Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator",
    "line": 31
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "The extra scope is covered by \"Moreover, ...\"",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T23:28:24Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator",
    "line": 31
  }],
  "prId": 23139
}, {
  "comments": [{
    "author": {
      "login": "aokolnychyi"
    },
    "body": "I am not sure I understand `\"which contain an implicit Boolean operator \"(search condition) = TRUE\"\"`. Could you, please, elaborate a bit?",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T23:25:22Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is",
    "line": 32
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "This is based on the ANSI SQL. All these clauses have the implicit Boolean operator \"(search condition) = TRUE\". That is why NULL and FALSE do not satisfy the condition in these clauses",
    "commit": "8b0401c4440136e33d4580a3f8da80164de3d4b4",
    "createdAt": "2018-11-26T23:29:43Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{And, ArrayExists, ArrayFilter, CaseWhen, Expression, If}\n+import org.apache.spark.sql.catalyst.expressions.{LambdaFunction, Literal, MapFilter, Or}\n+import org.apache.spark.sql.catalyst.expressions.Literal.FalseLiteral\n+import org.apache.spark.sql.catalyst.plans.logical.{Filter, Join, LogicalPlan}\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.types.BooleanType\n+import org.apache.spark.util.Utils\n+\n+\n+/**\n+ * A rule that replaces `Literal(null, BooleanType)` with `FalseLiteral`, if possible, in the search\n+ * condition of the WHERE/HAVING/ON(JOIN) clauses, which contain an implicit Boolean operator\n+ * \"(search condition) = TRUE\". The replacement is only valid when `Literal(null, BooleanType)` is",
    "line": 32
  }],
  "prId": 23139
}]