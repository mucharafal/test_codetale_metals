[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i'm sort of confused - why is this needed?\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T02:48:15Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {\n+    g match {\n+      case _: StructGetField => Some((g.child, null))\n+      case o: OrdinalGetField => Some((o.child, o.ordinal))\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * find the ordinal of StructField, report error if no desired field or over one\n+   * desired fields are found.\n+   */\n+  private def findField(fields: Array[StructField], fieldName: String, resolver: Resolver): Int = {\n+    val checkField = (f: StructField) => resolver(f.name, fieldName)\n+    val ordinal = fields.indexWhere(checkField)\n+    if (ordinal == -1) {\n+      throw new AnalysisException(\n+        s\"No such struct field $fieldName in ${fields.map(_.name).mkString(\", \")}\")\n+    } else if (fields.indexWhere(checkField, ordinal + 1) != -1) {\n+      throw new AnalysisException(\n+        s\"Ambiguous reference to fields ${fields.filter(checkField).mkString(\", \")}\")\n+    } else {\n+      ordinal\n+    }\n+  }\n+}\n+\n+trait GetField extends UnaryExpression {\n+  self: Product =>\n+\n+  type EvaluatedType = Any\n+}\n+\n+abstract class StructGetField extends GetField {\n+  self: Product =>\n+\n+  def field: StructField\n+\n+  override def foldable: Boolean = child.foldable\n+  override def toString: String = s\"$child.${field.name}\"\n+}\n+\n+abstract class OrdinalGetField extends GetField {\n+  self: Product =>\n+\n+  def ordinal: Expression\n+\n+  /** `Null` is returned for invalid ordinals. */\n+  override def nullable: Boolean = true\n+  override def foldable: Boolean = child.foldable && ordinal.foldable\n+  override def toString: String = s\"$child[$ordinal]\"\n+  override def children: Seq[Expression] = child :: ordinal :: Nil\n+\n+  override def eval(input: Row): Any = {\n+    val value = child.eval(input)\n+    if (value == null) {\n+      null\n+    } else {\n+      val o = ordinal.eval(input)\n+      if (o == null) {\n+        null\n+      } else {\n+        evalNotNull(value, o)\n+      }\n+    }\n+  }\n+\n+  protected def evalNotNull(value: Any, ordinal: Any): Any\n+}\n+\n+/**\n+ * Returns the value of fields in the Struct `child`.\n+ */\n+case class SimpleStructGetField(child: Expression, field: StructField, ordinal: Int)\n+  extends StructGetField {\n+\n+  override def dataType: DataType = field.dataType\n+  override def nullable: Boolean = child.nullable || field.nullable\n+\n+  override def eval(input: Row): Any = {\n+    val baseValue = child.eval(input).asInstanceOf[Row]\n+    if (baseValue == null) null else baseValue(ordinal)\n+  }\n+}\n+\n+/**\n+ * Returns the array of value of fields in the Array of Struct `child`.\n+ */\n+case class ArrayStructGetField("
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "see https://issues.apache.org/jira/browse/SPARK-2096.\n\"arrayOfStruct.field1\" means to access all values of \"field1\" in this array of structs and the returns those values as an array.\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T03:51:01Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {\n+    g match {\n+      case _: StructGetField => Some((g.child, null))\n+      case o: OrdinalGetField => Some((o.child, o.ordinal))\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * find the ordinal of StructField, report error if no desired field or over one\n+   * desired fields are found.\n+   */\n+  private def findField(fields: Array[StructField], fieldName: String, resolver: Resolver): Int = {\n+    val checkField = (f: StructField) => resolver(f.name, fieldName)\n+    val ordinal = fields.indexWhere(checkField)\n+    if (ordinal == -1) {\n+      throw new AnalysisException(\n+        s\"No such struct field $fieldName in ${fields.map(_.name).mkString(\", \")}\")\n+    } else if (fields.indexWhere(checkField, ordinal + 1) != -1) {\n+      throw new AnalysisException(\n+        s\"Ambiguous reference to fields ${fields.filter(checkField).mkString(\", \")}\")\n+    } else {\n+      ordinal\n+    }\n+  }\n+}\n+\n+trait GetField extends UnaryExpression {\n+  self: Product =>\n+\n+  type EvaluatedType = Any\n+}\n+\n+abstract class StructGetField extends GetField {\n+  self: Product =>\n+\n+  def field: StructField\n+\n+  override def foldable: Boolean = child.foldable\n+  override def toString: String = s\"$child.${field.name}\"\n+}\n+\n+abstract class OrdinalGetField extends GetField {\n+  self: Product =>\n+\n+  def ordinal: Expression\n+\n+  /** `Null` is returned for invalid ordinals. */\n+  override def nullable: Boolean = true\n+  override def foldable: Boolean = child.foldable && ordinal.foldable\n+  override def toString: String = s\"$child[$ordinal]\"\n+  override def children: Seq[Expression] = child :: ordinal :: Nil\n+\n+  override def eval(input: Row): Any = {\n+    val value = child.eval(input)\n+    if (value == null) {\n+      null\n+    } else {\n+      val o = ordinal.eval(input)\n+      if (o == null) {\n+        null\n+      } else {\n+        evalNotNull(value, o)\n+      }\n+    }\n+  }\n+\n+  protected def evalNotNull(value: Any, ordinal: Any): Any\n+}\n+\n+/**\n+ * Returns the value of fields in the Struct `child`.\n+ */\n+case class SimpleStructGetField(child: Expression, field: StructField, ordinal: Int)\n+  extends StructGetField {\n+\n+  override def dataType: DataType = field.dataType\n+  override def nullable: Boolean = child.nullable || field.nullable\n+\n+  override def eval(input: Row): Any = {\n+    val baseValue = child.eval(input).asInstanceOf[Row]\n+    if (baseValue == null) null else baseValue(ordinal)\n+  }\n+}\n+\n+/**\n+ * Returns the array of value of fields in the Array of Struct `child`.\n+ */\n+case class ArrayStructGetField("
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "I think we'd want a more friendly error message for the end user of SQL / data frames. I don't think know much about GetField, which is an internal concept.\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:40:47Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "one way I can think of to make the error messages more friendly is to specialize it for each child.datatype. \n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:44:12Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +"
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "we should document the logic here, i.e. in what case do we use which.\n\nThe code is still somewhat harder to read.\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:42:54Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply("
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "what is the unapply semantics?\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:44:38Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "The semantics is to return expressions the `GetField` have, it's used in [Optimizer](https://github.com/apache/spark/blob/master/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/Optimizer.scala#L228-L231)\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:51:22Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {"
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "uppercase Find\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:48:32Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {\n+    g match {\n+      case _: StructGetField => Some((g.child, null))\n+      case o: OrdinalGetField => Some((o.child, o.ordinal))\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * find the ordinal of StructField, report error if no desired field or over one"
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maybe we can remove this? I don't see a lot of benefits of having a common parent type for these 2 classes. On the contrary it makes the type hierarchy fairly complicated.\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-04-29T07:53:38Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {\n+  /**\n+   * Returns the resolved `GetField`. It will return one kind of concrete `GetField`,\n+   * depend on the type of `child` and `fieldExpr`.\n+   */\n+  def apply(\n+      child: Expression,\n+      fieldExpr: Expression,\n+      resolver: Resolver): GetField = {\n+\n+    (child.dataType, fieldExpr) match {\n+      case (StructType(fields), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        SimpleStructGetField(child, fields(ordinal), ordinal)\n+      case (ArrayType(StructType(fields), containsNull), Literal(fieldName, StringType)) =>\n+        val ordinal = findField(fields, fieldName.toString, resolver)\n+        ArrayStructGetField(child, fields(ordinal), ordinal, containsNull)\n+      case (_: ArrayType, _) if fieldExpr.dataType.isInstanceOf[IntegralType]  =>\n+        ArrayOrdinalGetField(child, fieldExpr)\n+      case (_: MapType, _) =>\n+        MapOrdinalGetField(child, fieldExpr)\n+      case (otherType, _) =>\n+        throw new AnalysisException(\n+          \"GetField is not valid on child of type \" +\n+            s\"$otherType with fieldExpr of type ${fieldExpr.dataType}\")\n+    }\n+  }\n+\n+  def unapply(g: GetField): Option[(Expression, Expression)] = {\n+    g match {\n+      case _: StructGetField => Some((g.child, null))\n+      case o: OrdinalGetField => Some((o.child, o.ordinal))\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * find the ordinal of StructField, report error if no desired field or over one\n+   * desired fields are found.\n+   */\n+  private def findField(fields: Array[StructField], fieldName: String, resolver: Resolver): Int = {\n+    val checkField = (f: StructField) => resolver(f.name, fieldName)\n+    val ordinal = fields.indexWhere(checkField)\n+    if (ordinal == -1) {\n+      throw new AnalysisException(\n+        s\"No such struct field $fieldName in ${fields.map(_.name).mkString(\", \")}\")\n+    } else if (fields.indexWhere(checkField, ordinal + 1) != -1) {\n+      throw new AnalysisException(\n+        s\"Ambiguous reference to fields ${fields.filter(checkField).mkString(\", \")}\")\n+    } else {\n+      ordinal\n+    }\n+  }\n+}\n+\n+trait GetField extends UnaryExpression {\n+  self: Product =>\n+\n+  type EvaluatedType = Any\n+}\n+\n+abstract class StructGetField extends GetField {"
  }],
  "prId": 5744
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "I have some naming suggestions here:\n- `(Unresolved)GetField` => `(Unresolved)ExtractValue`\n- `SimpleStructGetField` => `GetStructField`\n- `ArrayStructGetField` => `MapStructArray`?\n- `ArrayOrdinalGetField` => `GetArrayItem`\n- `MapOrdinalGetField` => `GetMapValue`\n",
    "commit": "715c5899d5d6d4982cccff0fc9b3f0726369da70",
    "createdAt": "2015-05-07T21:29:11Z",
    "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.Map\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis._\n+import org.apache.spark.sql.types._\n+\n+object GetField {"
  }],
  "prId": 5744
}]