[{
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "We cannot always share a function for non-deterministic cases? e.g.,\r\n```\r\nint subExpr1 = input[0] + random();\r\nint subExpr2 = input[1] + random();\r\n=>\r\nint subExpr1 = subExpr(input[0]);\r\nint subExpr2 = subExpr(input[1]);\r\n\r\nint subExpr(int v) { return v + random(); }\r\n```",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T05:28:09Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {",
    "line": 74
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Non-deterministic expressions can't do sub-expression elimination.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T05:40:45Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {",
    "line": 74
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "oh, I see.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T05:46:57Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {",
    "line": 74
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "btw, this idea is limited to common subexprs? For example, the idea can cover a case like;\r\n```\r\nselect sum(a + b), sum(b + c), sum(c + d), sum(d + e) from values (1, 1, 1, 1, 1) t(a, b, c, d, e)\r\n```\r\n?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T06:26:36Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {",
    "line": 74
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "It is probably suitable. Only if we want these functions sum(a+b)...etc. to be called in split functions. Their inputs can be parameterized.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T16:05:34Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {",
    "line": 74
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "nit: `boundInput` -> `ordinal`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T08:07:56Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b\n+      }\n+\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val parameterLength = CodeGenerator.calculateParamLength(refs.map(_ => Literal(0))) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val parameterizedExpr = parameterizedBoundReferences(ctx, expr)\n+\n+        val e: StructuralExpr = StructuralExpr(parameterizedExpr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Replaces bound references in given expression by parameterized bound references.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def parameterizedBoundReferences(ctx: CodegenContext, expr: Expression): Expression = {\n+    expr.transformUp {\n+      case b: BoundReference =>\n+        val param = ctx.freshName(\"boundInput\")"
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "We cannot do it like `!skip && !addStructExpr(expr, exprMap)` in the same way with `addExprTree`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T08:09:28Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b\n+      }\n+\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val parameterLength = CodeGenerator.calculateParamLength(refs.map(_ => Literal(0))) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val parameterizedExpr = parameterizedBoundReferences(ctx, expr)\n+\n+        val e: StructuralExpr = StructuralExpr(parameterizedExpr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Replaces bound references in given expression by parameterized bound references.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def parameterizedBoundReferences(ctx: CodegenContext, expr: Expression): Expression = {\n+    expr.transformUp {\n+      case b: BoundReference =>\n+        val param = ctx.freshName(\"boundInput\")\n+        ParameterizedBoundReference(param, b.dataType, b.nullable)\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n+   */\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively.  Stops if a matching expression\n+   * is found.\n+   */\n+  def addStructuralExprTree(ctx: CodegenContext, expr: Expression): Unit = {\n+    val skip = skipExpr(expr)\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Well, this also recursively adds children if the parent expr was added. I tested with adding or not in prototyping this. Adding children saves more code text.\r\n",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T20:20:29Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b\n+      }\n+\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val parameterLength = CodeGenerator.calculateParamLength(refs.map(_ => Literal(0))) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val parameterizedExpr = parameterizedBoundReferences(ctx, expr)\n+\n+        val e: StructuralExpr = StructuralExpr(parameterizedExpr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Replaces bound references in given expression by parameterized bound references.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def parameterizedBoundReferences(ctx: CodegenContext, expr: Expression): Expression = {\n+    expr.transformUp {\n+      case b: BoundReference =>\n+        val param = ctx.freshName(\"boundInput\")\n+        ParameterizedBoundReference(param, b.dataType, b.nullable)\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n+   */\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively.  Stops if a matching expression\n+   * is found.\n+   */\n+  def addStructuralExprTree(ctx: CodegenContext, expr: Expression): Unit = {\n+    val skip = skipExpr(expr)\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip) {"
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "To avoid unnecessary plan copys, we can check this equality based on `BoundReference` (by just copying it like `b.copy(ordinal = 0 or -1?)`)? IIUC its ok to replace `BoundReference` with `ParameterizedBoundReference` just when generating code in https://github.com/apache/spark/pull/25717/files#diff-8bcc5aea39c73d4bf38aef6f6951d42cR1117?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T08:13:03Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Isn't b.copy also copying the input expr?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-09T23:43:53Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Ah, I see. But, if we write it like this (https://github.com/apache/spark/commit/c1c5052902641d0cabc0a74f1556f01d3b2f4234), we don't need to pass `CodegenContext` into `EquivalentExpressions`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-14T01:19:43Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. looks good.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-14T17:16:56Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I just modified like this way, but it failed HashAggregationQuerySuite in jenkins and local.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-14T19:04:27Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I think I figured why. Made another commit.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-14T22:45:19Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "The current one looks super good to me. Thanks!",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-14T23:40:29Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>"
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "nit: `case b: BoundReference => Literal(0)`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T09:00:14Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b"
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "If the length goes over the limit, the current logic gives up eliminating common exprs? If so, can we fall back into the non-structural mode?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T09:14:33Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b\n+      }\n+\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val parameterLength = CodeGenerator.calculateParamLength(refs.map(_ => Literal(0))) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {",
    "line": 84
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Good idea.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T16:06:20Z",
    "diffHunk": "@@ -65,35 +89,102 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive.\n+   */\n+  def addStructExpr(ctx: CodegenContext, expr: Expression): Unit = {\n+    if (expr.deterministic) {\n+      val refs = expr.collect {\n+        case b: BoundReference => b\n+      }\n+\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val parameterLength = CodeGenerator.calculateParamLength(refs.map(_ => Literal(0))) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {",
    "line": 84
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "maropu"
    },
    "body": "Naturally thinking from the comment, I thought the type's `mutable.HashMap.empty[StructuralExpr, mutable.ArrayBuffer[Expression]]`. Is  the value `EquivalenceMap` because you reuse the existing logic?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T09:32:35Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>\n+          b.copy(parameter = \"\")\n+      }\n+    }\n+    override def equals(o: Any): Boolean = o match {\n+      case other: StructuralExpr =>\n+        normalized(e).semanticEquals(normalized(other.e))\n+      case _ => false\n+    }\n+\n+    override def hashCode: Int = normalized(e).semanticHash()\n+  }\n+\n+  type EquivalenceMap = mutable.HashMap[Expr, mutable.ArrayBuffer[Expression]]\n+\n   // For each expression, the set of equivalent expressions.\n   private val equivalenceMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n \n+  // For each expression, the set of structurally equivalent expressions.\n+  private val structEquivalenceMap = mutable.HashMap.empty[StructuralExpr, EquivalenceMap]",
    "line": 41
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Among expressions with same structure, there are still different sub-set of expressions which are semantically different to each others. I need the EquivalenceMap here to distinguish them. ",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T20:16:11Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>\n+          b.copy(parameter = \"\")\n+      }\n+    }\n+    override def equals(o: Any): Boolean = o match {\n+      case other: StructuralExpr =>\n+        normalized(e).semanticEquals(normalized(other.e))\n+      case _ => false\n+    }\n+\n+    override def hashCode: Int = normalized(e).semanticHash()\n+  }\n+\n+  type EquivalenceMap = mutable.HashMap[Expr, mutable.ArrayBuffer[Expression]]\n+\n   // For each expression, the set of equivalent expressions.\n   private val equivalenceMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n \n+  // For each expression, the set of structurally equivalent expressions.\n+  private val structEquivalenceMap = mutable.HashMap.empty[StructuralExpr, EquivalenceMap]",
    "line": 41
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "Yea, it looks ok. So, could you update the comment to describe more?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-08T22:42:56Z",
    "diffHunk": "@@ -40,23 +40,47 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: ParameterizedBoundReference =>\n+          b.copy(parameter = \"\")\n+      }\n+    }\n+    override def equals(o: Any): Boolean = o match {\n+      case other: StructuralExpr =>\n+        normalized(e).semanticEquals(normalized(other.e))\n+      case _ => false\n+    }\n+\n+    override def hashCode: Int = normalized(e).semanticHash()\n+  }\n+\n+  type EquivalenceMap = mutable.HashMap[Expr, mutable.ArrayBuffer[Expression]]\n+\n   // For each expression, the set of equivalent expressions.\n   private val equivalenceMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n \n+  // For each expression, the set of structurally equivalent expressions.\n+  private val structEquivalenceMap = mutable.HashMap.empty[StructuralExpr, EquivalenceMap]",
    "line": 41
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "nit: Do we need ` = this.equivalenceMap`? It seems that all of the callers pass two arguments.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T03:26:06Z",
    "diffHunk": "@@ -40,23 +40,50 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: BoundReference =>\n+          b.copy(ordinal = -1)\n+      }\n+    }\n+    override def equals(o: Any): Boolean = o match {\n+      case other: StructuralExpr =>\n+        normalized(e).semanticEquals(normalized(other.e))\n+      case _ => false\n+    }\n+\n+    override def hashCode: Int = normalized(e).semanticHash()\n+  }\n+\n+  type EquivalenceMap = mutable.HashMap[Expr, mutable.ArrayBuffer[Expression]]\n+\n   // For each expression, the set of equivalent expressions.\n   private val equivalenceMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n \n+  // For each expression, the set of structurally equivalent expressions.\n+  // Among expressions with same structure, there are different sub-set of expressions\n+  // which are semantically different to each others. Thus, under each key, the value is\n+  // the map structure used to do semantically sub-expression elimination.\n+  private val structEquivalenceMap = mutable.HashMap.empty[StructuralExpr, EquivalenceMap]\n+\n   /**\n    * Adds each expression to this data structure, grouping them with existing equivalent\n    * expressions. Non-recursive.\n    * Returns true if there was already a matching expression.\n    */\n-  def addExpr(expr: Expression): Boolean = {\n+  def addExpr(expr: Expression, exprMap: EquivalenceMap = this.equivalenceMap): Boolean = {",
    "line": 49
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "addExpr is also used at PhysicalAggregation:\r\n\r\nhttps://github.com/apache/spark/blob/2f3997fddca44a89b3b8e8b9cc114e26ee4c1d39/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/planning/patterns.scala#L222-L229",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T20:23:47Z",
    "diffHunk": "@@ -40,23 +40,50 @@ class EquivalentExpressions {\n     override def hashCode: Int = e.semanticHash()\n   }\n \n+  /**\n+   * Wrapper around an Expression that provides structural semantic equality.\n+   */\n+  case class StructuralExpr(e: Expression) {\n+    def normalized(expr: Expression): Expression = {\n+      expr.transformUp {\n+        case b: BoundReference =>\n+          b.copy(ordinal = -1)\n+      }\n+    }\n+    override def equals(o: Any): Boolean = o match {\n+      case other: StructuralExpr =>\n+        normalized(e).semanticEquals(normalized(other.e))\n+      case _ => false\n+    }\n+\n+    override def hashCode: Int = normalized(e).semanticHash()\n+  }\n+\n+  type EquivalenceMap = mutable.HashMap[Expr, mutable.ArrayBuffer[Expression]]\n+\n   // For each expression, the set of equivalent expressions.\n   private val equivalenceMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n \n+  // For each expression, the set of structurally equivalent expressions.\n+  // Among expressions with same structure, there are different sub-set of expressions\n+  // which are semantically different to each others. Thus, under each key, the value is\n+  // the map structure used to do semantically sub-expression elimination.\n+  private val structEquivalenceMap = mutable.HashMap.empty[StructuralExpr, EquivalenceMap]\n+\n   /**\n    * Adds each expression to this data structure, grouping them with existing equivalent\n    * expressions. Non-recursive.\n    * Returns true if there was already a matching expression.\n    */\n-  def addExpr(expr: Expression): Boolean = {\n+  def addExpr(expr: Expression, exprMap: EquivalenceMap = this.equivalenceMap): Boolean = {",
    "line": 49
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "nit: Do we need some words for `SortPrefix`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T03:35:39Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.",
    "line": 125
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "These words are copied from previous place. Let me add one for it.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T20:26:42Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.",
    "line": 125
  }],
  "prId": 25717
}, {
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "nit: do we want to add `(_)`?",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T03:41:52Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively. Returns false if this doesn't add\n+   * the input expression actually.\n+   */\n+  def addStructuralExprTree(expr: Expression): Boolean = {\n+    val skip = skipExpr(expr) || expr.isInstanceOf[CodegenFallback]\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip && addStructExpr(expr)) {\n+      childrenToRecurse(expr).foreach(addStructuralExprTree)",
    "line": 176
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "addExprTree doesn't add (_) too. Just followed it. If no special reason, I will leave it.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-16T20:27:32Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively. Returns false if this doesn't add\n+   * the input expression actually.\n+   */\n+  def addStructuralExprTree(expr: Expression): Boolean = {\n+    val skip = skipExpr(expr) || expr.isInstanceOf[CodegenFallback]\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip && addStructExpr(expr)) {\n+      childrenToRecurse(expr).foreach(addStructuralExprTree)",
    "line": 176
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I am neutral on this.   \r\nI was curious why [this line](https://github.com/apache/spark/pull/25717/files#diff-8bcc5aea39c73d4bf38aef6f6951d42cR1042) added `(_)`, but here does not add.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-17T08:52:02Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively. Returns false if this doesn't add\n+   * the input expression actually.\n+   */\n+  def addStructuralExprTree(expr: Expression): Boolean = {\n+    val skip = skipExpr(expr) || expr.isInstanceOf[CodegenFallback]\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip && addStructExpr(expr)) {\n+      childrenToRecurse(expr).foreach(addStructuralExprTree)",
    "line": 176
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "At that line, if not add a (_) to call addExprTree, will see compilation error:\r\n\r\n```\r\n[error]  found   : (org.apache.spark.sql.catalyst.expressions.Expression, equivalentExpressions.EquivalenceMap) => Unit                                                               \r\n[error]     (which expands to)  (org.apache.spark.sql.catalyst.expressions.Expression, scala.collection.mutable.HashMap[equivalentExpressions.Expr,scala.collection.mutable.ArrayBuff$r[org.apache.spark.sql.catalyst.expressions.Expression]]) => Unit                                                                                                                     \r\n[error]  required: org.apache.spark.sql.catalyst.expressions.Expression => ?               \r\n[error]     expressions.foreach(equivalentExpressions.addExprTree)     \r\n[error]                                               ^                                                                                                                               \r\n```\r\n\r\nBecause addExprTree actually needs to arguments, it doesn't match foreach's argument type.",
    "commit": "4700b89004380e48ed484311018686856df3027e",
    "createdAt": "2019-09-17T20:04:52Z",
    "diffHunk": "@@ -65,35 +92,96 @@ class EquivalentExpressions {\n   }\n \n   /**\n-   * Adds the expression to this data structure recursively. Stops if a matching expression\n-   * is found. That is, if `expr` has already been added, its children are not added.\n+   * Adds each expression to structural expression data structure, grouping them with existing\n+   * structurally equivalent expressions. Non-recursive. Returns false if this doesn't add input\n+   * expression actually.\n+   */\n+  def addStructExpr(expr: Expression): Boolean = {\n+    if (expr.deterministic) {\n+      // For structural equivalent expressions, we need to pass in int type ordinals into\n+      // split functions. If the number of ordinals is more than JVM function limit, we skip\n+      // this expression.\n+      // We calculate function parameter length by the number of ints plus `INPUT_ROW` plus\n+      // a int type result array index.\n+      val refs = expr.collect {\n+        case _: BoundReference => Literal(0)\n+      }\n+      val parameterLength = CodeGenerator.calculateParamLength(refs) + 2\n+      if (CodeGenerator.isValidParamLength(parameterLength)) {\n+        val e: StructuralExpr = StructuralExpr(expr)\n+        val f = structEquivalenceMap.get(e)\n+        if (f.isDefined) {\n+          addExpr(expr, f.get)\n+        } else {\n+          val exprMap = mutable.HashMap.empty[Expr, mutable.ArrayBuffer[Expression]]\n+          addExpr(expr, exprMap)\n+          structEquivalenceMap.put(e, exprMap)\n+        }\n+        true\n+      } else {\n+        false\n+      }\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Checks if we skip add sub-expressions for given expression.\n    */\n-  def addExprTree(expr: Expression): Unit = {\n-    val skip = expr.isInstanceOf[LeafExpression] ||\n+  private def skipExpr(expr: Expression): Boolean = {\n+    expr.isInstanceOf[LeafExpression] ||\n       // `LambdaVariable` is usually used as a loop variable, which can't be evaluated ahead of the\n       // loop. So we can't evaluate sub-expressions containing `LambdaVariable` at the beginning.\n       expr.find(_.isInstanceOf[LambdaVariable]).isDefined\n+  }\n+\n+\n+  // There are some special expressions that we should not recurse into all of its children.\n+  //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n+  //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n+  //          false expressions in `If` may not get accessed, according to the predicate\n+  //          expression. We should only recurse into the predicate expression.\n+  //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n+  //                condition. We should only recurse into the first condition expression as it\n+  //                will always get accessed.\n+  //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n+  //                children, because others may not get accessed.\n+  private def childrenToRecurse(expr: Expression): Seq[Expression] = expr match {\n+    case _: CodegenFallback => Nil\n+    case i: If => i.predicate :: Nil\n+    case c: CaseWhen => c.children.head :: Nil\n+    case c: Coalesce => c.children.head :: Nil\n+    case s: SortPrefix => s.child.child :: Nil\n+    case other => other.children\n+  }\n+\n+  /**\n+   * Adds the expression to this data structure recursively. Stops if a matching expression\n+   * is found. That is, if `expr` has already been added, its children are not added.\n+   */\n+  def addExprTree(\n+      expr: Expression,\n+      exprMap: EquivalenceMap = this.equivalenceMap): Unit = {\n+    val skip = skipExpr(expr)\n \n-    // There are some special expressions that we should not recurse into all of its children.\n-    //   1. CodegenFallback: it's children will not be used to generate code (call eval() instead)\n-    //   2. If: common subexpressions will always be evaluated at the beginning, but the true and\n-    //          false expressions in `If` may not get accessed, according to the predicate\n-    //          expression. We should only recurse into the predicate expression.\n-    //   3. CaseWhen: like `If`, the children of `CaseWhen` only get accessed in a certain\n-    //                condition. We should only recurse into the first condition expression as it\n-    //                will always get accessed.\n-    //   4. Coalesce: it's also a conditional expression, we should only recurse into the first\n-    //                children, because others may not get accessed.\n-    def childrenToRecurse: Seq[Expression] = expr match {\n-      case _: CodegenFallback => Nil\n-      case i: If => i.predicate :: Nil\n-      case c: CaseWhen => c.children.head :: Nil\n-      case c: Coalesce => c.children.head :: Nil\n-      case other => other.children\n+    if (!skip && !addExpr(expr, exprMap)) {\n+      childrenToRecurse(expr).foreach(addExprTree(_, exprMap))\n     }\n+  }\n+\n+  /**\n+   * Adds the expression to structural data structure recursively. Returns false if this doesn't add\n+   * the input expression actually.\n+   */\n+  def addStructuralExprTree(expr: Expression): Boolean = {\n+    val skip = skipExpr(expr) || expr.isInstanceOf[CodegenFallback]\n \n-    if (!skip && !addExpr(expr)) {\n-      childrenToRecurse.foreach(addExprTree)\n+    if (!skip && addStructExpr(expr)) {\n+      childrenToRecurse(expr).foreach(addStructuralExprTree)",
    "line": 176
  }],
  "prId": 25717
}]