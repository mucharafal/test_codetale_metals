[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Is this really the right thing to do?  I think we are going to NPE execution.  If anything I think we'd want to null out all the columns, though I'm not sure we need to handle this case at all.\n",
    "commit": "4551a921286437b2c3bb7c0d2194eb2da5db98cd",
    "createdAt": "2015-10-21T18:02:46Z",
    "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.encoders\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen.{GenerateSafeProjection, GenerateUnsafeProjection}\n+import org.apache.spark.sql.catalyst.plans.logical.{LocalRelation, Project}\n+import org.apache.spark.sql.types.{ObjectType, StructType}\n+\n+/**\n+ * A generic encoder for JVM objects.\n+ *\n+ * @param schema The schema after converting `T` to a Spark SQL row.\n+ * @param extractExpressions A set of expressions, one for each top-level field that can be used to\n+ *                           extract the values from a raw object.\n+ * @param clsTag A classtag for `T`.\n+ */\n+case class ClassEncoder[T](\n+    schema: StructType,\n+    extractExpressions: Seq[Expression],\n+    constructExpression: Expression,\n+    clsTag: ClassTag[T])\n+  extends Encoder[T] {\n+\n+  private val extractProjection = GenerateUnsafeProjection.generate(extractExpressions)\n+  private val inputRow = new GenericMutableRow(1)\n+\n+  private lazy val constructProjection = GenerateSafeProjection.generate(constructExpression :: Nil)\n+  private val dataType = ObjectType(clsTag.runtimeClass)\n+\n+  override def toRow(t: T): InternalRow = {\n+    if (t == null) {\n+      null",
    "line": 52
  }],
  "prId": 9184
}]