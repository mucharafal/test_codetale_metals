[{
  "comments": [{
    "author": {
      "login": "sadhen"
    },
    "body": "This is my improved version of InterpretedMutableProject:\r\n\r\n```\r\n  override def apply(input: InternalRow): InternalRow = {\r\n    var i = 0\r\n    while (i < exprArray.length) {\r\n      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\r\n      if (exprArray(i) != NoOp) {\r\n        buffer(i) = exprArray(i).eval(input)\r\n      }\r\n      i += 1\r\n    }\r\n    i = 0\r\n    while (i < exprArray.length) {\r\n      if (exprArray(i) != NoOp) {\r\n        mutableRow(i) = buffer(i)\r\n      }\r\n      i += 1\r\n    }\r\n    mutableRow\r\n  }\r\n```\r\n\r\nThe AggregationIterator uses NoOp. If you replace the codegen one with the interpreted one. You will encounter an exception from `NoOp.eval`.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-07T06:38:32Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }, {
    "author": {
      "login": "sadhen"
    },
    "body": "The improvement (written 3 months ago) is based on the generated Java code.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-07T06:55:11Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Looks good point. Do you know whether there is a test cause that causes the exception with the interpreted one?  \r\n",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-07T09:20:15Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "The change seems to look good to me though, I'ld like to address performance and code quality issues in follow-ups. cc: @gatorsmile ",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-08T00:42:38Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }, {
    "author": {
      "login": "sadhen"
    },
    "body": "Should be easy to create a test case.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-08T01:36:57Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }, {
    "author": {
      "login": "rednaxelafx"
    },
    "body": "+1 on the check for `NoOp`s.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-11T02:01:39Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val exprArray = expressions.toArray\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(exprArray.length)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    var i = 0\n+    while (i < exprArray.length) {\n+      // Store the result into buffer first, to make the projection atomic (needed by aggregation)\n+      buffer(i) = exprArray(i).eval(input)\n+      i += 1\n+    }\n+    i = 0\n+    while (i < exprArray.length) {\n+      mutableRow(i) = buffer(i)\n+      i += 1\n+    }\n+    mutableRow\n+  }\n+}",
    "line": 72
  }],
  "prId": 22355
}, {
  "comments": [{
    "author": {
      "login": "rednaxelafx"
    },
    "body": "use `toBoundExpr`?",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-11T01:49:27Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(BindReferences.bindReference(_, inputSchema)))"
  }],
  "prId": 22355
}, {
  "comments": [{
    "author": {
      "login": "rednaxelafx"
    },
    "body": "```\r\n[error] /home/jenkins/workspace/SparkPullRequestBuilder@2/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/InterpretedMutableProjection.scala:32: type mismatch;\r\n[error]  found   : org.apache.spark.sql.catalyst.expressions.Expression\r\n[error]  required: Seq[org.apache.spark.sql.catalyst.expressions.Expression]\r\n[error]     this(expressions.map(toBoundExprs(_, inputSchema)))\r\n[error]                                       ^\r\n```\r\n\r\nIt's probably `this(toBoundExprs(expressions, inputSchema))` right?",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-12T12:52:18Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(toBoundExprs(_, inputSchema)))"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "yea, haha. I've already updated!",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-12T12:53:25Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(expressions.map(toBoundExprs(_, inputSchema)))"
  }],
  "prId": 22355
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Can you please use something like the old code? That should be much more performant that this.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-14T21:00:21Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NoOp\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(toBoundExprs(expressions, inputSchema))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val validExprs = expressions.zipWithIndex.filter {\n+    case (NoOp, _) => false\n+    case _ => true\n+  }\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(expressions.size)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    validExprs.foreach { case (expr, i) =>"
  }, {
    "author": {
      "login": "maropu"
    },
    "body": "oh, I forgot that we should do that in performance-sensitive places... Thanks! I'll update.",
    "commit": "87491732e1473880077daf9ce5c080845f4742e1",
    "createdAt": "2018-09-14T22:56:11Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.aggregate.NoOp\n+\n+\n+/**\n+ * A [[MutableProjection]] that is calculated by calling `eval` on each of the specified\n+ * expressions.\n+ *\n+ * @param expressions a sequence of expressions that determine the value of each column of the\n+ *                    output row.\n+ */\n+class InterpretedMutableProjection(expressions: Seq[Expression]) extends MutableProjection {\n+  def this(expressions: Seq[Expression], inputSchema: Seq[Attribute]) =\n+    this(toBoundExprs(expressions, inputSchema))\n+\n+  private[this] val buffer = new Array[Any](expressions.size)\n+\n+  override def initialize(partitionIndex: Int): Unit = {\n+    expressions.foreach(_.foreach {\n+      case n: Nondeterministic => n.initialize(partitionIndex)\n+      case _ =>\n+    })\n+  }\n+\n+  private[this] val validExprs = expressions.zipWithIndex.filter {\n+    case (NoOp, _) => false\n+    case _ => true\n+  }\n+  private[this] var mutableRow: InternalRow = new GenericInternalRow(expressions.size)\n+  def currentValue: InternalRow = mutableRow\n+\n+  override def target(row: InternalRow): MutableProjection = {\n+    mutableRow = row\n+    this\n+  }\n+\n+  override def apply(input: InternalRow): InternalRow = {\n+    validExprs.foreach { case (expr, i) =>"
  }],
  "prId": 22355
}]