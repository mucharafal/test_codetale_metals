[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Why do we need to trim the extractors which contain attributes referred from `groupingExpressions ++ aggregateExpressions`?",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-09-18T04:53:53Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)",
    "line": 44
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "> Why do we need to trim the extractors which contain attributes referred from `groupingExpressions ++ aggregateExpressions`?\r\n\r\nConsider this query:\r\n\r\n```sql\r\nselect a, a.b, count(1) from r1 group by a, a.b\r\n```\r\n\r\nThe grouping fields are `a` and `a.b`. `a` is an `Attribute`. `a.b` is a `GetStructField`. Since we need all of `a` to answer this query, it doesn't make sense to attempt to push down `a.b`. At the same time, `fieldExtractors0` includes all `GetStructField` instances. This includes `a.b`. The code you refer to above filters out the `a.b` `GetStructField` because our query requires all of `a`.\r\n\r\nIf we do not filter out `a.b`, then the child (projection) of the new `Aggregate` will not contain `a` in its `output`. The query planner will barf.\r\n\r\nThe logic for the creation of the new child projection is here: https://github.com/apache/spark/blob/00ab80c9b78c45c1a8f8c202c5bab04a62cda2ef/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/AggregateFieldExtractionPushdown.scala#L63-L70\r\n\r\nThis case is tested by https://github.com/apache/spark/blob/00ab80c9b78c45c1a8f8c202c5bab04a62cda2ef/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/AggregateFieldExtractionPushdownSuite.scala#L60-L76",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-09-21T21:42:33Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)",
    "line": 44
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "If the query is:\r\n\r\n```sql\r\nselect a.b, count(1) from r1 group by a.b\r\n```\r\n\r\n`fieldExtractors0` gets `GetStructField` `a.b`. Won't `fieldExtractors1` filter it out, because the attribute `a` is contained in the attribute set of all expressions? But we don't need all fields of `a` now.",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-02T03:23:41Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)",
    "line": 44
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "The attribute `a` is not in `expressions`, so it is not in `attributes`. When we construct `attributes`, we simply collect instances of `Attribute`. We don't do any recursion.\r\n\r\nYour query is tested by the \"basic aggregate field extraction pushdown\" test in `AggregateFieldExtractionPushdownSuite`. It's a little difficult to see because I'm using the Catalyst DataFrame DSL. This seems to be the convention in these tests, though.",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-03T06:40:08Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)",
    "line": 44
  }],
  "prId": 16578
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "`asInstanceOf[Seq[NamedExpression]]`?",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-02T03:30:16Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)\n+        val fieldExtractors =\n+          fieldExtractors1\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(childAttributes.contains).nonEmpty)\n+\n+        if (fieldExtractors.nonEmpty) {\n+          val (aliases, substituteAttributes) = constructAliasesAndSubstitutions(fieldExtractors)\n+\n+          // Construct the new grouping and aggregate expressions by substituting\n+          // each GetStructField expression with a reference to its alias\n+          val newAggregateExpressions =\n+            aggregateExpressions.map(substituteAttributes)\n+              .collect { case named: NamedExpression => named }"
  }, {
    "author": {
      "login": "mallman"
    },
    "body": "I'm not sure exactly what you're asking, but the compiler infers that `newAggregateExpressions` is `Seq[NamedExpression]` because of the type signature of `{ case named: NamedExpression => named }`. We don't need any kind of type casting here.",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-03T06:46:07Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)\n+        val fieldExtractors =\n+          fieldExtractors1\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(childAttributes.contains).nonEmpty)\n+\n+        if (fieldExtractors.nonEmpty) {\n+          val (aliases, substituteAttributes) = constructAliasesAndSubstitutions(fieldExtractors)\n+\n+          // Construct the new grouping and aggregate expressions by substituting\n+          // each GetStructField expression with a reference to its alias\n+          val newAggregateExpressions =\n+            aggregateExpressions.map(substituteAttributes)\n+              .collect { case named: NamedExpression => named }"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I meant it might be like: `aggregateExpressions.map(substituteAttributes).asInstanceOf[Seq[NamedExpression]]`.",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-03T07:36:55Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)\n+        val fieldExtractors =\n+          fieldExtractors1\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(childAttributes.contains).nonEmpty)\n+\n+        if (fieldExtractors.nonEmpty) {\n+          val (aliases, substituteAttributes) = constructAliasesAndSubstitutions(fieldExtractors)\n+\n+          // Construct the new grouping and aggregate expressions by substituting\n+          // each GetStructField expression with a reference to its alias\n+          val newAggregateExpressions =\n+            aggregateExpressions.map(substituteAttributes)\n+              .collect { case named: NamedExpression => named }"
  }],
  "prId": 16578
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "\r\n\r\nWe can return original plan if aliases is empty.\r\n",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-02T03:42:54Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and\n+ * aggregate expressions into a projection over its children. The original\n+ * [[expressions.GetStructField]] expressions are replaced with references to the pushed down\n+ * aliases.\n+ */\n+object AggregateFieldExtractionPushdown extends FieldExtractionPushdown {\n+  override def apply(plan: LogicalPlan): LogicalPlan =\n+    plan transformDown {\n+      case agg @ Aggregate(groupingExpressions, aggregateExpressions, child) =>\n+        val expressions = groupingExpressions ++ aggregateExpressions\n+        val attributes = AttributeSet(expressions.collect { case att: Attribute => att })\n+        val childAttributes = AttributeSet(child.expressions)\n+        val fieldExtractors0 =\n+          expressions\n+            .flatMap(getFieldExtractors)\n+            .distinct\n+        val fieldExtractors1 =\n+          fieldExtractors0\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(attributes.contains).isEmpty)\n+        val fieldExtractors =\n+          fieldExtractors1\n+            .filter(_.collectFirst { case att: Attribute => att }\n+              .filter(childAttributes.contains).nonEmpty)\n+\n+        if (fieldExtractors.nonEmpty) {\n+          val (aliases, substituteAttributes) = constructAliasesAndSubstitutions(fieldExtractors)",
    "line": 51
  }],
  "prId": 16578
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Please describe this is specialized for pushing down pruned nested column.\r\n",
    "commit": "dd4f2d8829335b9d9e71fead6d0d056d48a9d7e6",
    "createdAt": "2017-11-02T05:36:47Z",
    "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeSet, NamedExpression}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, LogicalPlan, Project}\n+\n+/**\n+ * Pushes down aliases to [[expressions.GetStructField]] expressions in an aggregate's grouping and",
    "line": 24
  }],
  "prId": 16578
}]