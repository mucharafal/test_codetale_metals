[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "AND and OR is commutative, so we can reduce the entries in this table",
    "commit": "21dab84d2d54491a1cdd63f91ae5e83727f99526",
    "createdAt": "2018-10-13T06:24:56Z",
    "diffHunk": "@@ -276,31 +276,37 @@ object BooleanSimplification extends Rule[LogicalPlan] with PredicateHelper {\n       case a And b if a.semanticEquals(b) => a\n       case a Or b if a.semanticEquals(b) => a\n \n-      // The following optimization is applicable only when the operands are not nullable,\n+      // The following optimizations are applicable only when the operands are not nullable,\n       // since the three-value logic of AND and OR are different in NULL handling.\n       // See the chart:\n       // +---------+---------+---------+---------+\n-      // |    p    |    q    | p OR q  | p AND q |\n+      // | operand | operand |   OR    |   AND   |",
    "line": 10
  }],
  "prId": 22711
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "explain which input can break it, so it's easier to understand.",
    "commit": "21dab84d2d54491a1cdd63f91ae5e83727f99526",
    "createdAt": "2018-10-13T06:25:50Z",
    "diffHunk": "@@ -276,31 +276,37 @@ object BooleanSimplification extends Rule[LogicalPlan] with PredicateHelper {\n       case a And b if a.semanticEquals(b) => a\n       case a Or b if a.semanticEquals(b) => a\n \n-      // The following optimization is applicable only when the operands are not nullable,\n+      // The following optimizations are applicable only when the operands are not nullable,\n       // since the three-value logic of AND and OR are different in NULL handling.\n       // See the chart:\n       // +---------+---------+---------+---------+\n-      // |    p    |    q    | p OR q  | p AND q |\n+      // | operand | operand |   OR    |   AND   |\n       // +---------+---------+---------+---------+\n       // | TRUE    | TRUE    | TRUE    | TRUE    |\n       // | TRUE    | FALSE   | TRUE    | FALSE   |\n-      // | TRUE    | UNKNOWN | TRUE    | UNKNOWN |\n-      // | FALSE   | TRUE    | TRUE    | FALSE   |\n       // | FALSE   | FALSE   | FALSE   | FALSE   |\n-      // | FALSE   | UNKNOWN | UNKNOWN | FALSE   |\n       // | UNKNOWN | TRUE    | TRUE    | UNKNOWN |\n       // | UNKNOWN | FALSE   | UNKNOWN | FALSE   |\n       // | UNKNOWN | UNKNOWN | UNKNOWN | UNKNOWN |\n       // +---------+---------+---------+---------+\n+\n+      // This can break if a is null and c is false, so a can't be nullable."
  }, {
    "author": {
      "login": "gatorsmile"
    },
    "body": "The current code will not break. Thus, the comment is confusing to the future reader. To make it clear, we can just give the actual value. \r\n> (NULL And (NULL Or FALSE)) = NULL, but (NULL And FALSE) = FALSE. Thus, a can't be nullable. ",
    "commit": "21dab84d2d54491a1cdd63f91ae5e83727f99526",
    "createdAt": "2018-10-13T06:44:40Z",
    "diffHunk": "@@ -276,31 +276,37 @@ object BooleanSimplification extends Rule[LogicalPlan] with PredicateHelper {\n       case a And b if a.semanticEquals(b) => a\n       case a Or b if a.semanticEquals(b) => a\n \n-      // The following optimization is applicable only when the operands are not nullable,\n+      // The following optimizations are applicable only when the operands are not nullable,\n       // since the three-value logic of AND and OR are different in NULL handling.\n       // See the chart:\n       // +---------+---------+---------+---------+\n-      // |    p    |    q    | p OR q  | p AND q |\n+      // | operand | operand |   OR    |   AND   |\n       // +---------+---------+---------+---------+\n       // | TRUE    | TRUE    | TRUE    | TRUE    |\n       // | TRUE    | FALSE   | TRUE    | FALSE   |\n-      // | TRUE    | UNKNOWN | TRUE    | UNKNOWN |\n-      // | FALSE   | TRUE    | TRUE    | FALSE   |\n       // | FALSE   | FALSE   | FALSE   | FALSE   |\n-      // | FALSE   | UNKNOWN | UNKNOWN | FALSE   |\n       // | UNKNOWN | TRUE    | TRUE    | UNKNOWN |\n       // | UNKNOWN | FALSE   | UNKNOWN | FALSE   |\n       // | UNKNOWN | UNKNOWN | UNKNOWN | UNKNOWN |\n       // +---------+---------+---------+---------+\n+\n+      // This can break if a is null and c is false, so a can't be nullable."
  }],
  "prId": 22711
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`b.nullable` and `c.nullable` are same, because `a.semanticEquals(Not(c))`.",
    "commit": "21dab84d2d54491a1cdd63f91ae5e83727f99526",
    "createdAt": "2018-10-13T06:26:25Z",
    "diffHunk": "@@ -276,31 +276,37 @@ object BooleanSimplification extends Rule[LogicalPlan] with PredicateHelper {\n       case a And b if a.semanticEquals(b) => a\n       case a Or b if a.semanticEquals(b) => a\n \n-      // The following optimization is applicable only when the operands are not nullable,\n+      // The following optimizations are applicable only when the operands are not nullable,\n       // since the three-value logic of AND and OR are different in NULL handling.\n       // See the chart:\n       // +---------+---------+---------+---------+\n-      // |    p    |    q    | p OR q  | p AND q |\n+      // | operand | operand |   OR    |   AND   |\n       // +---------+---------+---------+---------+\n       // | TRUE    | TRUE    | TRUE    | TRUE    |\n       // | TRUE    | FALSE   | TRUE    | FALSE   |\n-      // | TRUE    | UNKNOWN | TRUE    | UNKNOWN |\n-      // | FALSE   | TRUE    | TRUE    | FALSE   |\n       // | FALSE   | FALSE   | FALSE   | FALSE   |\n-      // | FALSE   | UNKNOWN | UNKNOWN | FALSE   |\n       // | UNKNOWN | TRUE    | TRUE    | UNKNOWN |\n       // | UNKNOWN | FALSE   | UNKNOWN | FALSE   |\n       // | UNKNOWN | UNKNOWN | UNKNOWN | UNKNOWN |\n       // +---------+---------+---------+---------+\n+\n+      // This can break if a is null and c is false, so a can't be nullable.\n       case a And (b Or c) if !a.nullable && Not(a).semanticEquals(b) => And(a, c)\n+      // This can break if a is null and b is false, so a can't be nullable.\n       case a And (b Or c) if !a.nullable && Not(a).semanticEquals(c) => And(a, b)\n-      case (a Or b) And c if !a.nullable && a.semanticEquals(Not(c)) => And(b, c)\n-      case (a Or b) And c if !b.nullable && b.semanticEquals(Not(c)) => And(a, c)\n+      // This can break if c is null and b is false, so c can't be nullable.\n+      case (a Or b) And c if !c.nullable && a.semanticEquals(Not(c)) => And(b, c)",
    "line": 30
  }],
  "prId": 22711
}]