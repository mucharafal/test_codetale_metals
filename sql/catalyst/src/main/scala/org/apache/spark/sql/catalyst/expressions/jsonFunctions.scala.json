[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Do we need to close this parser later?\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:25:27Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)"
  }, {
    "author": {
      "login": "NathanHowell"
    },
    "body": "I think the answer is no, but it's probably better to do it anyways. `GetJsonObject` doesn't do this, for example... might be worth fixing there too.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T20:25:03Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)"
  }],
  "prId": 7946
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Can we reuse this output stream?\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:26:54Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()"
  }, {
    "author": {
      "login": "yhuai"
    },
    "body": "ah, I see. We need to create a new stream for every distinct UTF8String.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:28:00Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()"
  }],
  "prId": 7946
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "This case is used for handling numbers and booleans, right? If so, can we add a comment?\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:35:59Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)\n+            if (parser.nextToken() != JsonToken.VALUE_NULL) {\n+              copyCurrentStructure(generator, parser)\n+              generator.close()\n+\n+              row(idx) = UTF8String.fromBytes(output.toByteArray)\n+            }\n+          }\n+        }\n+\n+        // always skip children, it's cheap enough to do even if copyCurrentStructure was called\n+        parser.skipChildren()\n+      }\n+\n+      new GenericInternalRow(row)\n+    } catch {\n+      case _: JsonProcessingException =>\n+        nullRow\n+    }\n+  }\n+\n+  private def copyCurrentStructure(generator: JsonGenerator, parser: JsonParser): Unit = {\n+    parser.getCurrentToken match {\n+      case JsonToken.VALUE_STRING if parser.hasTextCharacters =>\n+        generator.writeRaw(parser.getTextCharacters, parser.getTextOffset, parser.getTextLength)\n+\n+      case JsonToken.VALUE_STRING =>\n+        generator.writeRaw(parser.getText)"
  }, {
    "author": {
      "login": "NathanHowell"
    },
    "body": "It's just for strings that do not have qualify for the offset/length optimization above. As above, we do not want quotes around the result. Booleans, numbers, arrays and objects are handled in the default case by `JsonGenerator.copyCurrentStructure`.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T15:40:37Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)\n+            if (parser.nextToken() != JsonToken.VALUE_NULL) {\n+              copyCurrentStructure(generator, parser)\n+              generator.close()\n+\n+              row(idx) = UTF8String.fromBytes(output.toByteArray)\n+            }\n+          }\n+        }\n+\n+        // always skip children, it's cheap enough to do even if copyCurrentStructure was called\n+        parser.skipChildren()\n+      }\n+\n+      new GenericInternalRow(row)\n+    } catch {\n+      case _: JsonProcessingException =>\n+        nullRow\n+    }\n+  }\n+\n+  private def copyCurrentStructure(generator: JsonGenerator, parser: JsonParser): Unit = {\n+    parser.getCurrentToken match {\n+      case JsonToken.VALUE_STRING if parser.hasTextCharacters =>\n+        generator.writeRaw(parser.getTextCharacters, parser.getTextOffset, parser.getTextLength)\n+\n+      case JsonToken.VALUE_STRING =>\n+        generator.writeRaw(parser.getText)"
  }],
  "prId": 7946
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "This case is for string values, right?\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:36:08Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)\n+            if (parser.nextToken() != JsonToken.VALUE_NULL) {\n+              copyCurrentStructure(generator, parser)\n+              generator.close()\n+\n+              row(idx) = UTF8String.fromBytes(output.toByteArray)\n+            }\n+          }\n+        }\n+\n+        // always skip children, it's cheap enough to do even if copyCurrentStructure was called\n+        parser.skipChildren()\n+      }\n+\n+      new GenericInternalRow(row)\n+    } catch {\n+      case _: JsonProcessingException =>\n+        nullRow\n+    }\n+  }\n+\n+  private def copyCurrentStructure(generator: JsonGenerator, parser: JsonParser): Unit = {\n+    parser.getCurrentToken match {\n+      case JsonToken.VALUE_STRING if parser.hasTextCharacters =>\n+        generator.writeRaw(parser.getTextCharacters, parser.getTextOffset, parser.getTextLength)"
  }, {
    "author": {
      "login": "NathanHowell"
    },
    "body": "It's an optimization to avoid creating a `String` instance if `hasTextCharacters` is true. This means we can access the field value by offset and index into a byte array.\n\nThis explicit handling of `VALUE_STRING` is just to avoid putting quotes around the output string, which is what `JsonGenerator.copyCurrentStructure` would do. I'll put comments in here to make that obvious.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T15:38:26Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)\n+            if (parser.nextToken() != JsonToken.VALUE_NULL) {\n+              copyCurrentStructure(generator, parser)\n+              generator.close()\n+\n+              row(idx) = UTF8String.fromBytes(output.toByteArray)\n+            }\n+          }\n+        }\n+\n+        // always skip children, it's cheap enough to do even if copyCurrentStructure was called\n+        parser.skipChildren()\n+      }\n+\n+      new GenericInternalRow(row)\n+    } catch {\n+      case _: JsonProcessingException =>\n+        nullRow\n+    }\n+  }\n+\n+  private def copyCurrentStructure(generator: JsonGenerator, parser: JsonParser): Unit = {\n+    parser.getCurrentToken match {\n+      case JsonToken.VALUE_STRING if parser.hasTextCharacters =>\n+        generator.writeRaw(parser.getTextCharacters, parser.getTextOffset, parser.getTextLength)"
  }],
  "prId": 7946
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Let's add comment to say it handles objects and arrays.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T04:36:25Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)\n+            if (parser.nextToken() != JsonToken.VALUE_NULL) {\n+              copyCurrentStructure(generator, parser)\n+              generator.close()\n+\n+              row(idx) = UTF8String.fromBytes(output.toByteArray)\n+            }\n+          }\n+        }\n+\n+        // always skip children, it's cheap enough to do even if copyCurrentStructure was called\n+        parser.skipChildren()\n+      }\n+\n+      new GenericInternalRow(row)\n+    } catch {\n+      case _: JsonProcessingException =>\n+        nullRow\n+    }\n+  }\n+\n+  private def copyCurrentStructure(generator: JsonGenerator, parser: JsonParser): Unit = {\n+    parser.getCurrentToken match {\n+      case JsonToken.VALUE_STRING if parser.hasTextCharacters =>\n+        generator.writeRaw(parser.getTextCharacters, parser.getTextOffset, parser.getTextLength)\n+\n+      case JsonToken.VALUE_STRING =>\n+        generator.writeRaw(parser.getText)\n+\n+      case JsonToken.VALUE_NULL =>\n+        throw new IllegalStateException(\"Do not attempt to copy a null field\")\n+\n+      case _ =>\n+        generator.copyCurrentStructure(parser)"
  }],
  "prId": 7946
}, {
  "comments": [{
    "author": {
      "login": "NathanHowell"
    },
    "body": "I'm going to move the generator construction into the `if` block, it's not used otherwise.\n",
    "commit": "1b917464cb9d976eb5a15066b939b9498c1bd37a",
    "createdAt": "2015-09-30T15:42:28Z",
    "diffHunk": "@@ -307,3 +308,140 @@ case class GetJsonObject(json: Expression, path: Expression)\n     }\n   }\n }\n+\n+case class JsonTuple(children: Seq[Expression])\n+  extends Expression with CodegenFallback {\n+\n+  import SharedFactory._\n+\n+  override def nullable: Boolean = {\n+    // a row is always returned\n+    false\n+  }\n+\n+  // if processing fails this shared value will be returned\n+  @transient private lazy val nullRow: InternalRow =\n+    new GenericInternalRow(Array.ofDim[Any](fieldExpressions.length))\n+\n+  // the json body is the first child\n+  @transient private lazy val jsonExpr: Expression = children.head\n+\n+  // the fields to query are the remaining children\n+  @transient private lazy val fieldExpressions: Seq[Expression] = children.tail\n+\n+  // eagerly evaluate any foldable the field names\n+  @transient private lazy val foldableFieldNames: IndexedSeq[String] = {\n+    fieldExpressions.map {\n+      case expr if expr.foldable => expr.eval().asInstanceOf[UTF8String].toString\n+      case _ => null\n+    }.toIndexedSeq\n+  }\n+\n+  // and count the number of foldable fields, we'll use this later to optimize evaluation\n+  @transient private lazy val constantFields: Int = foldableFieldNames.count(_ != null)\n+\n+  override lazy val dataType: StructType = {\n+    val fields = fieldExpressions.zipWithIndex.map {\n+      case (_, idx) => StructField(\n+        name = s\"c$idx\", // mirroring GenericUDTFJSONTuple.initialize\n+        dataType = StringType,\n+        nullable = true)\n+    }\n+\n+    StructType(fields)\n+  }\n+\n+  override def prettyName: String = \"json_tuple\"\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.length < 2) {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires at least two arguments\")\n+    } else if (children.forall(child => StringType.acceptsType(child.dataType))) {\n+      TypeCheckResult.TypeCheckSuccess\n+    } else {\n+      TypeCheckResult.TypeCheckFailure(s\"$prettyName requires that all arguments are strings\")\n+    }\n+  }\n+\n+  override def eval(input: InternalRow): InternalRow = {\n+    try {\n+      val json = jsonExpr.eval(input).asInstanceOf[UTF8String]\n+      if (json == null) {\n+        return nullRow\n+      }\n+\n+      val parser = jsonFactory.createParser(json.getBytes)\n+\n+      // only objects are supported\n+      if (parser.nextToken() != JsonToken.START_OBJECT) {\n+        return nullRow\n+      }\n+\n+      // evaluate the field names as String rather than UTF8String to\n+      // optimize lookups from the json token, which is also a String\n+      val fieldNames = if (constantFields == fieldExpressions.length) {\n+        // typically the user will provide the field names as foldable expressions\n+        // so we can use the cached copy\n+        foldableFieldNames\n+      } else if (constantFields == 0) {\n+        // none are foldable so all field names need to be evaluated from the input row\n+        fieldExpressions.map(_.eval(input).asInstanceOf[UTF8String].toString)\n+      } else {\n+        // if there is a mix of constant and non-constant expressions\n+        // prefer the cached copy when available\n+        foldableFieldNames.zip(fieldExpressions).map {\n+          case (null, expr) => expr.eval(input).asInstanceOf[UTF8String].toString\n+          case (fieldName, _) => fieldName\n+        }\n+      }\n+\n+      val row = Array.ofDim[Any](fieldNames.length)\n+\n+      // start reading through the token stream, looking for any requested field names\n+      while (parser.nextToken() != JsonToken.END_OBJECT) {\n+        if (parser.getCurrentToken == JsonToken.FIELD_NAME) {\n+          // check to see if this field is desired in the output\n+          val idx = fieldNames.indexOf(parser.getCurrentName)\n+          if (idx >= 0) {\n+            // it is, copy the child tree to the correct location in the output row\n+            val output = new ByteArrayOutputStream()\n+\n+            // write the output directly to UTF8 encoded byte array\n+            val generator = jsonFactory.createGenerator(output, JsonEncoding.UTF8)"
  }],
  "prId": 7946
}]