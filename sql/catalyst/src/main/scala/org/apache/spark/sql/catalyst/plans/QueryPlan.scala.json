[{
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Ok, so this works because of the way we plan aggregates and I am totally fine with this.\r\n\r\nI am slightly worried about non-complete aggregate expression that cannot be resolved and wreak havok further down the line because `sameResult` falsely evaluated to `true`. Can we special case non-complete aggregate expressions?\r\n\r\nFrom an architectural point of view it might be better to add this as a normalize function to Expression.",
    "commit": "49da955dce260260325708d07becbc692cd3a005",
    "createdAt": "2017-05-12T19:21:15Z",
    "diffHunk": "@@ -429,17 +429,13 @@ object QueryPlan {\n    * with its referenced ordinal from input attributes. It's similar to `BindReferences` but we\n    * do not use `BindReferences` here as the plan may take the expression as a parameter with type\n    * `Attribute`, and replace it with `BoundReference` will cause error.\n+   * Note that, we may have missing attributes, e.g. in the final aggregate of 2-phase aggregation,\n+   * we should normalize missing attributes too, with expr id -1.\n    */\n   def normalizeExprId[T <: Expression](e: T, input: AttributeSeq): T = {\n     e.transformUp {\n       case s: SubqueryExpression => s.canonicalize(input)\n-      case ar: AttributeReference =>\n-        val ordinal = input.indexOf(ar.exprId)\n-        if (ordinal == -1) {\n-          ar\n-        } else {\n-          ar.withExprId(ExprId(ordinal))\n-        }\n+      case ar: AttributeReference => ar.withExprId(ExprId(input.indexOf(ar.exprId)))"
  }],
  "prId": 17964
}]