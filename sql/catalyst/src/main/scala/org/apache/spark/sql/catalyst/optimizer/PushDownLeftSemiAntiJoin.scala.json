[{
  "comments": [{
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan I have a question here. Will it be safe to propagate the hints here ? I am inclined to only do this optimization if no join hints are specified in either parent and child joins. Currently i am propagating them as is but thinking of changing it. Wanted to check your opinion before i made the change.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-10T07:21:10Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n+       *    to the left leg of join.\n+       * 2) if a right outer join, to the right leg of join,\n+       */\n+      val action = joinType match {\n+        case RightOuter =>\n+          pushdownDirection.toRightBranch\n+        case _: InnerLike | LeftOuter =>\n+          pushdownDirection.toLeftBranch\n+        case _ =>\n+          pushdownDirection.none\n+      }\n+      (action, None)\n+    }\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    // push LeftSemi/LeftAnti down into the join below\n+    case j @ Join(left @ Join(gLeft, gRight, AllowedJoinTypes(_), belowJoinCond, childHint),\n+    right, LeftSemiOrAnti(joinType), joinCond, parentHint) =>\n+      val belowJoinType = left.joinType\n+      val (action, newJoinCond) = pushTo(left, right, joinCond)\n+\n+      action match {\n+        case pushdownDirection.toLeftBranch\n+          if (belowJoinType == LeftOuter || belowJoinType.isInstanceOf[InnerLike]) =>\n+          // push down leftsemi/anti join to the left table\n+          val newLeft = Join(gLeft, right, joinType, newJoinCond, parentHint)"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we upper case the first letter?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T12:05:58Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Sure.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T23:05:51Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "this is hard to read when 2 joins are extracted together. How about\r\n```\r\ncase j: Join(AllowedJoin(left), right, ...) =>\r\n```",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T12:11:00Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n+       *    to the left leg of join.\n+       * 2) if a right outer join, to the right leg of join,\n+       */\n+      val action = joinType match {\n+        case RightOuter =>\n+          pushdownDirection.toRightBranch\n+        case _: InnerLike | LeftOuter =>\n+          pushdownDirection.toLeftBranch\n+        case _ =>\n+          pushdownDirection.none\n+      }\n+      (action, None)\n+    }\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    // push LeftSemi/LeftAnti down into the join below\n+    case j @ Join(left @ Join(gLeft, gRight, AllowedJoinTypes(_), belowJoinCond, childHint),"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Good idea wenchen.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T23:06:06Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n+       *    to the left leg of join.\n+       * 2) if a right outer join, to the right leg of join,\n+       */\n+      val action = joinType match {\n+        case RightOuter =>\n+          pushdownDirection.toRightBranch\n+        case _: InnerLike | LeftOuter =>\n+          pushdownDirection.toLeftBranch\n+        case _ =>\n+          pushdownDirection.none\n+      }\n+      (action, None)\n+    }\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    // push LeftSemi/LeftAnti down into the join below\n+    case j @ Join(left @ Join(gLeft, gRight, AllowedJoinTypes(_), belowJoinCond, childHint),"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "when can this happen?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T12:11:29Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n+       *    to the left leg of join.\n+       * 2) if a right outer join, to the right leg of join,\n+       */\n+      val action = joinType match {\n+        case RightOuter =>\n+          pushdownDirection.toRightBranch\n+        case _: InnerLike | LeftOuter =>\n+          pushdownDirection.toLeftBranch\n+        case _ =>\n+          pushdownDirection.none\n+      }\n+      (action, None)\n+    }\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    // push LeftSemi/LeftAnti down into the join below\n+    case j @ Join(left @ Join(gLeft, gRight, AllowedJoinTypes(_), belowJoinCond, childHint),\n+    right, LeftSemiOrAnti(joinType), joinCond, parentHint) =>\n+      val belowJoinType = left.joinType\n+      val (action, newJoinCond) = pushTo(left, right, joinCond)\n+\n+      action match {\n+        case pushdownDirection.toLeftBranch\n+          if (belowJoinType == LeftOuter || belowJoinType.isInstanceOf[InnerLike]) =>\n+          // push down leftsemi/anti join to the left table\n+          val newLeft = Join(gLeft, right, joinType, newJoinCond, parentHint)\n+          Join(newLeft, gRight, belowJoinType, belowJoinCond, childHint)\n+        case pushdownDirection.toRightBranch\n+          if (belowJoinType == RightOuter || belowJoinType.isInstanceOf[InnerLike]) =>\n+          // push down leftsemi/anti join to the right table\n+          val newRight = Join(gRight, right, joinType, newJoinCond, parentHint)\n+          Join(gLeft, newRight, belowJoinType, belowJoinCond, childHint)\n+        case _ =>\n+          // Do nothing",
    "line": 101
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan When we decide that we can't pushdown the parent join. For example this [test](https://github.com/apache/spark/pull/24331/files#diff-22926b689dfba1ee84b9c35601990e81R380) should exercise the default case.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T23:04:55Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down\n+       *    to the left leg of join.\n+       * 2) if a right outer join, to the right leg of join,\n+       */\n+      val action = joinType match {\n+        case RightOuter =>\n+          pushdownDirection.toRightBranch\n+        case _: InnerLike | LeftOuter =>\n+          pushdownDirection.toLeftBranch\n+        case _ =>\n+          pushdownDirection.none\n+      }\n+      (action, None)\n+    }\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    // push LeftSemi/LeftAnti down into the join below\n+    case j @ Join(left @ Join(gLeft, gRight, AllowedJoinTypes(_), belowJoinCond, childHint),\n+    right, LeftSemiOrAnti(joinType), joinCond, parentHint) =>\n+      val belowJoinType = left.joinType\n+      val (action, newJoinCond) = pushTo(left, right, joinCond)\n+\n+      action match {\n+        case pushdownDirection.toLeftBranch\n+          if (belowJoinType == LeftOuter || belowJoinType.isInstanceOf[InnerLike]) =>\n+          // push down leftsemi/anti join to the left table\n+          val newLeft = Join(gLeft, right, joinType, newJoinCond, parentHint)\n+          Join(newLeft, gRight, belowJoinType, belowJoinCond, childHint)\n+        case pushdownDirection.toRightBranch\n+          if (belowJoinType == RightOuter || belowJoinType.isInstanceOf[InnerLike]) =>\n+          // push down leftsemi/anti join to the right table\n+          val newRight = Join(gRight, right, joinType, newJoinCond, parentHint)\n+          Join(gLeft, newRight, belowJoinType, belowJoinCond, childHint)\n+        case _ =>\n+          // Do nothing",
    "line": 101
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`PushPredicateThroughJoin` may pushdown to both sides, do we have such a case here?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T12:14:33Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan To the best of my knowledge, we don't have this case. I actually tried to get a subquery to push down to both legs of the join but couldn't. Normal filter conditions can trigger pushing down to both legs currently though.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-11T23:08:27Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "can we add a TODO and say we will revisit it?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-16T02:22:16Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Sure. I will add a TODO",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-16T02:35:39Z",
    "diffHunk": "@@ -159,3 +159,106 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object pushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  /**\n+   * LeftSemi/LeftAnti joins are pushed down when its left child is a join operator\n+   * with a join type that is in the AllowedJoinTypes.\n+   */\n+  object AllowedJoinTypes {\n+    def unapply(joinType: JoinType): Option[JoinType] = joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(joinType)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (pushdownDirection.none, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (pushdownDirection.toLeftBranch, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (pushdownDirection.toRightBranch, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "upper-case the first letter for them too. I think this is the policy when defining enums.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T15:03:43Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "actually, the policy is upper-case all the letters, e.g.\r\n```\r\nobject PushdownDirection extends Enumeration {\r\n  val TO_RIGHT_BRANCH, ...\r\n}\r\n```",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T15:04:27Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Will change.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T15:34:17Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "nit: it matches a single join, so no `s` at the end.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T15:05:34Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  object AllowedJoins {"
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan ok.. will make a change.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T15:34:31Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val toRightBranch, toLeftBranch, none = Value\n+  }\n+\n+  object AllowedJoins {"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why can't we push to both legs if it's inner join?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T16:57:04Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (PushdownDirection.NONE, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (PushdownDirection.TO_RIGHT_BRANCH, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down",
    "line": 67
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Perhaps its possible. In this PR, i was focusing on what is happening today in `PushPredicateThroughJoin` and keep the behaviour same. We can look into improving both this rule and `PushPredicateThroughJoin` as follow-up. The reason i say it is, probably we need to test more and prove that pushdown to both sides don't create any side effects or can cause wrong results ?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T17:24:28Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (PushdownDirection.NONE, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (PushdownDirection.TO_RIGHT_BRANCH, rightConditions.reduceLeftOption(And))\n+      } else {\n+        noPushdown\n+      }\n+    } else {\n+      /**\n+       * When the join condition is empty,\n+       * 1) if this is a left outer join or inner join, push leftsemi/anti join down",
    "line": 67
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "what if `commonConditions` is not empty? can we add a filter at top?",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T17:00:01Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (PushdownDirection.NONE, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {",
    "line": 57
  }, {
    "author": {
      "login": "dilipbiswal"
    },
    "body": "@cloud-fan Please refer to my answer above.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-15T17:25:38Z",
    "diffHunk": "@@ -159,3 +159,102 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = (PushdownDirection.NONE, None)\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH, leftConditions.reduceLeftOption(And))\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {",
    "line": 57
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "since we can only push down left semi/anti join to either left or right side, there is no need to return the new join condition in this method, because the join condition won't change.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-16T11:24:59Z",
    "diffHunk": "@@ -159,3 +159,109 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ *\n+ * TODO:\n+ * Currently this rule can push down the left semi or left anti joins to either\n+ * left or right leg of the child join. This matches the behaviour of `PushPredicateThroughJoin`\n+ * when the lefi semi or left anti join is in expression form. We need to explore the possibility\n+ * to push the left semi/anti joins to both legs of join if the join condition refers to\n+ * both left and right legs of the child join.\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {",
    "line": 40
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "We can use `PushdownDirection.NONE` directly.",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-17T03:40:34Z",
    "diffHunk": "@@ -159,3 +159,108 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ *\n+ * TODO:\n+ * Currently this rule can push down the left semi or left anti joins to either\n+ * left or right leg of the child join. This matches the behaviour of `PushPredicateThroughJoin`\n+ * when the lefi semi or left anti join is in expression form. We need to explore the possibility\n+ * to push the left semi/anti joins to both legs of join if the join condition refers to\n+ * both left and right legs of the child join.\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = PushdownDirection.NONE"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "no need to add `(...)`",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-17T03:40:58Z",
    "diffHunk": "@@ -159,3 +159,108 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ *\n+ * TODO:\n+ * Currently this rule can push down the left semi or left anti joins to either\n+ * left or right leg of the child join. This matches the behaviour of `PushPredicateThroughJoin`\n+ * when the lefi semi or left anti join is in expression form. We need to explore the possibility\n+ * to push the left semi/anti joins to both legs of join if the join condition refers to\n+ * both left and right legs of the child join.\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = PushdownDirection.NONE\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH)"
  }],
  "prId": 24331
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "ditto",
    "commit": "a5ed3d9f9fbe4081566a1b20c02a433c75edf2b9",
    "createdAt": "2019-04-17T03:41:03Z",
    "diffHunk": "@@ -159,3 +159,108 @@ object PushDownLeftSemiAntiJoin extends Rule[LogicalPlan] with PredicateHelper {\n     }\n   }\n }\n+\n+/**\n+ * This rule is a variant of [[PushPredicateThroughJoin]] which can handle\n+ * pushing down Left semi and Left Anti joins below a join operator. The\n+ * allowable join types are:\n+ *  1) Inner\n+ *  2) Cross\n+ *  3) LeftOuter\n+ *  4) RightOuter\n+ *\n+ * TODO:\n+ * Currently this rule can push down the left semi or left anti joins to either\n+ * left or right leg of the child join. This matches the behaviour of `PushPredicateThroughJoin`\n+ * when the lefi semi or left anti join is in expression form. We need to explore the possibility\n+ * to push the left semi/anti joins to both legs of join if the join condition refers to\n+ * both left and right legs of the child join.\n+ */\n+object PushLeftSemiLeftAntiThroughJoin extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Define an enumeration to identify whether a LeftSemi/LeftAnti join can be pushed down to\n+   * the left leg or the right leg of the join.\n+   */\n+  object PushdownDirection extends Enumeration {\n+    val TO_LEFT_BRANCH, TO_RIGHT_BRANCH, NONE = Value\n+  }\n+\n+  object AllowedJoin {\n+    def unapply(join: Join): Option[Join] = join.joinType match {\n+      case Inner | Cross | LeftOuter | RightOuter => Some(join)\n+      case _ => None\n+    }\n+  }\n+\n+  /**\n+   * Determine which side of the join a LeftSemi/LeftAnti join can be pushed to.\n+   */\n+  private def pushTo(leftChild: Join, rightChild: LogicalPlan, joinCond: Option[Expression]) = {\n+    val left = leftChild.left\n+    val right = leftChild.right\n+    val joinType = leftChild.joinType\n+    val rightOutput = rightChild.outputSet\n+\n+    if (joinCond.nonEmpty) {\n+      val noPushdown = PushdownDirection.NONE\n+      val conditions = splitConjunctivePredicates(joinCond.get)\n+      val (leftConditions, rest) =\n+        conditions.partition(_.references.subsetOf(left.outputSet ++ rightOutput))\n+      val (rightConditions, commonConditions) =\n+        rest.partition(_.references.subsetOf(right.outputSet ++ rightOutput))\n+\n+      if (rest.isEmpty && leftConditions.nonEmpty) {\n+        // When the join conditions can be computed based on the left leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the left side.\n+        (PushdownDirection.TO_LEFT_BRANCH)\n+      } else if (leftConditions.isEmpty && rightConditions.nonEmpty && commonConditions.isEmpty) {\n+        // When the join conditions can be computed based on the attributes from right leg of\n+        // leftsemi/anti join then push the leftsemi/anti join to the right side.\n+        (PushdownDirection.TO_RIGHT_BRANCH)"
  }],
  "prId": 24331
}]