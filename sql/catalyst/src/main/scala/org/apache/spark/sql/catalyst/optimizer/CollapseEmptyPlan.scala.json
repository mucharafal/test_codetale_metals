[{
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Actually `Generate` can't be included here. Our `Generate` also supports Hive style UDTF, which has a weird semantics: for a UDTF `f`, after all rows being processed, `f.close()` will be called, and _more rows can be generated_ within `f.close()`. This means a UDTF may generate one or more rows even if the underlying input is empty.\n\nSee [here](https://github.com/apache/spark/pull/5383/files) and PR #5338 for more details.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T03:18:39Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p @ Join(_, _, Inner, _) if p.children.exists(isEmptyLocalRelation) =>\n+      LocalRelation(p.output, data = Seq.empty)\n+\n+    case p: LogicalPlan if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      p match {\n+        case _: Project | _: Generate | _: Filter | _: Sample | _: Join |"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "what exactly are we checking here? it looks to me that we can do empty relation propagate if aggregate list has no aggregate function, e.g. `select col + 1 from tbl group by col` should also work.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T03:31:44Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p @ Join(_, _, Inner, _) if p.children.exists(isEmptyLocalRelation) =>\n+      LocalRelation(p.output, data = Seq.empty)\n+\n+    case p: LogicalPlan if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      p match {\n+        case _: Project | _: Generate | _: Filter | _: Sample | _: Join |\n+             _: Sort | _: GlobalLimit | _: LocalLimit | _: Union | _: Repartition =>\n+          LocalRelation(p.output, data = Seq.empty)\n+        case Aggregate(ge, ae, _) if ae.forall(ge.contains(_)) =>"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Yea. The following predicate should work:\n\n``` scala\nae.forall(_.collectFirst { case _: AggregateExpression => () }.isEmpty)\n```\n\n(But probably put it into a separate method though.)\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T08:11:39Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p @ Join(_, _, Inner, _) if p.children.exists(isEmptyLocalRelation) =>\n+      LocalRelation(p.output, data = Seq.empty)\n+\n+    case p: LogicalPlan if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      p match {\n+        case _: Project | _: Generate | _: Filter | _: Sample | _: Join |\n+             _: Sort | _: GlobalLimit | _: LocalLimit | _: Union | _: Repartition =>\n+          LocalRelation(p.output, data = Seq.empty)\n+        case Aggregate(ge, ae, _) if ae.forall(ge.contains(_)) =>"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I think this rule is very useful, we can avoid scanning one join side if the other side is empty\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T03:34:16Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p @ Join(_, _, Inner, _) if p.children.exists(isEmptyLocalRelation) =>"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Yea, we can also add `Intersect`.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T03:43:09Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p @ Join(_, _, Inner, _) if p.children.exists(isEmptyLocalRelation) =>"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "``` scala\nplan match {\n  case p: LocalRelation => p.data.isEmpty\n  case _ => false\n}\n```\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T03:41:16Z",
    "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. InnerJoin with one or two empty children.\n+ * 2. Project/Generate/Filter/Sample/Join/Limit/Union/Repartition with all empty children.\n+ * 3. Aggregate with all empty children and grpExprs containing all aggExprs.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean =\n+    plan.isInstanceOf[LocalRelation] && plan.asInstanceOf[LocalRelation].data.isEmpty"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Why `DeclarativeAggregate` rather than `AggregateFunction`? `AggregateFunction` also covers `ImperativeAggregate` like `ScalaUDAF`, which should also be covered here.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:31:39Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oh. I forgot your comment about this. I'll fix like that.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:37:35Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "I'd replace this method with:\n\n``` scala\ndef containsAggregateExpression(e: Expression): Boolean = {\n  e.collectFirst { case _: AggregateFunction => () }.isDefined\n}\n```\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:34:02Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Thanks, again!\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:38:05Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Could you please comment that `Intersect` is also covered here? I didn't realized that we've already translated `Intersect` using joins at first.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:36:06Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      empty(p)\n+\n+    case p @ Join(_, _, joinType, _) if p.children.exists(isEmptyLocalRelation) => joinType match {\n+      case Inner => empty(p)\n+      case LeftOuter | LeftSemi | LeftAnti if isEmptyLocalRelation(p.left) => empty(p)\n+      case RightOuter if isEmptyLocalRelation(p.right) => empty(p)\n+      case FullOuter if p.children.forall(isEmptyLocalRelation) => empty(p)\n+      case _ => p\n+    }"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Yep. I added line 30 https://github.com/apache/spark/pull/13906/files#diff-315910d950ea08479990c40570fbd216R30 currently.\n\nBut, I will add comment, too. Maybe beyond `LeftSemi` at line 56?\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:40:14Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      empty(p)\n+\n+    case p @ Join(_, _, joinType, _) if p.children.exists(isEmptyLocalRelation) => joinType match {\n+      case Inner => empty(p)\n+      case LeftOuter | LeftSemi | LeftAnti if isEmptyLocalRelation(p.left) => empty(p)\n+      case RightOuter if isEmptyLocalRelation(p.right) => empty(p)\n+      case FullOuter if p.children.forall(isEmptyLocalRelation) => empty(p)\n+      case _ => p\n+    }"
  }, {
    "author": {
      "login": "liancheng"
    },
    "body": "Sorry that I didn't notice the comment above. I think that should be enough.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T14:18:15Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      empty(p)\n+\n+    case p @ Join(_, _, joinType, _) if p.children.exists(isEmptyLocalRelation) => joinType match {\n+      case Inner => empty(p)\n+      case LeftOuter | LeftSemi | LeftAnti if isEmptyLocalRelation(p.left) => empty(p)\n+      case RightOuter if isEmptyLocalRelation(p.right) => empty(p)\n+      case FullOuter if p.children.forall(isEmptyLocalRelation) => empty(p)\n+      case _ => p\n+    }"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "liancheng"
    },
    "body": "Let's add comment here to explain why we must special case `Aggregate` and `Generate`.\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:41:46Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      empty(p)\n+\n+    case p @ Join(_, _, joinType, _) if p.children.exists(isEmptyLocalRelation) => joinType match {\n+      case Inner => empty(p)\n+      case LeftOuter | LeftSemi | LeftAnti if isEmptyLocalRelation(p.left) => empty(p)\n+      case RightOuter if isEmptyLocalRelation(p.right) => empty(p)\n+      case FullOuter if p.children.forall(isEmptyLocalRelation) => empty(p)\n+      case _ => p\n+    }\n+\n+    case p: UnaryNode if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) => p match {\n+      case _: Project | _: Filter | _: Sample | _: Sort | _: GlobalLimit | _: LocalLimit |\n+           _: Repartition | _: RepartitionByExpression => empty(p)\n+      case Aggregate(_, ae, _) if !ae.exists(isDeclarativeAggregate) => empty(p)\n+      case Generate(_ : Explode, _, _, _, _, _) => empty(p)"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Sure!\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T10:45:46Z",
    "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.DeclarativeAggregate\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def isDeclarativeAggregate(e: Expression): Boolean = e match {\n+    case _: DeclarativeAggregate => true\n+    case _: LeafExpression => false\n+    case other => other.children.forall(isDeclarativeAggregate)\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>\n+      empty(p)\n+\n+    case p @ Join(_, _, joinType, _) if p.children.exists(isEmptyLocalRelation) => joinType match {\n+      case Inner => empty(p)\n+      case LeftOuter | LeftSemi | LeftAnti if isEmptyLocalRelation(p.left) => empty(p)\n+      case RightOuter if isEmptyLocalRelation(p.right) => empty(p)\n+      case FullOuter if p.children.forall(isEmptyLocalRelation) => empty(p)\n+      case _ => p\n+    }\n+\n+    case p: UnaryNode if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) => p match {\n+      case _: Project | _: Filter | _: Sample | _: Sort | _: GlobalLimit | _: LocalLimit |\n+           _: Repartition | _: RepartitionByExpression => empty(p)\n+      case Aggregate(_, ae, _) if !ae.exists(isDeclarativeAggregate) => empty(p)\n+      case Generate(_ : Explode, _, _, _, _, _) => empty(p)"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`Union.resolved` already guarantee `children.length > 1`\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T13:30:25Z",
    "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def containsAggregateExpression(e: Expression): Boolean = {\n+    e.collectFirst { case _: AggregateFunction => () }.isDefined\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oh, thank you!\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T17:06:52Z",
    "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {\n+  private def isEmptyLocalRelation(plan: LogicalPlan): Boolean = plan match {\n+    case p: LocalRelation => p.data.isEmpty\n+    case _ => false\n+  }\n+\n+  private def containsAggregateExpression(e: Expression): Boolean = {\n+    e.collectFirst { case _: AggregateFunction => () }.isDefined\n+  }\n+\n+  private def empty(plan: LogicalPlan) = LocalRelation(plan.output, data = Seq.empty)\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+    case p: Union if p.children.nonEmpty && p.children.forall(isEmptyLocalRelation) =>"
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "`DeclarativeAggregate` -> aggregate function?\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T13:52:32Z",
    "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT."
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Ooops. :)\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T17:07:02Z",
    "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT."
  }],
  "prId": 13906
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "how about `PropagateEmptyRelation`\n",
    "commit": "984854b43444be928c2f22f5d16a9531e46292c3",
    "createdAt": "2016-06-30T13:52:53Z",
    "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.aggregate.AggregateFunction\n+import org.apache.spark.sql.catalyst.plans._\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules._\n+\n+/**\n+ * Collapse plans consisting empty local relations generated by [[PruneFilters]].\n+ * 1. Binary(or Higher)-node Logical Plans\n+ *    - Union with all empty children.\n+ *    - Join with one or two empty children (including Intersect/Except).\n+ * 2. Unary-node Logical Plans\n+ *    - Project/Filter/Sample/Join/Limit/Repartition with all empty children.\n+ *    - Aggregate with all empty children and without DeclarativeAggregate expressions like COUNT.\n+ *    - Generate(Explode) with all empty children. Others like Hive UDTF may return results.\n+ */\n+object CollapseEmptyPlan extends Rule[LogicalPlan] with PredicateHelper {"
  }],
  "prId": 13906
}]