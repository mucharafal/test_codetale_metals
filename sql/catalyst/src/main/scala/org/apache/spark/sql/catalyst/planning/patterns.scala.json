[{
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Remove the join filter push down stuff, as we have the `PushPredicateThroughJoin` in Optimizer(Catalyst), \n",
    "commit": "65c599e3f695035135647ab1717f4e134026e2ed",
    "createdAt": "2014-06-20T06:28:29Z",
    "diffHunk": "@@ -114,48 +94,27 @@ object HashFilteredJoin extends Logging with PredicateHelper {\n     (JoinType, Seq[Expression], Seq[Expression], Option[Expression], LogicalPlan, LogicalPlan)\n \n   def unapply(plan: LogicalPlan): Option[ReturnType] = plan match {"
  }],
  "prId": 1147
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Why are you deleting this?\n",
    "commit": "65c599e3f695035135647ab1717f4e134026e2ed",
    "createdAt": "2014-06-21T19:26:25Z",
    "diffHunk": "@@ -25,26 +25,6 @@ import org.apache.spark.sql.catalyst.expressions._\n import org.apache.spark.sql.catalyst.plans._\n import org.apache.spark.sql.catalyst.plans.logical._\n \n-/**\n- * A pattern that matches any number of filter operations on top of another relational operator.\n- * Adjacent filter operators are collected and their conditions are broken up and returned as a\n- * sequence of conjunctive predicates.\n- *\n- * @return A tuple containing a sequence of conjunctive predicates that should be used to filter the\n- *         output and a relational operator.\n- */\n-object FilteredOperation extends PredicateHelper {"
  }],
  "prId": 1147
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Why are you changing the semantics of this pattern?  It is called `HashFilteredJoin` but is now matching joins that cannot be answered using hashing techniques.\n",
    "commit": "65c599e3f695035135647ab1717f4e134026e2ed",
    "createdAt": "2014-06-21T19:29:10Z",
    "diffHunk": "@@ -114,48 +94,27 @@ object HashFilteredJoin extends Logging with PredicateHelper {\n     (JoinType, Seq[Expression], Seq[Expression], Option[Expression], LogicalPlan, LogicalPlan)\n \n   def unapply(plan: LogicalPlan): Option[ReturnType] = plan match {\n-    // All predicates can be evaluated for inner join (i.e., those that are in the ON\n-    // clause and WHERE clause.)\n-    case FilteredOperation(predicates, join @ Join(left, right, Inner, condition)) =>\n-      logger.debug(s\"Considering hash inner join on: ${predicates ++ condition}\")\n-      splitPredicates(predicates ++ condition, join)\n-    // All predicates can be evaluated for left semi join (those that are in the WHERE\n-    // clause can only from left table, so they can all be pushed down.)\n-    case FilteredOperation(predicates, join @ Join(left, right, LeftSemi, condition)) =>\n-      logger.debug(s\"Considering hash left semi join on: ${predicates ++ condition}\")\n-      splitPredicates(predicates ++ condition, join)\n     case join @ Join(left, right, joinType, condition) =>\n       logger.debug(s\"Considering hash join on: $condition\")\n-      splitPredicates(condition.toSeq, join)\n-    case _ => None\n-  }\n-\n-  // Find equi-join predicates that can be evaluated before the join, and thus can be used\n-  // as join keys.\n-  def splitPredicates(allPredicates: Seq[Expression], join: Join): Option[ReturnType] = {\n-    val Join(left, right, joinType, _) = join\n-    val (joinPredicates, otherPredicates) =\n-      allPredicates.flatMap(splitConjunctivePredicates).partition {\n+      // Find equi-join predicates that can be evaluated before the join, and thus can be used\n+      // as join keys.\n+      val (joinPredicates, otherPredicates) = condition.map(splitConjunctivePredicates).\n+        getOrElse(Nil).partition {\n         case Equals(l, r) if (canEvaluate(l, left) && canEvaluate(r, right)) ||\n           (canEvaluate(l, right) && canEvaluate(r, left)) => true\n         case _ => false\n       }\n \n-    val joinKeys = joinPredicates.map {\n-      case Equals(l, r) if canEvaluate(l, left) && canEvaluate(r, right) => (l, r)\n-      case Equals(l, r) if canEvaluate(l, right) && canEvaluate(r, left) => (r, l)\n-    }\n+      val joinKeys = joinPredicates.map {\n+        case Equals(l, r) if canEvaluate(l, left) && canEvaluate(r, right) => (l, r)\n+        case Equals(l, r) if canEvaluate(l, right) && canEvaluate(r, left) => (r, l)\n+      }\n \n-    // Do not consider this strategy if there are no join keys."
  }],
  "prId": 1147
}]