[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "it could extends BinaryExpression\n",
    "commit": "9192d097c18feebc7896aca56d81409e22d57355",
    "createdAt": "2015-08-03T17:50:14Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import java.io.{StringWriter, ByteArrayOutputStream}\n+\n+import com.fasterxml.jackson.core._\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.codegen.CodegenFallback\n+import org.apache.spark.sql.types.{StringType, DataType}\n+import org.apache.spark.unsafe.types.UTF8String\n+\n+import scala.util.parsing.combinator.RegexParsers\n+\n+private[this] sealed trait PathInstruction\n+private[this] object PathInstruction {\n+  private[expressions] case object Subscript extends PathInstruction\n+  private[expressions] case object Wildcard extends PathInstruction\n+  private[expressions] case object Key extends PathInstruction\n+  private[expressions] case class Index(index: Long) extends PathInstruction\n+  private[expressions] case class Named(name: String) extends PathInstruction\n+}\n+\n+private[this] sealed trait WriteStyle\n+private[this] object WriteStyle {\n+  private[expressions] case object RawStyle extends WriteStyle\n+  private[expressions] case object QuotedStyle extends WriteStyle\n+  private[expressions] case object FlattenStyle extends WriteStyle\n+}\n+\n+private[this] object JsonPathParser extends RegexParsers {\n+  import PathInstruction._\n+\n+  def root: Parser[Char] = '$'\n+\n+  def long: Parser[Long] = \"\\\\d+\".r ^? {\n+    case x => x.toLong\n+  }\n+\n+  // parse `[*]` and `[123]` subscripts\n+  def subscript: Parser[List[PathInstruction]] =\n+    for {\n+      operand <- '[' ~> ('*' ^^^ Wildcard | long ^^ Index) <~ ']'\n+    } yield {\n+      Subscript :: operand :: Nil\n+    }\n+\n+  // parse `.name` or `['name']` child expressions\n+  def named: Parser[List[PathInstruction]] =\n+    for {\n+      name <- '.' ~> \"[^\\\\.\\\\[]+\".r | \"[\\\\'\" ~> \"[^\\\\'\\\\?]+\" <~ \"\\\\']\"\n+    } yield {\n+      Key :: Named(name) :: Nil\n+    }\n+\n+  // child wildcards: `..`, `.*` or `['*']`\n+  def wildcard: Parser[List[PathInstruction]] =\n+    (\".*\" | \"['*']\") ^^^ List(Wildcard)\n+\n+  def node: Parser[List[PathInstruction]] =\n+    wildcard |\n+      named |\n+      subscript\n+\n+  val expression: Parser[List[PathInstruction]] = {\n+    phrase(root ~> rep(node) ^^ (x => x.flatten))\n+  }\n+\n+  def parse(str: String): Option[List[PathInstruction]] = {\n+    this.parseAll(expression, str) match {\n+      case Success(result, _) =>\n+        Some(result)\n+\n+      case NoSuccess(msg, next) =>\n+        None\n+    }\n+  }\n+}\n+\n+private[this] object GetJsonObject {\n+  private val jsonFactory = new JsonFactory()\n+\n+  // Enabled for Hive compatibility\n+  jsonFactory.enable(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS)\n+}\n+\n+case class GetJsonObject(\n+    jsonExpression: Expression,\n+    pathExpression: Expression)\n+  extends Expression",
    "line": 105
  }],
  "prId": 7485
}]