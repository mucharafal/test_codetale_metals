[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should the anti join not output the row if there is any null in the left key?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:17:09Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.find(references.contains).isDefined\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "never mind, the current behavior of anti join match the behavior of `not exists`.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:39:02Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.find(references.contains).isDefined\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "It's better to use AttributeSet or ExpressionSet\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:22:40Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "Done\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T21:17:01Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "We could use transformDown, that stop at some plans (outer joins, union) that we could not pull some predicates through it.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:30:56Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Or we could a white list of plans that we could pull the predicates?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:31:56Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Or maybe we could have a rule to pull up all the predicates that accessing outer attributes?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T06:34:10Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "The analyzer currently checks that we don't pull out references out of an outer join. I think I am going to add the condition to the `PredicateSubQuery` and move pulling out correlated conditions to the analyzer (and throw exceptions when we can't/shouldn't).\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T08:48:58Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "I'm thinking of this case\n\n``` sql\nSELECT * FROM A join B on A.k = A.k\n   WHERE EXISTS (SELECT id from C where C.id = A.id) AND \n           EXISTS (SELECT id from D where D.id = B.id)\n```\n\nThe two subqueries access different attributes from two A or B, the EXISTS could only be pushed down to A or B depends on the outer attributes they are accessing.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T19:33:23Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "This would be rewritten into\n\n``` SQL\nSELECT   *\nFROM     A\n         JOIN B ON A.k = B.k\n         LEFT SEMI JOIN C ON C.id = A.id\n         LEFT SEMI JOIN D ON D.id = B.id\n```\n\nWe would able to push the first SEMI JOIN down through the INNER by checking the outputSets of the INNER JOINs child nodes. I do think this is relevant but I would like to do this in a follow-up PR.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T20:10:23Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Since the rewrite is in the last batch of Optimizer, they will be pushed down through JOIN first, this does not work as expected in this PR, right?\n\nIt's fine to fix that in follow up PR.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T20:26:32Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I'll adress this in a follow-up.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-18T21:22:03Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references: Set[Expression] = query.output.toSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {"
  }],
  "prId": 12306
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "I do not understand why we need this.\n\n`NOT IN` is the most complicated one, can we remove this part, do it in follow-up PR (need more thinking on it)?\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T18:29:23Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "@davies this is needed. We currently only allow `NOT IN`s without any nullable columns in the sub-query. An Anti-Join returns a row when it does not match a row in the sub-query. If we try to match a row containing nulls the result will be undefined. Anti-join interprets an undefined match as a no match and returns the row. This violates the `NOT IN` semantic. In order to prevent this from happening we need to filter the rows produced by the query for nulls. The exception here is when the sub-query does not produce any results at all because no-match is possible at all. \n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T18:46:40Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "When we check whether there are rows or not in subquery, we need to consider `condition`, I think.\n\nAlso, even some column is null from `p`, the condition could still matched, for example, `If(IsNull(a), 1, 2) == c`, this predicate could be true whenever `a` is null or not.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T18:52:27Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "@davies I have updated the comment. We need this unfortunately.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T18:56:07Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "We can also drop support for `NOT IN` in this PR.\n\nJust had an idea to rewrite the condition. It'll turn the evaluation into a BNL, but it should have the proper semantics.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T19:21:06Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "How about this: introduce a SemiPlus join type (only used internally), which will emit all the rows from left with an additional column which is the result of condition (maintain the nullability), then these subquery could be rewritten as \n\n```\nExists -> condition_result\nNot Exists -> Not(condition_result)\nIn -> condition_result\nNot IN  -> Not(condition_result)\n```\n\nThis also works for subquery that is not top level predicate, or even in Project.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T20:25:12Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I do like the idea of adding a `Semi Join Plus`, it would solve a lot and is a logical next step.\n\nThe stopping criteria for a SEMI JOIN and a NAAJ would have to be slightly different though:\n- As soon as we find a match in a SEMI JOIN we are done.\n- In an NAAJ we have to check for both a match and a partial match (one or more NULLs).\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T21:15:59Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "So, what's the plan? should we merge this one first, then do the refactor later, or do that in first place?\n\nEight is good to me.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T21:21:11Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "I would like to merge this first.\n",
    "commit": "2658e0a4e72a810988686d2fb951bc436684db52",
    "createdAt": "2016-04-19T21:28:17Z",
    "diffHunk": "@@ -1447,3 +1450,133 @@ object EmbedSerializerInFilter extends Rule[LogicalPlan] {\n       }\n   }\n }\n+\n+/**\n+ * This rule rewrites predicate sub-queries into left semi/anti joins. The following predicates\n+ * are supported:\n+ * a. EXISTS/NOT EXISTS will be rewritten as semi/anti join, unresolved conditions in Filter\n+ *    will be pulled out as the join conditions.\n+ * b. IN/NOT IN will be rewritten as semi/anti join, unresolved conditions in the Filter will\n+ *    be pulled out as join conditions, value = selected column will also be used as join\n+ *    condition.\n+ */\n+object RewritePredicateSubquery extends Rule[LogicalPlan] with PredicateHelper {\n+  /**\n+   * Pull out all correlated predicates from a given sub-query. This method removes the correlated\n+   * predicates from sub-query [[Filter]]s and adds the references of these predicates to\n+   * all intermediate [[Project]] clauses (if they are missing) in order to be able to evaluate the\n+   * predicates in the join condition.\n+   *\n+   * This method returns the rewritten sub-query and the combined (AND) extracted predicate.\n+   */\n+  private def pullOutCorrelatedPredicates(\n+      subquery: LogicalPlan,\n+      query: LogicalPlan): (LogicalPlan, Option[Expression]) = {\n+    val references = query.outputSet\n+    val predicateMap = mutable.Map.empty[LogicalPlan, Seq[Expression]]\n+    val transformed = subquery transformUp {\n+      case f @ Filter(cond, child) =>\n+        // Find all correlated predicates.\n+        val (correlated, local) = splitConjunctivePredicates(cond).partition { e =>\n+          e.references.intersect(references).nonEmpty\n+        }\n+        // Rewrite the filter without the correlated predicates if any.\n+        correlated match {\n+          case Nil => f\n+          case xs if local.nonEmpty =>\n+            val newFilter = Filter(local.reduce(And), child)\n+            predicateMap += newFilter -> correlated\n+            newFilter\n+          case xs =>\n+            predicateMap += child -> correlated\n+            child\n+        }\n+      case p @ Project(expressions, child) =>\n+        // Find all pulled out predicates defined in the Project's subtree.\n+        val localPredicates = p.collect(predicateMap).flatten\n+\n+        // Determine which correlated predicate references are missing from this project.\n+        val localPredicateReferences = localPredicates\n+          .map(_.references)\n+          .reduceOption(_ ++ _)\n+          .getOrElse(AttributeSet.empty)\n+        val missingReferences = localPredicateReferences -- p.references -- query.outputSet\n+\n+        // Create a new project if we need to add missing references.\n+        if (missingReferences.nonEmpty) {\n+          Project(expressions ++ missingReferences, child)\n+        } else {\n+          p\n+        }\n+    }\n+    (transformed, predicateMap.values.flatten.reduceOption(And))\n+  }\n+\n+  /**\n+   * Prepare an [[InSubQuery]] by rewriting it (in case of correlated predicates) and by\n+   * constructing the required join condition. Both the rewritten subquery and the constructed\n+   * join condition are returned.\n+   */\n+  private def rewriteInSubquery(\n+      subquery: InSubQuery,\n+      query: LogicalPlan): (LogicalPlan, Expression) = {\n+    val expressions = subquery.expressions\n+    val (resolved, joinCondition) = pullOutCorrelatedPredicates(subquery.query, query)\n+    val conditions = joinCondition.toSeq ++ expressions.zip(resolved.output).map(EqualTo.tupled)\n+    (resolved, conditions.reduceLeft(And))\n+  }\n+\n+  def apply(plan: LogicalPlan): LogicalPlan = plan transform {\n+    case f @ Filter(condition, child) =>\n+      val (withSubquery, withoutSubquery) =\n+        splitConjunctivePredicates(condition).partition(PredicateSubquery.hasPredicateSubquery)\n+\n+      // Construct the pruned filter condition.\n+      val newFilter: LogicalPlan = withoutSubquery match {\n+        case Nil => child\n+        case conditions => Filter(conditions.reduce(And), child)\n+      }\n+\n+      // Filter the plan by applying left semi and left anti joins.\n+      withSubquery.foldLeft(newFilter) {\n+        case (p, Exists(sub)) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftSemi, joinCondition)\n+        case (p, Not(Exists(sub))) =>\n+          val (resolved, joinCondition) = pullOutCorrelatedPredicates(sub, p)\n+          Join(p, resolved, LeftAnti, joinCondition)\n+        case (p, in: InSubQuery) =>\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+          Join(p, resolved, LeftSemi, Option(cond))\n+        case (p, Not(in: InSubQuery)) =>\n+          // This is a NULL-aware (left) anti join (NAAJ).\n+          // We currently only allow subqueries with non-nullable fields. In this way we can plan a\n+          // regular ANTI join, instead of a much more complex NAAJ (which is not yet available in\n+          // Spark SQL). In order to get the NAAJ semantically right, we need to add a filter to\n+          // left hand side of the query that checks that either all columns are non-null or that\n+          // the right hand side is empty.\n+          val (resolved, cond) = rewriteInSubquery(in, p)\n+\n+          // Make absolutely sure that the rewritten query contains no nullable fields. We re-check\n+          // this here because the rewritten query can contain pulled-up nullable columns.\n+          if (resolved.output.exists(_.nullable)) {\n+            throw new AnalysisException(\"NOT IN with nullable subquery is not supported. \" +\n+              \"Please use a non-nullable sub-query or rewrite this using NOT EXISTS.\")\n+          }\n+\n+          // Construct filter for the left hand side\n+          val count = Alias(AggregateExpression(Count(Literal(1)), Complete, false), \"cnt\")()\n+          val isEmpty = EqualTo(ScalarSubquery(Aggregate(Nil, Seq(count), resolved)), Literal(0L))"
  }],
  "prId": 12306
}]