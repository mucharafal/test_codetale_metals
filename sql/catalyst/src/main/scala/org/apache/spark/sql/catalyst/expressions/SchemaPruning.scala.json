[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Except for `collectStructType` and `pruneSerializer`, other methods are moved here from `ParquetSchemaPruning`.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T02:55:37Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "As @HyukjinKwon suggested, let's remove `private[sql]` here, too.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:13:33Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {"
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`def` -> `private def`.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:10:46Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved.\n+   */\n+  def pruneDataSchema(\n+      fileDataSchema: StructType,\n+      requestedRootFields: Seq[RootField]): StructType = {\n+    // Merge the requested root fields into a single schema. Note the ordering of the fields\n+    // in the resulting schema may differ from their ordering in the logical relation's\n+    // original schema\n+    val mergedSchema = requestedRootFields\n+      .map { case root: RootField => StructType(Array(root.field)) }\n+      .reduceLeft(_ merge _)\n+    val dataSchemaFieldNames = fileDataSchema.fieldNames.toSet\n+    val mergedDataSchema =\n+      StructType(mergedSchema.filter(f => dataSchemaFieldNames.contains(f.name)))\n+    // Sort the fields of mergedDataSchema according to their order in dataSchema,\n+    // recursively. This makes mergedDataSchema a pruned schema of dataSchema\n+    sortLeftFieldsByRight(mergedDataSchema, fileDataSchema).asInstanceOf[StructType]\n+  }\n+\n+  /**\n+   * Sorts the fields and descendant fields of structs in left according to their order in\n+   * right. This function assumes that the fields of left are a subset of the fields of\n+   * right, recursively. That is, left is a \"subschema\" of right, ignoring order of\n+   * fields.\n+   */\n+  def sortLeftFieldsByRight(left: DataType, right: DataType): DataType ="
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Shall we indent like the following?\r\n```scala\r\ndef identifyRootFields(\r\n    projects: Seq[NamedExpression],\r\n    filters: Seq[Expression]): Seq[RootField] = {\r\n```",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:11:43Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved.\n+   */\n+  def pruneDataSchema(\n+      fileDataSchema: StructType,\n+      requestedRootFields: Seq[RootField]): StructType = {\n+    // Merge the requested root fields into a single schema. Note the ordering of the fields\n+    // in the resulting schema may differ from their ordering in the logical relation's\n+    // original schema\n+    val mergedSchema = requestedRootFields\n+      .map { case root: RootField => StructType(Array(root.field)) }\n+      .reduceLeft(_ merge _)\n+    val dataSchemaFieldNames = fileDataSchema.fieldNames.toSet\n+    val mergedDataSchema =\n+      StructType(mergedSchema.filter(f => dataSchemaFieldNames.contains(f.name)))\n+    // Sort the fields of mergedDataSchema according to their order in dataSchema,\n+    // recursively. This makes mergedDataSchema a pruned schema of dataSchema\n+    sortLeftFieldsByRight(mergedDataSchema, fileDataSchema).asInstanceOf[StructType]\n+  }\n+\n+  /**\n+   * Sorts the fields and descendant fields of structs in left according to their order in\n+   * right. This function assumes that the fields of left are a subset of the fields of\n+   * right, recursively. That is, left is a \"subschema\" of right, ignoring order of\n+   * fields.\n+   */\n+  def sortLeftFieldsByRight(left: DataType, right: DataType): DataType =\n+    (left, right) match {\n+      case (ArrayType(leftElementType, containsNull), ArrayType(rightElementType, _)) =>\n+        ArrayType(\n+          sortLeftFieldsByRight(leftElementType, rightElementType),\n+          containsNull)\n+      case (MapType(leftKeyType, leftValueType, containsNull),\n+      MapType(rightKeyType, rightValueType, _)) =>\n+        MapType(\n+          sortLeftFieldsByRight(leftKeyType, rightKeyType),\n+          sortLeftFieldsByRight(leftValueType, rightValueType),\n+          containsNull)\n+      case (leftStruct: StructType, rightStruct: StructType) =>\n+        val filteredRightFieldNames = rightStruct.fieldNames.filter(leftStruct.fieldNames.contains)\n+        val sortedLeftFields = filteredRightFieldNames.map { fieldName =>\n+          val leftFieldType = leftStruct(fieldName).dataType\n+          val rightFieldType = rightStruct(fieldName).dataType\n+          val sortedLeftFieldType = sortLeftFieldsByRight(leftFieldType, rightFieldType)\n+          StructField(fieldName, sortedLeftFieldType, nullable = leftStruct(fieldName).nullable)\n+        }\n+        StructType(sortedLeftFields)\n+      case _ => left\n+    }\n+\n+  /**\n+   * Returns the set of fields from the Parquet file that the query plan needs.\n+   */\n+  def identifyRootFields(projects: Seq[NamedExpression],\n+      filters: Seq[Expression]): Seq[RootField] = {",
    "line": 80
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "indentation?",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:12:09Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved.\n+   */\n+  def pruneDataSchema(\n+      fileDataSchema: StructType,\n+      requestedRootFields: Seq[RootField]): StructType = {\n+    // Merge the requested root fields into a single schema. Note the ordering of the fields\n+    // in the resulting schema may differ from their ordering in the logical relation's\n+    // original schema\n+    val mergedSchema = requestedRootFields\n+      .map { case root: RootField => StructType(Array(root.field)) }\n+      .reduceLeft(_ merge _)\n+    val dataSchemaFieldNames = fileDataSchema.fieldNames.toSet\n+    val mergedDataSchema =\n+      StructType(mergedSchema.filter(f => dataSchemaFieldNames.contains(f.name)))\n+    // Sort the fields of mergedDataSchema according to their order in dataSchema,\n+    // recursively. This makes mergedDataSchema a pruned schema of dataSchema\n+    sortLeftFieldsByRight(mergedDataSchema, fileDataSchema).asInstanceOf[StructType]\n+  }\n+\n+  /**\n+   * Sorts the fields and descendant fields of structs in left according to their order in\n+   * right. This function assumes that the fields of left are a subset of the fields of\n+   * right, recursively. That is, left is a \"subschema\" of right, ignoring order of\n+   * fields.\n+   */\n+  def sortLeftFieldsByRight(left: DataType, right: DataType): DataType =\n+    (left, right) match {\n+      case (ArrayType(leftElementType, containsNull), ArrayType(rightElementType, _)) =>\n+        ArrayType(\n+          sortLeftFieldsByRight(leftElementType, rightElementType),\n+          containsNull)\n+      case (MapType(leftKeyType, leftValueType, containsNull),\n+      MapType(rightKeyType, rightValueType, _)) =>"
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`def` -> `private def`",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:12:46Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved.\n+   */\n+  def pruneDataSchema(\n+      fileDataSchema: StructType,\n+      requestedRootFields: Seq[RootField]): StructType = {\n+    // Merge the requested root fields into a single schema. Note the ordering of the fields\n+    // in the resulting schema may differ from their ordering in the logical relation's\n+    // original schema\n+    val mergedSchema = requestedRootFields\n+      .map { case root: RootField => StructType(Array(root.field)) }\n+      .reduceLeft(_ merge _)\n+    val dataSchemaFieldNames = fileDataSchema.fieldNames.toSet\n+    val mergedDataSchema =\n+      StructType(mergedSchema.filter(f => dataSchemaFieldNames.contains(f.name)))\n+    // Sort the fields of mergedDataSchema according to their order in dataSchema,\n+    // recursively. This makes mergedDataSchema a pruned schema of dataSchema\n+    sortLeftFieldsByRight(mergedDataSchema, fileDataSchema).asInstanceOf[StructType]\n+  }\n+\n+  /**\n+   * Sorts the fields and descendant fields of structs in left according to their order in\n+   * right. This function assumes that the fields of left are a subset of the fields of\n+   * right, recursively. That is, left is a \"subschema\" of right, ignoring order of\n+   * fields.\n+   */\n+  def sortLeftFieldsByRight(left: DataType, right: DataType): DataType =\n+    (left, right) match {\n+      case (ArrayType(leftElementType, containsNull), ArrayType(rightElementType, _)) =>\n+        ArrayType(\n+          sortLeftFieldsByRight(leftElementType, rightElementType),\n+          containsNull)\n+      case (MapType(leftKeyType, leftValueType, containsNull),\n+      MapType(rightKeyType, rightValueType, _)) =>\n+        MapType(\n+          sortLeftFieldsByRight(leftKeyType, rightKeyType),\n+          sortLeftFieldsByRight(leftValueType, rightValueType),\n+          containsNull)\n+      case (leftStruct: StructType, rightStruct: StructType) =>\n+        val filteredRightFieldNames = rightStruct.fieldNames.filter(leftStruct.fieldNames.contains)\n+        val sortedLeftFields = filteredRightFieldNames.map { fieldName =>\n+          val leftFieldType = leftStruct(fieldName).dataType\n+          val rightFieldType = rightStruct(fieldName).dataType\n+          val sortedLeftFieldType = sortLeftFieldsByRight(leftFieldType, rightFieldType)\n+          StructField(fieldName, sortedLeftFieldType, nullable = leftStruct(fieldName).nullable)\n+        }\n+        StructType(sortedLeftFields)\n+      case _ => left\n+    }\n+\n+  /**\n+   * Returns the set of fields from the Parquet file that the query plan needs.\n+   */\n+  def identifyRootFields(projects: Seq[NamedExpression],\n+      filters: Seq[Expression]): Seq[RootField] = {\n+    val projectionRootFields = projects.flatMap(getRootFields)\n+    val filterRootFields = filters.flatMap(getRootFields)\n+\n+    // Kind of expressions don't need to access any fields of a root fields, e.g., `IsNotNull`.\n+    // For them, if there are any nested fields accessed in the query, we don't need to add root\n+    // field access of above expressions.\n+    // For example, for a query `SELECT name.first FROM contacts WHERE name IS NOT NULL`,\n+    // we don't need to read nested fields of `name` struct other than `first` field.\n+    val (rootFields, optRootFields) = (projectionRootFields ++ filterRootFields)\n+      .distinct.partition(!_.prunedIfAnyChildAccessed)\n+\n+    optRootFields.filter { opt =>\n+      !rootFields.exists { root =>\n+        root.field.name == opt.field.name && {\n+          // Checking if current optional root field can be pruned.\n+          // For each required root field, we merge it with the optional root field:\n+          // 1. If this optional root field has nested fields and any nested field of it is used\n+          //    in the query, the merged field type must equal to the optional root field type.\n+          //    We can prune this optional root field. For example, for optional root field\n+          //    `struct<name:struct<middle:string,last:string>>`, if its field\n+          //    `struct<name:struct<last:string>>` is used, we don't need to add this optional\n+          //    root field.\n+          // 2. If this optional root field has no nested fields, the merged field type equals\n+          //    to the optional root field only if they are the same. If they are, we can prune\n+          //    this optional root field too.\n+          val rootFieldType = StructType(Array(root.field))\n+          val optFieldType = StructType(Array(opt.field))\n+          val merged = optFieldType.merge(rootFieldType)\n+          merged.sameType(optFieldType)\n+        }\n+      }\n+    } ++ rootFields\n+  }\n+\n+  /**\n+   * Gets the root (aka top-level, no-parent) [[StructField]]s for the given [[Expression]].\n+   * When expr is an [[Attribute]], construct a field around it and indicate that that\n+   * field was derived from an attribute.\n+   */\n+  def getRootFields(expr: Expression): Seq[RootField] = {"
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Just curious. Is it difficult for map type?\r\nFor TODO, let's create a JIRA issue and use like `TODO(SPARK-XXXXX)`.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T07:33:53Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type."
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I'd say it's not difficult. But it needs more than the pruning logic for struct and array of struct. To keep this PR not too much big (now it is relatively large), I leave it as a TODO.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T09:22:30Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type."
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I created SPARK-26847 to track it. Once this gets in, I will make a PR to finish it.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-08T01:25:49Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type."
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Is this public for only testing purpose at `SchemaPruningSuite`?",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T08:01:09Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Yes.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-08T01:05:40Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {"
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Since this is in `catalyst` module from now, we had better update this description more properly.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T08:07:44Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved."
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Please remove `from the Parquet file` and update this description properly because this is irrelevant to `Parquet` from now.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-07T08:34:04Z",
    "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+private[sql] object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO: support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO: support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer(\n+      serializer: NamedExpression,\n+      prunedDataType: DataType): NamedExpression = {\n+    val prunedStructTypes = collectStructType(prunedDataType, ArrayBuffer.empty[StructType])\n+    var structTypeIndex = 0\n+\n+    val prunedSerializer = serializer.transformDown {\n+      case s: CreateNamedStruct if structTypeIndex < prunedStructTypes.size =>\n+        val prunedType = prunedStructTypes(structTypeIndex)\n+\n+        // Filters out the pruned fields.\n+        val prunedFields = s.nameExprs.zip(s.valExprs).filter { case (nameExpr, _) =>\n+          val name = nameExpr.eval(EmptyRow).toString\n+          prunedType.fieldNames.exists { fieldName =>\n+            if (SQLConf.get.caseSensitiveAnalysis) {\n+              fieldName.equals(name)\n+            } else {\n+              fieldName.equalsIgnoreCase(name)\n+            }\n+          }\n+        }.flatMap(pair => Seq(pair._1, pair._2))\n+\n+        structTypeIndex += 1\n+        CreateNamedStruct(prunedFields)\n+    }.transformUp {\n+      // When we change nested serializer data type, `If` expression will be unresolved because\n+      // literal null's data type doesn't match now. We need to align it with new data type.\n+      // Note: we should do `transformUp` explicitly to change data types.\n+      case i @ If(_: IsNull, Literal(null, dt), ser) if !dt.sameType(ser.dataType) =>\n+        i.copy(trueValue = Literal(null, ser.dataType))\n+    }.asInstanceOf[NamedExpression]\n+\n+    if (prunedSerializer.dataType.sameType(prunedDataType)) {\n+      prunedSerializer\n+    } else {\n+      serializer\n+    }\n+  }\n+\n+  /**\n+   * Filters the schema from the given file by the requested fields.\n+   * Schema field ordering from the file is preserved.\n+   */\n+  def pruneDataSchema(\n+      fileDataSchema: StructType,\n+      requestedRootFields: Seq[RootField]): StructType = {\n+    // Merge the requested root fields into a single schema. Note the ordering of the fields\n+    // in the resulting schema may differ from their ordering in the logical relation's\n+    // original schema\n+    val mergedSchema = requestedRootFields\n+      .map { case root: RootField => StructType(Array(root.field)) }\n+      .reduceLeft(_ merge _)\n+    val dataSchemaFieldNames = fileDataSchema.fieldNames.toSet\n+    val mergedDataSchema =\n+      StructType(mergedSchema.filter(f => dataSchemaFieldNames.contains(f.name)))\n+    // Sort the fields of mergedDataSchema according to their order in dataSchema,\n+    // recursively. This makes mergedDataSchema a pruned schema of dataSchema\n+    sortLeftFieldsByRight(mergedDataSchema, fileDataSchema).asInstanceOf[StructType]\n+  }\n+\n+  /**\n+   * Sorts the fields and descendant fields of structs in left according to their order in\n+   * right. This function assumes that the fields of left are a subset of the fields of\n+   * right, recursively. That is, left is a \"subschema\" of right, ignoring order of\n+   * fields.\n+   */\n+  def sortLeftFieldsByRight(left: DataType, right: DataType): DataType =\n+    (left, right) match {\n+      case (ArrayType(leftElementType, containsNull), ArrayType(rightElementType, _)) =>\n+        ArrayType(\n+          sortLeftFieldsByRight(leftElementType, rightElementType),\n+          containsNull)\n+      case (MapType(leftKeyType, leftValueType, containsNull),\n+      MapType(rightKeyType, rightValueType, _)) =>\n+        MapType(\n+          sortLeftFieldsByRight(leftKeyType, rightKeyType),\n+          sortLeftFieldsByRight(leftValueType, rightValueType),\n+          containsNull)\n+      case (leftStruct: StructType, rightStruct: StructType) =>\n+        val filteredRightFieldNames = rightStruct.fieldNames.filter(leftStruct.fieldNames.contains)\n+        val sortedLeftFields = filteredRightFieldNames.map { fieldName =>\n+          val leftFieldType = leftStruct(fieldName).dataType\n+          val rightFieldType = rightStruct(fieldName).dataType\n+          val sortedLeftFieldType = sortLeftFieldsByRight(leftFieldType, rightFieldType)\n+          StructField(fieldName, sortedLeftFieldType, nullable = leftStruct(fieldName).nullable)\n+        }\n+        StructType(sortedLeftFields)\n+      case _ => left\n+    }\n+\n+  /**\n+   * Returns the set of fields from the Parquet file that the query plan needs."
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "can you point out which methods are new in this file?",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-18T04:43:31Z",
    "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+object SchemaPruning {",
    "line": 22
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "`collectStructType` and `pruneSerializer` are new methods.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-18T04:49:10Z",
    "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+object SchemaPruning {",
    "line": 22
  }],
  "prId": 23740
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "this is specific to the column pruning of object serializers, shall we move this method there instead of putting it in the util?",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-18T06:18:32Z",
    "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO(SPARK-26847): support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO(SPARK-26847): support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer("
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "OK. I will do it later.",
    "commit": "ef392723a3ed8bc53332e15fc98c34ca4ff92cfb",
    "createdAt": "2019-02-18T07:34:51Z",
    "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+\n+object SchemaPruning {\n+\n+  /**\n+   * Collects all struct types from given data type object, recursively. Supports struct and array\n+   * types for now.\n+   * TODO(SPARK-26847): support map type.\n+   */\n+  def collectStructType(dt: DataType, structs: ArrayBuffer[StructType]): ArrayBuffer[StructType] = {\n+    dt match {\n+      case s @ StructType(fields) =>\n+        structs += s\n+        fields.map(f => collectStructType(f.dataType, structs))\n+      case ArrayType(elementType, _) =>\n+        collectStructType(elementType, structs)\n+      case _ =>\n+    }\n+    structs\n+  }\n+\n+  /**\n+   * This method prunes given serializer expression by given pruned data type. For example,\n+   * given a serializer creating struct(a int, b int) and pruned data type struct(a int),\n+   * this method returns pruned serializer creating struct(a int). For now it supports to\n+   * prune nested fields in struct and array of struct.\n+   * TODO(SPARK-26847): support to prune nested fields in key and value of map type.\n+   */\n+  def pruneSerializer("
  }],
  "prId": 23740
}]