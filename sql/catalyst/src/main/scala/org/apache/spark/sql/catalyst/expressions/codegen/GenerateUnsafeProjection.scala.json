[{
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Pass the correct precision and scale, we may use it in future.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:02:53Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\""
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should we delete all the old code?\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:14:32Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());\n+\n+      $bufferHolder.cursor += 8;\n+      // Remember the current cursor so that we can write numBytes of key array later.\n+      final int $tmpCursor = $bufferHolder.cursor;\n+\n+      ${writeArrayToBuffer(ctx, keys, keyType, bufferHolder, needHeader = false)}\n+      // Write the numBytes of key array into second 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $tmpCursor - 4, $bufferHolder.cursor - $tmpCursor);\n+\n+      ${writeArrayToBuffer(ctx, values, valueType, bufferHolder, needHeader = false)}\n+    \"\"\"\n+  }\n+\n+  private def writePrimitiveType(\n+      ctx: CodeGenContext,\n+      input: String,\n+      dt: DataType,\n+      buffer: String,\n+      offset: String) = {\n+    assert(ctx.isPrimitiveType(dt))\n+\n+    val putMethod = s\"put${ctx.primitiveTypeName(dt)}\"\n+\n+    dt match {\n+      case FloatType | DoubleType =>\n+        val normalized = ctx.freshName(\"normalized\")\n+        val boxedType = ctx.boxedType(dt)\n+        val handleNaN =\n+          s\"\"\"\n+            final ${ctx.javaType(dt)} $normalized;\n+            if ($boxedType.isNaN($input)) {\n+              $normalized = $boxedType.NaN;\n+            } else {\n+              $normalized = $input;\n+            }\n+          \"\"\"\n+\n+        s\"\"\"\n+          $handleNaN\n+          Platform.$putMethod($buffer, $offset, $normalized);\n+        \"\"\"\n+      case _ => s\"Platform.$putMethod($buffer, $offset, $input);\"\n+    }\n+  }\n+\n   def createCode(ctx: CodeGenContext, expressions: Seq[Expression]): GeneratedExpressionCode = {\n     val exprEvals = expressions.map(e => e.gen(ctx))\n     val exprTypes = expressions.map(_.dataType)\n-    createCodeForStruct(ctx, \"i\", exprEvals, exprTypes)",
    "line": 276
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "I'd like not, to keep the diff of this PR clear. We can remove the old code in a follow-up PR.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-02T01:22:01Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());\n+\n+      $bufferHolder.cursor += 8;\n+      // Remember the current cursor so that we can write numBytes of key array later.\n+      final int $tmpCursor = $bufferHolder.cursor;\n+\n+      ${writeArrayToBuffer(ctx, keys, keyType, bufferHolder, needHeader = false)}\n+      // Write the numBytes of key array into second 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $tmpCursor - 4, $bufferHolder.cursor - $tmpCursor);\n+\n+      ${writeArrayToBuffer(ctx, values, valueType, bufferHolder, needHeader = false)}\n+    \"\"\"\n+  }\n+\n+  private def writePrimitiveType(\n+      ctx: CodeGenContext,\n+      input: String,\n+      dt: DataType,\n+      buffer: String,\n+      offset: String) = {\n+    assert(ctx.isPrimitiveType(dt))\n+\n+    val putMethod = s\"put${ctx.primitiveTypeName(dt)}\"\n+\n+    dt match {\n+      case FloatType | DoubleType =>\n+        val normalized = ctx.freshName(\"normalized\")\n+        val boxedType = ctx.boxedType(dt)\n+        val handleNaN =\n+          s\"\"\"\n+            final ${ctx.javaType(dt)} $normalized;\n+            if ($boxedType.isNaN($input)) {\n+              $normalized = $boxedType.NaN;\n+            } else {\n+              $normalized = $input;\n+            }\n+          \"\"\"\n+\n+        s\"\"\"\n+          $handleNaN\n+          Platform.$putMethod($buffer, $offset, $normalized);\n+        \"\"\"\n+      case _ => s\"Platform.$putMethod($buffer, $offset, $input);\"\n+    }\n+  }\n+\n   def createCode(ctx: CodeGenContext, expressions: Seq[Expression]): GeneratedExpressionCode = {\n     val exprEvals = expressions.map(e => e.gen(ctx))\n     val exprTypes = expressions.map(_.dataType)\n-    createCodeForStruct(ctx, \"i\", exprEvals, exprTypes)",
    "line": 276
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Should we call grow first?\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:24:11Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "This will be wrong on BigEndian machine, we should use putLong()\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:28:49Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());\n+\n+      $bufferHolder.cursor += 8;\n+      // Remember the current cursor so that we can write numBytes of key array later.\n+      final int $tmpCursor = $bufferHolder.cursor;\n+\n+      ${writeArrayToBuffer(ctx, keys, keyType, bufferHolder, needHeader = false)}\n+      // Write the numBytes of key array into second 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $tmpCursor - 4, $bufferHolder.cursor - $tmpCursor);",
    "line": 235
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Never mind, I was wrong.\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:33:26Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());\n+\n+      $bufferHolder.cursor += 8;\n+      // Remember the current cursor so that we can write numBytes of key array later.\n+      final int $tmpCursor = $bufferHolder.cursor;\n+\n+      ${writeArrayToBuffer(ctx, keys, keyType, bufferHolder, needHeader = false)}\n+      // Write the numBytes of key array into second 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $tmpCursor - 4, $bufferHolder.cursor - $tmpCursor);",
    "line": 235
  }, {
    "author": {
      "login": "davies"
    },
    "body": "Could you document the format of UnsafeArrayData and UnsafeMapData somewhere?\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-01T20:34:15Z",
    "diffHunk": "@@ -393,10 +393,278 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, 0, 0);\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check.\n+  private def writeMapToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      keyType: DataType,\n+      valueType: DataType,\n+      bufferHolder: String): String = {\n+    val keys = ctx.freshName(\"keys\")\n+    val values = ctx.freshName(\"values\")\n+    val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+    s\"\"\"\n+      final ArrayData $keys = $input.keyArray();\n+      final ArrayData $values = $input.valueArray();\n+\n+      // Write the numElements into first 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $bufferHolder.cursor, $keys.numElements());\n+\n+      $bufferHolder.cursor += 8;\n+      // Remember the current cursor so that we can write numBytes of key array later.\n+      final int $tmpCursor = $bufferHolder.cursor;\n+\n+      ${writeArrayToBuffer(ctx, keys, keyType, bufferHolder, needHeader = false)}\n+      // Write the numBytes of key array into second 4 bytes.\n+      Platform.putInt($bufferHolder.buffer, $tmpCursor - 4, $bufferHolder.cursor - $tmpCursor);",
    "line": 235
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "private\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T17:13:02Z",
    "diffHunk": "@@ -393,10 +393,282 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName"
  }],
  "prId": 8747
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "todo -> TODO\n",
    "commit": "d7f941d4edc6e3165790f2546fc3e7f378f04250",
    "createdAt": "2015-10-05T17:19:18Z",
    "diffHunk": "@@ -393,10 +393,282 @@ object GenerateUnsafeProjection extends CodeGenerator[Seq[Expression], UnsafePro\n     case _ => input\n   }\n \n+  val rowWriterClass = classOf[UnsafeRowWriter].getName\n+  val arrayWriterClass = classOf[UnsafeArrayWriter].getName\n+\n+  // todo: if the nullability of field is correct, we can use it to save null check.\n+  private def writeStructToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      fieldTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val fieldEvals = fieldTypes.zipWithIndex.map { case (dt, i) =>\n+      val fieldName = ctx.freshName(\"fieldName\")\n+      val code = s\"final ${ctx.javaType(dt)} $fieldName = ${ctx.getValue(input, dt, i.toString)};\"\n+      val isNull = s\"$input.isNullAt($i)\"\n+      GeneratedExpressionCode(code, isNull, fieldName)\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeRow) {\n+        $rowWriterClass.directWrite($bufferHolder, (UnsafeRow) $input);\n+      } else {\n+        ${writeExpressionsToBuffer(ctx, input, fieldEvals, fieldTypes, bufferHolder)}\n+      }\n+    \"\"\"\n+  }\n+\n+  private def writeExpressionsToBuffer(\n+      ctx: CodeGenContext,\n+      row: String,\n+      inputs: Seq[GeneratedExpressionCode],\n+      inputTypes: Seq[DataType],\n+      bufferHolder: String): String = {\n+    val rowWriter = ctx.freshName(\"rowWriter\")\n+    ctx.addMutableState(rowWriterClass, rowWriter, s\"this.$rowWriter = new $rowWriterClass();\")\n+\n+    val writeFields = inputs.zip(inputTypes).zipWithIndex.map {\n+      case ((input, dt), index) =>\n+        val tmpCursor = ctx.freshName(\"tmpCursor\")\n+\n+        val setNull = dt match {\n+          case t: DecimalType if t.precision > Decimal.MAX_LONG_DIGITS =>\n+            // Can't call setNullAt() for DecimalType with precision larger than 18.\n+            s\"$rowWriter.write($index, null, ${t.precision}, ${t.scale});\"\n+          case _ => s\"$rowWriter.setNullAt($index);\"\n+        }\n+\n+        val writeField = dt match {\n+          case t: StructType =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeStructToBuffer(ctx, input.primitive, t.map(_.dataType), bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case a @ ArrayType(et, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeArrayToBuffer(ctx, input.primitive, et, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignToWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case m @ MapType(kt, vt, _) =>\n+            s\"\"\"\n+              // Remember the current cursor so that we can calculate how many bytes are\n+              // written later.\n+              final int $tmpCursor = $bufferHolder.cursor;\n+              ${writeMapToBuffer(ctx, input.primitive, kt, vt, bufferHolder)}\n+              $rowWriter.setOffsetAndSize($index, $tmpCursor, $bufferHolder.cursor - $tmpCursor);\n+              $rowWriter.alignToWords($bufferHolder.cursor - $tmpCursor);\n+            \"\"\"\n+\n+          case _ if ctx.isPrimitiveType(dt) =>\n+            val fieldOffset = ctx.freshName(\"fieldOffset\")\n+            s\"\"\"\n+              final long $fieldOffset = $rowWriter.getFieldOffset($index);\n+              Platform.putLong($bufferHolder.buffer, $fieldOffset, 0L);\n+              ${writePrimitiveType(ctx, input.primitive, dt, s\"$bufferHolder.buffer\", fieldOffset)}\n+            \"\"\"\n+\n+          case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+            s\"$rowWriter.writeCompactDecimal($index, ${input.primitive}, \" +\n+              s\"${t.precision}, ${t.scale});\"\n+\n+          case t: DecimalType =>\n+            s\"$rowWriter.write($index, ${input.primitive}, ${t.precision}, ${t.scale});\"\n+\n+          case NullType => \"\"\n+\n+          case _ => s\"$rowWriter.write($index, ${input.primitive});\"\n+        }\n+\n+        s\"\"\"\n+          ${input.code}\n+          if (${input.isNull}) {\n+            $setNull\n+          } else {\n+            $writeField\n+          }\n+        \"\"\"\n+    }\n+\n+    s\"\"\"\n+      $rowWriter.initialize($bufferHolder, ${inputs.length});\n+      ${ctx.splitExpressions(row, writeFields)}\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of array element is correct, we can use it to save null check.\n+  private def writeArrayToBuffer(\n+      ctx: CodeGenContext,\n+      input: String,\n+      elementType: DataType,\n+      bufferHolder: String,\n+      needHeader: Boolean = true): String = {\n+    val arrayWriter = ctx.freshName(\"arrayWriter\")\n+    ctx.addMutableState(arrayWriterClass, arrayWriter,\n+      s\"this.$arrayWriter = new $arrayWriterClass();\")\n+    val numElements = ctx.freshName(\"numElements\")\n+    val index = ctx.freshName(\"index\")\n+    val element = ctx.freshName(\"element\")\n+\n+    val jt = ctx.javaType(elementType)\n+\n+    val fixedElementSize = elementType match {\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS => 8\n+      case _ if ctx.isPrimitiveType(jt) => elementType.defaultSize\n+      case _ => 0\n+    }\n+\n+    val writeElement = elementType match {\n+      case t: StructType =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeStructToBuffer(ctx, element, t.map(_.dataType), bufferHolder)}\n+        \"\"\"\n+\n+      case a @ ArrayType(et, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeArrayToBuffer(ctx, element, et, bufferHolder)}\n+        \"\"\"\n+\n+      case m @ MapType(kt, vt, _) =>\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writeMapToBuffer(ctx, element, kt, vt, bufferHolder)}\n+        \"\"\"\n+\n+      case _ if ctx.isPrimitiveType(elementType) =>\n+        // Should we do word align?\n+        val dataSize = elementType.defaultSize\n+\n+        s\"\"\"\n+          $arrayWriter.setOffset($index);\n+          ${writePrimitiveType(ctx, element, elementType,\n+            s\"$bufferHolder.buffer\", s\"$bufferHolder.cursor\")}\n+          $bufferHolder.cursor += $dataSize;\n+        \"\"\"\n+\n+      case t: DecimalType if t.precision <= Decimal.MAX_LONG_DIGITS =>\n+        s\"$arrayWriter.writeCompactDecimal($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case t: DecimalType =>\n+        s\"$arrayWriter.write($index, $element, ${t.precision}, ${t.scale});\"\n+\n+      case NullType => \"\"\n+\n+      case _ => s\"$arrayWriter.write($index, $element);\"\n+    }\n+\n+    s\"\"\"\n+      if ($input instanceof UnsafeArrayData) {\n+        $arrayWriterClass.directWrite($bufferHolder, (UnsafeArrayData) $input, $needHeader);\n+      } else {\n+        final int $numElements = $input.numElements();\n+        $arrayWriter.initialize($bufferHolder, $numElements, $needHeader, $fixedElementSize);\n+\n+        for (int $index = 0; $index < $numElements; $index++) {\n+          if ($input.isNullAt($index)) {\n+            $arrayWriter.setNullAt($index);\n+          } else {\n+            final $jt $element = ${ctx.getValue(input, elementType, index)};\n+            $writeElement\n+          }\n+        }\n+      }\n+    \"\"\"\n+  }\n+\n+  // todo: if the nullability of value element is correct, we can use it to save null check."
  }],
  "prId": 8747
}]