[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Could we not just do this below when we create `lexical`?\n",
    "commit": "b6d1c745c6f22e34949794a55dd2ddc40da50fe9",
    "createdAt": "2015-06-29T23:55:56Z",
    "diffHunk": "@@ -30,12 +30,14 @@ private[sql] abstract class AbstractSparkSQLParser\n \n   def parse(input: String): LogicalPlan = {\n     // Initialize the Keywords.\n-    lexical.initialize(reservedWords)\n+    initLexical\n     phrase(start)(new lexical.Scanner(input)) match {\n       case Success(plan, _) => plan\n       case failureOrError => sys.error(failureOrError.toString)\n     }\n   }\n+  /* One time initialization of lexical.This avoid reinitialization of  lexical in parse method */\n+  protected lazy val initLexical: Unit = lexical.initialize(reservedWords)",
    "line": 21
  }, {
    "author": {
      "login": "vinodkc"
    },
    "body": " 'reservedWords' is generated using reflection. So during non-lazy 'lexical' initialization in constructor, method call to collect  reservedWords will fail as the object construction is still not over.\nCoud you suggest any other approach?\n",
    "commit": "b6d1c745c6f22e34949794a55dd2ddc40da50fe9",
    "createdAt": "2015-06-30T10:08:32Z",
    "diffHunk": "@@ -30,12 +30,14 @@ private[sql] abstract class AbstractSparkSQLParser\n \n   def parse(input: String): LogicalPlan = {\n     // Initialize the Keywords.\n-    lexical.initialize(reservedWords)\n+    initLexical\n     phrase(start)(new lexical.Scanner(input)) match {\n       case Success(plan, _) => plan\n       case failureOrError => sys.error(failureOrError.toString)\n     }\n   }\n+  /* One time initialization of lexical.This avoid reinitialization of  lexical in parse method */\n+  protected lazy val initLexical: Unit = lexical.initialize(reservedWords)",
    "line": 21
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "Hmm, okay I guess that is reasonable.\n",
    "commit": "b6d1c745c6f22e34949794a55dd2ddc40da50fe9",
    "createdAt": "2015-06-30T19:24:13Z",
    "diffHunk": "@@ -30,12 +30,14 @@ private[sql] abstract class AbstractSparkSQLParser\n \n   def parse(input: String): LogicalPlan = {\n     // Initialize the Keywords.\n-    lexical.initialize(reservedWords)\n+    initLexical\n     phrase(start)(new lexical.Scanner(input)) match {\n       case Success(plan, _) => plan\n       case failureOrError => sys.error(failureOrError.toString)\n     }\n   }\n+  /* One time initialization of lexical.This avoid reinitialization of  lexical in parse method */\n+  protected lazy val initLexical: Unit = lexical.initialize(reservedWords)",
    "line": 21
  }],
  "prId": 7015
}]