[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "are there any links you can include for reference?\n",
    "commit": "8d17f21b1f4bb7daa1dcf950330e53d8aebd074b",
    "createdAt": "2015-04-01T01:42:26Z",
    "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+* Licensed to the Apache Software Foundation (ASF) under one or more\n+* contributor license agreements.  See the NOTICE file distributed with\n+* this work for additional information regarding copyright ownership.\n+* The ASF licenses this file to You under the Apache License, Version 2.0\n+* (the \"License\"); you may not use this file except in compliance with\n+* the License.  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+* Unless required by applicable law or agreed to in writing, software\n+* distributed under the License is distributed on an \"AS IS\" BASIS,\n+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+* See the License for the specific language governing permissions and\n+* limitations under the License.\n+*/\n+\n+package org.apache.spark.sql.types\n+\n+/**\n+ *  A UTF-8 String used only in SparkSQL\n+ */\n+\n+private[sql] final class UTF8String extends Ordered[UTF8String] with Serializable {\n+  private var bytes: Array[Byte] = _\n+\n+  def set(str: String): UTF8String = {\n+    bytes = str.getBytes(\"utf-8\")\n+    this\n+  }\n+\n+  def set(bytes: Array[Byte]): UTF8String = {\n+    this.bytes = bytes.clone()\n+    this\n+  }\n+\n+  def length(): Int = {\n+    var len = 0\n+    var i: Int = 0\n+    while (i < bytes.length) {\n+      val b = bytes(i)\n+      i += 1\n+      if (b >= 196) {\n+        i += UTF8String.bytesFromUTF8(b - 196)\n+      }\n+      len += 1\n+    }\n+    len\n+  }\n+\n+  def getBytes: Array[Byte] = {\n+    bytes\n+  }\n+\n+  def slice(start: Int, end: Int): UTF8String = {\n+    if (end <= start || start >= bytes.length || bytes == null) {\n+      new UTF8String\n+    }\n+\n+    var c = 0\n+    var i: Int = 0\n+    while (c < start && i < bytes.length) {\n+      val b = bytes(i)\n+      i += 1\n+      if (b >= 196) {\n+        i += UTF8String.bytesFromUTF8(b - 196)\n+      }\n+      c += 1\n+    }\n+    val bstart = i\n+    while (c < end && i < bytes.length) {\n+      val b = bytes(i)\n+      i += 1\n+      if (b >= 196) {\n+        i += UTF8String.bytesFromUTF8(b - 196)\n+      }\n+      c += 1\n+    }\n+    UTF8String(java.util.Arrays.copyOfRange(bytes, bstart, i))\n+  }\n+\n+  def contains(sub: UTF8String): Boolean = {\n+    bytes.containsSlice(sub.bytes)\n+  }\n+\n+  def startsWith(prefix: UTF8String): Boolean = {\n+    bytes.startsWith(prefix.bytes)\n+  }\n+\n+  def endsWith(suffix: UTF8String): Boolean = {\n+    bytes.endsWith(suffix.bytes)\n+  }\n+\n+  def toUpperCase(): UTF8String = {\n+    UTF8String(toString().toUpperCase)\n+  }\n+\n+  def toLowerCase(): UTF8String = {\n+    UTF8String(toString().toLowerCase)\n+  }\n+\n+  override def toString(): String = {\n+    new String(bytes, \"utf-8\")\n+  }\n+\n+  override def clone(): UTF8String = new UTF8String().set(this.bytes)\n+\n+  override def compare(other: UTF8String): Int = {\n+    var i: Int = 0\n+    while (i < bytes.length && i < other.bytes.length) {\n+      val res = bytes(i).compareTo(other.bytes(i))\n+      if (res != 0) return res\n+      i += 1\n+    }\n+    bytes.length - other.bytes.length\n+  }\n+\n+  override def compareTo(other: UTF8String): Int = {\n+    compare(other)\n+  }\n+\n+  override def equals(other: Any): Boolean = other match {\n+    case s: UTF8String =>\n+      java.util.Arrays.equals(bytes, s.bytes)\n+    case s: String =>\n+      bytes.length >= s.length && length() == s.length && toString() == s\n+    case _ =>\n+      false\n+  }\n+\n+  override def hashCode(): Int = {\n+    java.util.Arrays.hashCode(bytes)\n+  }\n+}\n+\n+private[sql] object UTF8String {\n+  // number of tailing bytes in a UTF8 sequence for a code point\n+  private[types] val bytesFromUTF8: Array[Int] = Array(1, 1, 1, 1, 1,"
  }],
  "prId": 5303
}]