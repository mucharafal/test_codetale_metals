[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "remove this import\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-28T02:06:47Z",
    "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.mathfuncs\n+\n+import math._"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "looks like int/float/long are only used for signum. I think we can remove the non-double signum, and just let the auto cast you added handle it for all the types.\n\nI also checked with @mengxr on this. Supporting only double as the output type should be enough.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-28T06:13:36Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.mathfuncs\n+\n+import org.apache.spark.sql.catalyst.expressions.{ExpectsInputTypes, Expression, Row, UnaryExpression}\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * A unary expression specifically for math functions. Math Functions expect a specific type of\n+ * input format, therefore these functions extend `ExpectsInputTypes`.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpression(name: String)\n+  extends UnaryExpression with Serializable with ExpectsInputTypes {\n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take a `Double` as input and return\n+ * a `Double`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  \n+  override def expectedChildTypes: Seq[DataType] = Seq(DoubleType)\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(evalE.asInstanceOf[Double])\n+      if (result.isNaN) null else result\n+    }\n+  }\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take an `Int` as input and return\n+ * an `Int`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)",
    "line": 67
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "here too - would be great to sort them alphabetically. you can use the command line sort to do this for you.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-28T06:14:47Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.mathfuncs\n+\n+import org.apache.spark.sql.catalyst.expressions.{ExpectsInputTypes, Expression, Row, UnaryExpression}\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * A unary expression specifically for math functions. Math Functions expect a specific type of\n+ * input format, therefore these functions extend `ExpectsInputTypes`.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpression(name: String)\n+  extends UnaryExpression with Serializable with ExpectsInputTypes {\n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take a `Double` as input and return\n+ * a `Double`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  \n+  override def expectedChildTypes: Seq[DataType] = Seq(DoubleType)\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(evalE.asInstanceOf[Double])\n+      if (result.isNaN) null else result\n+    }\n+  }\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take an `Int` as input and return\n+ * an `Int`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = IntegerType\n+  override def expectedChildTypes: Seq[DataType] = Seq(IntegerType)\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) null else f(evalE.asInstanceOf[Int])\n+  }\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take a `Float` as input and return\n+ * a `Float`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+  override def expectedChildTypes: Seq[DataType] = Seq(FloatType)\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(evalE.asInstanceOf[Float])\n+      if (result.isNaN) null else result\n+    }\n+  }\n+}\n+\n+/**\n+ * A unary expression specifically for math functions that take a `Long` as input and return\n+ * a `Long`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+  override def expectedChildTypes: Seq[DataType] = Seq(LongType)\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) null else f(evalE.asInstanceOf[Long])\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")",
    "line": 120
  }],
  "prId": 5616
}]