[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "let's not do the wildcard import here ... too easy to have collision.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-28T01:14:41Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.mathfuncs\n+\n+import math._"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i think this technically becomes\n\n```\nInvalid call to datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}  on unresolved object\n```\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-28T04:39:15Z",
    "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions.mathfuncs\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.catalyst.expressions.{ExpectsInputTypes, BinaryExpression, Expression, Row}\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * A binary expression specifically for math functions that take two `Double`s as input and returns\n+ * a `Double`.\n+ * @param f The math function.\n+ * @param name The short name of the function\n+ */\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryExpression with Serializable with ExpectsInputTypes { self: Product =>\n+  type EvaluatedType = Any\n+  override def symbol: String = null\n+  override def expectedChildTypes: Seq[DataType] = Seq(DoubleType, DoubleType)\n+\n+  override def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  override def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")",
    "line": 47
  }],
  "prId": 5616
}]