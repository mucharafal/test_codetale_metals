[{
  "comments": [{
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Can we make it as the property of the class? We don't want to create new instance for every row, right? And don't forget to mark it as `transient`.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-06-17T07:35:37Z",
    "diffHunk": "@@ -312,3 +312,63 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*)\n+  extends Expression {\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.size > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"differing types in Least (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeCheckResult.TypeCheckSuccess\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    val cmp = GreaterThan"
  }, {
    "author": {
      "login": "chenghao-intel"
    },
    "body": "Oh, sorry, I just notice it's impossible, but after checking the code in `GreateThan`, we can borrow the `ordering = TypeUtils.getOrdering(left.dataType)`\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-06-17T07:37:41Z",
    "diffHunk": "@@ -312,3 +312,63 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*)\n+  extends Expression {\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.size > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"differing types in Least (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeCheckResult.TypeCheckSuccess\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    val cmp = GreaterThan"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "`0 until children.length`\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-12T01:43:11Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+          ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 to children.length - 1).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Expression*) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got GREATEST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.gt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+        ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} > 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 to children.length - 1).map(updateEval).mkString(\"\\n\")}"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "Could you move `${` to next line?\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-12T01:44:19Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+          ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 to children.length - 1).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Expression*) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got GREATEST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.gt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "davies"
    },
    "body": "`${ev.isNull} = false;`\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-12T01:45:08Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+          ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 to children.length - 1).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Expression*) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got GREATEST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.gt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+        ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} > 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};"
  }, {
    "author": {
      "login": "adrian-wang"
    },
    "body": "if ev.isNull, this will be executed.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-12T15:27:50Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+          ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 to children.length - 1).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Expression*) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got GREATEST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.gt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (${ev.isNull} || (!${evalChildren(i).isNull} && ${\n+        ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} > 0)) {\n+          ${ev.isNull} = ${evalChildren(i).isNull};"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "note: this should be Seq[Expression], not vararg\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-13T07:56:25Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "shouldn't least be nullable if any is nullable?\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-13T07:57:20Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)"
  }, {
    "author": {
      "login": "adrian-wang"
    },
    "body": "hive 1.2.0 only return null when all arguments are null.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-13T07:59:30Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)"
  }, {
    "author": {
      "login": "davies"
    },
    "body": "If any child is not nullable, the result will not be nullable.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-13T07:59:50Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Expression*) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)"
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can you add scaladoc explaining the semantics of this expression? also do it for greatest.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-13T18:40:47Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Seq[Expression]) extends Expression {",
    "line": 15
  }],
  "prId": 6851
}, {
  "comments": [{
    "author": {
      "login": "yjshen"
    },
    "body": "Why count against not `NullType`? any reason here?\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-29T14:57:21Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Seq[Expression]) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (!${evalChildren(i).isNull} && (${ev.isNull} ||\n+          ${ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = false;\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 until children.length).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Seq[Expression]) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {",
    "line": 74
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "i think the problem is that null literals are not converted into any non-null type when it happens in greatest.\n",
    "commit": "22e8f3d786a6903c6e0996b8003ca38b6f67f3f9",
    "createdAt": "2015-07-30T02:08:09Z",
    "diffHunk": "@@ -312,3 +313,103 @@ case class CaseKeyWhen(key: Expression, branches: Seq[Expression]) extends CaseW\n     }.mkString\n   }\n }\n+\n+case class Least(children: Seq[Expression]) extends Expression {\n+  require(children.length > 1, \"LEAST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {\n+      TypeCheckResult.TypeCheckFailure(\n+        s\"The expressions should all have the same type,\" +\n+          s\" got LEAST (${children.map(_.dataType)}).\")\n+    } else {\n+      TypeUtils.checkForOrderingExpr(dataType, \"function \" + prettyName)\n+    }\n+  }\n+\n+  override def dataType: DataType = children.head.dataType\n+\n+  override def eval(input: InternalRow): Any = {\n+    children.foldLeft[Any](null)((r, c) => {\n+      val evalc = c.eval(input)\n+      if (evalc != null) {\n+        if (r == null || ordering.lt(evalc, r)) evalc else r\n+      } else {\n+        r\n+      }\n+    })\n+  }\n+\n+  override def genCode(ctx: CodeGenContext, ev: GeneratedExpressionCode): String = {\n+    val evalChildren = children.map(_.gen(ctx))\n+    def updateEval(i: Int): String =\n+      s\"\"\"\n+        if (!${evalChildren(i).isNull} && (${ev.isNull} ||\n+          ${ctx.genComp(dataType, evalChildren(i).primitive, ev.primitive)} < 0)) {\n+          ${ev.isNull} = false;\n+          ${ev.primitive} = ${evalChildren(i).primitive};\n+        }\n+      \"\"\"\n+    s\"\"\"\n+      ${evalChildren.map(_.code).mkString(\"\\n\")}\n+      boolean ${ev.isNull} = true;\n+      ${ctx.javaType(dataType)} ${ev.primitive} = ${ctx.defaultValue(dataType)};\n+      ${(0 until children.length).map(updateEval).mkString(\"\\n\")}\n+    \"\"\"\n+  }\n+}\n+\n+case class Greatest(children: Seq[Expression]) extends Expression {\n+  require(children.length > 1, \"GREATEST requires at least 2 arguments, got \" + children.length)\n+\n+  override def nullable: Boolean = children.forall(_.nullable)\n+  override def foldable: Boolean = children.forall(_.foldable)\n+\n+  private lazy val ordering = TypeUtils.getOrdering(dataType)\n+\n+  override def checkInputDataTypes(): TypeCheckResult = {\n+    if (children.map(_.dataType).distinct.count(_ != NullType) > 1) {",
    "line": 74
  }],
  "prId": 6851
}]