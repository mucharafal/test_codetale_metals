[{
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Why are you converting the numbers to a String?  This is a pretty expensive operation.\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-26T01:12:03Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)"
  }, {
    "author": {
      "login": "xinyunh"
    },
    "body": "Ok, will convert it to Double directly.\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-29T22:21:07Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)"
  }],
  "prId": 2099
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Instead of creating another trait here, I think we should try an use the existing infrastructure based on Scala's `numeric` class.  I think for example that Abs's `eval` function could just be\n\n``` scala\ndef eval(input: Row) = n1(child, input, _.abs(_))\n```\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-26T01:15:43Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {"
  }],
  "prId": 2099
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "Should this always return a double?  It seems like in other SQL dialects the return type is the same as `base`'s datatype\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-26T01:18:53Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType"
  }, {
    "author": {
      "login": "xinyunh"
    },
    "body": "But there is a question, when I input, for example POWER(3, 0.5), the return result could not be the INT type. Should I try convert it to base's datatype as long as it could?\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-29T22:17:21Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType"
  }, {
    "author": {
      "login": "marmbrus"
    },
    "body": "It would be good to investigate what other systems do in this case or if the SQL standard says something.\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-29T22:26:03Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType"
  }, {
    "author": {
      "login": "nchammas"
    },
    "body": "Microsoft has some good documentation for how SQL Server handles these things. As an established and very popular product, SQL Server could provide y'all with a good reference implementation for this behavior.\n\nFrom their [documentation on `POWER()`](http://msdn.microsoft.com/en-us/library/ms174276.aspx):\n\n> Returns the same type as submitted in _float_expression_. For example, if a **decimal**(2,0) is submitted as _float_expression_, the result returned is **decimal**(2,0).\n\nThere are a few good examples that follow.\n\nMicrosoft also has some good documentation on [how precision, scale, and length are calculated for results of arithmetic operations](http://msdn.microsoft.com/en-us/library/ms190476.aspx).\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-30T05:23:05Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType"
  }],
  "prId": 2099
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "add newline.\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-26T01:19:05Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType\n+  }\n+\n+  override def eval(input: Row): Any = {\n+    def convertToDouble(num: EvaluatedType): Double = {\n+      num match {\n+        case d:Double => d\n+        case i:Integer => i.doubleValue()\n+        case f:Float => f.toDouble\n+      }\n+    }\n+\n+    val base_v = base.eval(input)\n+    val exponent_v = exponent.eval(input)\n+\n+    if ((base_v == null) || (exponent_v == null))  null\n+    else pow(convertToDouble(base_v), convertToDouble(exponent_v))\n+  }\n+\n+  override def toString = s\"Power($base, $exponent)\"\n+}"
  }, {
    "author": {
      "login": "xinyunh"
    },
    "body": "Ok, will do it.\n",
    "commit": "71d15e7eb757e32e6fa0c47425905f7cd58d9bee",
    "createdAt": "2014-08-29T22:21:19Z",
    "diffHunk": "@@ -0,0 +1,78 @@\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.types.{DoubleType, StringType, DataType}\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import scala.math.pow\n+\n+trait NumberConversionExpression {\n+  self: UnaryExpression =>\n+\n+  type EvaluatedType = Any\n+\n+  def convert(v: String): Any\n+\n+  override def foldable: Boolean = child.foldable\n+  def nullable: Boolean = child.nullable\n+  def dataType: DataType = StringType\n+\n+  override def eval(input: Row): Any = {\n+    val evaluated = child.eval(input)\n+    if (evaluated == null) {\n+      null\n+    } else {\n+      convert(evaluated.toString)\n+    }\n+  }\n+}\n+/**\n+ * A function that get the absolute value of the numeric value.\n+ */\n+case class Abs(child: Expression) extends UnaryExpression with NumberConversionExpression {\n+  def parseDouble(s: String) = try { Some(s.toDouble) } catch { case _ => None }\n+\n+  def convert(v: String): Any = {\n+    parseDouble(v)  match {\n+      case Some(s) => s.abs\n+      case None => null\n+    }\n+  }\n+\n+  override def toString() = s\"Abs($child)\"\n+}\n+\n+/**\n+ * A function that get the power value of two parameters.\n+ * First one is taken as base while second one taken as exponent\n+ */\n+case class Power(base: Expression, exponent: Expression) extends Expression {\n+\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = base.nullable || exponent.nullable\n+\n+  override def children = base :: exponent :: Nil\n+  def references = children.flatMap(_.references).toSet\n+\n+  def dataType: DataType = {\n+    if (!resolved) throw new UnresolvedException(this, s\"Cannot resolve since $children are not resolved\")\n+    DoubleType\n+  }\n+\n+  override def eval(input: Row): Any = {\n+    def convertToDouble(num: EvaluatedType): Double = {\n+      num match {\n+        case d:Double => d\n+        case i:Integer => i.doubleValue()\n+        case f:Float => f.toDouble\n+      }\n+    }\n+\n+    val base_v = base.eval(input)\n+    val exponent_v = exponent.eval(input)\n+\n+    if ((base_v == null) || (exponent_v == null))  null\n+    else pow(convertToDouble(base_v), convertToDouble(exponent_v))\n+  }\n+\n+  override def toString = s\"Power($base, $exponent)\"\n+}"
  }],
  "prId": 2099
}]