[{
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "When do we use `update` and when do we use `create`?\n",
    "commit": "29e292a954f1b07d80d03d0fd6c4ad4605b41ab7",
    "createdAt": "2016-09-25T23:57:47Z",
    "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.catalog\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.TempTableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.util.StringUtils\n+\n+\n+/**\n+ * A thread-safe manager for global temporary views, providing atomic operations to manage them,\n+ * e.g. create, update, remove, etc.\n+ *\n+ * Note that, the view name is always case-sensitive here, callers are responsible to format the\n+ * view name w.r.t. case-sensitive config.\n+ */\n+class GlobalTempViewManager {\n+\n+  /** List of view definitions, mapping from view name to logical plan. */\n+  @GuardedBy(\"this\")\n+  private val viewDefinitions = new mutable.HashMap[String, LogicalPlan]\n+\n+  def get(name: String): Option[LogicalPlan] = synchronized {\n+    viewDefinitions.get(name)\n+  }\n+\n+  def create(\n+      name: String,\n+      viewDefinition: LogicalPlan,\n+      overrideIfExists: Boolean): Unit = synchronized {\n+    if (!overrideIfExists && viewDefinitions.contains(name)) {\n+      throw new TempTableAlreadyExistsException(name)\n+    }\n+    viewDefinitions.put(name, viewDefinition)\n+  }\n+\n+  def update(\n+      name: String,\n+      viewDefinition: LogicalPlan): Boolean = synchronized {\n+    // Only update it when the view with the given name exits.\n+    if (viewDefinitions.contains(name)) {\n+      viewDefinitions.put(name, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }\n+  }",
    "line": 78
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "CREATE VIEW and ALTER VIEW.\n\nWe can have a single API for them, but need to introduce a write mode: errorIfExists, overrideIfExists(if not exists, create one), updateIfExists(if not exists, do nothing).\n",
    "commit": "29e292a954f1b07d80d03d0fd6c4ad4605b41ab7",
    "createdAt": "2016-09-26T02:59:23Z",
    "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.catalog\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.TempTableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.util.StringUtils\n+\n+\n+/**\n+ * A thread-safe manager for global temporary views, providing atomic operations to manage them,\n+ * e.g. create, update, remove, etc.\n+ *\n+ * Note that, the view name is always case-sensitive here, callers are responsible to format the\n+ * view name w.r.t. case-sensitive config.\n+ */\n+class GlobalTempViewManager {\n+\n+  /** List of view definitions, mapping from view name to logical plan. */\n+  @GuardedBy(\"this\")\n+  private val viewDefinitions = new mutable.HashMap[String, LogicalPlan]\n+\n+  def get(name: String): Option[LogicalPlan] = synchronized {\n+    viewDefinitions.get(name)\n+  }\n+\n+  def create(\n+      name: String,\n+      viewDefinition: LogicalPlan,\n+      overrideIfExists: Boolean): Unit = synchronized {\n+    if (!overrideIfExists && viewDefinitions.contains(name)) {\n+      throw new TempTableAlreadyExistsException(name)\n+    }\n+    viewDefinitions.put(name, viewDefinition)\n+  }\n+\n+  def update(\n+      name: String,\n+      viewDefinition: LogicalPlan): Boolean = synchronized {\n+    // Only update it when the view with the given name exits.\n+    if (viewDefinitions.contains(name)) {\n+      viewDefinitions.put(name, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }\n+  }",
    "line": 78
  }],
  "prId": 14897
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "Seems methods in this class need docs.\n",
    "commit": "29e292a954f1b07d80d03d0fd6c4ad4605b41ab7",
    "createdAt": "2016-09-25T23:58:00Z",
    "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.catalog\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.TempTableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.util.StringUtils\n+\n+\n+/**\n+ * A thread-safe manager for global temporary views, providing atomic operations to manage them,\n+ * e.g. create, update, remove, etc.\n+ *\n+ * Note that, the view name is always case-sensitive here, callers are responsible to format the\n+ * view name w.r.t. case-sensitive config.\n+ */\n+class GlobalTempViewManager {"
  }],
  "prId": 14897
}, {
  "comments": [{
    "author": {
      "login": "yhuai"
    },
    "body": "What is reason that failing to rename has two behavior (when source does not exist, we return false. But, when destination already exists, we thrown an error)?\n",
    "commit": "29e292a954f1b07d80d03d0fd6c4ad4605b41ab7",
    "createdAt": "2016-10-06T20:40:38Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.catalog\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.TempTableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.util.StringUtils\n+\n+\n+/**\n+ * A thread-safe manager for global temporary views, providing atomic operations to manage them,\n+ * e.g. create, update, remove, etc.\n+ *\n+ * Note that, the view name is always case-sensitive here, callers are responsible to format the\n+ * view name w.r.t. case-sensitive config.\n+ *\n+ * @param database The system preserved virtual database that keeps all the global temporary views.\n+ */\n+class GlobalTempViewManager(val database: String) {\n+\n+  /** List of view definitions, mapping from view name to logical plan. */\n+  @GuardedBy(\"this\")\n+  private val viewDefinitions = new mutable.HashMap[String, LogicalPlan]\n+\n+  /**\n+   * Returns the global view definition which matches the given name, or None if not found.\n+   */\n+  def get(name: String): Option[LogicalPlan] = synchronized {\n+    viewDefinitions.get(name)\n+  }\n+\n+  /**\n+   * Creates a global temp view, or issue an exception if the view already exists and\n+   * `overrideIfExists` is false.\n+   */\n+  def create(\n+      name: String,\n+      viewDefinition: LogicalPlan,\n+      overrideIfExists: Boolean): Unit = synchronized {\n+    if (!overrideIfExists && viewDefinitions.contains(name)) {\n+      throw new TempTableAlreadyExistsException(name)\n+    }\n+    viewDefinitions.put(name, viewDefinition)\n+  }\n+\n+  /**\n+   * Updates the global temp view if it exists, returns true if updated, false otherwise.\n+   */\n+  def update(\n+      name: String,\n+      viewDefinition: LogicalPlan): Boolean = synchronized {\n+    if (viewDefinitions.contains(name)) {\n+      viewDefinitions.put(name, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Removes the global temp view if it exists, returns true if removed, false otherwise.\n+   */\n+  def remove(name: String): Boolean = synchronized {\n+    viewDefinitions.remove(name).isDefined\n+  }\n+\n+  /**\n+   * Renames the global temp view if the source view exists and the destination view not exists, or\n+   * issue an exception if the source view exists but the destination view already exists. Returns\n+   * true if renamed, false otherwise.\n+   */\n+  def rename(oldName: String, newName: String): Boolean = synchronized {\n+    if (viewDefinitions.contains(oldName)) {\n+      if (viewDefinitions.contains(newName)) {\n+        throw new AnalysisException(\n+          s\"rename temporary view from '$oldName' to '$newName': destination view already exists\")\n+      }\n+\n+      val viewDefinition = viewDefinitions(oldName)\n+      viewDefinitions.remove(oldName)\n+      viewDefinitions.put(newName, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }",
    "line": 105
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "This behaviour comes from the previous temp view: If the source doesn't exist, try persisted table/view, if source exists but destination already exists, throw an error.\n",
    "commit": "29e292a954f1b07d80d03d0fd6c4ad4605b41ab7",
    "createdAt": "2016-10-09T07:47:31Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.catalog\n+\n+import javax.annotation.concurrent.GuardedBy\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.analysis.TempTableAlreadyExistsException\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.util.StringUtils\n+\n+\n+/**\n+ * A thread-safe manager for global temporary views, providing atomic operations to manage them,\n+ * e.g. create, update, remove, etc.\n+ *\n+ * Note that, the view name is always case-sensitive here, callers are responsible to format the\n+ * view name w.r.t. case-sensitive config.\n+ *\n+ * @param database The system preserved virtual database that keeps all the global temporary views.\n+ */\n+class GlobalTempViewManager(val database: String) {\n+\n+  /** List of view definitions, mapping from view name to logical plan. */\n+  @GuardedBy(\"this\")\n+  private val viewDefinitions = new mutable.HashMap[String, LogicalPlan]\n+\n+  /**\n+   * Returns the global view definition which matches the given name, or None if not found.\n+   */\n+  def get(name: String): Option[LogicalPlan] = synchronized {\n+    viewDefinitions.get(name)\n+  }\n+\n+  /**\n+   * Creates a global temp view, or issue an exception if the view already exists and\n+   * `overrideIfExists` is false.\n+   */\n+  def create(\n+      name: String,\n+      viewDefinition: LogicalPlan,\n+      overrideIfExists: Boolean): Unit = synchronized {\n+    if (!overrideIfExists && viewDefinitions.contains(name)) {\n+      throw new TempTableAlreadyExistsException(name)\n+    }\n+    viewDefinitions.put(name, viewDefinition)\n+  }\n+\n+  /**\n+   * Updates the global temp view if it exists, returns true if updated, false otherwise.\n+   */\n+  def update(\n+      name: String,\n+      viewDefinition: LogicalPlan): Boolean = synchronized {\n+    if (viewDefinitions.contains(name)) {\n+      viewDefinitions.put(name, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  /**\n+   * Removes the global temp view if it exists, returns true if removed, false otherwise.\n+   */\n+  def remove(name: String): Boolean = synchronized {\n+    viewDefinitions.remove(name).isDefined\n+  }\n+\n+  /**\n+   * Renames the global temp view if the source view exists and the destination view not exists, or\n+   * issue an exception if the source view exists but the destination view already exists. Returns\n+   * true if renamed, false otherwise.\n+   */\n+  def rename(oldName: String, newName: String): Boolean = synchronized {\n+    if (viewDefinitions.contains(oldName)) {\n+      if (viewDefinitions.contains(newName)) {\n+        throw new AnalysisException(\n+          s\"rename temporary view from '$oldName' to '$newName': destination view already exists\")\n+      }\n+\n+      val viewDefinition = viewDefinitions(oldName)\n+      viewDefinitions.remove(oldName)\n+      viewDefinitions.put(newName, viewDefinition)\n+      true\n+    } else {\n+      false\n+    }",
    "line": 105
  }],
  "prId": 14897
}]