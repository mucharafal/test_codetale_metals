[{
  "comments": [{
    "author": {
      "login": "kiszk"
    },
    "body": "Do we need a check `0 <= idx`, too? If so, it would be good to update a message in the exception.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-07T15:52:50Z",
    "diffHunk": "@@ -164,3 +167,32 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private lazy val accessor: (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)\n+    case LongType => (idx: Int) => arrayData.getLong(idx)\n+    case FloatType => (idx: Int) => arrayData.getFloat(idx)\n+    case DoubleType => (idx: Int) => arrayData.getDouble(idx)\n+    case d: DecimalType => (idx: Int) => arrayData.getDecimal(idx, d.precision, d.scale)\n+    case CalendarIntervalType => (idx: Int) => arrayData.getInterval(idx)\n+    case StringType => (idx: Int) => arrayData.getUTF8String(idx)\n+    case BinaryType => (idx: Int) => arrayData.getBinary(idx)\n+    case s: StructType => (idx: Int) => arrayData.getStruct(idx, s.length)\n+    case _: ArrayType => (idx: Int) => arrayData.getArray(idx)\n+    case _: MapType => (idx: Int) => arrayData.getMap(idx)\n+    case _ => (idx: Int) => arrayData.get(idx, dataType)\n+  }\n+\n+  override def apply(idx: Int): T = if (idx < arrayData.numElements()) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Thanks. Added the check now.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T04:10:11Z",
    "diffHunk": "@@ -164,3 +167,32 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private lazy val accessor: (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)\n+    case LongType => (idx: Int) => arrayData.getLong(idx)\n+    case FloatType => (idx: Int) => arrayData.getFloat(idx)\n+    case DoubleType => (idx: Int) => arrayData.getDouble(idx)\n+    case d: DecimalType => (idx: Int) => arrayData.getDecimal(idx, d.precision, d.scale)\n+    case CalendarIntervalType => (idx: Int) => arrayData.getInterval(idx)\n+    case StringType => (idx: Int) => arrayData.getUTF8String(idx)\n+    case BinaryType => (idx: Int) => arrayData.getBinary(idx)\n+    case s: StructType => (idx: Int) => arrayData.getStruct(idx, s.length)\n+    case _: ArrayType => (idx: Int) => arrayData.getArray(idx)\n+    case _: MapType => (idx: Int) => arrayData.getMap(idx)\n+    case _ => (idx: Int) => arrayData.get(idx, dataType)\n+  }\n+\n+  override def apply(idx: Int): T = if (idx < arrayData.numElements()) {"
  }],
  "prId": 20984
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "For primitive ArrayData, this seems to be an issue for null elements, if the caller asks for a primitive type sequence like `Seq[Int]`.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T09:46:21Z",
    "diffHunk": "@@ -164,3 +167,37 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private lazy val accessor: (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)\n+    case LongType => (idx: Int) => arrayData.getLong(idx)\n+    case FloatType => (idx: Int) => arrayData.getFloat(idx)\n+    case DoubleType => (idx: Int) => arrayData.getDouble(idx)\n+    case d: DecimalType => (idx: Int) => arrayData.getDecimal(idx, d.precision, d.scale)\n+    case CalendarIntervalType => (idx: Int) => arrayData.getInterval(idx)\n+    case StringType => (idx: Int) => arrayData.getUTF8String(idx)\n+    case BinaryType => (idx: Int) => arrayData.getBinary(idx)\n+    case s: StructType => (idx: Int) => arrayData.getStruct(idx, s.length)\n+    case _: ArrayType => (idx: Int) => arrayData.getArray(idx)\n+    case _: MapType => (idx: Int) => arrayData.getMap(idx)\n+    case _ => (idx: Int) => arrayData.get(idx, dataType)\n+  }\n+\n+  override def apply(idx: Int): T = if (0 <= idx && idx < arrayData.numElements()) {\n+    if (arrayData.isNullAt(idx)) {\n+      null.asInstanceOf[T]"
  }],
  "prId": 20984
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "NITish: Can you put the if statement on a separate line? This is kinda hard to read.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T09:54:03Z",
    "diffHunk": "@@ -164,3 +167,40 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)\n+    case LongType => (idx: Int) => arrayData.getLong(idx)\n+    case FloatType => (idx: Int) => arrayData.getFloat(idx)\n+    case DoubleType => (idx: Int) => arrayData.getDouble(idx)\n+    case d: DecimalType => (idx: Int) => arrayData.getDecimal(idx, d.precision, d.scale)\n+    case CalendarIntervalType => (idx: Int) => arrayData.getInterval(idx)\n+    case StringType => (idx: Int) => arrayData.getUTF8String(idx)\n+    case BinaryType => (idx: Int) => arrayData.getBinary(idx)\n+    case s: StructType => (idx: Int) => arrayData.getStruct(idx, s.length)\n+    case _: ArrayType => (idx: Int) => arrayData.getArray(idx)\n+    case _: MapType => (idx: Int) => arrayData.getMap(idx)\n+    case u: UserDefinedType[_] => getAccessor(u.sqlType)\n+    case _ => (idx: Int) => arrayData.get(idx, dataType)\n+  }\n+\n+  private val accessor: (Int) => Any = getAccessor(dataType)\n+\n+  override def apply(idx: Int): T = if (0 <= idx && idx < arrayData.numElements()) {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T10:00:15Z",
    "diffHunk": "@@ -164,3 +167,40 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)\n+    case LongType => (idx: Int) => arrayData.getLong(idx)\n+    case FloatType => (idx: Int) => arrayData.getFloat(idx)\n+    case DoubleType => (idx: Int) => arrayData.getDouble(idx)\n+    case d: DecimalType => (idx: Int) => arrayData.getDecimal(idx, d.precision, d.scale)\n+    case CalendarIntervalType => (idx: Int) => arrayData.getInterval(idx)\n+    case StringType => (idx: Int) => arrayData.getUTF8String(idx)\n+    case BinaryType => (idx: Int) => arrayData.getBinary(idx)\n+    case s: StructType => (idx: Int) => arrayData.getStruct(idx, s.length)\n+    case _: ArrayType => (idx: Int) => arrayData.getArray(idx)\n+    case _: MapType => (idx: Int) => arrayData.getMap(idx)\n+    case u: UserDefinedType[_] => getAccessor(u.sqlType)\n+    case _ => (idx: Int) => arrayData.get(idx, dataType)\n+  }\n+\n+  private val accessor: (Int) => Any = getAccessor(dataType)\n+\n+  override def apply(idx: Int): T = if (0 <= idx && idx < arrayData.numElements()) {"
  }],
  "prId": 20984
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Suggestion for a small follow-up: We could also use the `accessor` you create here to improve the `foreach` construct.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T10:10:27Z",
    "diffHunk": "@@ -164,3 +167,46 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+/**\n+ * Implements an `IndexedSeq` interface for `ArrayData`. Notice that if the original `ArrayData`\n+ * is a primitive array and contains null elements, it is better to ask for `IndexedSeq[Any]`,\n+ * instead of `IndexedSeq[Int]`, in order to keep the null elements.\n+ */\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Ok. I will also want to reuse the accessor getter in #20981 too.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-10T13:31:27Z",
    "diffHunk": "@@ -164,3 +167,46 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+/**\n+ * Implements an `IndexedSeq` interface for `ArrayData`. Notice that if the original `ArrayData`\n+ * is a primitive array and contains null elements, it is better to ask for `IndexedSeq[Any]`,\n+ * instead of `IndexedSeq[Int]`, in order to keep the null elements.\n+ */\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {"
  }],
  "prId": 20984
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "`DateType` and `TimestampType`? ",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-12T16:18:09Z",
    "diffHunk": "@@ -164,3 +167,46 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+/**\n+ * Implements an `IndexedSeq` interface for `ArrayData`. Notice that if the original `ArrayData`\n+ * is a primitive array and contains null elements, it is better to ask for `IndexedSeq[Any]`,\n+ * instead of `IndexedSeq[Int]`, in order to keep the null elements.\n+ */\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "I'd like to reuse the access getter in #20981 which covers `DateType` and `TimestampType`.",
    "commit": "8b5de0f7d18af1d194305d7cd8c43ca007a5b980",
    "createdAt": "2018-04-13T09:52:58Z",
    "diffHunk": "@@ -164,3 +167,46 @@ abstract class ArrayData extends SpecializedGetters with Serializable {\n     }\n   }\n }\n+\n+/**\n+ * Implements an `IndexedSeq` interface for `ArrayData`. Notice that if the original `ArrayData`\n+ * is a primitive array and contains null elements, it is better to ask for `IndexedSeq[Any]`,\n+ * instead of `IndexedSeq[Int]`, in order to keep the null elements.\n+ */\n+class ArrayDataIndexedSeq[T](arrayData: ArrayData, dataType: DataType) extends IndexedSeq[T] {\n+\n+  private def getAccessor(dataType: DataType): (Int) => Any = dataType match {\n+    case BooleanType => (idx: Int) => arrayData.getBoolean(idx)\n+    case ByteType => (idx: Int) => arrayData.getByte(idx)\n+    case ShortType => (idx: Int) => arrayData.getShort(idx)\n+    case IntegerType => (idx: Int) => arrayData.getInt(idx)"
  }],
  "prId": 20984
}]