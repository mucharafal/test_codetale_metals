[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this block needs to be updated.\r\n",
    "commit": "0d429782b38cf19c0d4d6a5102102e39d872fee7",
    "createdAt": "2017-02-14T17:08:37Z",
    "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.trees.CurrentOrigin\n+\n+\n+/**\n+ * Substitute Hints.\n+ * - BROADCAST/BROADCASTJOIN/MAPJOIN match the closest table with the given name parameters.\n+ *\n+ * In the case of broadcast hint, we find the frontier of"
  }],
  "prId": 16925
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we mention that, this can happen when users specify invalid hints and we will ignore it?",
    "commit": "0d429782b38cf19c0d4d6a5102102e39d872fee7",
    "createdAt": "2017-02-14T19:41:24Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.trees.CurrentOrigin\n+\n+\n+/**\n+ * Collection of rules related to hints. The only hint currently available is broadcast join hint.\n+ *\n+ * Note that this is separatedly into two rules because in the future we might introduce new hint\n+ * rules that have different ordering requirements from broadcast.\n+ */\n+object SubstituteHints {\n+\n+  /**\n+   * Substitute Hints.\n+   *\n+   * The only hint currently available is broadcast join hint.\n+   *\n+   * For broadcast hint, we accept \"BROADCAST\", \"BROADCASTJOIN\", and \"MAPJOIN\", and a sequence of\n+   * relation aliases can be specified in the hint. A broadcast hint plan node will be inserted\n+   * on top of any relation (that is not aliased differently), subquery, or common table expression\n+   * that match the specified name.\n+   *\n+   * The hint resolution works by recursively traversing down the query plan to find a relation or\n+   * subquery that matches one of the specified broadcast aliases. The traversal does not go past\n+   * beyond any existing broadcast hints, subquery aliases.\n+   *\n+   * This rule must happen before common table expressions.\n+   */\n+  class SubstituteBroadcastHints(conf: CatalystConf) extends Rule[LogicalPlan] {\n+    private val BROADCAST_HINT_NAMES = Set(\"BROADCAST\", \"BROADCASTJOIN\", \"MAPJOIN\")\n+\n+    def resolver: Resolver = conf.resolver\n+\n+    private def applyBroadcastHint(plan: LogicalPlan, toBroadcast: Set[String]): LogicalPlan = {\n+      // Whether to continue recursing down the tree\n+      var recurse = true\n+\n+      val newNode = CurrentOrigin.withOrigin(plan.origin) {\n+        plan match {\n+          case r: UnresolvedRelation =>\n+            val alias = r.alias.getOrElse(r.tableIdentifier.table)\n+            if (toBroadcast.exists(resolver(_, alias))) BroadcastHint(plan) else plan\n+          case r: SubqueryAlias =>\n+            if (toBroadcast.exists(resolver(_, r.alias))) {\n+              BroadcastHint(plan)\n+            } else {\n+              // Don't recurse down subquery aliases if there are no match.\n+              recurse = false\n+              plan\n+            }\n+          case _: BroadcastHint =>\n+            // Found a broadcast hint; don't change the plan but also don't recurse down.\n+            recurse = false\n+            plan\n+          case _ =>\n+            plan\n+        }\n+      }\n+\n+      if ((plan fastEquals newNode) && recurse) {\n+        newNode.mapChildren(child => applyBroadcastHint(child, toBroadcast))\n+      } else {\n+        newNode\n+      }\n+    }\n+\n+    def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+      case h: Hint if BROADCAST_HINT_NAMES.contains(h.name.toUpperCase) =>\n+        applyBroadcastHint(h.child, h.parameters.toSet)\n+    }\n+  }\n+\n+  /**\n+   * Removes all the hints. This must be executed after all the other hint rules are executed."
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "Yea let me add that.\r\n",
    "commit": "0d429782b38cf19c0d4d6a5102102e39d872fee7",
    "createdAt": "2017-02-14T20:03:17Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.trees.CurrentOrigin\n+\n+\n+/**\n+ * Collection of rules related to hints. The only hint currently available is broadcast join hint.\n+ *\n+ * Note that this is separatedly into two rules because in the future we might introduce new hint\n+ * rules that have different ordering requirements from broadcast.\n+ */\n+object SubstituteHints {\n+\n+  /**\n+   * Substitute Hints.\n+   *\n+   * The only hint currently available is broadcast join hint.\n+   *\n+   * For broadcast hint, we accept \"BROADCAST\", \"BROADCASTJOIN\", and \"MAPJOIN\", and a sequence of\n+   * relation aliases can be specified in the hint. A broadcast hint plan node will be inserted\n+   * on top of any relation (that is not aliased differently), subquery, or common table expression\n+   * that match the specified name.\n+   *\n+   * The hint resolution works by recursively traversing down the query plan to find a relation or\n+   * subquery that matches one of the specified broadcast aliases. The traversal does not go past\n+   * beyond any existing broadcast hints, subquery aliases.\n+   *\n+   * This rule must happen before common table expressions.\n+   */\n+  class SubstituteBroadcastHints(conf: CatalystConf) extends Rule[LogicalPlan] {\n+    private val BROADCAST_HINT_NAMES = Set(\"BROADCAST\", \"BROADCASTJOIN\", \"MAPJOIN\")\n+\n+    def resolver: Resolver = conf.resolver\n+\n+    private def applyBroadcastHint(plan: LogicalPlan, toBroadcast: Set[String]): LogicalPlan = {\n+      // Whether to continue recursing down the tree\n+      var recurse = true\n+\n+      val newNode = CurrentOrigin.withOrigin(plan.origin) {\n+        plan match {\n+          case r: UnresolvedRelation =>\n+            val alias = r.alias.getOrElse(r.tableIdentifier.table)\n+            if (toBroadcast.exists(resolver(_, alias))) BroadcastHint(plan) else plan\n+          case r: SubqueryAlias =>\n+            if (toBroadcast.exists(resolver(_, r.alias))) {\n+              BroadcastHint(plan)\n+            } else {\n+              // Don't recurse down subquery aliases if there are no match.\n+              recurse = false\n+              plan\n+            }\n+          case _: BroadcastHint =>\n+            // Found a broadcast hint; don't change the plan but also don't recurse down.\n+            recurse = false\n+            plan\n+          case _ =>\n+            plan\n+        }\n+      }\n+\n+      if ((plan fastEquals newNode) && recurse) {\n+        newNode.mapChildren(child => applyBroadcastHint(child, toBroadcast))\n+      } else {\n+        newNode\n+      }\n+    }\n+\n+    def apply(plan: LogicalPlan): LogicalPlan = plan transformUp {\n+      case h: Hint if BROADCAST_HINT_NAMES.contains(h.name.toUpperCase) =>\n+        applyBroadcastHint(h.child, h.parameters.toSet)\n+    }\n+  }\n+\n+  /**\n+   * Removes all the hints. This must be executed after all the other hint rules are executed."
  }],
  "prId": 16925
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "in the case of self-join, we may broadcast both side, is it expected?",
    "commit": "0d429782b38cf19c0d4d6a5102102e39d872fee7",
    "createdAt": "2017-02-14T19:46:38Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.trees.CurrentOrigin\n+\n+\n+/**\n+ * Collection of rules related to hints. The only hint currently available is broadcast join hint.\n+ *\n+ * Note that this is separatedly into two rules because in the future we might introduce new hint\n+ * rules that have different ordering requirements from broadcast.\n+ */\n+object SubstituteHints {\n+\n+  /**\n+   * Substitute Hints.\n+   *\n+   * The only hint currently available is broadcast join hint.\n+   *\n+   * For broadcast hint, we accept \"BROADCAST\", \"BROADCASTJOIN\", and \"MAPJOIN\", and a sequence of\n+   * relation aliases can be specified in the hint. A broadcast hint plan node will be inserted\n+   * on top of any relation (that is not aliased differently), subquery, or common table expression\n+   * that match the specified name.\n+   *\n+   * The hint resolution works by recursively traversing down the query plan to find a relation or\n+   * subquery that matches one of the specified broadcast aliases. The traversal does not go past\n+   * beyond any existing broadcast hints, subquery aliases.\n+   *\n+   * This rule must happen before common table expressions.\n+   */\n+  class SubstituteBroadcastHints(conf: CatalystConf) extends Rule[LogicalPlan] {\n+    private val BROADCAST_HINT_NAMES = Set(\"BROADCAST\", \"BROADCASTJOIN\", \"MAPJOIN\")\n+\n+    def resolver: Resolver = conf.resolver\n+\n+    private def applyBroadcastHint(plan: LogicalPlan, toBroadcast: Set[String]): LogicalPlan = {\n+      // Whether to continue recursing down the tree\n+      var recurse = true\n+\n+      val newNode = CurrentOrigin.withOrigin(plan.origin) {\n+        plan match {\n+          case r: UnresolvedRelation =>\n+            val alias = r.alias.getOrElse(r.tableIdentifier.table)\n+            if (toBroadcast.exists(resolver(_, alias))) BroadcastHint(plan) else plan\n+          case r: SubqueryAlias =>\n+            if (toBroadcast.exists(resolver(_, r.alias))) {\n+              BroadcastHint(plan)\n+            } else {\n+              // Don't recurse down subquery aliases if there are no match.\n+              recurse = false\n+              plan\n+            }\n+          case _: BroadcastHint =>\n+            // Found a broadcast hint; don't change the plan but also don't recurse down.\n+            recurse = false\n+            plan\n+          case _ =>\n+            plan\n+        }\n+      }\n+\n+      if ((plan fastEquals newNode) && recurse) {\n+        newNode.mapChildren(child => applyBroadcastHint(child, toBroadcast))",
    "line": 82
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "That's fine. Both being broadcastable doesn't mean we broadcast both.\r\n",
    "commit": "0d429782b38cf19c0d4d6a5102102e39d872fee7",
    "createdAt": "2017-02-14T20:03:04Z",
    "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.analysis\n+\n+import org.apache.spark.sql.catalyst.CatalystConf\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.trees.CurrentOrigin\n+\n+\n+/**\n+ * Collection of rules related to hints. The only hint currently available is broadcast join hint.\n+ *\n+ * Note that this is separatedly into two rules because in the future we might introduce new hint\n+ * rules that have different ordering requirements from broadcast.\n+ */\n+object SubstituteHints {\n+\n+  /**\n+   * Substitute Hints.\n+   *\n+   * The only hint currently available is broadcast join hint.\n+   *\n+   * For broadcast hint, we accept \"BROADCAST\", \"BROADCASTJOIN\", and \"MAPJOIN\", and a sequence of\n+   * relation aliases can be specified in the hint. A broadcast hint plan node will be inserted\n+   * on top of any relation (that is not aliased differently), subquery, or common table expression\n+   * that match the specified name.\n+   *\n+   * The hint resolution works by recursively traversing down the query plan to find a relation or\n+   * subquery that matches one of the specified broadcast aliases. The traversal does not go past\n+   * beyond any existing broadcast hints, subquery aliases.\n+   *\n+   * This rule must happen before common table expressions.\n+   */\n+  class SubstituteBroadcastHints(conf: CatalystConf) extends Rule[LogicalPlan] {\n+    private val BROADCAST_HINT_NAMES = Set(\"BROADCAST\", \"BROADCASTJOIN\", \"MAPJOIN\")\n+\n+    def resolver: Resolver = conf.resolver\n+\n+    private def applyBroadcastHint(plan: LogicalPlan, toBroadcast: Set[String]): LogicalPlan = {\n+      // Whether to continue recursing down the tree\n+      var recurse = true\n+\n+      val newNode = CurrentOrigin.withOrigin(plan.origin) {\n+        plan match {\n+          case r: UnresolvedRelation =>\n+            val alias = r.alias.getOrElse(r.tableIdentifier.table)\n+            if (toBroadcast.exists(resolver(_, alias))) BroadcastHint(plan) else plan\n+          case r: SubqueryAlias =>\n+            if (toBroadcast.exists(resolver(_, r.alias))) {\n+              BroadcastHint(plan)\n+            } else {\n+              // Don't recurse down subquery aliases if there are no match.\n+              recurse = false\n+              plan\n+            }\n+          case _: BroadcastHint =>\n+            // Found a broadcast hint; don't change the plan but also don't recurse down.\n+            recurse = false\n+            plan\n+          case _ =>\n+            plan\n+        }\n+      }\n+\n+      if ((plan fastEquals newNode) && recurse) {\n+        newNode.mapChildren(child => applyBroadcastHint(child, toBroadcast))",
    "line": 82
  }],
  "prId": 16925
}]