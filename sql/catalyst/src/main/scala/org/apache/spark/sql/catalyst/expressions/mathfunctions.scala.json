[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "space after if!\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-21T20:35:54Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+trait MathematicalExpression extends UnaryExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toDouble(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toFloat(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin) {\n+  override def toString: String = s\"SIN($child)\"\n+}\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin) {\n+  override def toString: String = s\"ASIN($child)\"\n+}\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh) {\n+  override def toString: String = s\"SINH($child)\"\n+}\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos) {\n+  override def toString: String = s\"COS($child)\"\n+}\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos) {\n+  override def toString: String = s\"ACOS($child)\"\n+}\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh) {\n+  override def toString: String = s\"COSH($child)\"\n+}\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan) {\n+  override def toString: String = s\"TAN($child)\"\n+}\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan) {\n+  override def toString: String = s\"ATAN($child)\"\n+}\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh) {\n+  override def toString: String = s\"TANH($child)\"\n+}\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil) {\n+  override def toString: String = s\"CEIL($child)\"\n+}\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor) {\n+  override def toString: String = s\"FLOOR($child)\"\n+}\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint) {\n+  override def toString: String = s\"RINT($child)\"\n+}\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt) {\n+  override def toString: String = s\"CBRT($child)\"\n+}\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum) {\n+  override def toString: String = s\"SIGNUM($child)\"\n+}\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum) {\n+  override def toString: String = s\"ISIGNUM($child)\"\n+}\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum) {\n+  override def toString: String = s\"FSIGNUM($child)\"\n+}\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum) {\n+  override def toString: String = s\"LSIGNUM($child)\"\n+}\n+\n+case class ToDegrees(child: Expression) extends MathematicalExpressionForDouble(math.toDegrees) {\n+  override def toString: String = s\"TODEG($child)\"\n+}\n+\n+case class ToRadians(child: Expression) extends MathematicalExpressionForDouble(math.toRadians) {\n+  override def toString: String = s\"TORAD($child)\"\n+}\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log) {\n+  override def toString: String = s\"LOG($child)\"\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val value = numeric.toDouble(evalE)\n+      if (value < 0) null\n+      else math.log(value)\n+    }\n+  }\n+}\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10) {\n+  override def toString: String = s\"LOG10($child)\"\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val value = numeric.toDouble(evalE)\n+      if (value < 0) null\n+      else math.log10(value)\n+    }\n+  }\n+}\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p) {\n+  override def toString: String = s\"LOG1P($child)\"\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val value = numeric.toDouble(evalE)\n+      if (value < -1) null\n+      else math.log1p(value)\n+    }\n+  }\n+}\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp) {\n+  override def toString: String = s\"EXP($child)\"\n+}\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1) {\n+  override def toString: String = s\"EXPM1($child)\"\n+}\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")\n+    }\n+    left.dataType\n+  }\n+\n+  lazy val numeric = dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+\n+  override def eval(input: Row): Any = {\n+    val evalE1 = left.eval(input)\n+    if(evalE1 == null) {"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "typically for all of our expressions, we have determined the output type based on the input type, instead of having custom expressions for each type (at codegen time you can still specialize).\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-21T20:50:29Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+trait MathematicalExpression extends UnaryExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double)"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "marmbrus"
    },
    "body": "This is a style nit so feel free to ignore, but you might just make the name an arg to the constructor so you don't have to write this method each time.  Similar to how we handle `BinaryExpression`.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-21T20:57:26Z",
    "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+trait MathematicalExpression extends UnaryExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toDouble(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toFloat(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long)\n+  extends MathematicalExpression { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin) {\n+  override def toString: String = s\"SIN($child)\""
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "put this in expressions.math package?\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:27:54Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "``` scala\nif (result.isNaN) null else result\n```\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:29:35Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "@marmbrus what's a better way to deal with this? Seems like some form of type coercion during analysis would be useful here, rather than throwing an exception at runtime if types don't match.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:30:39Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "also would be useful if we add an explicit cast expression, rather than doing a cast in eval.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:31:27Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "and burak numeric should be private[this]\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:36:05Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "``` scala\nif (result.isNaN) null else result\n```\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:32:30Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "add javadoc for this and explain what f / name is, and how they will be used\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:32:56Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "also for rest of the Math... abstract classes\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:33:18Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "override\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:34:59Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "i'd pull this up so all the abstract classes are defined up front.\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:35:19Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) "
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "alternatively, create the math package with unary.scala and binary.scala. \n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:37:00Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) "
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "override\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:35:26Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "private[this] ?\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:35:31Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")\n+    }\n+    left.dataType\n+  }\n+\n+  lazy val numeric = dataType match {"
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "`Atan2` accesses it down below. made it `private[math]`\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-27T21:55:28Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")\n+    }\n+    left.dataType\n+  }\n+\n+  lazy val numeric = dataType match {"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "protected then?\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-27T22:00:35Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")\n+    }\n+    left.dataType\n+  }\n+\n+  lazy val numeric = dataType match {"
  }],
  "prId": 5616
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "don't wrap here as well\n",
    "commit": "fb271536a68cf3f7ff267953098ce305512c65d0",
    "createdAt": "2015-04-26T07:37:40Z",
    "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.expressions\n+\n+import org.apache.spark.sql.catalyst.analysis.UnresolvedException\n+import org.apache.spark.sql.types._\n+\n+abstract class MathematicalExpression(name: String) extends UnaryExpression with Serializable { \n+  self: Product =>\n+  type EvaluatedType = Any\n+\n+  override def dataType: DataType = DoubleType\n+  override def foldable: Boolean = child.foldable\n+  override def nullable: Boolean = true\n+  override def toString: String = s\"$name($child)\"\n+\n+  lazy val numeric = child.dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+}\n+\n+abstract class MathematicalExpressionForDouble(f: Double => Double, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toDouble(evalE)) \n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForInt(f: Int => Int, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+  override def dataType: DataType = IntegerType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toInt(evalE))\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForFloat(f: Float => Float, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = FloatType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      val result = f(numeric.toFloat(evalE))\n+      if (result.isNaN) null\n+      else result\n+    }\n+  }\n+}\n+\n+abstract class MathematicalExpressionForLong(f: Long => Long, name: String)\n+  extends MathematicalExpression(name) { self: Product =>\n+\n+  override def dataType: DataType = LongType\n+\n+  override def eval(input: Row): Any = {\n+    val evalE = child.eval(input)\n+    if (evalE == null) {\n+      null\n+    } else {\n+      f(numeric.toLong(evalE))\n+    }\n+  }\n+}\n+\n+case class Sin(child: Expression) extends MathematicalExpressionForDouble(math.sin, \"SIN\")\n+\n+case class Asin(child: Expression) extends MathematicalExpressionForDouble(math.asin, \"ASIN\")\n+\n+case class Sinh(child: Expression) extends MathematicalExpressionForDouble(math.sinh, \"SINH\")\n+\n+case class Cos(child: Expression) extends MathematicalExpressionForDouble(math.cos, \"COS\")\n+\n+case class Acos(child: Expression) extends MathematicalExpressionForDouble(math.acos, \"ACOS\")\n+\n+case class Cosh(child: Expression) extends MathematicalExpressionForDouble(math.cosh, \"COSH\")\n+\n+case class Tan(child: Expression) extends MathematicalExpressionForDouble(math.tan, \"TAN\")\n+\n+case class Atan(child: Expression) extends MathematicalExpressionForDouble(math.atan, \"ATAN\")\n+\n+case class Tanh(child: Expression) extends MathematicalExpressionForDouble(math.tanh, \"TANH\")\n+\n+case class Ceil(child: Expression) extends MathematicalExpressionForDouble(math.ceil, \"CEIL\")\n+\n+case class Floor(child: Expression) extends MathematicalExpressionForDouble(math.floor, \"FLOOR\")\n+\n+case class Rint(child: Expression) extends MathematicalExpressionForDouble(math.rint, \"ROUND\")\n+\n+case class Cbrt(child: Expression) extends MathematicalExpressionForDouble(math.cbrt, \"CBRT\")\n+\n+case class Signum(child: Expression) extends MathematicalExpressionForDouble(math.signum, \"SIGNUM\")\n+\n+case class ISignum(child: Expression) extends MathematicalExpressionForInt(math.signum, \"ISIGNUM\")\n+\n+case class FSignum(child: Expression) extends MathematicalExpressionForFloat(math.signum, \"FSIGNUM\")\n+\n+case class LSignum(child: Expression) extends MathematicalExpressionForLong(math.signum, \"LSIGNUM\")\n+\n+case class ToDegrees(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toDegrees, \"DEGREES\")\n+\n+case class ToRadians(child: Expression) \n+  extends MathematicalExpressionForDouble(math.toRadians, \"RADIANS\")\n+\n+case class Log(child: Expression) extends MathematicalExpressionForDouble(math.log, \"LOG\")\n+\n+case class Log10(child: Expression) extends MathematicalExpressionForDouble(math.log10, \"LOG10\")\n+\n+case class Log1p(child: Expression) extends MathematicalExpressionForDouble(math.log1p, \"LOG1P\")\n+\n+case class Exp(child: Expression) extends MathematicalExpressionForDouble(math.exp, \"EXP\")\n+\n+case class Expm1(child: Expression) extends MathematicalExpressionForDouble(math.expm1, \"EXPM1\")\n+\n+abstract class BinaryMathExpression(f: (Double, Double) => Double, name: String) \n+  extends BinaryFunctionExpression with Serializable { self: Product =>\n+  type EvaluatedType = Any\n+\n+  def nullable: Boolean = left.nullable || right.nullable\n+  override def toString: String = s\"$name($left, $right)\"\n+\n+  override lazy val resolved =\n+    left.resolved && right.resolved &&\n+      left.dataType == right.dataType &&\n+      !DecimalType.isFixed(left.dataType)\n+\n+  def dataType: DataType = {\n+    if (!resolved) {\n+      throw new UnresolvedException(this,\n+        s\"datatype. Can not resolve due to differing types ${left.dataType}, ${right.dataType}\")\n+    }\n+    left.dataType\n+  }\n+\n+  lazy val numeric = dataType match {\n+    case n: NumericType => n.numeric.asInstanceOf[Numeric[Any]]\n+    case other => sys.error(s\"Type $other does not support numeric operations\")\n+  }\n+\n+  override def eval(input: Row): Any = {\n+    val evalE1 = left.eval(input)\n+    if (evalE1 == null) {\n+      null\n+    } else {\n+      val evalE2 = right.eval(input)\n+      if (evalE2 == null) {\n+        null\n+      } else {\n+        val result = f(numeric.toDouble(evalE1), numeric.toDouble(evalE2)) \n+        if (result.isNaN) null\n+        else result\n+      }\n+    }\n+  }\n+}\n+\n+case class Pow(left: Expression, right: Expression) extends BinaryMathExpression(math.pow, \"POWER\")\n+\n+case class Hypot(\n+    left: Expression,\n+    right: Expression) extends BinaryMathExpression(math.hypot, \"HYPOT\")\n+\n+case class Atan2(\n+    left: Expression,\n+    right: Expression) extends BinaryMathExpression(math.atan2, \"ATAN2\") {\n+  override def eval(input: Row): Any = {\n+    val evalE1 = left.eval(input)\n+    if (evalE1 == null) {\n+      null\n+    } else {\n+      val evalE2 = right.eval(input)\n+      if (evalE2 == null) {\n+        null\n+      } else {\n+        // With codegen, the values returned by -0.0 and 0.0 are different. Handled with +0.0\n+        val result = math.atan2(numeric.toDouble(evalE1) + 0.0, numeric.toDouble(evalE2) + 0.0)\n+        if (result.isNaN) null"
  }],
  "prId": 5616
}]