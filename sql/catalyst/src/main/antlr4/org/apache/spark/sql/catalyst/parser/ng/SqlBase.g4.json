[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "should we move these keyword/lexer rules into a separated file?\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-23T12:00:05Z",
    "diffHunk": "@@ -0,0 +1,742 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * This file is an adaptation of Presto's presto-parser/src/main/antlr4/com/facebook/presto/sql/parser/SqlBase.g4 grammar.\n+ */\n+\n+grammar SqlBase;\n+\n+tokens {\n+    DELIMITER\n+}\n+\n+singleStatement\n+    : statement EOF\n+    ;\n+\n+singleExpression\n+    : namedExpression EOF\n+    ;\n+\n+singleTableIdentifier\n+    : tableIdentifier EOF\n+    ;\n+\n+singleDataType\n+    : dataType EOF\n+    ;\n+\n+statement\n+    : query                                                            #statementDefault\n+    | USE db=identifier                                                #use\n+    | createTable ('(' colTypeList ')')? tableProvider tableProperties #createTableUsing\n+    | createTable tableProvider tableProperties? AS? query             #createTableUsingAsSelect\n+    | DROP TABLE (IF EXISTS)? qualifiedName                            #dropTable\n+    | DELETE FROM qualifiedName (WHERE booleanExpression)?             #delete\n+    | ALTER TABLE from=qualifiedName RENAME TO to=qualifiedName        #renameTable\n+    | ALTER TABLE tableName=qualifiedName\n+        RENAME COLUMN from=identifier TO to=identifier                 #renameColumn\n+    | ALTER TABLE tableName=qualifiedName\n+        ADD COLUMN column=colType                                      #addColumn\n+    | CREATE (OR REPLACE)? VIEW qualifiedName AS query                 #createView\n+    | DROP VIEW (IF EXISTS)? qualifiedName                             #dropView\n+    | CALL qualifiedName '(' (callArgument (',' callArgument)*)? ')'   #call\n+    | EXPLAIN explainOption* statement                                 #explain\n+    | SHOW TABLES ((FROM | IN) db=identifier)?\n+        (LIKE (qualifiedName | pattern=STRING))?                       #showTables\n+    | SHOW SCHEMAS ((FROM | IN) identifier)?                           #showSchemas\n+    | SHOW CATALOGS                                                    #showCatalogs\n+    | SHOW COLUMNS (FROM | IN) qualifiedName                           #showColumns\n+    | SHOW FUNCTIONS (LIKE? (qualifiedName | pattern=STRING))?         #showFunctions\n+    | (DESC | DESCRIBE) FUNCTION EXTENDED? qualifiedName               #describeFunction\n+    | (DESC | DESCRIBE) option=(EXTENDED | FORMATTED)?\n+        tableIdentifier partitionSpec? describeColName?                #describeTable\n+    | SHOW SESSION                                                     #showSession\n+    | SET SESSION qualifiedName EQ expression                          #setSession\n+    | RESET SESSION qualifiedName                                      #resetSession\n+    | START TRANSACTION (transactionMode (',' transactionMode)*)?      #startTransaction\n+    | COMMIT WORK?                                                     #commit\n+    | ROLLBACK WORK?                                                   #rollback\n+    | SHOW PARTITIONS (FROM | IN) qualifiedName\n+        (WHERE booleanExpression)?\n+        (ORDER BY sortItem (',' sortItem)*)?\n+        (LIMIT limit=(INTEGER_VALUE | ALL))?                           #showPartitions\n+    | REFRESH TABLE tableIdentifier                                    #refreshTable\n+    | CACHE LAZY? TABLE identifier (AS? query)?                        #cacheTable\n+    | UNCACHE TABLE identifier                                         #uncacheTable\n+    | CLEAR CACHE                                                      #clearCache\n+    | SET .*?                                                          #setConfiguration\n+    ;\n+\n+createTable\n+    : CREATE TEMPORARY? TABLE (IF NOT EXISTS)? tableIdentifier\n+    ;\n+\n+query\n+    : ctes? queryNoWith\n+    ;\n+\n+insertInto\n+    : INSERT OVERWRITE TABLE tableIdentifier partitionSpec? (IF NOT EXISTS)?\n+    | INSERT INTO TABLE? tableIdentifier partitionSpec?\n+    ;\n+\n+partitionSpec\n+    : PARTITION '(' partitionVal (',' partitionVal)* ')'\n+    ;\n+\n+partitionVal\n+    : identifier (EQ constant)?\n+    ;\n+\n+describeColName\n+    : identifier ('.' (identifier | STRING))*\n+    ;\n+\n+ctes\n+    : WITH namedQuery (',' namedQuery)*\n+    ;\n+\n+namedQuery\n+    : name=identifier AS? '(' queryNoWith ')'\n+    ;\n+\n+tableProvider\n+    : USING qualifiedName\n+    ;\n+\n+tableProperties\n+    :(OPTIONS | WITH) '(' tableProperty (',' tableProperty)* ')'\n+    ;\n+\n+tableProperty\n+    : key=tablePropertyKey (EQ? value=STRING)?\n+    ;\n+\n+tablePropertyKey\n+    : looseIdentifier ('.' looseIdentifier)*\n+    | STRING\n+    ;\n+\n+queryNoWith\n+    : insertInto? queryTerm queryOrganization                                              #singleInsertQuery\n+    | fromClause multiInsertQueryBody+                                                     #multiInsertQuery\n+    ;\n+\n+queryOrganization\n+    : (ORDER BY order+=sortItem (',' order+=sortItem)*)?\n+      (CLUSTER BY clusterBy+=expression (',' clusterBy+=expression)*)?\n+      (DISTRIBUTE BY distributeBy+=expression (',' distributeBy+=expression)*)?\n+      (SORT BY sort+=sortItem (',' sort+=sortItem)*)?\n+      windows?\n+      (LIMIT limit=expression)?\n+    ;\n+\n+multiInsertQueryBody\n+    : insertInto?\n+      querySpecification\n+      queryOrganization\n+    ;\n+\n+queryTerm\n+    : queryPrimary                                                                         #queryTermDefault\n+    | left=queryTerm operator=(INTERSECT | UNION | EXCEPT) setQuantifier? right=queryTerm  #setOperation\n+    ;\n+\n+queryPrimary\n+    : querySpecification                                                    #queryPrimaryDefault\n+    | TABLE tableIdentifier                                                 #table\n+    | inlineTable                                                           #inlineTableDefault1\n+    | '(' queryNoWith  ')'                                                  #subquery\n+    ;\n+\n+sortItem\n+    : expression ordering=(ASC | DESC)?\n+    ;\n+\n+querySpecification\n+    : (((SELECT kind=TRANSFORM | kind=MAP | kind=REDUCE)) '(' namedExpression (',' namedExpression)* ')'\n+       inRowFormat=rowFormat?\n+       USING script=STRING\n+       (AS (columnAliasList | colTypeList | ('(' (columnAliasList | colTypeList) ')')))?\n+       outRowFormat=rowFormat?\n+       (RECORDREADER outRecordReader=STRING)?\n+       fromClause?\n+       (WHERE where=booleanExpression)?)\n+    | (kind=SELECT setQuantifier? namedExpression (',' namedExpression)*\n+       fromClause?\n+       lateralView*\n+       (WHERE where=booleanExpression)?\n+       aggregation?\n+       (HAVING having=booleanExpression)?\n+       windows?)\n+    ;\n+\n+fromClause\n+    : FROM relation (',' relation)* lateralView*\n+    ;\n+\n+aggregation\n+    : GROUP BY groupingExpressions+=expression (',' groupingExpressions+=expression)* (\n+      WITH kind=ROLLUP\n+    | WITH kind=CUBE\n+    | kind=GROUPING SETS '(' groupingSet (',' groupingSet)* ')')?\n+    ;\n+\n+groupingSet\n+    : '(' (expression (',' expression)*)? ')'\n+    | expression\n+    ;\n+\n+lateralView\n+    : LATERAL VIEW (OUTER)? qualifiedName '(' (expression (',' expression)*)? ')' tblName=identifier (AS? colName+=identifier (',' colName+=identifier)*)\n+    ;\n+\n+setQuantifier\n+    : DISTINCT\n+    | ALL\n+    ;\n+\n+relation\n+    : left=relation\n+      ( CROSS JOIN right=sampledRelation\n+      | joinType JOIN rightRelation=relation joinCriteria?\n+      | NATURAL joinType JOIN right=sampledRelation\n+      )                                           #joinRelation\n+    | sampledRelation                             #relationDefault\n+    ;\n+\n+joinType\n+    : INNER?\n+    | LEFT OUTER?\n+    | LEFT SEMI\n+    | RIGHT OUTER?\n+    | FULL OUTER?\n+    ;\n+\n+joinCriteria\n+    : ON booleanExpression\n+    | USING '(' identifier (',' identifier)* ')'\n+    ;\n+\n+sampledRelation\n+    : relationPrimary (\n+        TABLESAMPLE '('\n+         ( (percentage=(INTEGER_VALUE | DECIMAL_VALUE) sampleType=PERCENTLIT)\n+         | (expression sampleType=ROWS)\n+         | (sampleType=BUCKET numerator=INTEGER_VALUE OUT OF denominator=INTEGER_VALUE (ON identifier)?))\n+         ')'\n+      )?\n+    ;\n+\n+columnAliases\n+    : '(' columnAliasList ')'\n+    ;\n+\n+columnAliasList\n+    : identifier (',' identifier)*\n+    ;\n+\n+relationPrimary\n+    : tableIdentifier (AS? identifier)?                             #tableName\n+    | '(' queryNoWith ')' (AS? identifier)?                         #aliasedQuery\n+    | '(' relation ')'  (AS? identifier)?                           #aliasedRelation\n+    | inlineTable                                                   #inlineTableDefault2\n+    ;\n+\n+inlineTable\n+    : VALUES expression (',' expression)*  (AS? identifier columnAliases?)?\n+    ;\n+\n+rowFormat\n+    : rowFormatSerde\n+    | rowFormatDelimited\n+    ;\n+\n+rowFormatSerde\n+    : ROW FORMAT SERDE name=STRING (WITH SERDEPROPERTIES props=tableProperties)?\n+    ;\n+\n+rowFormatDelimited\n+    : ROW FORMAT DELIMITED\n+      (FIELDS TERMINATED BY fieldsTerminatedBy=STRING)?\n+      (COLLECTION ITEMS TERMINATED BY collectionItemsTerminatedBy=STRING)?\n+      (MAP KEYS TERMINATED BY keysTerminatedBy=STRING)?\n+      (ESCAPED BY escapedBy=STRING)?\n+      (LINES SEPARATED BY linesSeparatedBy=STRING)?\n+    ;\n+\n+tableIdentifier\n+    : (db=identifier '.')? table=identifier\n+    ;\n+\n+namedExpression\n+    : expression (AS? (identifier | columnAliases))?\n+    ;\n+\n+expression\n+    : booleanExpression\n+    ;\n+\n+booleanExpression\n+    : predicated                                                   #booleanDefault\n+    | NOT booleanExpression                                        #logicalNot\n+    | left=booleanExpression operator=AND right=booleanExpression  #logicalBinary\n+    | left=booleanExpression operator=OR right=booleanExpression   #logicalBinary\n+    | EXISTS '(' query ')'                                         #exists\n+    ;\n+\n+// workaround for:\n+//  https://github.com/antlr/antlr4/issues/780\n+//  https://github.com/antlr/antlr4/issues/781\n+predicated\n+    : valueExpression predicate[$valueExpression.ctx]?\n+    ;\n+\n+predicate[ParserRuleContext value]\n+    : comparisonOperator right=valueExpression                            #comparison\n+    | NOT? BETWEEN lower=valueExpression AND upper=valueExpression        #between\n+    | NOT? IN '(' expression (',' expression)* ')'                        #inList\n+    | NOT? IN '(' query ')'                                               #inSubquery\n+    | NOT? like=(RLIKE | LIKE) pattern=valueExpression                    #like\n+    | IS NOT? NULL                                                        #nullPredicate\n+    ;\n+\n+valueExpression\n+    : primaryExpression                                                                      #valueExpressionDefault\n+    | operator=(MINUS | PLUS | TILDE) valueExpression                                        #arithmeticUnary\n+    | left=valueExpression operator=(ASTERISK | SLASH | PERCENT | DIV) right=valueExpression #arithmeticBinary\n+    | left=valueExpression operator=(PLUS | MINUS) right=valueExpression                     #arithmeticBinary\n+    | left=valueExpression operator=AMPERSAND right=valueExpression                          #arithmeticBinary\n+    | left=valueExpression operator=HAT right=valueExpression                                #arithmeticBinary\n+    | left=valueExpression operator=PIPE right=valueExpression                               #arithmeticBinary\n+    ;\n+\n+primaryExpression\n+    : constant                                                                                 #constantDefault\n+    | ASTERISK                                                                                 #star\n+    | qualifiedName '.' ASTERISK                                                               #star\n+    | '(' expression (',' expression)+ ')'                                                     #rowConstructor\n+    | qualifiedName '(' (ASTERISK) ')' (OVER windowSpec)?                                      #functionCall\n+    | qualifiedName '(' (setQuantifier? expression (',' expression)*)? ')' (OVER windowSpec)?  #functionCall\n+    | '(' query ')'                                                                            #subqueryExpression\n+    | CASE valueExpression whenClause+ (ELSE elseExpression=expression)? END                   #simpleCase\n+    | CASE whenClause+ (ELSE elseExpression=expression)? END                                   #searchedCase\n+    | CAST '(' expression AS dataType ')'                                                      #cast\n+    | value=primaryExpression '[' index=valueExpression ']'                                    #subscript\n+    | identifier                                                                               #columnReference\n+    | base=primaryExpression '.' fieldName=identifier                                          #dereference\n+    | '(' expression ')'                                                                       #parenthesizedExpression\n+    ;\n+\n+constant\n+    : NULL                                                                                     #nullLiteral\n+    | interval                                                                                 #intervalLiteral\n+    | identifier STRING                                                                        #typeConstructor\n+    | number                                                                                   #numericLiteral\n+    | booleanValue                                                                             #booleanLiteral\n+    | STRING+                                                                                  #stringLiteral\n+    ;\n+\n+comparisonOperator\n+    : EQ | NEQ | NEQJ | LT | LTE | GT | GTE | NSEQ\n+    ;\n+\n+booleanValue\n+    : TRUE | FALSE\n+    ;\n+\n+interval\n+    : INTERVAL intervalField*\n+    ;\n+\n+intervalField\n+    : value=intervalValue unit=identifier (TO to=identifier)?\n+    ;\n+\n+intervalValue\n+    : (PLUS | MINUS)? (INTEGER_VALUE | DECIMAL_VALUE)\n+    | STRING\n+    ;\n+\n+dataType\n+    : complex=ARRAY '<' dataType '>'                            #complexDataType\n+    | complex=MAP '<' dataType ',' dataType '>'                 #complexDataType\n+    | complex=STRUCT ('<' colTypeList? '>' | NEQ)              #complexDataType\n+    | identifier ('(' INTEGER_VALUE (',' INTEGER_VALUE)* ')')?  #primitiveDataType\n+    ;\n+\n+colTypeList\n+    : colType (',' colType)*\n+    ;\n+\n+colType\n+    : identifier ':'? dataType (COMMENT STRING)?\n+    ;\n+\n+whenClause\n+    : WHEN condition=expression THEN result=expression\n+    ;\n+\n+windows\n+    : WINDOW namedWindow (',' namedWindow)*\n+    ;\n+\n+namedWindow\n+    : identifier AS windowSpec\n+    ;\n+\n+windowSpec\n+    : name=identifier  #windowRef\n+    | '('\n+      (PARTITION BY partition+=expression (',' partition+=expression)*)?\n+      (ORDER BY sortItem (',' sortItem)* windowFrame?)?\n+      ')'              #windowDef\n+    ;\n+\n+windowFrame\n+    : frameType=RANGE start=frameBound\n+    | frameType=ROWS start=frameBound\n+    | frameType=RANGE BETWEEN start=frameBound AND end=frameBound\n+    | frameType=ROWS BETWEEN start=frameBound AND end=frameBound\n+    ;\n+\n+frameBound\n+    : UNBOUNDED boundType=(PRECEDING | FOLLOWING)\n+    | boundType=CURRENT ROW\n+    | expression boundType=(PRECEDING | FOLLOWING)\n+    ;\n+\n+\n+explainOption\n+    : LOGICAL | FORMATTED | EXTENDED\n+    ;\n+\n+transactionMode\n+    : ISOLATION LEVEL levelOfIsolation    #isolationLevel\n+    | READ accessMode=(ONLY | WRITE)      #transactionAccessMode\n+    ;\n+\n+levelOfIsolation\n+    : READ UNCOMMITTED                    #readUncommitted\n+    | READ COMMITTED                      #readCommitted\n+    | REPEATABLE READ                     #repeatableRead\n+    | SERIALIZABLE                        #serializable\n+    ;\n+\n+callArgument\n+    : expression                    #positionalArgument\n+    | identifier '=>' expression    #namedArgument\n+    ;\n+\n+qualifiedName\n+    : identifier ('.' identifier)*\n+    ;\n+\n+// Identifier that also allows the use of a number of SQL keywords (mainly for backwards compatibility).\n+looseIdentifier\n+    : identifier\n+    | FROM\n+    | TO\n+    | TABLE\n+    | WITH\n+    ;\n+\n+identifier\n+    : IDENTIFIER             #unquotedIdentifier\n+    | quotedIdentifier       #quotedIdentifierAlternative\n+    | nonReserved            #unquotedIdentifier\n+    ;\n+\n+quotedIdentifier\n+    : BACKQUOTED_IDENTIFIER\n+    ;\n+\n+number\n+    : DECIMAL_VALUE            #decimalLiteral\n+    | SCIENTIFIC_DECIMAL_VALUE #scientificDecimalLiteral\n+    | INTEGER_VALUE            #integerLiteral\n+    | BIGINT_LITERAL           #bigIntLiteral\n+    | SMALLINT_LITERAL         #smallIntLiteral\n+    | TINYINT_LITERAL          #tinyIntLiteral\n+    | DOUBLE_LITERAL           #doubleLiteral\n+    ;\n+\n+nonReserved\n+    : SHOW | TABLES | COLUMNS | COLUMN | PARTITIONS | FUNCTIONS | SCHEMAS | CATALOGS | SESSION\n+    | ADD\n+    | OVER | PARTITION | RANGE | ROWS | PRECEDING | FOLLOWING | CURRENT | ROW | MAP | ARRAY | STRUCT\n+    | LATERAL | WINDOW | REDUCE | TRANSFORM | USING | SERDE | SERDEPROPERTIES | RECORDREADER\n+    | DELIMITED | FIELDS | TERMINATED | COLLECTION | ITEMS | KEYS | ESCAPED | LINES | SEPARATED\n+    | EXTENDED | REFRESH | CLEAR | CACHE | UNCACHE | LAZY | TEMPORARY | OPTIONS\n+    | GROUPING | CUBE | ROLLUP\n+    | EXPLAIN | FORMAT | LOGICAL | FORMATTED\n+    | TABLESAMPLE | USE | TO | BUCKET | PERCENTLIT | OUT | OF\n+    | SET | RESET\n+    | VIEW | REPLACE\n+    | IF\n+    | NO | DATA\n+    | START | TRANSACTION | COMMIT | ROLLBACK | WORK | ISOLATION | LEVEL\n+    | SERIALIZABLE | REPEATABLE | COMMITTED | UNCOMMITTED | READ | WRITE | ONLY\n+    | CALL\n+    | SORT | CLUSTER | DISTRIBUTE\n+    ;\n+\n+SELECT: 'SELECT';"
  }, {
    "author": {
      "login": "hvanhovell"
    },
    "body": "We could. However it currently works better if they are in the same file when we are making modifications (which we currently are).\n",
    "commit": "6f1c535162397f01acf0405bdc80b8c4c141fc64",
    "createdAt": "2016-03-23T12:17:20Z",
    "diffHunk": "@@ -0,0 +1,742 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * This file is an adaptation of Presto's presto-parser/src/main/antlr4/com/facebook/presto/sql/parser/SqlBase.g4 grammar.\n+ */\n+\n+grammar SqlBase;\n+\n+tokens {\n+    DELIMITER\n+}\n+\n+singleStatement\n+    : statement EOF\n+    ;\n+\n+singleExpression\n+    : namedExpression EOF\n+    ;\n+\n+singleTableIdentifier\n+    : tableIdentifier EOF\n+    ;\n+\n+singleDataType\n+    : dataType EOF\n+    ;\n+\n+statement\n+    : query                                                            #statementDefault\n+    | USE db=identifier                                                #use\n+    | createTable ('(' colTypeList ')')? tableProvider tableProperties #createTableUsing\n+    | createTable tableProvider tableProperties? AS? query             #createTableUsingAsSelect\n+    | DROP TABLE (IF EXISTS)? qualifiedName                            #dropTable\n+    | DELETE FROM qualifiedName (WHERE booleanExpression)?             #delete\n+    | ALTER TABLE from=qualifiedName RENAME TO to=qualifiedName        #renameTable\n+    | ALTER TABLE tableName=qualifiedName\n+        RENAME COLUMN from=identifier TO to=identifier                 #renameColumn\n+    | ALTER TABLE tableName=qualifiedName\n+        ADD COLUMN column=colType                                      #addColumn\n+    | CREATE (OR REPLACE)? VIEW qualifiedName AS query                 #createView\n+    | DROP VIEW (IF EXISTS)? qualifiedName                             #dropView\n+    | CALL qualifiedName '(' (callArgument (',' callArgument)*)? ')'   #call\n+    | EXPLAIN explainOption* statement                                 #explain\n+    | SHOW TABLES ((FROM | IN) db=identifier)?\n+        (LIKE (qualifiedName | pattern=STRING))?                       #showTables\n+    | SHOW SCHEMAS ((FROM | IN) identifier)?                           #showSchemas\n+    | SHOW CATALOGS                                                    #showCatalogs\n+    | SHOW COLUMNS (FROM | IN) qualifiedName                           #showColumns\n+    | SHOW FUNCTIONS (LIKE? (qualifiedName | pattern=STRING))?         #showFunctions\n+    | (DESC | DESCRIBE) FUNCTION EXTENDED? qualifiedName               #describeFunction\n+    | (DESC | DESCRIBE) option=(EXTENDED | FORMATTED)?\n+        tableIdentifier partitionSpec? describeColName?                #describeTable\n+    | SHOW SESSION                                                     #showSession\n+    | SET SESSION qualifiedName EQ expression                          #setSession\n+    | RESET SESSION qualifiedName                                      #resetSession\n+    | START TRANSACTION (transactionMode (',' transactionMode)*)?      #startTransaction\n+    | COMMIT WORK?                                                     #commit\n+    | ROLLBACK WORK?                                                   #rollback\n+    | SHOW PARTITIONS (FROM | IN) qualifiedName\n+        (WHERE booleanExpression)?\n+        (ORDER BY sortItem (',' sortItem)*)?\n+        (LIMIT limit=(INTEGER_VALUE | ALL))?                           #showPartitions\n+    | REFRESH TABLE tableIdentifier                                    #refreshTable\n+    | CACHE LAZY? TABLE identifier (AS? query)?                        #cacheTable\n+    | UNCACHE TABLE identifier                                         #uncacheTable\n+    | CLEAR CACHE                                                      #clearCache\n+    | SET .*?                                                          #setConfiguration\n+    ;\n+\n+createTable\n+    : CREATE TEMPORARY? TABLE (IF NOT EXISTS)? tableIdentifier\n+    ;\n+\n+query\n+    : ctes? queryNoWith\n+    ;\n+\n+insertInto\n+    : INSERT OVERWRITE TABLE tableIdentifier partitionSpec? (IF NOT EXISTS)?\n+    | INSERT INTO TABLE? tableIdentifier partitionSpec?\n+    ;\n+\n+partitionSpec\n+    : PARTITION '(' partitionVal (',' partitionVal)* ')'\n+    ;\n+\n+partitionVal\n+    : identifier (EQ constant)?\n+    ;\n+\n+describeColName\n+    : identifier ('.' (identifier | STRING))*\n+    ;\n+\n+ctes\n+    : WITH namedQuery (',' namedQuery)*\n+    ;\n+\n+namedQuery\n+    : name=identifier AS? '(' queryNoWith ')'\n+    ;\n+\n+tableProvider\n+    : USING qualifiedName\n+    ;\n+\n+tableProperties\n+    :(OPTIONS | WITH) '(' tableProperty (',' tableProperty)* ')'\n+    ;\n+\n+tableProperty\n+    : key=tablePropertyKey (EQ? value=STRING)?\n+    ;\n+\n+tablePropertyKey\n+    : looseIdentifier ('.' looseIdentifier)*\n+    | STRING\n+    ;\n+\n+queryNoWith\n+    : insertInto? queryTerm queryOrganization                                              #singleInsertQuery\n+    | fromClause multiInsertQueryBody+                                                     #multiInsertQuery\n+    ;\n+\n+queryOrganization\n+    : (ORDER BY order+=sortItem (',' order+=sortItem)*)?\n+      (CLUSTER BY clusterBy+=expression (',' clusterBy+=expression)*)?\n+      (DISTRIBUTE BY distributeBy+=expression (',' distributeBy+=expression)*)?\n+      (SORT BY sort+=sortItem (',' sort+=sortItem)*)?\n+      windows?\n+      (LIMIT limit=expression)?\n+    ;\n+\n+multiInsertQueryBody\n+    : insertInto?\n+      querySpecification\n+      queryOrganization\n+    ;\n+\n+queryTerm\n+    : queryPrimary                                                                         #queryTermDefault\n+    | left=queryTerm operator=(INTERSECT | UNION | EXCEPT) setQuantifier? right=queryTerm  #setOperation\n+    ;\n+\n+queryPrimary\n+    : querySpecification                                                    #queryPrimaryDefault\n+    | TABLE tableIdentifier                                                 #table\n+    | inlineTable                                                           #inlineTableDefault1\n+    | '(' queryNoWith  ')'                                                  #subquery\n+    ;\n+\n+sortItem\n+    : expression ordering=(ASC | DESC)?\n+    ;\n+\n+querySpecification\n+    : (((SELECT kind=TRANSFORM | kind=MAP | kind=REDUCE)) '(' namedExpression (',' namedExpression)* ')'\n+       inRowFormat=rowFormat?\n+       USING script=STRING\n+       (AS (columnAliasList | colTypeList | ('(' (columnAliasList | colTypeList) ')')))?\n+       outRowFormat=rowFormat?\n+       (RECORDREADER outRecordReader=STRING)?\n+       fromClause?\n+       (WHERE where=booleanExpression)?)\n+    | (kind=SELECT setQuantifier? namedExpression (',' namedExpression)*\n+       fromClause?\n+       lateralView*\n+       (WHERE where=booleanExpression)?\n+       aggregation?\n+       (HAVING having=booleanExpression)?\n+       windows?)\n+    ;\n+\n+fromClause\n+    : FROM relation (',' relation)* lateralView*\n+    ;\n+\n+aggregation\n+    : GROUP BY groupingExpressions+=expression (',' groupingExpressions+=expression)* (\n+      WITH kind=ROLLUP\n+    | WITH kind=CUBE\n+    | kind=GROUPING SETS '(' groupingSet (',' groupingSet)* ')')?\n+    ;\n+\n+groupingSet\n+    : '(' (expression (',' expression)*)? ')'\n+    | expression\n+    ;\n+\n+lateralView\n+    : LATERAL VIEW (OUTER)? qualifiedName '(' (expression (',' expression)*)? ')' tblName=identifier (AS? colName+=identifier (',' colName+=identifier)*)\n+    ;\n+\n+setQuantifier\n+    : DISTINCT\n+    | ALL\n+    ;\n+\n+relation\n+    : left=relation\n+      ( CROSS JOIN right=sampledRelation\n+      | joinType JOIN rightRelation=relation joinCriteria?\n+      | NATURAL joinType JOIN right=sampledRelation\n+      )                                           #joinRelation\n+    | sampledRelation                             #relationDefault\n+    ;\n+\n+joinType\n+    : INNER?\n+    | LEFT OUTER?\n+    | LEFT SEMI\n+    | RIGHT OUTER?\n+    | FULL OUTER?\n+    ;\n+\n+joinCriteria\n+    : ON booleanExpression\n+    | USING '(' identifier (',' identifier)* ')'\n+    ;\n+\n+sampledRelation\n+    : relationPrimary (\n+        TABLESAMPLE '('\n+         ( (percentage=(INTEGER_VALUE | DECIMAL_VALUE) sampleType=PERCENTLIT)\n+         | (expression sampleType=ROWS)\n+         | (sampleType=BUCKET numerator=INTEGER_VALUE OUT OF denominator=INTEGER_VALUE (ON identifier)?))\n+         ')'\n+      )?\n+    ;\n+\n+columnAliases\n+    : '(' columnAliasList ')'\n+    ;\n+\n+columnAliasList\n+    : identifier (',' identifier)*\n+    ;\n+\n+relationPrimary\n+    : tableIdentifier (AS? identifier)?                             #tableName\n+    | '(' queryNoWith ')' (AS? identifier)?                         #aliasedQuery\n+    | '(' relation ')'  (AS? identifier)?                           #aliasedRelation\n+    | inlineTable                                                   #inlineTableDefault2\n+    ;\n+\n+inlineTable\n+    : VALUES expression (',' expression)*  (AS? identifier columnAliases?)?\n+    ;\n+\n+rowFormat\n+    : rowFormatSerde\n+    | rowFormatDelimited\n+    ;\n+\n+rowFormatSerde\n+    : ROW FORMAT SERDE name=STRING (WITH SERDEPROPERTIES props=tableProperties)?\n+    ;\n+\n+rowFormatDelimited\n+    : ROW FORMAT DELIMITED\n+      (FIELDS TERMINATED BY fieldsTerminatedBy=STRING)?\n+      (COLLECTION ITEMS TERMINATED BY collectionItemsTerminatedBy=STRING)?\n+      (MAP KEYS TERMINATED BY keysTerminatedBy=STRING)?\n+      (ESCAPED BY escapedBy=STRING)?\n+      (LINES SEPARATED BY linesSeparatedBy=STRING)?\n+    ;\n+\n+tableIdentifier\n+    : (db=identifier '.')? table=identifier\n+    ;\n+\n+namedExpression\n+    : expression (AS? (identifier | columnAliases))?\n+    ;\n+\n+expression\n+    : booleanExpression\n+    ;\n+\n+booleanExpression\n+    : predicated                                                   #booleanDefault\n+    | NOT booleanExpression                                        #logicalNot\n+    | left=booleanExpression operator=AND right=booleanExpression  #logicalBinary\n+    | left=booleanExpression operator=OR right=booleanExpression   #logicalBinary\n+    | EXISTS '(' query ')'                                         #exists\n+    ;\n+\n+// workaround for:\n+//  https://github.com/antlr/antlr4/issues/780\n+//  https://github.com/antlr/antlr4/issues/781\n+predicated\n+    : valueExpression predicate[$valueExpression.ctx]?\n+    ;\n+\n+predicate[ParserRuleContext value]\n+    : comparisonOperator right=valueExpression                            #comparison\n+    | NOT? BETWEEN lower=valueExpression AND upper=valueExpression        #between\n+    | NOT? IN '(' expression (',' expression)* ')'                        #inList\n+    | NOT? IN '(' query ')'                                               #inSubquery\n+    | NOT? like=(RLIKE | LIKE) pattern=valueExpression                    #like\n+    | IS NOT? NULL                                                        #nullPredicate\n+    ;\n+\n+valueExpression\n+    : primaryExpression                                                                      #valueExpressionDefault\n+    | operator=(MINUS | PLUS | TILDE) valueExpression                                        #arithmeticUnary\n+    | left=valueExpression operator=(ASTERISK | SLASH | PERCENT | DIV) right=valueExpression #arithmeticBinary\n+    | left=valueExpression operator=(PLUS | MINUS) right=valueExpression                     #arithmeticBinary\n+    | left=valueExpression operator=AMPERSAND right=valueExpression                          #arithmeticBinary\n+    | left=valueExpression operator=HAT right=valueExpression                                #arithmeticBinary\n+    | left=valueExpression operator=PIPE right=valueExpression                               #arithmeticBinary\n+    ;\n+\n+primaryExpression\n+    : constant                                                                                 #constantDefault\n+    | ASTERISK                                                                                 #star\n+    | qualifiedName '.' ASTERISK                                                               #star\n+    | '(' expression (',' expression)+ ')'                                                     #rowConstructor\n+    | qualifiedName '(' (ASTERISK) ')' (OVER windowSpec)?                                      #functionCall\n+    | qualifiedName '(' (setQuantifier? expression (',' expression)*)? ')' (OVER windowSpec)?  #functionCall\n+    | '(' query ')'                                                                            #subqueryExpression\n+    | CASE valueExpression whenClause+ (ELSE elseExpression=expression)? END                   #simpleCase\n+    | CASE whenClause+ (ELSE elseExpression=expression)? END                                   #searchedCase\n+    | CAST '(' expression AS dataType ')'                                                      #cast\n+    | value=primaryExpression '[' index=valueExpression ']'                                    #subscript\n+    | identifier                                                                               #columnReference\n+    | base=primaryExpression '.' fieldName=identifier                                          #dereference\n+    | '(' expression ')'                                                                       #parenthesizedExpression\n+    ;\n+\n+constant\n+    : NULL                                                                                     #nullLiteral\n+    | interval                                                                                 #intervalLiteral\n+    | identifier STRING                                                                        #typeConstructor\n+    | number                                                                                   #numericLiteral\n+    | booleanValue                                                                             #booleanLiteral\n+    | STRING+                                                                                  #stringLiteral\n+    ;\n+\n+comparisonOperator\n+    : EQ | NEQ | NEQJ | LT | LTE | GT | GTE | NSEQ\n+    ;\n+\n+booleanValue\n+    : TRUE | FALSE\n+    ;\n+\n+interval\n+    : INTERVAL intervalField*\n+    ;\n+\n+intervalField\n+    : value=intervalValue unit=identifier (TO to=identifier)?\n+    ;\n+\n+intervalValue\n+    : (PLUS | MINUS)? (INTEGER_VALUE | DECIMAL_VALUE)\n+    | STRING\n+    ;\n+\n+dataType\n+    : complex=ARRAY '<' dataType '>'                            #complexDataType\n+    | complex=MAP '<' dataType ',' dataType '>'                 #complexDataType\n+    | complex=STRUCT ('<' colTypeList? '>' | NEQ)              #complexDataType\n+    | identifier ('(' INTEGER_VALUE (',' INTEGER_VALUE)* ')')?  #primitiveDataType\n+    ;\n+\n+colTypeList\n+    : colType (',' colType)*\n+    ;\n+\n+colType\n+    : identifier ':'? dataType (COMMENT STRING)?\n+    ;\n+\n+whenClause\n+    : WHEN condition=expression THEN result=expression\n+    ;\n+\n+windows\n+    : WINDOW namedWindow (',' namedWindow)*\n+    ;\n+\n+namedWindow\n+    : identifier AS windowSpec\n+    ;\n+\n+windowSpec\n+    : name=identifier  #windowRef\n+    | '('\n+      (PARTITION BY partition+=expression (',' partition+=expression)*)?\n+      (ORDER BY sortItem (',' sortItem)* windowFrame?)?\n+      ')'              #windowDef\n+    ;\n+\n+windowFrame\n+    : frameType=RANGE start=frameBound\n+    | frameType=ROWS start=frameBound\n+    | frameType=RANGE BETWEEN start=frameBound AND end=frameBound\n+    | frameType=ROWS BETWEEN start=frameBound AND end=frameBound\n+    ;\n+\n+frameBound\n+    : UNBOUNDED boundType=(PRECEDING | FOLLOWING)\n+    | boundType=CURRENT ROW\n+    | expression boundType=(PRECEDING | FOLLOWING)\n+    ;\n+\n+\n+explainOption\n+    : LOGICAL | FORMATTED | EXTENDED\n+    ;\n+\n+transactionMode\n+    : ISOLATION LEVEL levelOfIsolation    #isolationLevel\n+    | READ accessMode=(ONLY | WRITE)      #transactionAccessMode\n+    ;\n+\n+levelOfIsolation\n+    : READ UNCOMMITTED                    #readUncommitted\n+    | READ COMMITTED                      #readCommitted\n+    | REPEATABLE READ                     #repeatableRead\n+    | SERIALIZABLE                        #serializable\n+    ;\n+\n+callArgument\n+    : expression                    #positionalArgument\n+    | identifier '=>' expression    #namedArgument\n+    ;\n+\n+qualifiedName\n+    : identifier ('.' identifier)*\n+    ;\n+\n+// Identifier that also allows the use of a number of SQL keywords (mainly for backwards compatibility).\n+looseIdentifier\n+    : identifier\n+    | FROM\n+    | TO\n+    | TABLE\n+    | WITH\n+    ;\n+\n+identifier\n+    : IDENTIFIER             #unquotedIdentifier\n+    | quotedIdentifier       #quotedIdentifierAlternative\n+    | nonReserved            #unquotedIdentifier\n+    ;\n+\n+quotedIdentifier\n+    : BACKQUOTED_IDENTIFIER\n+    ;\n+\n+number\n+    : DECIMAL_VALUE            #decimalLiteral\n+    | SCIENTIFIC_DECIMAL_VALUE #scientificDecimalLiteral\n+    | INTEGER_VALUE            #integerLiteral\n+    | BIGINT_LITERAL           #bigIntLiteral\n+    | SMALLINT_LITERAL         #smallIntLiteral\n+    | TINYINT_LITERAL          #tinyIntLiteral\n+    | DOUBLE_LITERAL           #doubleLiteral\n+    ;\n+\n+nonReserved\n+    : SHOW | TABLES | COLUMNS | COLUMN | PARTITIONS | FUNCTIONS | SCHEMAS | CATALOGS | SESSION\n+    | ADD\n+    | OVER | PARTITION | RANGE | ROWS | PRECEDING | FOLLOWING | CURRENT | ROW | MAP | ARRAY | STRUCT\n+    | LATERAL | WINDOW | REDUCE | TRANSFORM | USING | SERDE | SERDEPROPERTIES | RECORDREADER\n+    | DELIMITED | FIELDS | TERMINATED | COLLECTION | ITEMS | KEYS | ESCAPED | LINES | SEPARATED\n+    | EXTENDED | REFRESH | CLEAR | CACHE | UNCACHE | LAZY | TEMPORARY | OPTIONS\n+    | GROUPING | CUBE | ROLLUP\n+    | EXPLAIN | FORMAT | LOGICAL | FORMATTED\n+    | TABLESAMPLE | USE | TO | BUCKET | PERCENTLIT | OUT | OF\n+    | SET | RESET\n+    | VIEW | REPLACE\n+    | IF\n+    | NO | DATA\n+    | START | TRANSACTION | COMMIT | ROLLBACK | WORK | ISOLATION | LEVEL\n+    | SERIALIZABLE | REPEATABLE | COMMITTED | UNCOMMITTED | READ | WRITE | ONLY\n+    | CALL\n+    | SORT | CLUSTER | DISTRIBUTE\n+    ;\n+\n+SELECT: 'SELECT';"
  }],
  "prId": 11557
}]