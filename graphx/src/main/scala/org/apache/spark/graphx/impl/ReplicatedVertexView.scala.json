[{
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "Use withEdges\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:20:31Z",
    "diffHunk": "@@ -21,192 +21,102 @@ import scala.reflect.{classTag, ClassTag}\n \n import org.apache.spark.SparkContext._\n import org.apache.spark.rdd.RDD\n-import org.apache.spark.util.collection.{PrimitiveVector, OpenHashSet}\n \n import org.apache.spark.graphx._\n \n /**\n- * A view of the vertices after they are shipped to the join sites specified in\n- * `vertexPlacement`. The resulting view is co-partitioned with `edges`. If `prevViewOpt` is\n- * specified, `updatedVerts` are treated as incremental updates to the previous view. Otherwise, a\n- * fresh view is created.\n- *\n- * The view is always cached (i.e., once it is evaluated, it remains materialized). This avoids\n- * constructing it twice if the user calls graph.triplets followed by graph.mapReduceTriplets, for\n- * example. However, it means iterative algorithms must manually call `Graph.unpersist` on previous\n- * iterations' graphs for best GC performance. See the implementation of\n- * [[org.apache.spark.graphx.Pregel]] for an example.\n+ * Manages shipping vertex attributes to the edge partitions of an\n+ * [[org.apache.spark.graphx.EdgeRDD]]. Vertex attributes may be partially shipped to construct a\n+ * triplet view with vertex attributes on only one side, and they may be updated. An active vertex\n+ * set may additionally be shipped to the edge partitions. Be careful not to store a reference to\n+ * `edges`, since it may be modified when the attribute shipping level is upgraded.\n  */\n private[impl]\n-class ReplicatedVertexView[VD: ClassTag](\n-    updatedVerts: VertexRDD[VD],\n-    edges: EdgeRDD[_],\n-    routingTable: RoutingTable,\n-    prevViewOpt: Option[ReplicatedVertexView[VD]] = None) {\n+class ReplicatedVertexView[VD: ClassTag, ED: ClassTag](\n+    var edges: EdgeRDD[ED, VD],\n+    var hasSrcId: Boolean = false,\n+    var hasDstId: Boolean = false) {\n \n   /**\n-   * Within each edge partition, create a local map from vid to an index into the attribute\n-   * array. Each map contains a superset of the vertices that it will receive, because it stores\n-   * vids from both the source and destination of edges. It must always include both source and\n-   * destination vids because some operations, such as GraphImpl.mapReduceTriplets, rely on this.\n+   * Return a new `ReplicatedVertexView` with the specified `EdgeRDD`, which must have the same\n+   * shipping level.\n    */\n-  private val localVertexIdMap: RDD[(Int, VertexIdToIndexMap)] = prevViewOpt match {\n-    case Some(prevView) =>\n-      prevView.localVertexIdMap\n-    case None =>\n-      edges.partitionsRDD.mapPartitions(_.map {\n-        case (pid, epart) =>\n-          val vidToIndex = new VertexIdToIndexMap\n-          epart.foreach { e =>\n-            vidToIndex.add(e.srcId)\n-            vidToIndex.add(e.dstId)\n-          }\n-          (pid, vidToIndex)\n-      }, preservesPartitioning = true).cache().setName(\"ReplicatedVertexView localVertexIdMap\")\n-  }\n-\n-  private lazy val bothAttrs: RDD[(PartitionID, VertexPartition[VD])] = create(true, true)\n-  private lazy val srcAttrOnly: RDD[(PartitionID, VertexPartition[VD])] = create(true, false)\n-  private lazy val dstAttrOnly: RDD[(PartitionID, VertexPartition[VD])] = create(false, true)\n-  private lazy val noAttrs: RDD[(PartitionID, VertexPartition[VD])] = create(false, false)\n-\n-  def unpersist(blocking: Boolean = true): ReplicatedVertexView[VD] = {\n-    bothAttrs.unpersist(blocking)\n-    srcAttrOnly.unpersist(blocking)\n-    dstAttrOnly.unpersist(blocking)\n-    noAttrs.unpersist(blocking)\n-    // Don't unpersist localVertexIdMap because a future ReplicatedVertexView may be using it\n-    // without modification\n-    this\n+  def withEdges[VD2: ClassTag, ED2: ClassTag](\n+      edges_ : EdgeRDD[ED2, VD2]): ReplicatedVertexView[VD2, ED2] = {\n+    new ReplicatedVertexView(edges_, hasSrcId, hasDstId)\n   }\n \n-  def get(includeSrc: Boolean, includeDst: Boolean): RDD[(PartitionID, VertexPartition[VD])] = {\n-    (includeSrc, includeDst) match {\n-      case (true, true) => bothAttrs\n-      case (true, false) => srcAttrOnly\n-      case (false, true) => dstAttrOnly\n-      case (false, false) => noAttrs\n-    }\n+  /**\n+   * Return a new `ReplicatedVertexView` where edges are reversed and shipping levels are swapped to\n+   * match.\n+   */\n+  def reverse() = {\n+    val newEdges = edges.mapEdgePartitions((pid, part) => part.reverse)\n+    new ReplicatedVertexView(newEdges, hasDstId, hasSrcId)\n   }\n \n-  def get(\n-      includeSrc: Boolean,\n-      includeDst: Boolean,\n-      actives: VertexRDD[_]): RDD[(PartitionID, VertexPartition[VD])] = {\n-    // Ship active sets to edge partitions using vertexPlacement, but ignoring includeSrc and\n-    // includeDst. These flags govern attribute shipping, but the activeness of a vertex must be\n-    // shipped to all edges mentioning that vertex, regardless of whether the vertex attribute is\n-    // also shipped there.\n-    val shippedActives = routingTable.get(true, true)\n-      .zipPartitions(actives.partitionsRDD)(ReplicatedVertexView.buildActiveBuffer(_, _))\n-      .partitionBy(edges.partitioner.get)\n-    // Update the view with shippedActives, setting activeness flags in the resulting\n-    // VertexPartitions\n-    get(includeSrc, includeDst).zipPartitions(shippedActives) { (viewIter, shippedActivesIter) =>\n-      val (pid, vPart) = viewIter.next()\n-      val newPart = vPart.replaceActives(shippedActivesIter.flatMap(_._2.iterator))\n-      Iterator((pid, newPart))\n+  /**\n+   * Upgrade the shipping level in-place to the specified levels by shipping vertex attributes from\n+   * `vertices`. This operation modifies the `ReplicatedVertexView`, and callers can access `edges`\n+   * afterwards to obtain the upgraded view.\n+   */\n+  def upgrade(vertices: VertexRDD[VD], includeSrc: Boolean, includeDst: Boolean) {\n+    val shipSrc = includeSrc && !hasSrcId\n+    val shipDst = includeDst && !hasDstId\n+    if (shipSrc || shipDst) {\n+      val shippedVerts: RDD[(Int, VertexAttributeBlock[VD])] =\n+        vertices.shipVertexAttributes(shipSrc, shipDst)\n+          .setName(\"ReplicatedVertexView.upgrade(%s, %s) - shippedVerts %s %s (broadcast)\".format(\n+            includeSrc, includeDst, shipSrc, shipDst))\n+          .partitionBy(edges.partitioner.get)\n+      val newEdges = new EdgeRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n+        (ePartIter, shippedVertsIter) => ePartIter.map {\n+          case (pid, edgePartition) =>\n+            (pid, edgePartition.updateVertices(shippedVertsIter.flatMap(_._2.iterator)))\n+        }\n+      })\n+      edges = newEdges\n+      hasSrcId = includeSrc\n+      hasDstId = includeDst\n     }\n   }\n \n-  private def create(includeSrc: Boolean, includeDst: Boolean)\n-    : RDD[(PartitionID, VertexPartition[VD])] = {\n-    val vdTag = classTag[VD]\n-\n-    // Ship vertex attributes to edge partitions according to vertexPlacement\n-    val verts = updatedVerts.partitionsRDD\n-    val shippedVerts = routingTable.get(includeSrc, includeDst)\n-      .zipPartitions(verts)(ReplicatedVertexView.buildBuffer(_, _)(vdTag))\n+  /**\n+   * Return a new `ReplicatedVertexView` where the `activeSet` in each edge partition contains only\n+   * vertex ids present in `actives`. This ships a vertex id to all edge partitions where it is\n+   * referenced, ignoring the attribute shipping level.\n+   */\n+  def withActiveSet(actives: VertexRDD[_]): ReplicatedVertexView[VD, ED] = {\n+    val shippedActives = actives.shipVertexIds()\n+      .setName(\"ReplicatedVertexView.withActiveSet - shippedActives (broadcast)\")\n       .partitionBy(edges.partitioner.get)\n-    // TODO: Consider using a specialized shuffler.\n-\n-    prevViewOpt match {\n-      case Some(prevView) =>\n-        // Update prevView with shippedVerts, setting staleness flags in the resulting\n-        // VertexPartitions\n-        prevView.get(includeSrc, includeDst).zipPartitions(shippedVerts) {\n-          (prevViewIter, shippedVertsIter) =>\n-            val (pid, prevVPart) = prevViewIter.next()\n-            val newVPart = prevVPart.innerJoinKeepLeft(shippedVertsIter.flatMap(_._2.iterator))\n-            Iterator((pid, newVPart))\n-        }.cache().setName(\"ReplicatedVertexView delta %s %s\".format(includeSrc, includeDst))\n \n-      case None =>\n-        // Within each edge partition, place the shipped vertex attributes into the correct\n-        // locations specified in localVertexIdMap\n-        localVertexIdMap.zipPartitions(shippedVerts) { (mapIter, shippedVertsIter) =>\n-          val (pid, vidToIndex) = mapIter.next()\n-          assert(!mapIter.hasNext)\n-          // Populate the vertex array using the vidToIndex map\n-          val vertexArray = vdTag.newArray(vidToIndex.capacity)\n-          for ((_, block) <- shippedVertsIter) {\n-            for (i <- 0 until block.vids.size) {\n-              val vid = block.vids(i)\n-              val attr = block.attrs(i)\n-              val ind = vidToIndex.getPos(vid)\n-              vertexArray(ind) = attr\n-            }\n-          }\n-          val newVPart = new VertexPartition(\n-            vidToIndex, vertexArray, vidToIndex.getBitSet)(vdTag)\n-          Iterator((pid, newVPart))\n-        }.cache().setName(\"ReplicatedVertexView %s %s\".format(includeSrc, includeDst))\n-    }\n-  }\n-}\n-\n-private object ReplicatedVertexView {\n-  protected def buildBuffer[VD: ClassTag](\n-      pid2vidIter: Iterator[Array[Array[VertexId]]],\n-      vertexPartIter: Iterator[VertexPartition[VD]]) = {\n-    val pid2vid: Array[Array[VertexId]] = pid2vidIter.next()\n-    val vertexPart: VertexPartition[VD] = vertexPartIter.next()\n-\n-    Iterator.tabulate(pid2vid.size) { pid =>\n-      val vidsCandidate = pid2vid(pid)\n-      val size = vidsCandidate.length\n-      val vids = new PrimitiveVector[VertexId](pid2vid(pid).size)\n-      val attrs = new PrimitiveVector[VD](pid2vid(pid).size)\n-      var i = 0\n-      while (i < size) {\n-        val vid = vidsCandidate(i)\n-        if (vertexPart.isDefined(vid)) {\n-          vids += vid\n-          attrs += vertexPart(vid)\n-        }\n-        i += 1\n+    val newEdges = new EdgeRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n+      (ePartIter, shippedActivesIter) => ePartIter.map {\n+        case (pid, edgePartition) =>\n+          (pid, edgePartition.withActiveSet(shippedActivesIter.flatMap(_._2.iterator)))\n       }\n-      (pid, new VertexAttributeBlock(vids.trim().array, attrs.trim().array))\n-    }\n+    })\n+    new ReplicatedVertexView(newEdges, hasSrcId, hasDstId)",
    "line": 218
  }],
  "prId": 497
}]