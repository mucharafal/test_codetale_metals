[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "map with case is also probably slower than it needs to be\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-06T18:46:43Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { case (vid, position) => new RoutingTableMessage(vid, pid, position) }"
  }],
  "prId": 497
}, {
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "Merge srcFlags and dstFlags into a PrimitiveVector[Byte]\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:28:56Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { vidAndPosition =>\n+      new RoutingTableMessage(vidAndPosition._1, pid, vidAndPosition._2)\n+    }\n+  }\n+\n+  /** Build a `RoutingTablePartition` from `RoutingTableMessage`s. */\n+  def fromMsgs(numEdgePartitions: Int, iter: Iterator[RoutingTableMessage])\n+    : RoutingTablePartition = {\n+    val pid2vid = Array.fill(numEdgePartitions)(new PrimitiveVector[VertexId])\n+    val srcFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])",
    "line": 88
  }, {
    "author": {
      "login": "ankurdave"
    },
    "body": "@rxin What is the reason to use PrimitiveVector over ArrayBuilder? The latter specializes for all primitives, including Bytes: https://github.com/scala/scala/blob/v2.10.4/src/library/scala/collection/mutable/ArrayBuilder.scala#L40\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:31:34Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { vidAndPosition =>\n+      new RoutingTableMessage(vidAndPosition._1, pid, vidAndPosition._2)\n+    }\n+  }\n+\n+  /** Build a `RoutingTablePartition` from `RoutingTableMessage`s. */\n+  def fromMsgs(numEdgePartitions: Int, iter: Iterator[RoutingTableMessage])\n+    : RoutingTablePartition = {\n+    val pid2vid = Array.fill(numEdgePartitions)(new PrimitiveVector[VertexId])\n+    val srcFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])",
    "line": 88
  }, {
    "author": {
      "login": "ankurdave"
    },
    "body": "TODO: Use Scala BitSet, which is auto-resizing, avoiding the copy\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:38:10Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { vidAndPosition =>\n+      new RoutingTableMessage(vidAndPosition._1, pid, vidAndPosition._2)\n+    }\n+  }\n+\n+  /** Build a `RoutingTablePartition` from `RoutingTableMessage`s. */\n+  def fromMsgs(numEdgePartitions: Int, iter: Iterator[RoutingTableMessage])\n+    : RoutingTablePartition = {\n+    val pid2vid = Array.fill(numEdgePartitions)(new PrimitiveVector[VertexId])\n+    val srcFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])",
    "line": 88
  }],
  "prId": 497
}, {
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "TODO: Switch to while\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:40:05Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { vidAndPosition =>\n+      new RoutingTableMessage(vidAndPosition._1, pid, vidAndPosition._2)\n+    }\n+  }\n+\n+  /** Build a `RoutingTablePartition` from `RoutingTableMessage`s. */\n+  def fromMsgs(numEdgePartitions: Int, iter: Iterator[RoutingTableMessage])\n+    : RoutingTablePartition = {\n+    val pid2vid = Array.fill(numEdgePartitions)(new PrimitiveVector[VertexId])\n+    val srcFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])\n+    val dstFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])\n+    for (msg <- iter) {\n+      pid2vid(msg.pid) += msg.vid\n+      srcFlags(msg.pid) += (msg.position & 0x1) != 0\n+      dstFlags(msg.pid) += (msg.position & 0x2) != 0\n+    }\n+\n+    new RoutingTablePartition(pid2vid.zipWithIndex.map {\n+      case (vids, pid) => (vids.trim().array, toBitSet(srcFlags(pid)), toBitSet(dstFlags(pid)))\n+    })\n+  }\n+\n+  /** Compact the given vector of Booleans into a BitSet. */\n+  private def toBitSet(flags: PrimitiveVector[Boolean]): BitSet = {\n+    val bitset = new BitSet(flags.size)\n+    var i = 0\n+    while (i < flags.size) {\n+      if (flags(i)) {\n+        bitset.set(i)\n+      }\n+      i += 1\n+    }\n+    bitset\n+  }\n+}\n+\n+/**\n+ * Stores the locations of edge-partition join sites for each vertex attribute in a particular\n+ * vertex partition. This provides routing information for shipping vertex attributes to edge\n+ * partitions.\n+ */\n+private[graphx]\n+class RoutingTablePartition(\n+    private val routingTable: Array[(Array[VertexId], BitSet, BitSet)]) {\n+  /** The maximum number of edge partitions this `RoutingTablePartition` is built to join with. */\n+  val numEdgePartitions: Int = routingTable.size\n+\n+  /** Returns the number of vertices that will be sent to the specified edge partition. */\n+  def partitionSize(pid: PartitionID): Int = routingTable(pid)._1.size\n+\n+  /** Returns an iterator over all vertex ids stored in this `RoutingTablePartition`. */\n+  def iterator: Iterator[VertexId] = routingTable.iterator.flatMap(_._1.iterator)\n+\n+  /** Returns a new RoutingTablePartition reflecting a reversal of all edge directions. */\n+  def reverse: RoutingTablePartition = {\n+    new RoutingTablePartition(routingTable.map {\n+      case (vids, srcVids, dstVids) => (vids, dstVids, srcVids)\n+    })\n+  }\n+\n+  /**\n+   * Runs `f` on each vertex id to be sent to the specified edge partition. Vertex ids can be\n+   * filtered by the position they have in the edge partition.\n+   */\n+  def foreachWithinEdgePartition\n+      (pid: PartitionID, includeSrc: Boolean, includeDst: Boolean)\n+      (f: VertexId => Unit) {\n+    val (vidsCandidate, srcVids, dstVids) = routingTable(pid)\n+    val size = vidsCandidate.length\n+    if (includeSrc && includeDst) {\n+      // Avoid checks for performance\n+      vidsCandidate.iterator.foreach(f)",
    "line": 150
  }],
  "prId": 497
}, {
  "comments": [{
    "author": {
      "login": "ankurdave"
    },
    "body": "TODO: Switch to while\n",
    "commit": "332ab43f388a1e0a1e445971289df80c68072ad6",
    "createdAt": "2014-05-08T22:40:12Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.graphx.impl\n+\n+import scala.reflect.ClassTag\n+\n+import org.apache.spark.Partitioner\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.rdd.ShuffledRDD\n+import org.apache.spark.util.collection.{BitSet, PrimitiveVector}\n+\n+import org.apache.spark.graphx._\n+import org.apache.spark.graphx.util.collection.PrimitiveKeyOpenHashMap\n+\n+/**\n+ * A message from the edge partition `pid` to the vertex partition containing `vid` specifying that\n+ * the edge partition references `vid` in the specified `position` (src, dst, or both).\n+*/\n+private[graphx]\n+class RoutingTableMessage(\n+    var vid: VertexId,\n+    var pid: PartitionID,\n+    var position: Byte)\n+  extends Product2[VertexId, (PartitionID, Byte)] with Serializable {\n+  override def _1 = vid\n+  override def _2 = (pid, position)\n+  override def canEqual(that: Any): Boolean = that.isInstanceOf[RoutingTableMessage]\n+}\n+\n+private[graphx]\n+class RoutingTableMessageRDDFunctions(self: RDD[RoutingTableMessage]) {\n+  /** Copartition an `RDD[RoutingTableMessage]` with the vertex RDD with the given `partitioner`. */\n+  def copartitionWithVertices(partitioner: Partitioner): RDD[RoutingTableMessage] = {\n+    new ShuffledRDD[VertexId, (PartitionID, Byte), RoutingTableMessage](self, partitioner)\n+      .setSerializer(new RoutingTableMessageSerializer)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTableMessageRDDFunctions {\n+  import scala.language.implicitConversions\n+\n+  implicit def rdd2RoutingTableMessageRDDFunctions(rdd: RDD[RoutingTableMessage]) = {\n+    new RoutingTableMessageRDDFunctions(rdd)\n+  }\n+}\n+\n+private[graphx]\n+object RoutingTablePartition {\n+  val empty: RoutingTablePartition = new RoutingTablePartition(Array.empty)\n+\n+  /** Generate a `RoutingTableMessage` for each vertex referenced in `edgePartition`. */\n+  def edgePartitionToMsgs(pid: PartitionID, edgePartition: EdgePartition[_, _])\n+    : Iterator[RoutingTableMessage] = {\n+    // Determine which positions each vertex id appears in using a map where the low 2 bits\n+    // represent src and dst\n+    val map = new PrimitiveKeyOpenHashMap[VertexId, Byte]\n+    edgePartition.srcIds.iterator.foreach { srcId =>\n+      map.changeValue(srcId, 0x1, (b: Byte) => (b | 0x1).toByte)\n+    }\n+    edgePartition.dstIds.iterator.foreach { dstId =>\n+      map.changeValue(dstId, 0x2, (b: Byte) => (b | 0x2).toByte)\n+    }\n+    map.iterator.map { vidAndPosition =>\n+      new RoutingTableMessage(vidAndPosition._1, pid, vidAndPosition._2)\n+    }\n+  }\n+\n+  /** Build a `RoutingTablePartition` from `RoutingTableMessage`s. */\n+  def fromMsgs(numEdgePartitions: Int, iter: Iterator[RoutingTableMessage])\n+    : RoutingTablePartition = {\n+    val pid2vid = Array.fill(numEdgePartitions)(new PrimitiveVector[VertexId])\n+    val srcFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])\n+    val dstFlags = Array.fill(numEdgePartitions)(new PrimitiveVector[Boolean])\n+    for (msg <- iter) {\n+      pid2vid(msg.pid) += msg.vid\n+      srcFlags(msg.pid) += (msg.position & 0x1) != 0\n+      dstFlags(msg.pid) += (msg.position & 0x2) != 0\n+    }\n+\n+    new RoutingTablePartition(pid2vid.zipWithIndex.map {\n+      case (vids, pid) => (vids.trim().array, toBitSet(srcFlags(pid)), toBitSet(dstFlags(pid)))\n+    })\n+  }\n+\n+  /** Compact the given vector of Booleans into a BitSet. */\n+  private def toBitSet(flags: PrimitiveVector[Boolean]): BitSet = {\n+    val bitset = new BitSet(flags.size)\n+    var i = 0\n+    while (i < flags.size) {\n+      if (flags(i)) {\n+        bitset.set(i)\n+      }\n+      i += 1\n+    }\n+    bitset\n+  }\n+}\n+\n+/**\n+ * Stores the locations of edge-partition join sites for each vertex attribute in a particular\n+ * vertex partition. This provides routing information for shipping vertex attributes to edge\n+ * partitions.\n+ */\n+private[graphx]\n+class RoutingTablePartition(\n+    private val routingTable: Array[(Array[VertexId], BitSet, BitSet)]) {\n+  /** The maximum number of edge partitions this `RoutingTablePartition` is built to join with. */\n+  val numEdgePartitions: Int = routingTable.size\n+\n+  /** Returns the number of vertices that will be sent to the specified edge partition. */\n+  def partitionSize(pid: PartitionID): Int = routingTable(pid)._1.size\n+\n+  /** Returns an iterator over all vertex ids stored in this `RoutingTablePartition`. */\n+  def iterator: Iterator[VertexId] = routingTable.iterator.flatMap(_._1.iterator)\n+\n+  /** Returns a new RoutingTablePartition reflecting a reversal of all edge directions. */\n+  def reverse: RoutingTablePartition = {\n+    new RoutingTablePartition(routingTable.map {\n+      case (vids, srcVids, dstVids) => (vids, dstVids, srcVids)\n+    })\n+  }\n+\n+  /**\n+   * Runs `f` on each vertex id to be sent to the specified edge partition. Vertex ids can be\n+   * filtered by the position they have in the edge partition.\n+   */\n+  def foreachWithinEdgePartition\n+      (pid: PartitionID, includeSrc: Boolean, includeDst: Boolean)\n+      (f: VertexId => Unit) {\n+    val (vidsCandidate, srcVids, dstVids) = routingTable(pid)\n+    val size = vidsCandidate.length\n+    if (includeSrc && includeDst) {\n+      // Avoid checks for performance\n+      vidsCandidate.iterator.foreach(f)\n+    } else if (!includeSrc && !includeDst) {\n+      // Do nothing\n+    } else {\n+      val relevantVids = if (includeSrc) srcVids else dstVids\n+      relevantVids.iterator.foreach { i => f(vidsCandidate(i)) }",
    "line": 155
  }],
  "prId": 497
}]