[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I would just `require(...)` this condition. `(dblCount % 2) == 0` would be a little more canonical\n",
    "commit": "1e6f5d2e01ea7902a1c7ec5261e21e855ed8b073",
    "createdAt": "2016-02-21T12:41:25Z",
    "diffHunk": "@@ -80,15 +103,18 @@ object TriangleCount {\n       ctx.sendToSrc(counter)\n       ctx.sendToDst(counter)\n     }\n+\n     // compute the intersection along edges\n     val counters: VertexRDD[Int] = setGraph.aggregateMessages(edgeFunc, _ + _)\n     // Merge counters with the graph and divide by two since each triangle is counted twice\n-    g.outerJoinVertices(counters) {\n-      (vid, _, optCounter: Option[Int]) =>\n-        val dblCount = optCounter.getOrElse(0)\n-        // double count should be even (divisible by two)\n-        assert((dblCount & 1) == 0)\n-        dblCount / 2\n+    graph.outerJoinVertices(counters) { (vid, _, optCounter: Option[Int]) =>\n+      val dblCount = optCounter.getOrElse(0)\n+      // This algorithm double counts each triangle so the final count should be even\n+      val isEven = (dblCount & 1) == 0\n+      if (!isEven) {\n+        throw new Exception(\"Triangle count resulted in an invalid number of triangles.\")"
  }],
  "prId": 11290
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: just `{ (_, _, optCounter) =>` right?\n",
    "commit": "1e6f5d2e01ea7902a1c7ec5261e21e855ed8b073",
    "createdAt": "2016-02-21T12:42:13Z",
    "diffHunk": "@@ -27,25 +28,47 @@ import org.apache.spark.graphx._\n  * The algorithm is relatively straightforward and can be computed in three steps:\n  *\n  * <ul>\n- * <li>Compute the set of neighbors for each vertex\n- * <li>For each edge compute the intersection of the sets and send the count to both vertices.\n+ * <li> Compute the set of neighbors for each vertex\n+ * <li> For each edge compute the intersection of the sets and send the count to both vertices.\n  * <li> Compute the sum at each vertex and divide by two since each triangle is counted twice.\n  * </ul>\n  *\n- * Note that the input graph should have its edges in canonical direction\n- * (i.e. the `sourceId` less than `destId`). Also the graph must have been partitioned\n- * using [[org.apache.spark.graphx.Graph#partitionBy]].\n+ * There are two implementations.  The default `TriangleCount.run` implementation first removes\n+ * self cycles and canonicalizes the graph to ensure that the following conditions hold:\n+ * <ul>\n+ * <li> There are no self edges\n+ * <li> All edges are oriented src > dst\n+ * <li> There are no duplicate edges\n+ * </ul>\n+ * However, the canonicalization procedure is costly as it requires repartitioning the graph.\n+ * If the input data is already in \"canonical form\" with self cycles removed then the\n+ * `TriangleCount.runPreCanonicalized` should be used instead.\n+ *\n+ * {{{\n+ * val canonicalGraph = graph.mapEdges(e => 1).removeSelfEdges().canonicalizeEdges()\n+ * val counts = TriangleCount.runPreCanonicalized(canonicalGraph).vertices\n+ * }}}\n+ *\n  */\n object TriangleCount {\n \n   def run[VD: ClassTag, ED: ClassTag](graph: Graph[VD, ED]): Graph[Int, ED] = {\n-    // Remove redundant edges\n-    val g = graph.groupEdges((a, b) => a).cache()\n+    // Transform the edge data something cheap to shuffle and then canonicalize\n+    val canonicalGraph = graph.mapEdges(e => true).removeSelfEdges().convertToCanonicalEdges()\n+    // Get the triangle counts\n+    val counters = runPreCanonicalized(canonicalGraph).vertices\n+    // Join them bath with the original graph\n+    graph.outerJoinVertices(counters) { (vid, _, optCounter: Option[Int]) =>",
    "line": 50
  }],
  "prId": 11290
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: the `<li>` should be closed if you're writing HTML tags\n",
    "commit": "1e6f5d2e01ea7902a1c7ec5261e21e855ed8b073",
    "createdAt": "2016-02-21T12:42:48Z",
    "diffHunk": "@@ -27,25 +28,47 @@ import org.apache.spark.graphx._\n  * The algorithm is relatively straightforward and can be computed in three steps:\n  *\n  * <ul>\n- * <li>Compute the set of neighbors for each vertex\n- * <li>For each edge compute the intersection of the sets and send the count to both vertices.\n+ * <li> Compute the set of neighbors for each vertex"
  }],
  "prId": 11290
}]