[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "maek this private[this] val instead\n",
    "commit": "194a2df94768be9c08ed50654170bad937bd115a",
    "createdAt": "2014-11-11T00:31:23Z",
    "diffHunk": "@@ -38,19 +39,77 @@ class EdgePartitionBuilder[@specialized(Long, Int, Double) ED: ClassTag, VD: Cla\n   def toEdgePartition: EdgePartition[ED, VD] = {\n     val edgeArray = edges.trim().array\n     Sorting.quickSort(edgeArray)(Edge.lexicographicOrdering)\n-    val srcIds = new Array[VertexId](edgeArray.size)\n-    val dstIds = new Array[VertexId](edgeArray.size)\n+    val localSrcIds = new Array[Int](edgeArray.size)\n+    val localDstIds = new Array[Int](edgeArray.size)\n+    val data = new Array[ED](edgeArray.size)\n+    val index = new GraphXPrimitiveKeyOpenHashMap[VertexId, Int]\n+    val global2local = new GraphXPrimitiveKeyOpenHashMap[VertexId, Int]\n+    val local2global = new PrimitiveVector[VertexId]\n+    var vertexAttrs = Array.empty[VD]\n+    // Copy edges into columnar structures, tracking the beginnings of source vertex id clusters and\n+    // adding them to the index. Also populate a map from vertex id to a sequential local offset.\n+    if (edgeArray.length > 0) {\n+      index.update(edgeArray(0).srcId, 0)\n+      var currSrcId: VertexId = edgeArray(0).srcId\n+      var currLocalId = -1\n+      var i = 0\n+      while (i < edgeArray.size) {\n+        val srcId = edgeArray(i).srcId\n+        val dstId = edgeArray(i).dstId\n+        localSrcIds(i) = global2local.changeValue(srcId,\n+          { currLocalId += 1; local2global += srcId; currLocalId }, identity)\n+        localDstIds(i) = global2local.changeValue(dstId,\n+          { currLocalId += 1; local2global += dstId; currLocalId }, identity)\n+        data(i) = edgeArray(i).attr\n+        if (srcId != currSrcId) {\n+          currSrcId = srcId\n+          index.update(currSrcId, i)\n+        }\n+\n+        i += 1\n+      }\n+      vertexAttrs = new Array[VD](currLocalId + 1)\n+    }\n+    new EdgePartition(\n+      localSrcIds, localDstIds, data, index, global2local, local2global.trim().array, vertexAttrs)\n+  }\n+}\n+\n+/**\n+ * Constructs an EdgePartition from an existing EdgePartition with the same vertex set. This enables\n+ * reuse of the local vertex ids. Intended for internal use in EdgePartition only.\n+ */\n+private[impl]\n+class ExistingEdgePartitionBuilder[\n+    @specialized(Long, Int, Double) ED: ClassTag, VD: ClassTag](\n+    global2local: GraphXPrimitiveKeyOpenHashMap[VertexId, Int],\n+    local2global: Array[VertexId],\n+    vertexAttrs: Array[VD],\n+    activeSet: Option[VertexSet],\n+    size: Int = 64) {\n+  var edges = new PrimitiveVector[EdgeWithLocalIds[ED]](size)",
    "line": 62
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "also do it for the one in EdgePartitionBuilder\n",
    "commit": "194a2df94768be9c08ed50654170bad937bd115a",
    "createdAt": "2014-11-11T00:31:44Z",
    "diffHunk": "@@ -38,19 +39,77 @@ class EdgePartitionBuilder[@specialized(Long, Int, Double) ED: ClassTag, VD: Cla\n   def toEdgePartition: EdgePartition[ED, VD] = {\n     val edgeArray = edges.trim().array\n     Sorting.quickSort(edgeArray)(Edge.lexicographicOrdering)\n-    val srcIds = new Array[VertexId](edgeArray.size)\n-    val dstIds = new Array[VertexId](edgeArray.size)\n+    val localSrcIds = new Array[Int](edgeArray.size)\n+    val localDstIds = new Array[Int](edgeArray.size)\n+    val data = new Array[ED](edgeArray.size)\n+    val index = new GraphXPrimitiveKeyOpenHashMap[VertexId, Int]\n+    val global2local = new GraphXPrimitiveKeyOpenHashMap[VertexId, Int]\n+    val local2global = new PrimitiveVector[VertexId]\n+    var vertexAttrs = Array.empty[VD]\n+    // Copy edges into columnar structures, tracking the beginnings of source vertex id clusters and\n+    // adding them to the index. Also populate a map from vertex id to a sequential local offset.\n+    if (edgeArray.length > 0) {\n+      index.update(edgeArray(0).srcId, 0)\n+      var currSrcId: VertexId = edgeArray(0).srcId\n+      var currLocalId = -1\n+      var i = 0\n+      while (i < edgeArray.size) {\n+        val srcId = edgeArray(i).srcId\n+        val dstId = edgeArray(i).dstId\n+        localSrcIds(i) = global2local.changeValue(srcId,\n+          { currLocalId += 1; local2global += srcId; currLocalId }, identity)\n+        localDstIds(i) = global2local.changeValue(dstId,\n+          { currLocalId += 1; local2global += dstId; currLocalId }, identity)\n+        data(i) = edgeArray(i).attr\n+        if (srcId != currSrcId) {\n+          currSrcId = srcId\n+          index.update(currSrcId, i)\n+        }\n+\n+        i += 1\n+      }\n+      vertexAttrs = new Array[VD](currLocalId + 1)\n+    }\n+    new EdgePartition(\n+      localSrcIds, localDstIds, data, index, global2local, local2global.trim().array, vertexAttrs)\n+  }\n+}\n+\n+/**\n+ * Constructs an EdgePartition from an existing EdgePartition with the same vertex set. This enables\n+ * reuse of the local vertex ids. Intended for internal use in EdgePartition only.\n+ */\n+private[impl]\n+class ExistingEdgePartitionBuilder[\n+    @specialized(Long, Int, Double) ED: ClassTag, VD: ClassTag](\n+    global2local: GraphXPrimitiveKeyOpenHashMap[VertexId, Int],\n+    local2global: Array[VertexId],\n+    vertexAttrs: Array[VD],\n+    activeSet: Option[VertexSet],\n+    size: Int = 64) {\n+  var edges = new PrimitiveVector[EdgeWithLocalIds[ED]](size)",
    "line": 62
  }],
  "prId": 3054
}]