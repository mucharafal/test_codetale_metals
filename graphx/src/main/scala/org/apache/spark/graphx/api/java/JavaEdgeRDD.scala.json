[{
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Should this class be public?\n",
    "commit": "d0a747901af273c5eb8578ec191cc7673f6efce5",
    "createdAt": "2015-01-26T19:14:30Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.graphx.api.java\n+\n+import java.lang.{Long => JLong}\n+import java.util.{List => JList}\n+\n+import org.apache.spark.api.java.JavaRDD\n+import org.apache.spark.api.java.function.{Function => JFunction}\n+import org.apache.spark.graphx._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+import scala.language.implicitConversions\n+import scala.reflect.ClassTag\n+\n+/**\n+ * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].\n+ * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class\n+ *\n+ * @param targetStorageLevel\n+ * @tparam ED\n+ */\n+class JavaEdgeRDD[ED](",
    "line": 38
  }],
  "prId": 4205
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "If you're not going to document parameters, just omit them.\n",
    "commit": "d0a747901af273c5eb8578ec191cc7673f6efce5",
    "createdAt": "2015-01-26T19:14:53Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.graphx.api.java\n+\n+import java.lang.{Long => JLong}\n+import java.util.{List => JList}\n+\n+import org.apache.spark.api.java.JavaRDD\n+import org.apache.spark.api.java.function.{Function => JFunction}\n+import org.apache.spark.graphx._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+import scala.language.implicitConversions\n+import scala.reflect.ClassTag\n+\n+/**\n+ * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].\n+ * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class\n+ *\n+ * @param targetStorageLevel\n+ * @tparam ED\n+ */\n+class JavaEdgeRDD[ED](\n+    val edges: RDD[Edge[ED]],\n+    val targetStorageLevel: StorageLevel = StorageLevel.MEMORY_ONLY)\n+    (implicit val classTag: ClassTag[ED])\n+  extends JavaEdgeRDDLike[ED, JavaEdgeRDD[ED], JavaRDD[(VertexId, VertexId, ED)]] {\n+\n+//  /**\n+//   * To create JavaEdgeRDD from JavaRDDs of tuples\n+//   * (source vertex id, destination vertex id and edge property class).\n+//   * The edge property class can be Array[Byte]\n+//   * @param jEdges\n+//   */\n+//  def this(jEdges: JavaRDD[(VertexId, VertexId, ED)]) = {\n+//    this(jEdges.rdd.map(x => Edge[ED](x._1, x._2, x._3)))\n+//  }\n+\n+  /* Convert RDD[(PartitionID, EdgePartition[ED, VD])] to EdgeRDD[ED, VD] */\n+  override def edgeRDD = EdgeRDD.fromEdges(edges)\n+\n+  /**\n+   * Java Wrapper for RDD of Edges\n+   *\n+   * @param edgeRDD",
    "line": 60
  }],
  "prId": 4205
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Mind removing all of the commented-out code?\n",
    "commit": "d0a747901af273c5eb8578ec191cc7673f6efce5",
    "createdAt": "2015-01-26T19:15:36Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.graphx.api.java\n+\n+import java.lang.{Long => JLong}\n+import java.util.{List => JList}\n+\n+import org.apache.spark.api.java.JavaRDD\n+import org.apache.spark.api.java.function.{Function => JFunction}\n+import org.apache.spark.graphx._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+import scala.language.implicitConversions\n+import scala.reflect.ClassTag\n+\n+/**\n+ * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].\n+ * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class\n+ *\n+ * @param targetStorageLevel\n+ * @tparam ED\n+ */\n+class JavaEdgeRDD[ED](\n+    val edges: RDD[Edge[ED]],\n+    val targetStorageLevel: StorageLevel = StorageLevel.MEMORY_ONLY)\n+    (implicit val classTag: ClassTag[ED])\n+  extends JavaEdgeRDDLike[ED, JavaEdgeRDD[ED], JavaRDD[(VertexId, VertexId, ED)]] {\n+\n+//  /**\n+//   * To create JavaEdgeRDD from JavaRDDs of tuples\n+//   * (source vertex id, destination vertex id and edge property class).\n+//   * The edge property class can be Array[Byte]\n+//   * @param jEdges\n+//   */\n+//  def this(jEdges: JavaRDD[(VertexId, VertexId, ED)]) = {\n+//    this(jEdges.rdd.map(x => Edge[ED](x._1, x._2, x._3)))\n+//  }\n+\n+  /* Convert RDD[(PartitionID, EdgePartition[ED, VD])] to EdgeRDD[ED, VD] */\n+  override def edgeRDD = EdgeRDD.fromEdges(edges)\n+\n+  /**\n+   * Java Wrapper for RDD of Edges\n+   *\n+   * @param edgeRDD\n+   * @return\n+   */\n+  def wrapRDD(edgeRDD: RDD[Edge[ED]]): JavaRDD[Edge[ED]] = {\n+    JavaRDD.fromRDD(edgeRDD)\n+  }\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def cache(): this.type = {\n+    edges.cache()\n+    this\n+  }\n+\n+  def collect(): JList[Edge[ED]] = {\n+    import scala.collection.JavaConversions._\n+    val arr: java.util.Collection[Edge[ED]] = edges.collect().toSeq\n+    new java.util.ArrayList(arr)\n+  }\n+\n+  /**\n+   * Return a new single long element generated by counting all elements in the vertex RDD\n+   */\n+  override def count(): JLong = edges.count()\n+\n+  /** Return a new VertexRDD containing only the elements that satisfy a predicate. */\n+  def filter(f: JFunction[Edge[ED], Boolean]): JavaEdgeRDD[ED] =\n+    JavaEdgeRDD(edgeRDD.filter(x => f.call(x).booleanValue()))\n+\n+  def id: JLong = edges.id.toLong\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def persist(): this.type = {\n+    edges.persist()\n+    this\n+  }\n+\n+  /** Persist the RDDs of this EdgeRDD with the given storage level */\n+  def persist(storageLevel: StorageLevel): this.type = {\n+    edges.persist(storageLevel)\n+    this\n+  }\n+\n+  def unpersist(blocking: Boolean = true) : this.type = {\n+    edgeRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  override def mapValues[ED2: ClassTag](f: Edge[ED] => ED2): JavaEdgeRDD[ED2] = {\n+    JavaEdgeRDD(edgeRDD.mapValues(f))\n+  }\n+\n+  override def reverse: JavaEdgeRDD[ED] = JavaEdgeRDD(edgeRDD.reverse)\n+\n+  def innerJoin[ED2: ClassTag, ED3: ClassTag]\n+    (other: EdgeRDD[ED2])\n+    (f: (VertexId, VertexId, ED, ED2) => ED3): JavaEdgeRDD[ED3] = {\n+    JavaEdgeRDD(edgeRDD.innerJoin(other)(f))\n+  }\n+\n+  def toRDD : RDD[Edge[ED]] = edges\n+}\n+\n+object JavaEdgeRDD {\n+\n+  implicit def apply[ED: ClassTag](edges: JavaRDD[Edge[ED]]) : JavaEdgeRDD[ED] = {\n+    JavaEdgeRDD(EdgeRDD.fromEdges(edges.rdd))\n+  }\n+\n+  def toEdgeRDD[ED: ClassTag](edges: JavaEdgeRDD[ED]): RDD[Edge[ED]] = {\n+    JavaEdgeRDD(edges.edgeRDD).toRDD\n+  }\n+\n+//  def apply[ED: ClassTag](",
    "line": 132
  }, {
    "author": {
      "login": "kdatta"
    },
    "body": "Removed.\n",
    "commit": "d0a747901af273c5eb8578ec191cc7673f6efce5",
    "createdAt": "2015-01-26T19:30:29Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.graphx.api.java\n+\n+import java.lang.{Long => JLong}\n+import java.util.{List => JList}\n+\n+import org.apache.spark.api.java.JavaRDD\n+import org.apache.spark.api.java.function.{Function => JFunction}\n+import org.apache.spark.graphx._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+import scala.language.implicitConversions\n+import scala.reflect.ClassTag\n+\n+/**\n+ * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].\n+ * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class\n+ *\n+ * @param targetStorageLevel\n+ * @tparam ED\n+ */\n+class JavaEdgeRDD[ED](\n+    val edges: RDD[Edge[ED]],\n+    val targetStorageLevel: StorageLevel = StorageLevel.MEMORY_ONLY)\n+    (implicit val classTag: ClassTag[ED])\n+  extends JavaEdgeRDDLike[ED, JavaEdgeRDD[ED], JavaRDD[(VertexId, VertexId, ED)]] {\n+\n+//  /**\n+//   * To create JavaEdgeRDD from JavaRDDs of tuples\n+//   * (source vertex id, destination vertex id and edge property class).\n+//   * The edge property class can be Array[Byte]\n+//   * @param jEdges\n+//   */\n+//  def this(jEdges: JavaRDD[(VertexId, VertexId, ED)]) = {\n+//    this(jEdges.rdd.map(x => Edge[ED](x._1, x._2, x._3)))\n+//  }\n+\n+  /* Convert RDD[(PartitionID, EdgePartition[ED, VD])] to EdgeRDD[ED, VD] */\n+  override def edgeRDD = EdgeRDD.fromEdges(edges)\n+\n+  /**\n+   * Java Wrapper for RDD of Edges\n+   *\n+   * @param edgeRDD\n+   * @return\n+   */\n+  def wrapRDD(edgeRDD: RDD[Edge[ED]]): JavaRDD[Edge[ED]] = {\n+    JavaRDD.fromRDD(edgeRDD)\n+  }\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def cache(): this.type = {\n+    edges.cache()\n+    this\n+  }\n+\n+  def collect(): JList[Edge[ED]] = {\n+    import scala.collection.JavaConversions._\n+    val arr: java.util.Collection[Edge[ED]] = edges.collect().toSeq\n+    new java.util.ArrayList(arr)\n+  }\n+\n+  /**\n+   * Return a new single long element generated by counting all elements in the vertex RDD\n+   */\n+  override def count(): JLong = edges.count()\n+\n+  /** Return a new VertexRDD containing only the elements that satisfy a predicate. */\n+  def filter(f: JFunction[Edge[ED], Boolean]): JavaEdgeRDD[ED] =\n+    JavaEdgeRDD(edgeRDD.filter(x => f.call(x).booleanValue()))\n+\n+  def id: JLong = edges.id.toLong\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def persist(): this.type = {\n+    edges.persist()\n+    this\n+  }\n+\n+  /** Persist the RDDs of this EdgeRDD with the given storage level */\n+  def persist(storageLevel: StorageLevel): this.type = {\n+    edges.persist(storageLevel)\n+    this\n+  }\n+\n+  def unpersist(blocking: Boolean = true) : this.type = {\n+    edgeRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  override def mapValues[ED2: ClassTag](f: Edge[ED] => ED2): JavaEdgeRDD[ED2] = {\n+    JavaEdgeRDD(edgeRDD.mapValues(f))\n+  }\n+\n+  override def reverse: JavaEdgeRDD[ED] = JavaEdgeRDD(edgeRDD.reverse)\n+\n+  def innerJoin[ED2: ClassTag, ED3: ClassTag]\n+    (other: EdgeRDD[ED2])\n+    (f: (VertexId, VertexId, ED, ED2) => ED3): JavaEdgeRDD[ED3] = {\n+    JavaEdgeRDD(edgeRDD.innerJoin(other)(f))\n+  }\n+\n+  def toRDD : RDD[Edge[ED]] = edges\n+}\n+\n+object JavaEdgeRDD {\n+\n+  implicit def apply[ED: ClassTag](edges: JavaRDD[Edge[ED]]) : JavaEdgeRDD[ED] = {\n+    JavaEdgeRDD(EdgeRDD.fromEdges(edges.rdd))\n+  }\n+\n+  def toEdgeRDD[ED: ClassTag](edges: JavaEdgeRDD[ED]): RDD[Edge[ED]] = {\n+    JavaEdgeRDD(edges.edgeRDD).toRDD\n+  }\n+\n+//  def apply[ED: ClassTag](",
    "line": 132
  }],
  "prId": 4205
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Style nit: no space before the `:`.\n",
    "commit": "d0a747901af273c5eb8578ec191cc7673f6efce5",
    "createdAt": "2015-01-26T19:15:52Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.graphx.api.java\n+\n+import java.lang.{Long => JLong}\n+import java.util.{List => JList}\n+\n+import org.apache.spark.api.java.JavaRDD\n+import org.apache.spark.api.java.function.{Function => JFunction}\n+import org.apache.spark.graphx._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+import scala.language.implicitConversions\n+import scala.reflect.ClassTag\n+\n+/**\n+ * EdgeRDD['ED'] is a column-oriented edge partition RDD created from RDD[Edge[ED]].\n+ * JavaEdgeRDD class provides a Java API to access implementations of the EdgeRDD class\n+ *\n+ * @param targetStorageLevel\n+ * @tparam ED\n+ */\n+class JavaEdgeRDD[ED](\n+    val edges: RDD[Edge[ED]],\n+    val targetStorageLevel: StorageLevel = StorageLevel.MEMORY_ONLY)\n+    (implicit val classTag: ClassTag[ED])\n+  extends JavaEdgeRDDLike[ED, JavaEdgeRDD[ED], JavaRDD[(VertexId, VertexId, ED)]] {\n+\n+//  /**\n+//   * To create JavaEdgeRDD from JavaRDDs of tuples\n+//   * (source vertex id, destination vertex id and edge property class).\n+//   * The edge property class can be Array[Byte]\n+//   * @param jEdges\n+//   */\n+//  def this(jEdges: JavaRDD[(VertexId, VertexId, ED)]) = {\n+//    this(jEdges.rdd.map(x => Edge[ED](x._1, x._2, x._3)))\n+//  }\n+\n+  /* Convert RDD[(PartitionID, EdgePartition[ED, VD])] to EdgeRDD[ED, VD] */\n+  override def edgeRDD = EdgeRDD.fromEdges(edges)\n+\n+  /**\n+   * Java Wrapper for RDD of Edges\n+   *\n+   * @param edgeRDD\n+   * @return\n+   */\n+  def wrapRDD(edgeRDD: RDD[Edge[ED]]): JavaRDD[Edge[ED]] = {\n+    JavaRDD.fromRDD(edgeRDD)\n+  }\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def cache(): this.type = {\n+    edges.cache()\n+    this\n+  }\n+\n+  def collect(): JList[Edge[ED]] = {\n+    import scala.collection.JavaConversions._\n+    val arr: java.util.Collection[Edge[ED]] = edges.collect().toSeq\n+    new java.util.ArrayList(arr)\n+  }\n+\n+  /**\n+   * Return a new single long element generated by counting all elements in the vertex RDD\n+   */\n+  override def count(): JLong = edges.count()\n+\n+  /** Return a new VertexRDD containing only the elements that satisfy a predicate. */\n+  def filter(f: JFunction[Edge[ED], Boolean]): JavaEdgeRDD[ED] =\n+    JavaEdgeRDD(edgeRDD.filter(x => f.call(x).booleanValue()))\n+\n+  def id: JLong = edges.id.toLong\n+\n+  /** Persist RDDs of this JavaEdgeRDD with the default storage level (MEMORY_ONLY_SER) */\n+  def persist(): this.type = {\n+    edges.persist()\n+    this\n+  }\n+\n+  /** Persist the RDDs of this EdgeRDD with the given storage level */\n+  def persist(storageLevel: StorageLevel): this.type = {\n+    edges.persist(storageLevel)\n+    this\n+  }\n+\n+  def unpersist(blocking: Boolean = true) : this.type = {\n+    edgeRDD.unpersist(blocking)\n+    this\n+  }\n+\n+  override def mapValues[ED2: ClassTag](f: Edge[ED] => ED2): JavaEdgeRDD[ED2] = {\n+    JavaEdgeRDD(edgeRDD.mapValues(f))\n+  }\n+\n+  override def reverse: JavaEdgeRDD[ED] = JavaEdgeRDD(edgeRDD.reverse)\n+\n+  def innerJoin[ED2: ClassTag, ED3: ClassTag]\n+    (other: EdgeRDD[ED2])\n+    (f: (VertexId, VertexId, ED, ED2) => ED3): JavaEdgeRDD[ED3] = {\n+    JavaEdgeRDD(edgeRDD.innerJoin(other)(f))\n+  }\n+\n+  def toRDD : RDD[Edge[ED]] = edges\n+}\n+\n+object JavaEdgeRDD {\n+\n+  implicit def apply[ED: ClassTag](edges: JavaRDD[Edge[ED]]) : JavaEdgeRDD[ED] = {",
    "line": 124
  }],
  "prId": 4205
}]