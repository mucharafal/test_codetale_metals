[{
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Not sure is this \"call-by-name\" parameter Java friendly? Assuming this `State` should also be used in Java code :).\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-10-27T06:37:17Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+  \n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+  \n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Yeah, that is probably a valid concern. If users cannot call it from Java, this could be a Scala-only thing. \n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-10-27T08:48:47Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+  \n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+  \n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "jerryshao"
    },
    "body": "Is this required for defensive guard `require(!updated, \"cannot update the state this is already updated\")`? \n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-10-27T06:48:44Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+  \n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+  \n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {\n+    if (exists) this.get else default\n+  }\n+\n+  @inline final override def toString() = getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  def exists(): Boolean = {\n+    defined\n+  }\n+\n+  def get(): S = {\n+    state\n+  }\n+\n+  def update(newState: S): Unit = {\n+    require(!removed, \"Cannot update the state after it has been removed\")\n+    require(!timingOut, \"Cannot update the state that is timing out\")\n+    state = newState"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Yeah, if the user accidentally tries to update the state that is going to be removed by timeout anyways, the system should throw an error rather than silently allowing him/her to update without actually being updated.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-10-27T08:50:39Z",
    "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+  \n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+  \n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {\n+    if (exists) this.get else default\n+  }\n+\n+  @inline final override def toString() = getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  def exists(): Boolean = {\n+    defined\n+  }\n+\n+  def get(): S = {\n+    state\n+  }\n+\n+  def update(newState: S): Unit = {\n+    require(!removed, \"Cannot update the state after it has been removed\")\n+    require(!timingOut, \"Cannot update the state that is timing out\")\n+    state = newState"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Todo: Add example in doc.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-04T22:07:44Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Should this be `delete` or `destroy`? Not sure if we have used similar terminology elsewhere. Also it would be good to state the semantics of calling this.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-05T07:00:33Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "BTW I have no strong feeling here other than that it match existing things, if we have them.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-05T07:06:48Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "The only semantically similar thing is a HashMap, and there both Scala and Java HashMap uses remove()\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-06T00:59:48Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "`State.get` says `Get the state if it exists, otherwise wise it will throw an exception.` but here it won't throw an exception.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-06T00:48:18Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {\n+    if (exists) this.get else default\n+  }\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  def exists(): Boolean = {\n+    defined\n+  }\n+\n+  def get(): S = {\n+    state"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Good catch. On the todo list to add State unit tests to verify this behavior.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-06T01:00:32Z",
    "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+/**\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] and\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream]].\n+ * {{{\n+ *\n+ * }}}\n+ */\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise wise it will throw an exception.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value. Note that you cannot update the state if the state is\n+   * timing out (that is, `isTimingOut() return true`, or if the state has already been removed by\n+   * `remove()`.\n+   */\n+  def update(newState: S): Unit\n+\n+  /** Remove the state if it exists. */\n+  def remove(): Unit\n+\n+  /** Is the state going to be timed out by the system after this batch interval */\n+  def isTimingOut(): Boolean\n+\n+  @inline final def getOption(): Option[S] = Option(get())\n+\n+  /** Get the state if it exists, otherwise return the default value */\n+  @inline final def getOrElse[S1 >: S](default: => S1): S1 = {\n+    if (exists) this.get else default\n+  }\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  def exists(): Boolean = {\n+    defined\n+  }\n+\n+  def get(): S = {\n+    state"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can we remove some blank lines ?\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T01:37:43Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can you add override modifier to everything that's implementing an interface function\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T01:41:14Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  def exists(): Boolean = {"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Why do we need this?\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T16:17:35Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "We dont \"need\" it. But its just convenient for people to automatically convert to an option, so that they can write `state.getOrElse(...)` in Scala.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-08T23:52:30Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}"
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "We shouldn't have that as part of our API, we don't use implicit conversions in other places in Spark. It will be pretty confusing. Instead they can just do state.getOption.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-09T16:57:03Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Cool. Will remove it.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-09T21:49:52Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Typo: timeou\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T16:18:07Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Why did we separate this into another class? I don't see any other subclasses of State or great reasons to create them\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T16:20:04Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I did it so that we can separate the publicly visible interfaces, from the private[streaming] ones. private[streaming] ones are still publicly accessible from Java, so I was trying to avoid that. Other than than I dont really have a strong reason. If that isnt a strong enough reason to have a separate abstract class and concrete implementation, then I can merge them into one.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-09T00:06:08Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {"
  }],
  "prId": 9256
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Seems to contain a typo? It's also not clear how this is different from wrap, from the comment\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-07T16:20:56Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  override def exists(): Boolean = {\n+    defined\n+  }\n+\n+  override def get(): S = {\n+    state\n+  }\n+\n+  override def update(newState: S): Unit = {\n+    require(!removed, \"Cannot update the state after it has been removed\")\n+    require(!timingOut, \"Cannot update the state that is timing out\")\n+    state = newState\n+    updated = true\n+  }\n+\n+  override def isTimingOut(): Boolean = {\n+    timingOut\n+  }\n+\n+  override def remove(): Unit = {\n+    require(!timingOut, \"Cannot remove the state that is timing out\")\n+    require(!removed, \"Cannot remove the state that has already been removed\")\n+    removed = true\n+  }\n+\n+  // ========= Internal API =========\n+\n+  /** Whether the state has been marked for removing */\n+  def isRemoved(): Boolean = {\n+    removed\n+  }\n+\n+  /** Whether the state has been been updated */\n+  def isUpdated(): Boolean = {\n+    updated\n+  }\n+\n+  /**\n+   * Internal method to update the state data and reset internal flags in `this`.\n+   * This method allows `this` object to be reused across many state records.\n+   */\n+  def wrap(optionalState: Option[S]): Unit = {\n+    optionalState match {\n+      case Some(newState) =>\n+        this.state = newState\n+        defined = true\n+\n+      case None =>\n+        this.state = null.asInstanceOf[S]\n+        defined = false\n+    }\n+    timingOut = false\n+    removed = false\n+    updated = false\n+  }\n+\n+  /**\n+   * Internal method to update the state data and reset internal flags in `this`.\n+   * This method allows `this` object to be reused across many state records.\n+   */\n+  def wrapTiminoutState(newState: S): Unit = {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Good point, will update comment.\n",
    "commit": "ae64786fd937002a2cc1f80518d54e970a6bbb21",
    "createdAt": "2015-11-09T03:12:50Z",
    "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming\n+\n+import scala.language.implicitConversions\n+\n+import org.apache.spark.annotation.Experimental\n+\n+/**\n+ * :: Experimental ::\n+ * Abstract class for getting and updating the tracked state in the `trackStateByKey` operation of\n+ * a [[org.apache.spark.streaming.dstream.PairDStreamFunctions pair DStream]] (Scala) or a\n+ * [[org.apache.spark.streaming.api.java.JavaPairDStream JavaPairDStream]] (Java).\n+ *\n+ * Scala example of using `State`:\n+ * {{{\n+ *    def trackStateFunc(key: String, data: Option[Int], wrappedState: State[Int]): Option[Int] = {\n+ *\n+ *      // Check if state exists\n+ *      if (state.exists) {\n+ *\n+ *        val existingState = wrappedState.get  // Get the existing state\n+ *\n+ *        val shouldRemove = ...      // Decide whether to remove the state\n+ *\n+ *        if (shouldRemove) {\n+ *\n+ *          wrappedState.remove()     // Remove the state\n+ *\n+ *        } else {\n+ *\n+ *          val newState = ...\n+ *          wrappedState(newState)    // Set the new state\n+ *\n+ *        }\n+ *      } else {\n+ *\n+ *        val initialState = ...\n+ *        state.update(initialState)  // Set the initial state\n+ *\n+ *      }\n+ *    }\n+ *\n+ * }}}\n+ *\n+ * Java example:\n+ * {{{\n+ *      TODO(@zsxwing)\n+ * }}}\n+ */\n+@Experimental\n+sealed abstract class State[S] {\n+\n+  /** Whether the state already exists */\n+  def exists(): Boolean\n+\n+  /**\n+   * Get the state if it exists, otherwise it will throw `java.util.NoSuchElementException`.\n+   * Check with `exists()` whether the state exists or not before calling `get()`.\n+   *\n+   * @throws java.util.NoSuchElementException If the state does not exist.\n+   */\n+  def get(): S\n+\n+  /**\n+   * Update the state with a new value.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   *\n+   * @throws java.lang.IllegalArgumentException If the state has already been removed, or is\n+   *                                            going to be removed\n+   */\n+  def update(newState: S): Unit\n+\n+  /**\n+   * Remove the state if it exists.\n+   *\n+   * State cannot be updated if it has been already removed (that is, `remove()` has already been\n+   * called) or it is going to be removed due to timeout (that is, `isTimingOut()` is `true`).\n+   */\n+  def remove(): Unit\n+\n+  /**\n+   * Whether the state is timing out and going to be removed by the system after the current batch.\n+   * This timeou can occur if timeout duration has been specified in the\n+   * [[org.apache.spark.streaming.StateSpec StatSpec]] and the key has not received any new data\n+   * for that timeout duration.\n+   */\n+  def isTimingOut(): Boolean\n+\n+  /**\n+   * Get the state as an [[scala.Option]]. It will be `Some(state)` if it exists, otherwise `None`.\n+   */\n+  @inline final def getOption(): Option[S] = if (exists) Some(get()) else None\n+\n+  @inline final override def toString(): String = {\n+    getOption.map { _.toString }.getOrElse(\"<state not set>\")\n+  }\n+}\n+\n+private[streaming]\n+object State {\n+  implicit def toOption[S](state: State[S]): Option[S] = state.getOption()\n+}\n+\n+/** Internal implementation of the [[State]] interface */\n+private[streaming] class StateImpl[S] extends State[S] {\n+\n+  private var state: S = null.asInstanceOf[S]\n+  private var defined: Boolean = true\n+  private var timingOut: Boolean = false\n+  private var updated: Boolean = false\n+  private var removed: Boolean = false\n+\n+  // ========= Public API =========\n+  override def exists(): Boolean = {\n+    defined\n+  }\n+\n+  override def get(): S = {\n+    state\n+  }\n+\n+  override def update(newState: S): Unit = {\n+    require(!removed, \"Cannot update the state after it has been removed\")\n+    require(!timingOut, \"Cannot update the state that is timing out\")\n+    state = newState\n+    updated = true\n+  }\n+\n+  override def isTimingOut(): Boolean = {\n+    timingOut\n+  }\n+\n+  override def remove(): Unit = {\n+    require(!timingOut, \"Cannot remove the state that is timing out\")\n+    require(!removed, \"Cannot remove the state that has already been removed\")\n+    removed = true\n+  }\n+\n+  // ========= Internal API =========\n+\n+  /** Whether the state has been marked for removing */\n+  def isRemoved(): Boolean = {\n+    removed\n+  }\n+\n+  /** Whether the state has been been updated */\n+  def isUpdated(): Boolean = {\n+    updated\n+  }\n+\n+  /**\n+   * Internal method to update the state data and reset internal flags in `this`.\n+   * This method allows `this` object to be reused across many state records.\n+   */\n+  def wrap(optionalState: Option[S]): Unit = {\n+    optionalState match {\n+      case Some(newState) =>\n+        this.state = newState\n+        defined = true\n+\n+      case None =>\n+        this.state = null.asInstanceOf[S]\n+        defined = false\n+    }\n+    timingOut = false\n+    removed = false\n+    updated = false\n+  }\n+\n+  /**\n+   * Internal method to update the state data and reset internal flags in `this`.\n+   * This method allows `this` object to be reused across many state records.\n+   */\n+  def wrapTiminoutState(newState: S): Unit = {"
  }],
  "prId": 9256
}]