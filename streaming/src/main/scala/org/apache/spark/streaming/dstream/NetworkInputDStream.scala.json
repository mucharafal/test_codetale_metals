[{
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "If this is user facing, would it make sense to have the message not depend on the function name. I.e. \"Starting the receiver\" or something?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-02T21:07:25Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Will address this in PR #300 \n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T02:41:36Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")"
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "should the below method `start()` be private?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-02T21:10:07Z",
    "diffHunk": "@@ -112,7 +131,7 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n   def getLocationPreference() : Option[String] = None\n \n   /**\n-   * Starts the receiver. First is accesses all the lazy members to\n+   * Start the receiver. First is accesses all the lazy members to",
    "line": 72
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I am not entirely sure. Lets address this in the other PR #300 where this is refactored any way. \n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T02:41:18Z",
    "diffHunk": "@@ -112,7 +131,7 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n   def getLocationPreference() : Option[String] = None\n \n   /**\n-   * Starts the receiver. First is accesses all the lazy members to\n+   * Start the receiver. First is accesses all the lazy members to",
    "line": 72
  }, {
    "author": {
      "login": "andrewor14"
    },
    "body": "First _it_ accesses\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-07T21:45:24Z",
    "diffHunk": "@@ -112,7 +131,7 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n   def getLocationPreference() : Option[String] = None\n \n   /**\n-   * Starts the receiver. First is accesses all the lazy members to\n+   * Start the receiver. First is accesses all the lazy members to",
    "line": 72
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "I'm a little confused here about whether the receiver `onStart` is supposed to block forever or if it's supposed to exit int he normal case. It would be good to add documentation to make it clear whether this represents an error case or a normal case.\n\nAlso, instead of busy waiting why not sleep on a condition variable here?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-02T21:23:07Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Will address this in PR #300 \n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T02:42:06Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)"
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Do we want to log this every time? It seems really chatty. Was this a debug statement?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-02T21:28:06Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()\n-    onStop()\n-    //TODO: terminate the actor\n+    logInfo(\"Interrupted receiving thread \" + receivingThread + \" for stopping\")\n   }\n \n   /**\n-   * Stops the receiver and reports exception to the tracker.\n+   * Stop the receiver and reports exception to the tracker.\n    * This should be called whenever an exception is to be handled on any thread\n    * of the receiver.\n    */\n   protected def stopOnError(e: Exception) {\n     logError(\"Error receiving data\", e)\n+    exceptions += e\n     stop()\n-    actor ! ReportError(e.toString)\n   }\n \n-\n   /**\n-   * Pushes a block (as an ArrayBuffer filled with data) into the block manager.\n+   * Push a block (as an ArrayBuffer filled with data) into the block manager.\n    */\n   def pushBlock(blockId: BlockId, arrayBuffer: ArrayBuffer[T], metadata: Any, level: StorageLevel) {\n+    logInfo(\"Block \" + blockId + \" has last element as \" + arrayBuffer.last)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Removed this.\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T03:57:40Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()\n-    onStop()\n-    //TODO: terminate the actor\n+    logInfo(\"Interrupted receiving thread \" + receivingThread + \" for stopping\")\n   }\n \n   /**\n-   * Stops the receiver and reports exception to the tracker.\n+   * Stop the receiver and reports exception to the tracker.\n    * This should be called whenever an exception is to be handled on any thread\n    * of the receiver.\n    */\n   protected def stopOnError(e: Exception) {\n     logError(\"Error receiving data\", e)\n+    exceptions += e\n     stop()\n-    actor ! ReportError(e.toString)\n   }\n \n-\n   /**\n-   * Pushes a block (as an ArrayBuffer filled with data) into the block manager.\n+   * Push a block (as an ArrayBuffer filled with data) into the block manager.\n    */\n   def pushBlock(blockId: BlockId, arrayBuffer: ArrayBuffer[T], metadata: Any, level: StorageLevel) {\n+    logInfo(\"Block \" + blockId + \" has last element as \" + arrayBuffer.last)"
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "This also seems pretty chatty... do we want to log at `INFO` level at block granularity?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-02T21:29:44Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()\n-    onStop()\n-    //TODO: terminate the actor\n+    logInfo(\"Interrupted receiving thread \" + receivingThread + \" for stopping\")\n   }\n \n   /**\n-   * Stops the receiver and reports exception to the tracker.\n+   * Stop the receiver and reports exception to the tracker.\n    * This should be called whenever an exception is to be handled on any thread\n    * of the receiver.\n    */\n   protected def stopOnError(e: Exception) {\n     logError(\"Error receiving data\", e)\n+    exceptions += e\n     stop()\n-    actor ! ReportError(e.toString)\n   }\n \n-\n   /**\n-   * Pushes a block (as an ArrayBuffer filled with data) into the block manager.\n+   * Push a block (as an ArrayBuffer filled with data) into the block manager.\n    */\n   def pushBlock(blockId: BlockId, arrayBuffer: ArrayBuffer[T], metadata: Any, level: StorageLevel) {\n+    logInfo(\"Block \" + blockId + \" has last element as \" + arrayBuffer.last)\n     env.blockManager.put(blockId, arrayBuffer.asInstanceOf[ArrayBuffer[Any]], level)\n-    actor ! ReportBlock(blockId, metadata)\n+    trackerActor ! AddBlocks(streamId, Array(blockId), metadata)\n+    logInfo(\"Pushed block \" + blockId)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Converted to debug.\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T03:58:29Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()\n-    onStop()\n-    //TODO: terminate the actor\n+    logInfo(\"Interrupted receiving thread \" + receivingThread + \" for stopping\")\n   }\n \n   /**\n-   * Stops the receiver and reports exception to the tracker.\n+   * Stop the receiver and reports exception to the tracker.\n    * This should be called whenever an exception is to be handled on any thread\n    * of the receiver.\n    */\n   protected def stopOnError(e: Exception) {\n     logError(\"Error receiving data\", e)\n+    exceptions += e\n     stop()\n-    actor ! ReportError(e.toString)\n   }\n \n-\n   /**\n-   * Pushes a block (as an ArrayBuffer filled with data) into the block manager.\n+   * Push a block (as an ArrayBuffer filled with data) into the block manager.\n    */\n   def pushBlock(blockId: BlockId, arrayBuffer: ArrayBuffer[T], metadata: Any, level: StorageLevel) {\n+    logInfo(\"Block \" + blockId + \" has last element as \" + arrayBuffer.last)\n     env.blockManager.put(blockId, arrayBuffer.asInstanceOf[ArrayBuffer[Any]], level)\n-    actor ! ReportBlock(blockId, metadata)\n+    trackerActor ! AddBlocks(streamId, Array(blockId), metadata)\n+    logInfo(\"Pushed block \" + blockId)"
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "This javadoc is outdated now, isn't it?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-03T00:16:23Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Why do you think so?\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T02:46:17Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "It says \"Then it calls the user-defined onStop method\" but in this change you remove that call.\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T03:56:47Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Ooops! Sorry! Yeah changed that.\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T06:05:26Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined"
  }],
  "prId": 247
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "This is a bit confusing - is the receivingThread assumed to be running user code or is the assumption that it's sleeping in the `Thread.sleep(` line? I think it would simplify things a lot if you could assume that `onStart` doesn't block. \n\nAlso, could you have a condition variable here instead of using sleep/interruption? \n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-03T00:19:50Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Summarizing our offline conversation, we will document the semantics of onStart not blocking, and convert sleep to condition variable. But I think it best to address in # PR 300, rather than duplicating the changes.\n",
    "commit": "61c001676a0e098a0bbefca838df91dfd2375b03",
    "createdAt": "2014-04-04T03:55:33Z",
    "diffHunk": "@@ -124,84 +143,109 @@ abstract class NetworkReceiver[T: ClassTag]() extends Serializable with Logging\n       receivingThread\n \n       // Call user-defined onStart()\n+      logInfo(\"Calling onStart\")\n       onStart()\n+\n+      // Wait until interrupt is called on this thread\n+      while(true) Thread.sleep(100000)\n     } catch {\n       case ie: InterruptedException =>\n-        logInfo(\"Receiving thread interrupted\")\n-        //println(\"Receiving thread interrupted\")\n+        logInfo(\"Receiving thread has been interrupted, receiver \"  + streamId + \" stopped\")\n       case e: Exception =>\n-        stopOnError(e)\n+        logError(\"Error receiving data in receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    // Call user-defined onStop()\n+    logInfo(\"Calling onStop\")\n+    try {\n+      onStop()\n+    } catch {\n+      case  e: Exception =>\n+        logError(\"Error stopping receiver \" + streamId, e)\n+        exceptions += e\n+    }\n+\n+    val message = if (exceptions.isEmpty) {\n+      null\n+    } else if (exceptions.size == 1) {\n+      val e = exceptions.head\n+      \"Exception in receiver \" + streamId + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+    } else {\n+      \"Multiple exceptions in receiver \" + streamId + \"(\" + exceptions.size + \"):\\n\"\n+        exceptions.zipWithIndex.map {\n+          case (e, i) => \"Exception \" + i + \": \" + e.getMessage + \"\\n\" + e.getStackTraceString\n+        }.mkString(\"\\n\")\n     }\n+    logInfo(\"Deregistering receiver \" + streamId)\n+    val future = trackerActor.ask(DeregisterReceiver(streamId, message))(askTimeout)\n+    Await.result(future, askTimeout)\n+    logInfo(\"Deregistered receiver \" + streamId)\n+    env.actorSystem.stop(actor)\n+    logInfo(\"Stopped receiver \" + streamId)\n   }\n \n   /**\n-   * Stops the receiver. First it interrupts the main receiving thread,\n+   * Stop the receiver. First it interrupts the main receiving thread,\n    * that is, the thread that called receiver.start(). Then it calls the user-defined\n    * onStop() method to stop other threads and/or do cleanup.\n    */\n   def stop() {\n+    // Stop receiving by interrupting the receiving thread\n     receivingThread.interrupt()"
  }],
  "prId": 247
}]