[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: the key type is `String` now.\n",
    "commit": "6d29b7a69c81f19b241a6b0202ddd07b990fd508",
    "createdAt": "2015-12-10T00:18:30Z",
    "diffHunk": "@@ -430,42 +430,37 @@ class JavaPairDStream[K, V](val dstream: DStream[(K, V)])(\n \n   /**\n    * :: Experimental ::\n-   * Return a new [[JavaDStream]] of data generated by combining the key-value data in `this` stream\n-   * with a continuously updated per-key state. The user-provided state tracking function is\n-   * applied on each keyed data item along with its corresponding state. The function can choose to\n-   * update/remove the state and return a transformed data, which forms the\n-   * [[JavaTrackStateDStream]].\n+   * Return a [[JavaMapWithStateDStream]] by applying a function to every key-value element of\n+   * `this` stream, while maintaining some state data for each unique key. The mapping function\n+   * and other specification (e.g. partitioners, timeouts, initial state data, etc.) of this\n+   * transformation can be specified using [[StateSpec]] class. The state data is accessible in\n+   * as a parameter of type [[State]] in the mapping function.\n    *\n-   * The specifications of this transformation is made through the\n-   * [[org.apache.spark.streaming.StateSpec StateSpec]] class. Besides the tracking function, there\n-   * are a number of optional parameters - initial state data, number of partitions, timeouts, etc.\n-   * See the [[org.apache.spark.streaming.StateSpec StateSpec]] for more details.\n-   *\n-   * Example of using `trackStateByKey`:\n+   * Example of using `mapWithState`:\n    * {{{\n-   *   // A tracking function that maintains an integer state and return a String\n-   *   Function2<Optional<Integer>, State<Integer>, Optional<String>> trackStateFunc =\n-   *       new Function2<Optional<Integer>, State<Integer>, Optional<String>>() {\n-   *\n-   *         @Override\n-   *         public Optional<String> call(Optional<Integer> one, State<Integer> state) {\n-   *           // Check if state exists, accordingly update/remove state and return transformed data\n-   *         }\n+   *   // A mapping function that maintains an integer state and return a string\n+   *   Function3<String, Optional<Integer>, State<Integer>, String> mappingFunction =\n+   *       new Function3<String, Optional<Integer>, State<Integer>, String>() {\n+   *           @Override\n+   *           public Optional<String> call(Optional<Integer> value, State<Integer> state) {\n+   *               // Use state.exists(), state.get(), state.update() and state.remove()\n+   *               // to manage state, and return the necessary string\n+   *           }\n    *       };\n    *\n-   *    JavaTrackStateDStream<Integer, Integer, Integer, String> trackStateDStream =\n-   *        keyValueDStream.<Integer, String>trackStateByKey(\n-   *                 StateSpec.function(trackStateFunc).numPartitions(10));\n+   *    JavaMapWithStateDStream<Integer, Integer, Integer, String> mapWithStateDStream ="
  }],
  "prId": 10224
}]