[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Use `TaskLocation` in the return type because the locations could be host from `Receiver.preferredLocation`, or `ExecutorCacheTaskLocation`.\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-20T14:02:20Z",
    "diffHunk": "@@ -69,9 +69,12 @@ private[streaming] class ReceiverSchedulingPolicy {\n    * </ol>\n    *\n    * This method is called when we start to launch receivers at the first time.\n+   *\n+   * @return a map for receivers and their scheduled locations\n    */\n   def scheduleReceivers(\n-      receivers: Seq[Receiver[_]], executors: Seq[String]): Map[Int, Seq[String]] = {\n+      receivers: Seq[Receiver[_]],\n+      executors: Seq[ExecutorCacheTaskLocation]): Map[Int, Seq[TaskLocation]] = {",
    "line": 55
  }],
  "prId": 9181
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: grammar. It will try to scheduler receiver such that they are evenly distributed\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-26T22:34:41Z",
    "diffHunk": "@@ -30,22 +30,22 @@ import org.apache.spark.util.Utils\n  * - The first phase is global scheduling when ReceiverTracker is starting and we need to schedule\n  *   all receivers at the same time. ReceiverTracker will call `scheduleReceivers` at this phase.\n  *   It will try to schedule receivers with evenly distributed. ReceiverTracker should update its"
  }],
  "prId": 9181
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: will set --> should be set\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-26T22:35:16Z",
    "diffHunk": "@@ -30,22 +30,22 @@ import org.apache.spark.util.Utils\n  * - The first phase is global scheduling when ReceiverTracker is starting and we need to schedule\n  *   all receivers at the same time. ReceiverTracker will call `scheduleReceivers` at this phase.\n  *   It will try to schedule receivers with evenly distributed. ReceiverTracker should update its\n- *   receiverTrackingInfoMap according to the results of `scheduleReceivers`.\n- *   `ReceiverTrackingInfo.scheduledExecutors` for each receiver will set to an executor list that\n+ *   `receiverTrackingInfoMap` according to the results of `scheduleReceivers`.\n+ *   `ReceiverTrackingInfo.scheduledLocations` for each receiver will set to an location list that"
  }],
  "prId": 9181
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: would be good to put a `{...}` around this whole thing.\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-26T22:37:26Z",
    "diffHunk": "@@ -163,40 +169,46 @@ private[streaming] class ReceiverSchedulingPolicy {\n       receiverId: Int,\n       preferredLocation: Option[String],\n       receiverTrackingInfoMap: Map[Int, ReceiverTrackingInfo],\n-      executors: Seq[String]): Seq[String] = {\n+      executors: Seq[ExecutorCacheTaskLocation]): Seq[TaskLocation] = {\n     if (executors.isEmpty) {\n       return Seq.empty\n     }\n \n     // Always try to schedule to the preferred locations\n-    val scheduledExecutors = mutable.Set[String]()\n-    scheduledExecutors ++= preferredLocation\n-\n-    val executorWeights = receiverTrackingInfoMap.values.flatMap { receiverTrackingInfo =>\n-      receiverTrackingInfo.state match {\n-        case ReceiverState.INACTIVE => Nil\n-        case ReceiverState.SCHEDULED =>\n-          val scheduledExecutors = receiverTrackingInfo.scheduledExecutors.get\n-          // The probability that a scheduled receiver will run in an executor is\n-          // 1.0 / scheduledLocations.size\n-          scheduledExecutors.map(location => location -> (1.0 / scheduledExecutors.size))\n-        case ReceiverState.ACTIVE => Seq(receiverTrackingInfo.runningExecutor.get -> 1.0)\n-      }\n-    }.groupBy(_._1).mapValues(_.map(_._2).sum) // Sum weights for each executor\n+    val scheduledLocations = mutable.Set[TaskLocation]()\n+    // Note: preferredLocation could be `HDFSCacheTaskLocation`, so use `TaskLocation.apply` to\n+    // handle this case\n+    scheduledLocations ++= preferredLocation.map(TaskLocation(_))\n+\n+    val executorWeights: Map[ExecutorCacheTaskLocation, Double] ="
  }],
  "prId": 9181
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "can you make this a separate method, this is getting pretty big and hard to read.\nand add comments.\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-26T22:38:43Z",
    "diffHunk": "@@ -163,40 +169,46 @@ private[streaming] class ReceiverSchedulingPolicy {\n       receiverId: Int,\n       preferredLocation: Option[String],\n       receiverTrackingInfoMap: Map[Int, ReceiverTrackingInfo],\n-      executors: Seq[String]): Seq[String] = {\n+      executors: Seq[ExecutorCacheTaskLocation]): Seq[TaskLocation] = {\n     if (executors.isEmpty) {\n       return Seq.empty\n     }\n \n     // Always try to schedule to the preferred locations\n-    val scheduledExecutors = mutable.Set[String]()\n-    scheduledExecutors ++= preferredLocation\n-\n-    val executorWeights = receiverTrackingInfoMap.values.flatMap { receiverTrackingInfo =>\n-      receiverTrackingInfo.state match {\n-        case ReceiverState.INACTIVE => Nil\n-        case ReceiverState.SCHEDULED =>\n-          val scheduledExecutors = receiverTrackingInfo.scheduledExecutors.get\n-          // The probability that a scheduled receiver will run in an executor is\n-          // 1.0 / scheduledLocations.size\n-          scheduledExecutors.map(location => location -> (1.0 / scheduledExecutors.size))\n-        case ReceiverState.ACTIVE => Seq(receiverTrackingInfo.runningExecutor.get -> 1.0)\n-      }\n-    }.groupBy(_._1).mapValues(_.map(_._2).sum) // Sum weights for each executor\n+    val scheduledLocations = mutable.Set[TaskLocation]()\n+    // Note: preferredLocation could be `HDFSCacheTaskLocation`, so use `TaskLocation.apply` to\n+    // handle this case\n+    scheduledLocations ++= preferredLocation.map(TaskLocation(_))\n+\n+    val executorWeights: Map[ExecutorCacheTaskLocation, Double] =\n+      receiverTrackingInfoMap.values.flatMap { receiverTrackingInfo =>\n+        receiverTrackingInfo.state match {"
  }],
  "prId": 9181
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit:shouldnt this map be in the line above? I think `.map { loc =>` would fit.\n",
    "commit": "46c5197c946cbed75ac28e1b60e64266ca070ee1",
    "createdAt": "2015-10-27T08:24:12Z",
    "diffHunk": "@@ -163,40 +169,59 @@ private[streaming] class ReceiverSchedulingPolicy {\n       receiverId: Int,\n       preferredLocation: Option[String],\n       receiverTrackingInfoMap: Map[Int, ReceiverTrackingInfo],\n-      executors: Seq[String]): Seq[String] = {\n+      executors: Seq[ExecutorCacheTaskLocation]): Seq[TaskLocation] = {\n     if (executors.isEmpty) {\n       return Seq.empty\n     }\n \n     // Always try to schedule to the preferred locations\n-    val scheduledExecutors = mutable.Set[String]()\n-    scheduledExecutors ++= preferredLocation\n-\n-    val executorWeights = receiverTrackingInfoMap.values.flatMap { receiverTrackingInfo =>\n-      receiverTrackingInfo.state match {\n-        case ReceiverState.INACTIVE => Nil\n-        case ReceiverState.SCHEDULED =>\n-          val scheduledExecutors = receiverTrackingInfo.scheduledExecutors.get\n-          // The probability that a scheduled receiver will run in an executor is\n-          // 1.0 / scheduledLocations.size\n-          scheduledExecutors.map(location => location -> (1.0 / scheduledExecutors.size))\n-        case ReceiverState.ACTIVE => Seq(receiverTrackingInfo.runningExecutor.get -> 1.0)\n-      }\n-    }.groupBy(_._1).mapValues(_.map(_._2).sum) // Sum weights for each executor\n+    val scheduledLocations = mutable.Set[TaskLocation]()\n+    // Note: preferredLocation could be `HDFSCacheTaskLocation`, so use `TaskLocation.apply` to\n+    // handle this case\n+    scheduledLocations ++= preferredLocation.map(TaskLocation(_))\n+\n+    val executorWeights: Map[ExecutorCacheTaskLocation, Double] = {\n+      receiverTrackingInfoMap.values.flatMap(convertReceiverTrackingInfoToExecutorWeights)\n+        .groupBy(_._1).mapValues(_.map(_._2).sum) // Sum weights for each executor\n+    }\n \n     val idleExecutors = executors.toSet -- executorWeights.keys\n     if (idleExecutors.nonEmpty) {\n-      scheduledExecutors ++= idleExecutors\n+      scheduledLocations ++= idleExecutors\n     } else {\n       // There is no idle executor. So select all executors that have the minimum weight.\n       val sortedExecutors = executorWeights.toSeq.sortBy(_._2)\n       if (sortedExecutors.nonEmpty) {\n         val minWeight = sortedExecutors(0)._2\n-        scheduledExecutors ++= sortedExecutors.takeWhile(_._2 == minWeight).map(_._1)\n+        scheduledLocations ++= sortedExecutors.takeWhile(_._2 == minWeight).map(_._1)\n       } else {\n         // This should not happen since \"executors\" is not empty\n       }\n     }\n-    scheduledExecutors.toSeq\n+    scheduledLocations.toSeq\n+  }\n+\n+  /**\n+   * This method tries to convert a receiver tracking info to executor weights. Every executor will\n+   * be assigned to a weight according to the receivers running or scheduling on it:\n+   *\n+   * - If a receiver is running on an executor, it contributes 1.0 to the executor's weight.\n+   * - If a receiver is scheduled to an executor but has not yet run, it contributes\n+   * `1.0 / #candidate_executors_of_this_receiver` to the executor's weight.\n+   */\n+  private def convertReceiverTrackingInfoToExecutorWeights(\n+      receiverTrackingInfo: ReceiverTrackingInfo): Seq[(ExecutorCacheTaskLocation, Double)] = {\n+    receiverTrackingInfo.state match {\n+      case ReceiverState.INACTIVE => Nil\n+      case ReceiverState.SCHEDULED =>\n+        val scheduledLocations = receiverTrackingInfo.scheduledLocations.get\n+        // The probability that a scheduled receiver will run in an executor is\n+        // 1.0 / scheduledLocations.size\n+        scheduledLocations.filter(_.isInstanceOf[ExecutorCacheTaskLocation]).\n+          map { location =>"
  }],
  "prId": 9181
}]