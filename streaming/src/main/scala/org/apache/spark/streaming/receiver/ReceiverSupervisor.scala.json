[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Does this need to be public?\n",
    "commit": "137b257fabaa198706528a008394f41ca247782a",
    "createdAt": "2015-07-10T02:02:10Z",
    "diffHunk": "@@ -64,6 +64,8 @@ private[streaming] abstract class ReceiverSupervisor(\n   /** State of the receiver */\n   @volatile private[streaming] var receiverState = Initialized\n \n+  val host = Utils.localHostName()"
  }],
  "prId": 7276
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Please update the scala docs to match the name. \n",
    "commit": "137b257fabaa198706528a008394f41ca247782a",
    "createdAt": "2015-07-13T22:13:26Z",
    "diffHunk": "@@ -161,12 +163,20 @@ private[streaming] abstract class ReceiverSupervisor(\n       stopReceiver(\"Restarting receiver with delay \" + delay + \"ms: \" + message, error)\n       logDebug(\"Sleeping for \" + delay)\n       Thread.sleep(delay)\n-      logInfo(\"Starting receiver again\")\n-      startReceiver()\n-      logInfo(\"Receiver started again\")\n+      val scheduledLocations = getAllowedLocations()\n+      if (scheduledLocations.isEmpty || scheduledLocations.contains(host)) {\n+        logInfo(\"Starting receiver again\")\n+        startReceiver()\n+        logInfo(\"Receiver started again\")\n+      } else {\n+        stop(\"Receiver is scheduled to another executor\", None)\n+      }\n     }(futureExecutionContext)\n   }\n \n+  /** Reschedule this receiver and return a candidate executor list */"
  }],
  "prId": 7276
}]