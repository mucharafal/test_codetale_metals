[{
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "style nit `preferredLocation: Option[String]`\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-17T06:42:16Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None"
  }],
  "prId": 300
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "should these be `final`? \n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-17T06:43:10Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None\n+\n+  /** Store a single item of received data to Spark's memory. */\n+  def store(dataItem: T) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Not sure if these are that critical. I would think that if some one is doing something advanced enough to require overriding them, then they would know what they are doing.\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-17T23:50:34Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None\n+\n+  /** Store a single item of received data to Spark's memory. */\n+  def store(dataItem: T) {"
  }],
  "prId": 300
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "Since you are doing a refactoring here, is there any reason not to just call this `Receiver` instead of `NetworkReceiver`? I always found this a bit strange. In Spark most components communicate somehow over the network, but we don't call them e.g. `NetworkBlockManager`, `NetworkExecutor`, etc... \n\nAlso since this is a very general interface, there is no reason someone couldn't build one of these that e.g. read data from a filesystem.\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-17T06:57:56Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {"
  }],
  "prId": 300
}, {
  "comments": [{
    "author": {
      "login": "pwendell"
    },
    "body": "There is a class of ingestion sources like flume that will allow you to receive data before fully \"acknowledging\" it in order to allow transactional semantics.\n\nI'm not sure the current API here really supports using those, because it's not clear to the receiver implementer when the underlying blocks get replicated.\n\nI think it would be good to expose either (a) some kind of `flush` operation, where you can force the block generator to create blocks for all outstanding pushed objects or (b) a way to do a bulk write where it guarantees that the iterator is fully pushed into a block.\n\nAn in both cases, it would be nice to have a way to wait until the blocks are fully replicated.\n\nIf you have those then you would be able to support the failure of a receiver in a nice way for sources like flume.\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-17T07:20:42Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None\n+\n+  /** Store a single item of received data to Spark's memory. */\n+  def store(dataItem: T) {\n+    executor.pushSingle(dataItem)\n+  }\n+\n+  /** Store a sequence of received data into Spark's memory. */\n+  def store(dataBuffer: ArrayBuffer[T]) {\n+    executor.pushArrayBuffer(dataBuffer, None, None)\n+  }\n+\n+  /**\n+   * Store a sequence of received data into Spark's memory.\n+   * The metadata will be associated with this block of data\n+   * for being used in the corresponding InputDStream.\n+   */\n+  def store(dataBuffer: ArrayBuffer[T], metadata: Any) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "As we discussed offline, that can introduced later as storeReliably methods. And that change will be additive, so should not break binary compatibility.\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-18T00:08:38Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None\n+\n+  /** Store a single item of received data to Spark's memory. */\n+  def store(dataItem: T) {\n+    executor.pushSingle(dataItem)\n+  }\n+\n+  /** Store a sequence of received data into Spark's memory. */\n+  def store(dataBuffer: ArrayBuffer[T]) {\n+    executor.pushArrayBuffer(dataBuffer, None, None)\n+  }\n+\n+  /**\n+   * Store a sequence of received data into Spark's memory.\n+   * The metadata will be associated with this block of data\n+   * for being used in the corresponding InputDStream.\n+   */\n+  def store(dataBuffer: ArrayBuffer[T], metadata: Any) {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Also note, I am adding two more store function, corresponding to Java iterator.\n",
    "commit": "ea27b38e262bafb0f97575eb7c2d941af9a5e62f",
    "createdAt": "2014-04-18T00:09:27Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import java.nio.ByteBuffer\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Abstract class of a receiver that can be run on worker nodes to receive external data. A\n+ * custom receiver can be defined by defining the functions onStart() and onStop(). onStart()\n+ * should define the setup steps necessary to start receiving data,\n+ * and onStop() should define the cleanup steps necessary to stop receiving data. A custom\n+ * receiver would look something like this.\n+ *\n+ * class MyReceiver(storageLevel) extends NetworkReceiver[String](storageLevel) {\n+ *   def onStart() {\n+ *     // Setup stuff (start threads, open sockets, etc.) to start receiving data.\n+ *     // Must start new thread to receive data, as onStart() must be non-blocking.\n+ *\n+ *     // Call store(...) in those threads to store received data into Spark's memory.\n+ *\n+ *     // Call stop(...), restart() or reportError(...) on any thread based on how\n+ *     // different errors should be handled.\n+ *\n+ *     // See corresponding method documentation for more details.\n+ *   }\n+ *\n+ *   def onStop() {\n+ *     // Cleanup stuff (stop threads, close sockets, etc.) to stop receiving data.\n+ *   }\n+ * }\n+ */\n+abstract class NetworkReceiver[T](val storageLevel: StorageLevel) extends Serializable {\n+\n+  /**\n+   * This method is called by the system when the receiver is started. This function\n+   * must initialize all resources (threads, buffers, etc.) necessary for receiving data.\n+   * This function must be non-blocking, so receiving the data must occur on a different\n+   * thread. Received data can be stored with Spark by calling `store(data)`.\n+   *\n+   * If there are errors in threads started here, then following options can be done\n+   * (i) `reportError(...)` can be called to report the error to the driver.\n+   * The receiving of data will continue uninterrupted.\n+   * (ii) `stop(...)` can be called to stop receiving data. This will call `onStop()` to\n+   * clear up all resources allocated (threads, buffers, etc.) during `onStart()`.\n+   * (iii) `restart(...)` can be called to restart the receiver. This will call `onStop()`\n+   * immediately, and then `onStart()` after a delay.\n+   */\n+  def onStart()\n+\n+  /**\n+   * This method is called by the system when the receiver is stopped. All resources\n+   * (threads, buffers, etc.) setup in `onStart()` must be cleaned up in this method.\n+   */\n+  def onStop()\n+\n+  /** Override this to specify a preferred location (hostname). */\n+  def preferredLocation : Option[String] = None\n+\n+  /** Store a single item of received data to Spark's memory. */\n+  def store(dataItem: T) {\n+    executor.pushSingle(dataItem)\n+  }\n+\n+  /** Store a sequence of received data into Spark's memory. */\n+  def store(dataBuffer: ArrayBuffer[T]) {\n+    executor.pushArrayBuffer(dataBuffer, None, None)\n+  }\n+\n+  /**\n+   * Store a sequence of received data into Spark's memory.\n+   * The metadata will be associated with this block of data\n+   * for being used in the corresponding InputDStream.\n+   */\n+  def store(dataBuffer: ArrayBuffer[T], metadata: Any) {"
  }],
  "prId": 300
}]