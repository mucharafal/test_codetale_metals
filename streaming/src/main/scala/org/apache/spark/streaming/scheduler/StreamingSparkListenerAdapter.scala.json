[{
  "comments": [{
    "author": {
      "login": "andrewor14"
    },
    "body": "do we need this class? What if we made `StreamingListener` extend `SparkListener` and override `onOtherEvent` to delegate the streaming events?\n",
    "commit": "8eb545c7b6c8fbb2c67f0aadd8ec070f9b10ba9e",
    "createdAt": "2016-01-18T22:12:06Z",
    "diffHunk": "@@ -17,19 +17,16 @@\n \n package org.apache.spark.streaming.scheduler\n \n-import java.util.concurrent.atomic.AtomicBoolean\n+import org.apache.spark.scheduler.{SparkListener, SparkListenerEvent}\n \n-import org.apache.spark.Logging\n-import org.apache.spark.util.AsynchronousListenerBus\n-\n-/** Asynchronously passes StreamingListenerEvents to registered StreamingListeners. */\n-private[spark] class StreamingListenerBus\n-  extends AsynchronousListenerBus[StreamingListener, StreamingListenerEvent](\"StreamingListenerBus\")\n-  with Logging {\n-\n-  private val logDroppedEvent = new AtomicBoolean(false)\n+/**\n+ * A SparkListener adapter for StreamingListener that will dispatch the Streaming events to\n+ * the underlying StreamingListener.\n+ */\n+private[spark] class StreamingSparkListenerAdapter(listener: StreamingListener)"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Making StreamingListener extend SparkListener has a tricky issue. \n\nImage someone implements both StreamingListener and SparkListener in the current codes. Then he needs to register this one with SparkContext and StreamingContext. If we make StreamingListener extend SparkListener, the user usually won't notice this change as his codes can be compiled successfully, however, the listener receives SparkListenerEvent twice and cause very tricky issue and hard to find the real problem.\n",
    "commit": "8eb545c7b6c8fbb2c67f0aadd8ec070f9b10ba9e",
    "createdAt": "2016-01-18T22:39:36Z",
    "diffHunk": "@@ -17,19 +17,16 @@\n \n package org.apache.spark.streaming.scheduler\n \n-import java.util.concurrent.atomic.AtomicBoolean\n+import org.apache.spark.scheduler.{SparkListener, SparkListenerEvent}\n \n-import org.apache.spark.Logging\n-import org.apache.spark.util.AsynchronousListenerBus\n-\n-/** Asynchronously passes StreamingListenerEvents to registered StreamingListeners. */\n-private[spark] class StreamingListenerBus\n-  extends AsynchronousListenerBus[StreamingListener, StreamingListenerEvent](\"StreamingListenerBus\")\n-  with Logging {\n-\n-  private val logDroppedEvent = new AtomicBoolean(false)\n+/**\n+ * A SparkListener adapter for StreamingListener that will dispatch the Streaming events to\n+ * the underlying StreamingListener.\n+ */\n+private[spark] class StreamingSparkListenerAdapter(listener: StreamingListener)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "nitL The name is very long. How about `WrappedStreamingListener`. \n",
    "commit": "8eb545c7b6c8fbb2c67f0aadd8ec070f9b10ba9e",
    "createdAt": "2016-01-19T02:22:23Z",
    "diffHunk": "@@ -17,19 +17,16 @@\n \n package org.apache.spark.streaming.scheduler\n \n-import java.util.concurrent.atomic.AtomicBoolean\n+import org.apache.spark.scheduler.{SparkListener, SparkListenerEvent}\n \n-import org.apache.spark.Logging\n-import org.apache.spark.util.AsynchronousListenerBus\n-\n-/** Asynchronously passes StreamingListenerEvents to registered StreamingListeners. */\n-private[spark] class StreamingListenerBus\n-  extends AsynchronousListenerBus[StreamingListener, StreamingListenerEvent](\"StreamingListenerBus\")\n-  with Logging {\n-\n-  private val logDroppedEvent = new AtomicBoolean(false)\n+/**\n+ * A SparkListener adapter for StreamingListener that will dispatch the Streaming events to\n+ * the underlying StreamingListener.\n+ */\n+private[spark] class StreamingSparkListenerAdapter(listener: StreamingListener)"
  }],
  "prId": 10779
}]