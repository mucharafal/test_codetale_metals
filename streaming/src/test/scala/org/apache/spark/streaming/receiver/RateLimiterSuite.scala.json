[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "@dragos I had mentioned in the earlier PR that we need these test to actually send data through the rateLimiter to see whether the updated rate is taking effect. Otherwise this test to see test whether `a == 10` after setting `a = 10` is nice but not very useful.\n",
    "commit": "8941cf91b03aa7835a78bc756bee1f32cb7bb1d8",
    "createdAt": "2015-07-20T01:58:52Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.SparkFunSuite\n+\n+/** Testsuite for testing the network receiver behavior */\n+class RateLimiterSuite extends SparkFunSuite {\n+\n+  test(\"rate limiter initializes even without a maxRate set\") {",
    "line": 26
  }, {
    "author": {
      "login": "dragos"
    },
    "body": "We could add an integration test. On the other hand, I personally don't see great use in testing Guava's code, I assume we take the same stance towards other libraries too. So, my assumption here is that _if_ the update reaches the receiver, Guava's RateLimiter is working just fine.\n",
    "commit": "8941cf91b03aa7835a78bc756bee1f32cb7bb1d8",
    "createdAt": "2015-07-20T08:43:19Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.SparkFunSuite\n+\n+/** Testsuite for testing the network receiver behavior */\n+class RateLimiterSuite extends SparkFunSuite {\n+\n+  test(\"rate limiter initializes even without a maxRate set\") {",
    "line": 26
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "I was not sure whether the Guava rate limiter behaves in the desired way when the rate is updated. There are several ways of implementing a updateable rate limiter, and I wanted to understand this's one behavior, and cover it in tests. However, I just digged deeper in Guava RateLimiter code, and realized that there are fundamentally bigger problems in using the Guava rate limiter, even for stable rate. It works effectively using token bucket philosophy, which allows a large burst of data to be allowed, if there has been no data for while. We DONT want that. This means that we need to implement our own rate limiter (which was the case, until someone replaced my implementation with Guava). Anyways, thats not something outside the scope of this PR. So I am okay not testing the rate limiting. \n\nSo please revert ReceiverSuite, and remove the block manager unit tests in this testsuite. Basically, revert it to the previous iteration (sorry :) )\n",
    "commit": "8941cf91b03aa7835a78bc756bee1f32cb7bb1d8",
    "createdAt": "2015-07-20T21:48:37Z",
    "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.SparkFunSuite\n+\n+/** Testsuite for testing the network receiver behavior */\n+class RateLimiterSuite extends SparkFunSuite {\n+\n+  test(\"rate limiter initializes even without a maxRate set\") {",
    "line": 26
  }],
  "prId": 7471
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This is a good attempt, but this is not the right attempt. This is a RateLimiterSuite, so ideally it should not be using something like a BlockGenerator to test the RateLimiter. So I would update the first three tests (\"rate limiter **\") to use a dummy rate limiter tester, that tests the upper limit that has been set, before and after any rate update has been made. The tester can be a simple integer increment. Note that only the upper limit needs to be tested, unlike the flaky block generator tests which test for both upper and lower limit. \n",
    "commit": "8941cf91b03aa7835a78bc756bee1f32cb7bb1d8",
    "createdAt": "2015-07-20T21:18:44Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.streaming.StreamingContext\n+import org.apache.spark.streaming.FakeBlockGeneratorListener\n+\n+/** Testsuite for testing the network receiver behavior */\n+class RateLimiterSuite extends SparkFunSuite {\n+\n+  test(\"rate limiter initializes even without a maxRate set\") {\n+    val conf = new SparkConf()\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit == 105)\n+  }\n+\n+  test(\"rate limiter updates when below maxRate\") {\n+    val conf = new SparkConf().set(\"spark.streaming.receiver.maxRate\", \"110\")\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit == 105)\n+  }\n+\n+  test(\"rate limiter stays below maxRate despite large updates\") {\n+    val conf = new SparkConf().set(\"spark.streaming.receiver.maxRate\", \"100\")\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit === 100)\n+  }\n+\n+  def setupGenerator(blockInterval: Int): (BlockGenerator, FakeBlockGeneratorListener) = {\n+    val blockGeneratorListener = new FakeBlockGeneratorListener\n+    val conf = new SparkConf().set(\"spark.streaming.blockInterval\", s\"${blockInterval}ms\")\n+    val blockGenerator = new BlockGenerator(blockGeneratorListener, 1, conf)\n+    (blockGenerator, blockGeneratorListener)\n+  }\n+\n+  test(\"throttling block generator\") {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Ignore this. See comment in the above thread.\n",
    "commit": "8941cf91b03aa7835a78bc756bee1f32cb7bb1d8",
    "createdAt": "2015-07-20T21:39:56Z",
    "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.SparkConf\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.streaming.StreamingContext\n+import org.apache.spark.streaming.FakeBlockGeneratorListener\n+\n+/** Testsuite for testing the network receiver behavior */\n+class RateLimiterSuite extends SparkFunSuite {\n+\n+  test(\"rate limiter initializes even without a maxRate set\") {\n+    val conf = new SparkConf()\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit == 105)\n+  }\n+\n+  test(\"rate limiter updates when below maxRate\") {\n+    val conf = new SparkConf().set(\"spark.streaming.receiver.maxRate\", \"110\")\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit == 105)\n+  }\n+\n+  test(\"rate limiter stays below maxRate despite large updates\") {\n+    val conf = new SparkConf().set(\"spark.streaming.receiver.maxRate\", \"100\")\n+    val rateLimiter = new RateLimiter(conf){}\n+    rateLimiter.updateRate(105)\n+    assert(rateLimiter.getCurrentLimit === 100)\n+  }\n+\n+  def setupGenerator(blockInterval: Int): (BlockGenerator, FakeBlockGeneratorListener) = {\n+    val blockGeneratorListener = new FakeBlockGeneratorListener\n+    val conf = new SparkConf().set(\"spark.streaming.blockInterval\", s\"${blockInterval}ms\")\n+    val blockGenerator = new BlockGenerator(blockGeneratorListener, 1, conf)\n+    (blockGenerator, blockGeneratorListener)\n+  }\n+\n+  test(\"throttling block generator\") {"
  }],
  "prId": 7471
}]