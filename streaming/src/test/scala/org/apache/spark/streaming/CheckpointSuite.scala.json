[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Why real delay? Why not just use eventually?\n",
    "commit": "f168c9476fc7104d3d3f92702793e0d9116117d0",
    "createdAt": "2015-07-28T13:11:03Z",
    "diffHunk": "@@ -391,6 +393,32 @@ class CheckpointSuite extends TestSuiteBase {\n     testCheckpointedOperation(input, operation, output, 7)\n   }\n \n+  test(\"recovery maintains rate controller\") {\n+    ssc = new StreamingContext(conf, batchDuration)\n+    ssc.checkpoint(checkpointDir)\n+\n+    val dstream = new RateLimitInputDStream(ssc) {\n+      override val rateController =\n+        Some(new ReceiverRateController(id, new ConstantEstimator(200.0)))\n+    }\n+    SingletonDummyReceiver.reset()\n+\n+    val output = new TestOutputStreamWithPartitions(dstream.checkpoint(batchDuration * 2))\n+    output.register()\n+    runStreams(ssc, 5, 5)\n+\n+    SingletonDummyReceiver.reset()\n+    ssc = new StreamingContext(checkpointDir)\n+    ssc.start()\n+    val outputNew = advanceTimeWithRealDelay(ssc, 2)"
  }, {
    "author": {
      "login": "dragos"
    },
    "body": "I don't remember, the thing is that it didn't get any batch updates without a real delay. I didn't investigate further.\n",
    "commit": "f168c9476fc7104d3d3f92702793e0d9116117d0",
    "createdAt": "2015-07-28T16:28:06Z",
    "diffHunk": "@@ -391,6 +393,32 @@ class CheckpointSuite extends TestSuiteBase {\n     testCheckpointedOperation(input, operation, output, 7)\n   }\n \n+  test(\"recovery maintains rate controller\") {\n+    ssc = new StreamingContext(conf, batchDuration)\n+    ssc.checkpoint(checkpointDir)\n+\n+    val dstream = new RateLimitInputDStream(ssc) {\n+      override val rateController =\n+        Some(new ReceiverRateController(id, new ConstantEstimator(200.0)))\n+    }\n+    SingletonDummyReceiver.reset()\n+\n+    val output = new TestOutputStreamWithPartitions(dstream.checkpoint(batchDuration * 2))\n+    output.register()\n+    runStreams(ssc, 5, 5)\n+\n+    SingletonDummyReceiver.reset()\n+    ssc = new StreamingContext(checkpointDir)\n+    ssc.start()\n+    val outputNew = advanceTimeWithRealDelay(ssc, 2)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "That is because you were running manual clock through the conf generated by TestSuiteBase. When on manual clock, unless you manually add time to the clock, batches will not be generated. If you run on a normal clock, and use eventually sufficiently large timeout, batches will complete.\n",
    "commit": "f168c9476fc7104d3d3f92702793e0d9116117d0",
    "createdAt": "2015-07-28T19:20:56Z",
    "diffHunk": "@@ -391,6 +393,32 @@ class CheckpointSuite extends TestSuiteBase {\n     testCheckpointedOperation(input, operation, output, 7)\n   }\n \n+  test(\"recovery maintains rate controller\") {\n+    ssc = new StreamingContext(conf, batchDuration)\n+    ssc.checkpoint(checkpointDir)\n+\n+    val dstream = new RateLimitInputDStream(ssc) {\n+      override val rateController =\n+        Some(new ReceiverRateController(id, new ConstantEstimator(200.0)))\n+    }\n+    SingletonDummyReceiver.reset()\n+\n+    val output = new TestOutputStreamWithPartitions(dstream.checkpoint(batchDuration * 2))\n+    output.register()\n+    runStreams(ssc, 5, 5)\n+\n+    SingletonDummyReceiver.reset()\n+    ssc = new StreamingContext(checkpointDir)\n+    ssc.start()\n+    val outputNew = advanceTimeWithRealDelay(ssc, 2)"
  }],
  "prId": 7600
}]