[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "Why `stop` is in `before`?\n",
    "commit": "41d4461ec2d7bf5de6b35ba5001bce7bdcad95a8",
    "createdAt": "2015-08-05T16:00:00Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable\n+\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.Matchers._\n+import org.scalatest.PrivateMethodTester._\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.time.SpanSugar._\n+\n+import org.apache.spark.storage.StreamBlockId\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+\n+class BlockGeneratorSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import BlockGeneratorSuite._\n+\n+  private val conf = new SparkConf().set(\"spark.streaming.blockInterval\", \"100ms\")\n+  @volatile private var blockGenerator: BlockGenerator = null\n+\n+  before {"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Right. Mistake.\n",
    "commit": "41d4461ec2d7bf5de6b35ba5001bce7bdcad95a8",
    "createdAt": "2015-08-05T21:47:33Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable\n+\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.Matchers._\n+import org.scalatest.PrivateMethodTester._\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.time.SpanSugar._\n+\n+import org.apache.spark.storage.StreamBlockId\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+\n+class BlockGeneratorSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import BlockGeneratorSuite._\n+\n+  private val conf = new SparkConf().set(\"spark.streaming.blockInterval\", \"100ms\")\n+  @volatile private var blockGenerator: BlockGenerator = null\n+\n+  before {"
  }],
  "prId": 7913
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "This line and next line could be flaky. I think we can remove them.\n",
    "commit": "41d4461ec2d7bf5de6b35ba5001bce7bdcad95a8",
    "createdAt": "2015-08-05T16:03:08Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable\n+\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.Matchers._\n+import org.scalatest.PrivateMethodTester._\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.time.SpanSugar._\n+\n+import org.apache.spark.storage.StreamBlockId\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+\n+class BlockGeneratorSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import BlockGeneratorSuite._\n+\n+  private val conf = new SparkConf().set(\"spark.streaming.blockInterval\", \"100ms\")\n+  @volatile private var blockGenerator: BlockGenerator = null\n+\n+  before {\n+    if (blockGenerator != null) {\n+      blockGenerator.stop()\n+    }\n+  }\n+\n+  test(\"block generation and callbacks\") {\n+    val listener = new TestBlockGeneratorListener\n+    blockGenerator = new BlockGenerator(listener, 0, conf)\n+    require(listener.onAddDataCalled === false)\n+    require(listener.onGenerateBlockCalled === false)\n+    require(listener.onPushBlockCalled === false)\n+    assert(blockGenerator.isStopped() === false)\n+\n+    blockGenerator.start()\n+    assert(listener.onAddDataCalled === false)\n+    assert(listener.onGenerateBlockCalled === false)\n+    assert(listener.onPushBlockCalled === false)\n+    assert(blockGenerator.isStopped() === false)\n+\n+    // Verify data is added and callback is called\n+    val data1 = 1 to 10\n+    data1.foreach { blockGenerator.addData _ }\n+    assert(listener.onAddDataCalled === false)\n+    assert(listener.onGenerateBlockCalled === false)"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Can be but very unlikely as the block interval is 100 ms. Let me try putting in a manual clock there.\n",
    "commit": "41d4461ec2d7bf5de6b35ba5001bce7bdcad95a8",
    "createdAt": "2015-08-05T22:12:07Z",
    "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.receiver\n+\n+import scala.collection.mutable\n+\n+import org.scalatest.BeforeAndAfter\n+import org.scalatest.Matchers._\n+import org.scalatest.PrivateMethodTester._\n+import org.scalatest.concurrent.Eventually._\n+import org.scalatest.time.SpanSugar._\n+\n+import org.apache.spark.storage.StreamBlockId\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+\n+class BlockGeneratorSuite extends SparkFunSuite with BeforeAndAfter {\n+\n+  import BlockGeneratorSuite._\n+\n+  private val conf = new SparkConf().set(\"spark.streaming.blockInterval\", \"100ms\")\n+  @volatile private var blockGenerator: BlockGenerator = null\n+\n+  before {\n+    if (blockGenerator != null) {\n+      blockGenerator.stop()\n+    }\n+  }\n+\n+  test(\"block generation and callbacks\") {\n+    val listener = new TestBlockGeneratorListener\n+    blockGenerator = new BlockGenerator(listener, 0, conf)\n+    require(listener.onAddDataCalled === false)\n+    require(listener.onGenerateBlockCalled === false)\n+    require(listener.onPushBlockCalled === false)\n+    assert(blockGenerator.isStopped() === false)\n+\n+    blockGenerator.start()\n+    assert(listener.onAddDataCalled === false)\n+    assert(listener.onGenerateBlockCalled === false)\n+    assert(listener.onPushBlockCalled === false)\n+    assert(blockGenerator.isStopped() === false)\n+\n+    // Verify data is added and callback is called\n+    val data1 = 1 to 10\n+    data1.foreach { blockGenerator.addData _ }\n+    assert(listener.onAddDataCalled === false)\n+    assert(listener.onGenerateBlockCalled === false)"
  }],
  "prId": 7913
}]