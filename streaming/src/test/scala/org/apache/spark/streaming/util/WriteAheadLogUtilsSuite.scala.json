[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "nit: direction --> directory\n",
    "commit": "1fe2e7bf6d428738944ec0880f848633e9c0b6c7",
    "createdAt": "2015-11-09T03:17:23Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.util\n+\n+import java.io.EOFException\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.language.{implicitConversions, postfixOps}\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+import org.apache.spark.util.{ManualClock, Utils}\n+\n+class WriteAheadLogUtilsSuite extends SparkFunSuite {\n+  import WriteAheadLogSuite._\n+\n+  private val logDir = Utils.createTempDir().getAbsolutePath()\n+  private val hadoopConf = new Configuration()\n+\n+  def assertDriverLogClass[T <: WriteAheadLog: ClassTag](\n+      conf: SparkConf,\n+      isBatched: Boolean = false): WriteAheadLog = {\n+    val log = WriteAheadLogUtils.createLogForDriver(conf, logDir, hadoopConf)\n+    if (isBatched) {\n+      assert(log.isInstanceOf[BatchedWriteAheadLog])\n+      val parentLog = log.asInstanceOf[BatchedWriteAheadLog].wrappedLog\n+      assert(parentLog.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    } else {\n+      assert(log.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    }\n+    log\n+  }\n+\n+  def assertReceiverLogClass[T <: WriteAheadLog: ClassTag](conf: SparkConf): WriteAheadLog = {\n+    val log = WriteAheadLogUtils.createLogForReceiver(conf, logDir, hadoopConf)\n+    assert(log.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    log\n+  }\n+\n+  test(\"log selection and creation\") {\n+\n+    val emptyConf = new SparkConf()  // no log configuration\n+    assertDriverLogClass[FileBasedWriteAheadLog](emptyConf)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](emptyConf)\n+\n+    // Verify setting driver WAL class\n+    val driverWALConf = new SparkConf().set(\"spark.streaming.driver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[MockWriteAheadLog0](driverWALConf)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](driverWALConf)\n+\n+    // Verify setting receiver WAL class\n+    val receiverWALConf = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[FileBasedWriteAheadLog](receiverWALConf)\n+    assertReceiverLogClass[MockWriteAheadLog0](receiverWALConf)\n+\n+    // Verify setting receiver WAL class with 1-arg constructor\n+    val receiverWALConf2 = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog1].getName())\n+    assertReceiverLogClass[MockWriteAheadLog1](receiverWALConf2)\n+\n+    // Verify failure setting receiver WAL class with 2-arg constructor\n+    intercept[SparkException] {\n+      val receiverWALConf3 = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+        classOf[MockWriteAheadLog2].getName())\n+      assertReceiverLogClass[MockWriteAheadLog1](receiverWALConf3)\n+    }\n+  }\n+\n+  test(\"wrap WriteAheadLog in BatchedWriteAheadLog when batching is enabled\") {\n+    def getBatchedSparkConf: SparkConf =\n+      new SparkConf().set(\"spark.streaming.driver.writeAheadLog.allowBatching\", \"true\")\n+\n+    val justBatchingConf = getBatchedSparkConf\n+    assertDriverLogClass[FileBasedWriteAheadLog](justBatchingConf, isBatched = true)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](justBatchingConf)\n+\n+    // Verify setting driver WAL class\n+    val driverWALConf = getBatchedSparkConf.set(\"spark.streaming.driver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[MockWriteAheadLog0](driverWALConf, isBatched = true)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](driverWALConf)\n+\n+    // Verify receivers are not wrapped\n+    val receiverWALConf = getBatchedSparkConf.set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[FileBasedWriteAheadLog](receiverWALConf, isBatched = true)\n+    assertReceiverLogClass[MockWriteAheadLog0](receiverWALConf)\n+  }\n+}\n+\n+object WriteAheadLogSuite {\n+\n+  class MockWriteAheadLog0() extends WriteAheadLog {\n+    override def write(record: ByteBuffer, time: Long): WriteAheadLogRecordHandle = { null }\n+    override def read(handle: WriteAheadLogRecordHandle): ByteBuffer = { null }\n+    override def readAll(): util.Iterator[ByteBuffer] = { null }\n+    override def clean(threshTime: Long, waitForCompletion: Boolean): Unit = { }\n+    override def close(): Unit = { }\n+  }\n+\n+  class MockWriteAheadLog1(val conf: SparkConf) extends MockWriteAheadLog0()\n+\n+  class MockWriteAheadLog2(val conf: SparkConf, x: Int) extends MockWriteAheadLog0()\n+\n+  private val hadoopConf = new Configuration()\n+\n+  /** Write data to a file directly and return an array of the file segments written. */\n+  def writeDataManually(data: Seq[String], file: String): Seq[FileBasedWriteAheadLogSegment] = {\n+    val segments = new ArrayBuffer[FileBasedWriteAheadLogSegment]()\n+    val writer = HdfsUtils.getOutputStream(file, hadoopConf)\n+    data.foreach { item =>\n+      val offset = writer.getPos\n+      val bytes = Utils.serialize(item)\n+      writer.writeInt(bytes.size)\n+      writer.write(bytes)\n+      segments += FileBasedWriteAheadLogSegment(file, offset, bytes.size)\n+    }\n+    writer.close()\n+    segments\n+  }\n+\n+  /**\n+   * Write data to a file using the writer class and return an array of the file segments written.\n+   */\n+  def writeDataUsingWriter(\n+      filePath: String,\n+      data: Seq[String]): Seq[FileBasedWriteAheadLogSegment] = {\n+    val writer = new FileBasedWriteAheadLogWriter(filePath, hadoopConf)\n+    val segments = data.map {\n+      item => writer.write(item)\n+    }\n+    writer.close()\n+    segments\n+  }\n+\n+  /** Write data to rotating files in log directory using the WriteAheadLog class. */\n+  def writeDataUsingWriteAheadLog(\n+      logDirectory: String,\n+      data: Seq[String],\n+      closeFileAfterWrite: Boolean,\n+      allowBatching: Boolean,\n+      manualClock: ManualClock = new ManualClock,\n+      closeLog: Boolean = true,\n+      clockAdvanceTime: Int = 500): WriteAheadLog = {\n+    if (manualClock.getTimeMillis() < 100000) manualClock.setTime(10000)\n+    val wal = createWriteAheadLog(logDirectory, closeFileAfterWrite, allowBatching)\n+\n+    // Ensure that 500 does not get sorted after 2000, so put a high base value.\n+    data.foreach { item =>\n+      manualClock.advance(clockAdvanceTime)\n+      wal.write(item, manualClock.getTimeMillis())\n+    }\n+    if (closeLog) wal.close()\n+    wal\n+  }\n+\n+  /** Read data from a segments of a log file directly and return the list of byte buffers. */\n+  def readDataManually(segments: Seq[FileBasedWriteAheadLogSegment]): Seq[String] = {\n+    segments.map { segment =>\n+      val reader = HdfsUtils.getInputStream(segment.path, hadoopConf)\n+      try {\n+        reader.seek(segment.offset)\n+        val bytes = new Array[Byte](segment.length)\n+        reader.readInt()\n+        reader.readFully(bytes)\n+        val data = Utils.deserialize[String](bytes)\n+        reader.close()\n+        data\n+      } finally {\n+        reader.close()\n+      }\n+    }\n+  }\n+\n+  /** Read all the data from a log file directly and return the list of byte buffers. */\n+  def readDataManually[T](file: String): Seq[T] = {\n+    val reader = HdfsUtils.getInputStream(file, hadoopConf)\n+    val buffer = new ArrayBuffer[T]\n+    try {\n+      while (true) {\n+        // Read till EOF is thrown\n+        val length = reader.readInt()\n+        val bytes = new Array[Byte](length)\n+        reader.read(bytes)\n+        buffer += Utils.deserialize[T](bytes)\n+      }\n+    } catch {\n+      case ex: EOFException =>\n+    } finally {\n+      reader.close()\n+    }\n+    buffer\n+  }\n+\n+  /** Read all the data from a log file using reader class and return the list of byte buffers. */\n+  def readDataUsingReader(file: String): Seq[String] = {\n+    val reader = new FileBasedWriteAheadLogReader(file, hadoopConf)\n+    val readData = reader.toList.map(byteBufferToString)\n+    reader.close()\n+    readData\n+  }\n+\n+  /** Read all the data in the log file in a directory using the WriteAheadLog class. */\n+  def readDataUsingWriteAheadLog(\n+      logDirectory: String,\n+      closeFileAfterWrite: Boolean,\n+      allowBatching: Boolean): Seq[String] = {\n+    val wal = createWriteAheadLog(logDirectory, closeFileAfterWrite, allowBatching)\n+    val data = wal.readAll().asScala.map(byteBufferToString).toSeq\n+    wal.close()\n+    data\n+  }\n+\n+  /** Get the log files in a direction */"
  }],
  "prId": 9143
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Why is WriteAheadLogSuite in the file WriteAheadLogUtilsSuite. Should be in the file WriteAheadLogSuite. Only the stuff needed by the class WriteAheadLogUtilsSuite (like the MockWAL classes) should be in the WriteAheadLogSuite object.\n",
    "commit": "1fe2e7bf6d428738944ec0880f848633e9c0b6c7",
    "createdAt": "2015-11-09T04:29:55Z",
    "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.streaming.util\n+\n+import java.io.EOFException\n+import java.nio.ByteBuffer\n+import java.util\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ArrayBuffer\n+import scala.language.{implicitConversions, postfixOps}\n+import scala.reflect.ClassTag\n+\n+import org.apache.hadoop.conf.Configuration\n+import org.apache.hadoop.fs.Path\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.{SparkException, SparkConf, SparkFunSuite}\n+import org.apache.spark.util.{ManualClock, Utils}\n+\n+class WriteAheadLogUtilsSuite extends SparkFunSuite {\n+  import WriteAheadLogSuite._\n+\n+  private val logDir = Utils.createTempDir().getAbsolutePath()\n+  private val hadoopConf = new Configuration()\n+\n+  def assertDriverLogClass[T <: WriteAheadLog: ClassTag](\n+      conf: SparkConf,\n+      isBatched: Boolean = false): WriteAheadLog = {\n+    val log = WriteAheadLogUtils.createLogForDriver(conf, logDir, hadoopConf)\n+    if (isBatched) {\n+      assert(log.isInstanceOf[BatchedWriteAheadLog])\n+      val parentLog = log.asInstanceOf[BatchedWriteAheadLog].wrappedLog\n+      assert(parentLog.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    } else {\n+      assert(log.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    }\n+    log\n+  }\n+\n+  def assertReceiverLogClass[T <: WriteAheadLog: ClassTag](conf: SparkConf): WriteAheadLog = {\n+    val log = WriteAheadLogUtils.createLogForReceiver(conf, logDir, hadoopConf)\n+    assert(log.getClass === implicitly[ClassTag[T]].runtimeClass)\n+    log\n+  }\n+\n+  test(\"log selection and creation\") {\n+\n+    val emptyConf = new SparkConf()  // no log configuration\n+    assertDriverLogClass[FileBasedWriteAheadLog](emptyConf)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](emptyConf)\n+\n+    // Verify setting driver WAL class\n+    val driverWALConf = new SparkConf().set(\"spark.streaming.driver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[MockWriteAheadLog0](driverWALConf)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](driverWALConf)\n+\n+    // Verify setting receiver WAL class\n+    val receiverWALConf = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[FileBasedWriteAheadLog](receiverWALConf)\n+    assertReceiverLogClass[MockWriteAheadLog0](receiverWALConf)\n+\n+    // Verify setting receiver WAL class with 1-arg constructor\n+    val receiverWALConf2 = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog1].getName())\n+    assertReceiverLogClass[MockWriteAheadLog1](receiverWALConf2)\n+\n+    // Verify failure setting receiver WAL class with 2-arg constructor\n+    intercept[SparkException] {\n+      val receiverWALConf3 = new SparkConf().set(\"spark.streaming.receiver.writeAheadLog.class\",\n+        classOf[MockWriteAheadLog2].getName())\n+      assertReceiverLogClass[MockWriteAheadLog1](receiverWALConf3)\n+    }\n+  }\n+\n+  test(\"wrap WriteAheadLog in BatchedWriteAheadLog when batching is enabled\") {\n+    def getBatchedSparkConf: SparkConf =\n+      new SparkConf().set(\"spark.streaming.driver.writeAheadLog.allowBatching\", \"true\")\n+\n+    val justBatchingConf = getBatchedSparkConf\n+    assertDriverLogClass[FileBasedWriteAheadLog](justBatchingConf, isBatched = true)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](justBatchingConf)\n+\n+    // Verify setting driver WAL class\n+    val driverWALConf = getBatchedSparkConf.set(\"spark.streaming.driver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[MockWriteAheadLog0](driverWALConf, isBatched = true)\n+    assertReceiverLogClass[FileBasedWriteAheadLog](driverWALConf)\n+\n+    // Verify receivers are not wrapped\n+    val receiverWALConf = getBatchedSparkConf.set(\"spark.streaming.receiver.writeAheadLog.class\",\n+      classOf[MockWriteAheadLog0].getName())\n+    assertDriverLogClass[FileBasedWriteAheadLog](receiverWALConf, isBatched = true)\n+    assertReceiverLogClass[MockWriteAheadLog0](receiverWALConf)\n+  }\n+}\n+\n+object WriteAheadLogSuite {"
  }],
  "prId": 9143
}]