[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Here the whole unit test to test the deleted API has been replaced by a sub-unit-test that tests older API's ability to use an existing SparkContext.\n",
    "commit": "53f4b2d30010f435ea027b2ad8c72d191b3750dc",
    "createdAt": "2015-05-12T20:53:36Z",
    "diffHunk": "@@ -418,76 +418,16 @@ class StreamingContextSuite extends FunSuite with BeforeAndAfter with Timeouts w\n       ssc = StreamingContext.getOrCreate(checkpointPath, creatingFunction _)\n       assert(ssc != null, \"no context created\")\n       assert(!newContextCreated, \"old context not recovered\")\n-      assert(ssc.conf.get(\"someKey\") === \"someValue\")\n+      assert(ssc.conf.get(\"someKey\") === \"someValue\", \"checkpointed config not recovered\")\n     }\n-  }\n-\n-  test(\"getOrCreate with existing SparkContext\") {\n-    val conf = new SparkConf().setMaster(master).setAppName(appName)\n-    sc = new SparkContext(conf)\n \n-    // Function to create StreamingContext that has a config to identify it to be new context\n-    var newContextCreated = false\n-    def creatingFunction(sparkContext: SparkContext): StreamingContext = {\n-      newContextCreated = true\n-      new StreamingContext(sparkContext, batchDuration)\n-    }\n-\n-    // Call ssc.stop(stopSparkContext = false) after a body of cody\n-    def testGetOrCreate(body: => Unit): Unit = {\n-      newContextCreated = false\n-      try {\n-        body\n-      } finally {\n-        if (ssc != null) {\n-          ssc.stop(stopSparkContext = false)\n-        }\n-        ssc = null\n-      }\n-    }\n-\n-    val emptyPath = Utils.createTempDir().getAbsolutePath()\n-\n-    // getOrCreate should create new context with empty path\n+    // getOrCreate should recover StreamingContext with existing SparkContext\n     testGetOrCreate {\n-      ssc = StreamingContext.getOrCreate(emptyPath, creatingFunction _, sc, createOnError = true)\n-      assert(ssc != null, \"no context created\")\n-      assert(newContextCreated, \"new context not created\")\n-      assert(ssc.sparkContext === sc, \"new StreamingContext does not use existing SparkContext\")\n-    }\n-\n-    val corrutedCheckpointPath = createCorruptedCheckpoint()\n-\n-    // getOrCreate should throw exception with fake checkpoint file and createOnError = false\n-    intercept[Exception] {\n-      ssc = StreamingContext.getOrCreate(corrutedCheckpointPath, creatingFunction _, sc)\n-    }\n-\n-    // getOrCreate should throw exception with fake checkpoint file\n-    intercept[Exception] {\n-      ssc = StreamingContext.getOrCreate(\n-        corrutedCheckpointPath, creatingFunction _, sc, createOnError = false)\n-    }\n-\n-    // getOrCreate should create new context with fake checkpoint file and createOnError = true\n-    testGetOrCreate {\n-      ssc = StreamingContext.getOrCreate(\n-        corrutedCheckpointPath, creatingFunction _, sc, createOnError = true)\n-      assert(ssc != null, \"no context created\")\n-      assert(newContextCreated, \"new context not created\")\n-      assert(ssc.sparkContext === sc, \"new StreamingContext does not use existing SparkContext\")\n-    }\n-\n-    val checkpointPath = createValidCheckpoint()\n-\n-    // StreamingContext.getOrCreate should recover context with checkpoint path\n-    testGetOrCreate {\n-      ssc = StreamingContext.getOrCreate(checkpointPath, creatingFunction _, sc)\n+      sc = new SparkContext(conf)"
  }],
  "prId": 6096
}]