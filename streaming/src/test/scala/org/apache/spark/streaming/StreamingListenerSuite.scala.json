[{
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This needs to be changed too to extraListeners.\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-10T19:28:55Z",
    "diffHunk": "@@ -140,6 +141,18 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.listeners\") {\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.listeners\", classOf[BatchInfoCollector].getName + \",\" +"
  }],
  "prId": 6380
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Its easier to understand if this check is replaced with `... listeners.exists { _.isInstanceOf[...] }`\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-13T21:56:33Z",
    "diffHunk": "@@ -140,6 +141,18 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\", classOf[BatchInfoCollector].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))\n+\n+    scc.scheduler.listenerBus.listeners.collect {"
  }],
  "prId": 6380
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "I missed it earlier, this unit does not cover the two cases, one without constructor and one with constructor.\nIt may be easier to read if you create new classes - `StreamingListenerWithoutArg`, and `StreamingListenerWithConf`\n(similar to ListenerThatAcceptsSparkConf for spark.extraListeners in SparkListenerSuite)\n\nAlso, the `StreamingContextSuite` is getting really overloaded, mind shifting this to `StreamingListenerSuite`, and reverting this file?\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-13T23:36:13Z",
    "diffHunk": "@@ -140,6 +141,16 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\", classOf[BatchInfoCollector].getName + \",\" +"
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Also please include a third case where the incorrect StreamingListener with 2 args is specified, which is expected throw an exception. Test with `intercept[SparkException]` and check whether the exception message has \"Exception when registering Streaming Listener:\" and the class name\".\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-14T23:47:55Z",
    "diffHunk": "@@ -140,6 +141,16 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\", classOf[BatchInfoCollector].getName + \",\" +"
  }, {
    "author": {
      "login": "His-name-is-Joof"
    },
    "body": "The change is already in StreamingListenerSuite.scala (and the class\nStreamingListenerSuite) which seems appropriate. Did you mean create new\nclasses within StreamingListenerSuite.scala to handle the test cases?\n\nOn Mon, Jul 13, 2015 at 5:36 PM, Tathagata Das notifications@github.com\nwrote:\n\n> In\n> streaming/src/test/scala/org/apache/spark/streaming/StreamingListenerSuite.scala\n> https://github.com/apache/spark/pull/6380#discussion_r34524259:\n> \n> > @@ -140,6 +141,16 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n> >      }\n> >      true\n> >    }\n> > +\n> > -  test(\"registering listeners via spark.streaming.extraListeners\") {\n> > -    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n> > -      .set(\"spark.streaming.extraListeners\", classOf[BatchInfoCollector].getName + \",\" +\n> \n> I missed it earlier, this unit does not cover the two cases, one without\n> constructor and one with constructor.\n> It may be easier to read if you create new classes -\n> StreamingListenerWithoutArg, and StreamingListenerWithConf\n> (similar to ListenerThatAcceptsSparkConf for spark.extraListeners in\n> SparkListenerSuite)\n> \n> Also, the StreamingContextSuite is getting really overloaded, mind\n> shifting this to StreamingListenerSuite, and reverting this file?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/apache/spark/pull/6380/files#r34524259.\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-16T20:40:52Z",
    "diffHunk": "@@ -140,6 +141,16 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\", classOf[BatchInfoCollector].getName + \",\" +"
  }],
  "prId": 6380
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "Lets not be so specific, the exact text can change. Just verify whether the message has the name of the class inside it. \n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-17T07:52:55Z",
    "diffHunk": "@@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    // Test for success with zero-argument constructor and sparkConf constructor\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\",\n+        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))\n+\n+    scc.scheduler.listenerBus.listeners.exists {\n+      _.isInstanceOf[StreamingListenerThatAcceptsSparkConf] }\n+    scc.scheduler.listenerBus.listeners.exists {\n+      _.isInstanceOf[ReceiverInfoCollector] }\n+\n+    // Test for failure with too many arguments in constructor\n+    val failingConf = new SparkConf().setMaster(\"local\").setAppName(\"failingTest\")\n+      .set(\"spark.streaming.extraListeners\", classOf[StreamingListenerTooManyArguments].getName)\n+    val thrown = intercept[SparkException] {\n+      val failingScc = new StreamingContext(failingConf, Seconds(1))\n+    }\n+    val expectedErrorMessage =\n+        \"Exception when registering Streaming Listener:\" +",
    "line": 46
  }],
  "prId": 6380
}, {
  "comments": [{
    "author": {
      "login": "tdas"
    },
    "body": "This can lead to a leak in the StreamingContext and underlying SparkContext. Please put the whole in \n\n```\nvar ssc: StremaingContext = null\ntry {\n  ssc = new StreamingContext...\n\n} finally {\n   if (ssc != null) {\n     ssc.stop()\n   }\n}\n\n```\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-17T07:54:33Z",
    "diffHunk": "@@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    // Test for success with zero-argument constructor and sparkConf constructor\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\",\n+        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))",
    "line": 32
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "StreamingListenerSuite extends TestSuiteBase, so I think we can use the `withStreamingContext(ssc) { }` construct to manage cleanup for us: https://github.com/apache/spark/blob/master/streaming/src/test/scala/org/apache/spark/streaming/TestSuiteBase.scala#L270\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-17T15:30:00Z",
    "diffHunk": "@@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    // Test for success with zero-argument constructor and sparkConf constructor\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\",\n+        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))",
    "line": 32
  }, {
    "author": {
      "login": "His-name-is-Joof"
    },
    "body": "Is this still the case when the context is never started?\n\nOn Fri, Jul 17, 2015 at 1:55 AM, Tathagata Das notifications@github.com\nwrote:\n\n> In\n> streaming/src/test/scala/org/apache/spark/streaming/StreamingListenerSuite.scala\n> https://github.com/apache/spark/pull/6380#discussion_r34868938:\n> \n> > @@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n> >      }\n> >      true\n> >    }\n> > +\n> > -  test(\"registering listeners via spark.streaming.extraListeners\") {\n> > -    // Test for success with zero-argument constructor and sparkConf constructor\n> > -    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n> > -      .set(\"spark.streaming.extraListeners\",\n> > -        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n> > -        classOf[ReceiverInfoCollector].getName)\n> > -    val scc = new StreamingContext(conf, Seconds(1))\n> \n> This can lead to a leak in the StreamingContext and underlying\n> SparkContext. Please put the whole in\n> \n> var ssc: StremaingContext = null\n> try {\n>   ssc = new StreamingContext...\n> \n> } finally {\n>    if (ssc != null) {\n>      ssc.stop()\n>    }\n> }\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/apache/spark/pull/6380/files#r34868938.\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-18T07:08:49Z",
    "diffHunk": "@@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    // Test for success with zero-argument constructor and sparkConf constructor\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\",\n+        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))",
    "line": 32
  }, {
    "author": {
      "login": "tdas"
    },
    "body": "Yes, the StreamingContext is being created, which means an underlying SparkContext is being created, which is not being cleaned up.\n",
    "commit": "fa8c752d6a78d1c54717819f37ffe2a0f0ec48a5",
    "createdAt": "2015-07-20T17:37:25Z",
    "diffHunk": "@@ -140,6 +141,37 @@ class StreamingListenerSuite extends TestSuiteBase with Matchers {\n     }\n     true\n   }\n+\n+  test(\"registering listeners via spark.streaming.extraListeners\") {\n+    // Test for success with zero-argument constructor and sparkConf constructor\n+    val conf = new SparkConf().setMaster(\"local\").setAppName(\"test\")\n+      .set(\"spark.streaming.extraListeners\",\n+        classOf[StreamingListenerThatAcceptsSparkConf].getName + \",\" +\n+        classOf[ReceiverInfoCollector].getName)\n+    val scc = new StreamingContext(conf, Seconds(1))",
    "line": 32
  }],
  "prId": 6380
}]