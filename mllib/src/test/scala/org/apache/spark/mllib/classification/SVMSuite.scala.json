[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Please put a `,` after `B`.\n",
    "commit": "770f55d5c9f8d95b5be1454a887086128db0d90c",
    "createdAt": "2014-05-13T16:53:52Z",
    "diffHunk": "@@ -69,6 +69,43 @@ class SVMSuite extends FunSuite with LocalSparkContext {\n     assert(numOffPredictions < input.length / 5)\n   }\n \n+  test(\"SVM with threshold\") {\n+    val nPoints = 10000\n+\n+    // NOTE: Intercept should be small for generating equal 0s and 1s\n+    val A = 0.01\n+    val B = -1.5\n+    val C = 1.0\n+\n+    val testData = SVMSuite.generateSVMInput(A, Array[Double](B,C), nPoints, 42)"
  }],
  "prId": 725
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Ditto.\n",
    "commit": "770f55d5c9f8d95b5be1454a887086128db0d90c",
    "createdAt": "2014-05-13T16:55:35Z",
    "diffHunk": "@@ -69,6 +69,43 @@ class SVMSuite extends FunSuite with LocalSparkContext {\n     assert(numOffPredictions < input.length / 5)\n   }\n \n+  test(\"SVM with threshold\") {\n+    val nPoints = 10000\n+\n+    // NOTE: Intercept should be small for generating equal 0s and 1s\n+    val A = 0.01\n+    val B = -1.5\n+    val C = 1.0\n+\n+    val testData = SVMSuite.generateSVMInput(A, Array[Double](B,C), nPoints, 42)\n+\n+    val testRDD = sc.parallelize(testData, 2)\n+    testRDD.cache()\n+\n+    val svm = new SVMWithSGD().setIntercept(true)\n+    svm.optimizer.setStepSize(1.0).setRegParam(1.0).setNumIterations(100)\n+\n+    val model = svm.run(testRDD)\n+\n+    val validationData = SVMSuite.generateSVMInput(A, Array[Double](B,C), nPoints, 17)"
  }],
  "prId": 725
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Change to `count(_ == 0.0)`, which is more common in Spark.\n",
    "commit": "770f55d5c9f8d95b5be1454a887086128db0d90c",
    "createdAt": "2014-05-13T16:58:00Z",
    "diffHunk": "@@ -69,6 +69,43 @@ class SVMSuite extends FunSuite with LocalSparkContext {\n     assert(numOffPredictions < input.length / 5)\n   }\n \n+  test(\"SVM with threshold\") {\n+    val nPoints = 10000\n+\n+    // NOTE: Intercept should be small for generating equal 0s and 1s\n+    val A = 0.01\n+    val B = -1.5\n+    val C = 1.0\n+\n+    val testData = SVMSuite.generateSVMInput(A, Array[Double](B,C), nPoints, 42)\n+\n+    val testRDD = sc.parallelize(testData, 2)\n+    testRDD.cache()\n+\n+    val svm = new SVMWithSGD().setIntercept(true)\n+    svm.optimizer.setStepSize(1.0).setRegParam(1.0).setNumIterations(100)\n+\n+    val model = svm.run(testRDD)\n+\n+    val validationData = SVMSuite.generateSVMInput(A, Array[Double](B,C), nPoints, 17)\n+    val validationRDD  = sc.parallelize(validationData, 2)\n+\n+    // Test prediction on RDD.\n+\n+    var predictions = model.predict(validationRDD.map(_.features)).collect()\n+    assert(predictions.count {_ == 0.0 } != predictions.length)"
  }],
  "prId": 725
}]