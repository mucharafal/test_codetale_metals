[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It was `SquaredError` before.\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T00:36:51Z",
    "diffHunk": "@@ -23,104 +23,95 @@ import org.apache.spark.mllib.regression.LabeledPoint\n import org.apache.spark.mllib.tree.configuration.Algo._\n import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n import org.apache.spark.mllib.tree.impurity.Variance\n-import org.apache.spark.mllib.tree.loss.{SquaredError, LogLoss}\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, SquaredError, LogLoss}\n \n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n /**\n- * Test suite for [[GradientBoosting]].\n+ * Test suite for [[GradientBoostedTrees]].\n  */\n-class GradientBoostingSuite extends FunSuite with MLlibTestSparkContext {\n+class GradientBoostedTreesSuite extends FunSuite with MLlibTestSparkContext {\n \n   test(\"Regression with continuous features: SquaredError\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n-\n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,\n-          learningRate, 1, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, SquaredError, numIterations, learningRate)\n \n-        val gbt = GradientBoosting.trainRegressor(rdd, boostingStrategy)\n-        assert(gbt.weakHypotheses.size === numIterations)\n-        val gbtTree = gbt.weakHypotheses(0)\n+        val gbt = GradientBoostedTrees.train(rdd, boostingStrategy)\n \n+        assert(gbt.trees.size === numIterations)\n         EnsembleTestHelper.validateRegressor(gbt, arr, 0.03)\n \n+        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n+        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+\n         // Make sure trees are the same.\n-        assert(gbtTree.toString == dt.toString)\n+        assert(gbt.trees.head.toString == dt.toString)\n     }\n   }\n \n   test(\"Regression with continuous features: Absolute Error\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, AbsoluteError, numIterations, learningRate)\n \n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,",
    "line": 74
  }, {
    "author": {
      "login": "manishamde"
    },
    "body": "Thanks for fixing this. I am taking a look at it.\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T02:15:22Z",
    "diffHunk": "@@ -23,104 +23,95 @@ import org.apache.spark.mllib.regression.LabeledPoint\n import org.apache.spark.mllib.tree.configuration.Algo._\n import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n import org.apache.spark.mllib.tree.impurity.Variance\n-import org.apache.spark.mllib.tree.loss.{SquaredError, LogLoss}\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, SquaredError, LogLoss}\n \n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n /**\n- * Test suite for [[GradientBoosting]].\n+ * Test suite for [[GradientBoostedTrees]].\n  */\n-class GradientBoostingSuite extends FunSuite with MLlibTestSparkContext {\n+class GradientBoostedTreesSuite extends FunSuite with MLlibTestSparkContext {\n \n   test(\"Regression with continuous features: SquaredError\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n-\n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,\n-          learningRate, 1, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, SquaredError, numIterations, learningRate)\n \n-        val gbt = GradientBoosting.trainRegressor(rdd, boostingStrategy)\n-        assert(gbt.weakHypotheses.size === numIterations)\n-        val gbtTree = gbt.weakHypotheses(0)\n+        val gbt = GradientBoostedTrees.train(rdd, boostingStrategy)\n \n+        assert(gbt.trees.size === numIterations)\n         EnsembleTestHelper.validateRegressor(gbt, arr, 0.03)\n \n+        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n+        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+\n         // Make sure trees are the same.\n-        assert(gbtTree.toString == dt.toString)\n+        assert(gbt.trees.head.toString == dt.toString)\n     }\n   }\n \n   test(\"Regression with continuous features: Absolute Error\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, AbsoluteError, numIterations, learningRate)\n \n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,",
    "line": 74
  }, {
    "author": {
      "login": "manishamde"
    },
    "body": "Here are my findings. I added two more test cases with numIterations = 100.\n\n```\nnumIterations = 10, learningRate = 1.0, subsamplingRate = 1.0\nmetric = 0.8400000000000005\nnumIterations = 100, learningRate = 1.0, subsamplingRate = 1.0\nmetric = 0.5344090056285183\nnumIterations = 10, learningRate = 0.1, subsamplingRate = 1.0\nmetric = 0.08399999999999984\nnumIterations = 10, learningRate = 1.0, subsamplingRate = 0.75\nmetric = 0.8102205882352937\nnumIterations = 100, learningRate = 1.0, subsamplingRate = 0.75\nmetric = 0.565608647936787\nnumIterations = 10, learningRate = 0.1, subsamplingRate = 0.75\nmetric = 0.11179411764705861\n```\n\nA learning rate of 1 doesn't work very well especially with low number of iterations. Our default learning rate is 0.1 which should be fine.\n\nSuggestion: We remove the learningRate = 1 option from the absolute error test. I can do more testing to check what settings work well for our GBT model and include it as a part of the documentation. I will also compare with scikit-learn to see how much additional loss do we get from an ideal implementation during the documentation phase.\n\ncc: @jkbradley\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T02:46:22Z",
    "diffHunk": "@@ -23,104 +23,95 @@ import org.apache.spark.mllib.regression.LabeledPoint\n import org.apache.spark.mllib.tree.configuration.Algo._\n import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n import org.apache.spark.mllib.tree.impurity.Variance\n-import org.apache.spark.mllib.tree.loss.{SquaredError, LogLoss}\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, SquaredError, LogLoss}\n \n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n /**\n- * Test suite for [[GradientBoosting]].\n+ * Test suite for [[GradientBoostedTrees]].\n  */\n-class GradientBoostingSuite extends FunSuite with MLlibTestSparkContext {\n+class GradientBoostedTreesSuite extends FunSuite with MLlibTestSparkContext {\n \n   test(\"Regression with continuous features: SquaredError\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n-\n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,\n-          learningRate, 1, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, SquaredError, numIterations, learningRate)\n \n-        val gbt = GradientBoosting.trainRegressor(rdd, boostingStrategy)\n-        assert(gbt.weakHypotheses.size === numIterations)\n-        val gbtTree = gbt.weakHypotheses(0)\n+        val gbt = GradientBoostedTrees.train(rdd, boostingStrategy)\n \n+        assert(gbt.trees.size === numIterations)\n         EnsembleTestHelper.validateRegressor(gbt, arr, 0.03)\n \n+        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n+        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+\n         // Make sure trees are the same.\n-        assert(gbtTree.toString == dt.toString)\n+        assert(gbt.trees.head.toString == dt.toString)\n     }\n   }\n \n   test(\"Regression with continuous features: Absolute Error\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, AbsoluteError, numIterations, learningRate)\n \n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,",
    "line": 74
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "@manishamde Thanks for checking this test! Let's fix it in a separate PR. We are going to cut a release candidate and I hope we can update the API before that. Let me know when you finish a pass, I will update the PR following your suggestions.\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T04:44:22Z",
    "diffHunk": "@@ -23,104 +23,95 @@ import org.apache.spark.mllib.regression.LabeledPoint\n import org.apache.spark.mllib.tree.configuration.Algo._\n import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n import org.apache.spark.mllib.tree.impurity.Variance\n-import org.apache.spark.mllib.tree.loss.{SquaredError, LogLoss}\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, SquaredError, LogLoss}\n \n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n /**\n- * Test suite for [[GradientBoosting]].\n+ * Test suite for [[GradientBoostedTrees]].\n  */\n-class GradientBoostingSuite extends FunSuite with MLlibTestSparkContext {\n+class GradientBoostedTreesSuite extends FunSuite with MLlibTestSparkContext {\n \n   test(\"Regression with continuous features: SquaredError\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n-\n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,\n-          learningRate, 1, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, SquaredError, numIterations, learningRate)\n \n-        val gbt = GradientBoosting.trainRegressor(rdd, boostingStrategy)\n-        assert(gbt.weakHypotheses.size === numIterations)\n-        val gbtTree = gbt.weakHypotheses(0)\n+        val gbt = GradientBoostedTrees.train(rdd, boostingStrategy)\n \n+        assert(gbt.trees.size === numIterations)\n         EnsembleTestHelper.validateRegressor(gbt, arr, 0.03)\n \n+        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n+        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+\n         // Make sure trees are the same.\n-        assert(gbtTree.toString == dt.toString)\n+        assert(gbt.trees.head.toString == dt.toString)\n     }\n   }\n \n   test(\"Regression with continuous features: Absolute Error\") {\n-    GradientBoostingSuite.testCombinations.foreach {\n+    GradientBoostedTreesSuite.testCombinations.foreach {\n       case (numIterations, learningRate, subsamplingRate) =>\n         val arr = EnsembleTestHelper.generateOrderedLabeledPoints(numFeatures = 10, 100)\n-        val rdd = sc.parallelize(arr)\n-        val categoricalFeaturesInfo = Map.empty[Int, Int]\n+        val rdd = sc.parallelize(arr, 2)\n \n-        val remappedInput = rdd.map(x => new LabeledPoint((x.label * 2) - 1, x.features))\n         val treeStrategy = new Strategy(algo = Regression, impurity = Variance, maxDepth = 2,\n-          numClassesForClassification = 2, categoricalFeaturesInfo = categoricalFeaturesInfo,\n-          subsamplingRate = subsamplingRate)\n-\n-        val dt = DecisionTree.train(remappedInput, treeStrategy)\n+          categoricalFeaturesInfo = Map.empty, subsamplingRate = subsamplingRate)\n+        val boostingStrategy =\n+          new BoostingStrategy(treeStrategy, AbsoluteError, numIterations, learningRate)\n \n-        val boostingStrategy = new BoostingStrategy(Regression, numIterations, SquaredError,",
    "line": 74
  }],
  "prId": 3374
}]