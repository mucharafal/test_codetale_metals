[{
  "comments": [{
    "author": {
      "login": "selvinsource"
    },
    "body": "This test on the right exporter could be moved to PMMLModelExportFactorySuite where I kept all the exporter checks for the factory.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-22T10:42:03Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext\n+with PrivateMethodTester {\n+\n+  test(\"PMML export should work as expected for DecisionTree model with regressor\") {\n+\n+    // instantiate a MLLib DecisionTreeModel with Regression and with 3 nodes with continuous\n+    // feature type\n+    val mlLeftNode = new Node(2, new Predict(0.5, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode = new Node(3, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(100, 10.00, FeatureType.Continuous, Nil)\n+    val mlTopNode = new Node(1, new Predict(0.0, 0.1), 0.2, false,\n+      Some(split), Some(mlLeftNode), Some(mlRightNode), None)\n+\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Regression)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])",
    "line": 48
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "I am not sure of the position of with statement. @mengxr Should we leave 2 or 4 spaces in this scenario?\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:41:48Z",
    "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove `()` in the end.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:42:39Z",
    "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext\n+with PrivateMethodTester {\n+\n+  test(\"PMML export should work as expected for DecisionTree model with regressor\") {\n+\n+    // instantiate a MLLib DecisionTreeModel with Regression and with 3 nodes with continuous\n+    // feature type\n+    val mlLeftNode = new Node(2, new Predict(0.5, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode = new Node(3, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(100, 10.00, FeatureType.Continuous, Nil)\n+    val mlTopNode = new Node(1, new Predict(0.0, 0.1), 0.2, false,\n+      Some(split), Some(mlLeftNode), Some(mlRightNode), None)\n+\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Regression)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.REGRESSION)\n+\n+    // validate the root PMML node is populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+    // validate the root node predicate is populated as expected\n+    val predicate = pmmlRootNode.getPredicate()"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "too many empty lines.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:43:26Z",
    "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext\n+with PrivateMethodTester {\n+\n+  test(\"PMML export should work as expected for DecisionTree model with regressor\") {\n+\n+    // instantiate a MLLib DecisionTreeModel with Regression and with 3 nodes with continuous\n+    // feature type\n+    val mlLeftNode = new Node(2, new Predict(0.5, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode = new Node(3, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(100, 10.00, FeatureType.Continuous, Nil)\n+    val mlTopNode = new Node(1, new Predict(0.0, 0.1), 0.2, false,\n+      Some(split), Some(mlLeftNode), Some(mlRightNode), None)\n+\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Regression)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.REGRESSION)\n+\n+    // validate the root PMML node is populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+    // validate the root node predicate is populated as expected\n+    val predicate = pmmlRootNode.getPredicate()\n+    assert(predicate != null)\n+    assert(predicate.isInstanceOf[True])\n+\n+    // validate the left node is populated as expected\n+    val pmmlLeftNode = pmmlRootNode.getNodes.get(0)\n+    assert(pmmlLeftNode != null)\n+    assert(!pmmlLeftNode.hasNodes)\n+    assert(pmmlLeftNode.getId === \"2\")\n+    assert(pmmlLeftNode.getScore == \"0.5\")\n+    val predicate1 = pmmlLeftNode.getPredicate\n+    assert(predicate1 != null)\n+    assert(predicate1.isInstanceOf[SimplePredicate])\n+    assert(predicate1.asInstanceOf[SimplePredicate].getField.getValue === \"field_100\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getOperator == SimplePredicate.Operator\n+          .LESS_OR_EQUAL)\n+\n+    // validate the right node is populated as expected\n+    val pmmlRightNode = pmmlRootNode.getNodes.get(1)\n+    assert(pmmlRightNode != null)\n+    assert(!pmmlRightNode.hasNodes)\n+    assert(pmmlRightNode.getId === \"3\")\n+    assert(pmmlRightNode.getScore == \"1.0\")\n+\n+    val predicate2 = pmmlRightNode.getPredicate\n+    assert(predicate2 != null)\n+    assert(predicate2.isInstanceOf[SimplePredicate])\n+    assert(predicate2.asInstanceOf[SimplePredicate].getField.getValue === \"field_100\")\n+    assert(predicate2.asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicate2.asInstanceOf[SimplePredicate].getOperator == SimplePredicate.Operator\n+      .GREATER_THAN)\n+\n+    // validate the mining schema is populated as expected\n+    assert(pmmlModelForDT.getMiningSchema != null)\n+    val miningSchema = pmmlModelForDT.getMiningSchema\n+    assert(miningSchema.getMiningFields != null && miningSchema.getMiningFields.size() == 2)\n+    val miningFields = miningSchema.getMiningFields\n+    assert(miningFields.get(0).getName.getValue == \"field_100\")\n+    assert(miningFields.get(1).getName.getValue == \"target\")\n+\n+    // validate the data dictionay is populated as expected\n+    val dataDictionary = pmmlWrapperForDT.getDataDictionary\n+    assert(dataDictionary != null)\n+    val dataFields = dataDictionary.getDataFields\n+    assert(dataFields != null && dataFields.size() == 2)\n+    assert(dataFields.get(0).getName.getValue == \"field_100\")\n+    assert(dataFields.get(0).getOpType == OpType.CONTINUOUS)\n+    assert(dataFields.get(1).getName.getValue == \"target\")\n+    assert(dataFields.get(1).getOpType == OpType.CONTINUOUS)\n+  }\n+\n+  test(\"PMML export should work as expected for DecisionTree model with classifier\") {\n+\n+    // instantiate MLLIb DecisionTreeModel with Classification algo ,5 nodes, 2 levels\n+    val mlLeftNode_L2 = new Node(4, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode_L2 = new Node(5, new Predict(2.0, 0.5), 0.2, true, None, None, None, None)\n+    val splitForL2 = new Split(100, 10.00, FeatureType.Categorical, List(1, 4))\n+    val mlLeftNode_L1 = new Node(2, new Predict(3.0, 0.5), 0.2, false,\n+      Some(splitForL2), Some(mlLeftNode_L2), Some(mlRightNode_L2), None)\n+    val mlRightNode_L1 = new Node(3, new Predict(4.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(200, 10.00, FeatureType.Categorical, List(10, 20))\n+    val mlTopNode = new Node(1, new Predict(5.0, 0.1), 0.2, false, Some(split),\n+      Some(mlLeftNode_L1), Some(mlRightNode_L1), None)\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Classification)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.CLASSIFICATION)\n+\n+    // validate the pmml root node fields are populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+\n+    // validate the pmml root node predicate is a true predicate since its root node\n+\n+    val predicate = pmmlRootNode.getPredicate()\n+    assert(predicate != null)\n+    assert(predicate.isInstanceOf[True])\n+\n+    // validate level 1 left node is populated properly\n+    val pmmlLeftNode_L1 = pmmlRootNode.getNodes.get(0)\n+    assert(pmmlLeftNode_L1 != null)\n+    assert(pmmlLeftNode_L1.hasNodes)\n+    assert(pmmlLeftNode_L1.getId === \"2\")\n+    assert(pmmlLeftNode_L1.getScore == \"3.0\")\n+    // left node to the root node should have compound predicate, since its condition is on multiple\n+    // categories\n+    val predicateL1 = pmmlLeftNode_L1.getPredicate\n+    assert(predicateL1 != null)\n+    assert(predicateL1.isInstanceOf[CompoundPredicate])\n+    val cPredicate1 = predicateL1.asInstanceOf[CompoundPredicate]\n+    assert(cPredicate1.getBooleanOperator == BooleanOperator.OR)\n+    assert(cPredicate1.getPredicates != null && cPredicate1.getPredicates.size() == 2)\n+    val predicatesList1 = cPredicate1.getPredicates\n+    assert(predicatesList1.get(0).isInstanceOf[SimplePredicate])\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getField.getValue === \"field_200\")\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getOperator == SimplePredicate\n+      .Operator.EQUAL)\n+\n+    assert(predicatesList1.get(1).isInstanceOf[SimplePredicate])\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getField.getValue === \"field_200\")\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getValue === \"20.0\")\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getOperator == SimplePredicate\n+      .Operator.EQUAL)\n+\n+    // validate level 1 right node is populated properly\n+    val pmmlRightNode_L1 = pmmlRootNode.getNodes.get(1)\n+    assert(pmmlRightNode_L1 != null)\n+    assert(!pmmlRightNode_L1.hasNodes)\n+    assert(pmmlRightNode_L1.getId === \"3\")\n+    assert(pmmlRightNode_L1.getScore == \"4.0\")\n+    // right node at level 1 should have True Predicate since the left node is the list of\n+    // categories predicate\n+    val predicateR1 = pmmlRightNode_L1.getPredicate\n+    assert(predicateR1 != null)\n+    assert(predicateR1.isInstanceOf[True])\n+",
    "line": 202
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove `()` in the end\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:43:50Z",
    "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext\n+with PrivateMethodTester {\n+\n+  test(\"PMML export should work as expected for DecisionTree model with regressor\") {\n+\n+    // instantiate a MLLib DecisionTreeModel with Regression and with 3 nodes with continuous\n+    // feature type\n+    val mlLeftNode = new Node(2, new Predict(0.5, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode = new Node(3, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(100, 10.00, FeatureType.Continuous, Nil)\n+    val mlTopNode = new Node(1, new Predict(0.0, 0.1), 0.2, false,\n+      Some(split), Some(mlLeftNode), Some(mlRightNode), None)\n+\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Regression)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.REGRESSION)\n+\n+    // validate the root PMML node is populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+    // validate the root node predicate is populated as expected\n+    val predicate = pmmlRootNode.getPredicate()\n+    assert(predicate != null)\n+    assert(predicate.isInstanceOf[True])\n+\n+    // validate the left node is populated as expected\n+    val pmmlLeftNode = pmmlRootNode.getNodes.get(0)\n+    assert(pmmlLeftNode != null)\n+    assert(!pmmlLeftNode.hasNodes)\n+    assert(pmmlLeftNode.getId === \"2\")\n+    assert(pmmlLeftNode.getScore == \"0.5\")\n+    val predicate1 = pmmlLeftNode.getPredicate\n+    assert(predicate1 != null)\n+    assert(predicate1.isInstanceOf[SimplePredicate])\n+    assert(predicate1.asInstanceOf[SimplePredicate].getField.getValue === \"field_100\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getOperator == SimplePredicate.Operator\n+          .LESS_OR_EQUAL)\n+\n+    // validate the right node is populated as expected\n+    val pmmlRightNode = pmmlRootNode.getNodes.get(1)\n+    assert(pmmlRightNode != null)\n+    assert(!pmmlRightNode.hasNodes)\n+    assert(pmmlRightNode.getId === \"3\")\n+    assert(pmmlRightNode.getScore == \"1.0\")\n+\n+    val predicate2 = pmmlRightNode.getPredicate\n+    assert(predicate2 != null)\n+    assert(predicate2.isInstanceOf[SimplePredicate])\n+    assert(predicate2.asInstanceOf[SimplePredicate].getField.getValue === \"field_100\")\n+    assert(predicate2.asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicate2.asInstanceOf[SimplePredicate].getOperator == SimplePredicate.Operator\n+      .GREATER_THAN)\n+\n+    // validate the mining schema is populated as expected\n+    assert(pmmlModelForDT.getMiningSchema != null)\n+    val miningSchema = pmmlModelForDT.getMiningSchema\n+    assert(miningSchema.getMiningFields != null && miningSchema.getMiningFields.size() == 2)\n+    val miningFields = miningSchema.getMiningFields\n+    assert(miningFields.get(0).getName.getValue == \"field_100\")\n+    assert(miningFields.get(1).getName.getValue == \"target\")\n+\n+    // validate the data dictionay is populated as expected\n+    val dataDictionary = pmmlWrapperForDT.getDataDictionary\n+    assert(dataDictionary != null)\n+    val dataFields = dataDictionary.getDataFields\n+    assert(dataFields != null && dataFields.size() == 2)\n+    assert(dataFields.get(0).getName.getValue == \"field_100\")\n+    assert(dataFields.get(0).getOpType == OpType.CONTINUOUS)\n+    assert(dataFields.get(1).getName.getValue == \"target\")\n+    assert(dataFields.get(1).getOpType == OpType.CONTINUOUS)\n+  }\n+\n+  test(\"PMML export should work as expected for DecisionTree model with classifier\") {\n+\n+    // instantiate MLLIb DecisionTreeModel with Classification algo ,5 nodes, 2 levels\n+    val mlLeftNode_L2 = new Node(4, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode_L2 = new Node(5, new Predict(2.0, 0.5), 0.2, true, None, None, None, None)\n+    val splitForL2 = new Split(100, 10.00, FeatureType.Categorical, List(1, 4))\n+    val mlLeftNode_L1 = new Node(2, new Predict(3.0, 0.5), 0.2, false,\n+      Some(splitForL2), Some(mlLeftNode_L2), Some(mlRightNode_L2), None)\n+    val mlRightNode_L1 = new Node(3, new Predict(4.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(200, 10.00, FeatureType.Categorical, List(10, 20))\n+    val mlTopNode = new Node(1, new Predict(5.0, 0.1), 0.2, false, Some(split),\n+      Some(mlLeftNode_L1), Some(mlRightNode_L1), None)\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Classification)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.CLASSIFICATION)\n+\n+    // validate the pmml root node fields are populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+\n+    // validate the pmml root node predicate is a true predicate since its root node\n+\n+    val predicate = pmmlRootNode.getPredicate()\n+    assert(predicate != null)\n+    assert(predicate.isInstanceOf[True])\n+\n+    // validate level 1 left node is populated properly\n+    val pmmlLeftNode_L1 = pmmlRootNode.getNodes.get(0)\n+    assert(pmmlLeftNode_L1 != null)\n+    assert(pmmlLeftNode_L1.hasNodes)\n+    assert(pmmlLeftNode_L1.getId === \"2\")\n+    assert(pmmlLeftNode_L1.getScore == \"3.0\")\n+    // left node to the root node should have compound predicate, since its condition is on multiple\n+    // categories\n+    val predicateL1 = pmmlLeftNode_L1.getPredicate\n+    assert(predicateL1 != null)\n+    assert(predicateL1.isInstanceOf[CompoundPredicate])\n+    val cPredicate1 = predicateL1.asInstanceOf[CompoundPredicate]\n+    assert(cPredicate1.getBooleanOperator == BooleanOperator.OR)\n+    assert(cPredicate1.getPredicates != null && cPredicate1.getPredicates.size() == 2)\n+    val predicatesList1 = cPredicate1.getPredicates\n+    assert(predicatesList1.get(0).isInstanceOf[SimplePredicate])\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getField.getValue === \"field_200\")\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicatesList1.get(0).asInstanceOf[SimplePredicate].getOperator == SimplePredicate\n+      .Operator.EQUAL)\n+\n+    assert(predicatesList1.get(1).isInstanceOf[SimplePredicate])\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getField.getValue === \"field_200\")\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getValue === \"20.0\")\n+    assert(predicatesList1.get(1).asInstanceOf[SimplePredicate].getOperator == SimplePredicate\n+      .Operator.EQUAL)\n+\n+    // validate level 1 right node is populated properly\n+    val pmmlRightNode_L1 = pmmlRootNode.getNodes.get(1)\n+    assert(pmmlRightNode_L1 != null)\n+    assert(!pmmlRightNode_L1.hasNodes)\n+    assert(pmmlRightNode_L1.getId === \"3\")\n+    assert(pmmlRightNode_L1.getScore == \"4.0\")\n+    // right node at level 1 should have True Predicate since the left node is the list of\n+    // categories predicate\n+    val predicateR1 = pmmlRightNode_L1.getPredicate\n+    assert(predicateR1 != null)\n+    assert(predicateR1.isInstanceOf[True])\n+\n+\n+\n+\n+    // validate level 2 left node is populated as expected\n+    val pmmlLeftNode_L2 = pmmlLeftNode_L1.getNodes.get(0)\n+    assert(pmmlLeftNode_L2 != null)\n+    assert(!pmmlLeftNode_L2.hasNodes)\n+    assert(pmmlLeftNode_L2.getId === \"4\")\n+    assert(pmmlLeftNode_L2.getScore == \"1.0\")\n+    // validate predicate for level 2 split is populated as expected\n+    val predicateL2 = pmmlLeftNode_L2.getPredicate()"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "the indent should be 2 spaces.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:51:07Z",
    "diffHunk": "@@ -0,0 +1,431 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml._\n+import org.dmg.pmml.CompoundPredicate.BooleanOperator\n+import org.scalatest.PrivateMethodTester\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node, Predict, Split}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+class DecisionTreePMMLModelExportSuite extends SparkFunSuite\n+with MLlibTestSparkContext\n+with PrivateMethodTester {\n+\n+  test(\"PMML export should work as expected for DecisionTree model with regressor\") {\n+\n+    // instantiate a MLLib DecisionTreeModel with Regression and with 3 nodes with continuous\n+    // feature type\n+    val mlLeftNode = new Node(2, new Predict(0.5, 0.5), 0.2, true, None, None, None, None)\n+    val mlRightNode = new Node(3, new Predict(1.0, 0.5), 0.2, true, None, None, None, None)\n+    val split = new Split(100, 10.00, FeatureType.Continuous, Nil)\n+    val mlTopNode = new Node(1, new Predict(0.0, 0.1), 0.2, false,\n+      Some(split), Some(mlLeftNode), Some(mlRightNode), None)\n+\n+    val decisionTreeModel = new DecisionTreeModel(mlTopNode, Algo.Regression)\n+\n+    // get the pmml exporter for the DT and verify its the right exporter\n+    val pmmlExporterForDT = PMMLModelExportFactory.createPMMLModelExport(decisionTreeModel)\n+    assert(pmmlExporterForDT.isInstanceOf[DecisionTreePMMLModelExport])\n+\n+    // get the pmmlwrapper object for DT and verify the inner model is of type TreeModel\n+    // and basic fields are populated as expected\n+    val pmmlWrapperForDT = pmmlExporterForDT.getPmml\n+    assert(pmmlWrapperForDT.getHeader.getDescription == \"decision tree\")\n+    assert(!pmmlWrapperForDT.getModels.isEmpty)\n+    assert(pmmlWrapperForDT.getModels.size() == 1)\n+    val pmmlModelForDT = pmmlWrapperForDT.getModels.get(0)\n+    assert(pmmlModelForDT.isInstanceOf[TreeModel])\n+\n+    // validate the inner tree model fields are populated as expected\n+    val pmmlTreeModel = pmmlModelForDT.asInstanceOf[TreeModel]\n+    assert(pmmlTreeModel.getFunctionName == MiningFunctionType.REGRESSION)\n+\n+    // validate the root PMML node is populated as expected\n+    val pmmlRootNode = pmmlTreeModel.getNode\n+    assert(pmmlRootNode != null)\n+    assert(pmmlRootNode.getNodes != null && pmmlRootNode.getNodes.size() == 2)\n+    assert(pmmlRootNode.getId === \"1\")\n+    // validate the root node predicate is populated as expected\n+    val predicate = pmmlRootNode.getPredicate()\n+    assert(predicate != null)\n+    assert(predicate.isInstanceOf[True])\n+\n+    // validate the left node is populated as expected\n+    val pmmlLeftNode = pmmlRootNode.getNodes.get(0)\n+    assert(pmmlLeftNode != null)\n+    assert(!pmmlLeftNode.hasNodes)\n+    assert(pmmlLeftNode.getId === \"2\")\n+    assert(pmmlLeftNode.getScore == \"0.5\")\n+    val predicate1 = pmmlLeftNode.getPredicate\n+    assert(predicate1 != null)\n+    assert(predicate1.isInstanceOf[SimplePredicate])\n+    assert(predicate1.asInstanceOf[SimplePredicate].getField.getValue === \"field_100\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getValue === \"10.0\")\n+    assert(predicate1.asInstanceOf[SimplePredicate].getOperator == SimplePredicate.Operator\n+          .LESS_OR_EQUAL)"
  }],
  "prId": 7842
}]