[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "need a comment about the purpose of the tests here\n",
    "commit": "f19fc02418b7790103406bfb8f1c0e982abe17f2",
    "createdAt": "2014-08-12T07:36:15Z",
    "diffHunk": "@@ -185,6 +185,58 @@ class LogisticRegressionSuite extends FunSuite with LocalSparkContext with Match\n     // Test prediction on Array.\n     validatePrediction(validationData.map(row => model.predict(row.features)), validationData)\n   }\n+\n+  test(\"numerical stability of scaling features using logistic regression with LBFGS\") {\n+    /**\n+     * If we rescale the features, the condition number will be changed so the convergence rate\n+     * and the solution will not equal to the original solution multiple by the scaling factor\n+     * which it should be.\n+     *\n+     * However, since in the LogisticRegressionWithLBFGS, we standardize the training dataset first,\n+     * no matter how we multiple a scaling factor into the dataset, the convergence rate should be\n+     * the same, and the solution should equal to the original solution multiple by the scaling\n+     * factor.\n+     */\n+\n+    val nPoints = 10000\n+    val A = 2.0\n+    val B = -1.5\n+\n+    val testData = LogisticRegressionSuite.generateLogisticInput(A, B, nPoints, 42)\n+\n+    val initialWeights = Vectors.dense(0.0)\n+\n+    val testRDD1 = sc.parallelize(testData, 2)\n+\n+    val testRDD2 = sc.parallelize(\n+      testData.map(x => LabeledPoint(x.label, Vectors.fromBreeze(x.features.toBreeze * 1.0E3))), 2)\n+\n+    val testRDD3 = sc.parallelize(\n+      testData.map(x => LabeledPoint(x.label, Vectors.fromBreeze(x.features.toBreeze * 1.0E6))), 2)\n+\n+    testRDD1.cache()\n+    testRDD2.cache()\n+    testRDD3.cache()\n+\n+    val lrA = new LogisticRegressionWithLBFGS().setIntercept(true)\n+    val lrB = new LogisticRegressionWithLBFGS().setIntercept(true).setFeatureScaling(false)\n+\n+    val modelA1 = lrA.run(testRDD1, initialWeights)\n+    val modelA2 = lrA.run(testRDD2, initialWeights)\n+    val modelA3 = lrA.run(testRDD3, initialWeights)\n+\n+    val modelB1 = lrB.run(testRDD1, initialWeights)\n+    val modelB2 = lrB.run(testRDD2, initialWeights)\n+    val modelB3 = lrB.run(testRDD3, initialWeights)\n+\n+    // Test the weights\n+    assert(modelA1.weights(0) ~== modelA2.weights(0) * 1.0E3 absTol 0.01)\n+    assert(modelA1.weights(0) ~== modelA3.weights(0) * 1.0E6 absTol 0.01)\n+\n+    assert(modelB1.weights(0) !~== modelB2.weights(0) * 1.0E3 absTol 0.1)"
  }],
  "prId": 1897
}]