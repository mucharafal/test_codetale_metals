[{
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "use `1E-7` ?",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-24T08:27:53Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T14:58:42Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "Use operator `A ~== B absTol delta` like other tests.",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-24T08:29:14Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T15:11:58Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "There're many repeated expressions here such as `(2 * w1 + 1 * w2 + 1 * w1) / tw`, could you store them in variables first ?",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-24T08:31:46Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n+    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n+    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n+    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n+    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n+    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n+    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n+    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n+    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+\n+    assert(math.abs(metrics.accuracy -\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n+    assert(math.abs(metrics.weightedTruePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * tpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * tpRate1 +\n+        (1 * w2 / tw) * tpRate2)) < delta)\n+    assert(math.abs(metrics.weightedFalsePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * fpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * fpRate1 +\n+        (1 * w2 / tw) * fpRate2)) < delta)\n+    assert(math.abs(metrics.weightedPrecision -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * precision0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * precision1 +\n+        (1 * w2 / tw) * precision2)) < delta)\n+    assert(math.abs(metrics.weightedRecall -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * recall0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * recall1 +\n+        (1 * w2 / tw) * recall2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f1measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f1measure1 +\n+        (1 * w2 / tw) * f1measure2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure(2.0) -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f2measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f2measure1 +\n+        (1 * w2 / tw) * f2measure2)) < delta)"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "sure, I was trying to follow the format of the other existing test, made the change in both test cases",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T15:23:31Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n+    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n+    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n+    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n+    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n+    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n+    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n+    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n+    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+\n+    assert(math.abs(metrics.accuracy -\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n+    assert(math.abs(metrics.weightedTruePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * tpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * tpRate1 +\n+        (1 * w2 / tw) * tpRate2)) < delta)\n+    assert(math.abs(metrics.weightedFalsePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * fpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * fpRate1 +\n+        (1 * w2 / tw) * fpRate2)) < delta)\n+    assert(math.abs(metrics.weightedPrecision -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * precision0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * precision1 +\n+        (1 * w2 / tw) * precision2)) < delta)\n+    assert(math.abs(metrics.weightedRecall -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * recall0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * recall1 +\n+        (1 * w2 / tw) * recall2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f1measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f1measure1 +\n+        (1 * w2 / tw) * f1measure2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure(2.0) -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f2measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f2measure1 +\n+        (1 * w2 / tw) * f2measure2)) < delta)"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "use `assert(metrics.labels === labels)` like other tests.",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-24T08:33:39Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n+    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n+    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n+    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n+    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n+    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n+    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n+    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n+    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+\n+    assert(math.abs(metrics.accuracy -\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n+    assert(math.abs(metrics.weightedTruePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * tpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * tpRate1 +\n+        (1 * w2 / tw) * tpRate2)) < delta)\n+    assert(math.abs(metrics.weightedFalsePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * fpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * fpRate1 +\n+        (1 * w2 / tw) * fpRate2)) < delta)\n+    assert(math.abs(metrics.weightedPrecision -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * precision0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * precision1 +\n+        (1 * w2 / tw) * precision2)) < delta)\n+    assert(math.abs(metrics.weightedRecall -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * recall0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * recall1 +\n+        (1 * w2 / tw) * recall2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f1measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f1measure1 +\n+        (1 * w2 / tw) * f1measure2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure(2.0) -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f2measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f2measure1 +\n+        (1 * w2 / tw) * f2measure2)) < delta)\n+    assert(metrics.labels.sameElements(labels))"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T15:24:04Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n+    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n+    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n+    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n+    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n+    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n+    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n+    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n+    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n+    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n+    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n+    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n+    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n+    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+\n+    assert(math.abs(metrics.accuracy -\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n+    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n+    assert(math.abs(metrics.weightedTruePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * tpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * tpRate1 +\n+        (1 * w2 / tw) * tpRate2)) < delta)\n+    assert(math.abs(metrics.weightedFalsePositiveRate -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * fpRate0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * fpRate1 +\n+        (1 * w2 / tw) * fpRate2)) < delta)\n+    assert(math.abs(metrics.weightedPrecision -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * precision0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * precision1 +\n+        (1 * w2 / tw) * precision2)) < delta)\n+    assert(math.abs(metrics.weightedRecall -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * recall0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * recall1 +\n+        (1 * w2 / tw) * recall2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f1measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f1measure1 +\n+        (1 * w2 / tw) * f1measure2)) < delta)\n+    assert(math.abs(metrics.weightedFMeasure(2.0) -\n+      (((2 * w1 + 1 * w2 + 1 * w1) / tw) * f2measure0 +\n+        ((1 * w2 + 2 * w1 + 1 * w2) / tw) * f2measure1 +\n+        (1 * w2 / tw) * f2measure2)) < delta)\n+    assert(metrics.labels.sameElements(labels))"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "don't `toArray`, use `assert(metrics.confusionMatrix ~== confusionMatrix relTol e)`",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-24T08:35:25Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T15:25:53Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "it looks like I needed to change this to an ML matrix instead of MLLIB matrix in order to make this ~== work, so I used .asML",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-26T16:35:03Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }, {
    "author": {
      "login": "WeichenXu123"
    },
    "body": "Oh, that's because you use `Matrices` in `mllib`, change it to `Matrices` in `ml`, i.e.,  `import org.apache.spark.ml.linalg.Matrices`",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-27T00:26:31Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-05-01T04:07:22Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "however, I still need to do asML on the metrics.confusionMatrix as that property is from mllib (in MulticlassMetrics class)",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-05-01T04:14:26Z",
    "diffHunk": "@@ -95,4 +95,95 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n       ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n     assert(metrics.labels.sameElements(labels))\n   }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val delta = 0.0000001\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "I think maybe `relTol` will be better than `absTol`, except the cases that one side is zero. What do you think of it ?",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-04-27T03:35:10Z",
    "diffHunk": "@@ -55,44 +60,128 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n     val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n     val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n \n-    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n-    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n-    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n-    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n-    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n-    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n-    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n-    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n-    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n-    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n-    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n-    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n-    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n-    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n-    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n-    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+    assert(metrics.confusionMatrix.asML ~== confusionMatrix.asML relTol delta)\n+    assert(metrics.truePositiveRate(0.0) ~== tpRate0 absTol delta)\n+    assert(metrics.truePositiveRate(1.0) ~== tpRate1 absTol delta)\n+    assert(metrics.truePositiveRate(2.0) ~== tpRate2 absTol delta)\n+    assert(metrics.falsePositiveRate(0.0) ~== fpRate0 absTol delta)\n+    assert(metrics.falsePositiveRate(1.0) ~== fpRate1 absTol delta)\n+    assert(metrics.falsePositiveRate(2.0) ~== fpRate2 absTol delta)\n+    assert(metrics.precision(0.0) ~== precision0 absTol delta)\n+    assert(metrics.precision(1.0) ~== precision1 absTol delta)\n+    assert(metrics.precision(2.0) ~== precision2 absTol delta)\n+    assert(metrics.recall(0.0) ~== recall0 absTol delta)\n+    assert(metrics.recall(1.0) ~== recall1 absTol delta)\n+    assert(metrics.recall(2.0) ~== recall2 absTol delta)\n+    assert(metrics.fMeasure(0.0) ~== f1measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0) ~== f1measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0) ~== f1measure2 absTol delta)\n+    assert(metrics.fMeasure(0.0, 2.0) ~== f2measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0, 2.0) ~== f2measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0, 2.0) ~== f2measure2 absTol delta)\n+\n+    assert(metrics.accuracy ~==\n+      (2.0 + 3.0 + 1.0) / ((2 + 3 + 1) + (1 + 1 + 1)) absTol delta)\n+    assert(metrics.accuracy ~== metrics.precision absTol delta)\n+    assert(metrics.accuracy ~== metrics.recall absTol delta)\n+    assert(metrics.accuracy ~== metrics.fMeasure absTol delta)\n+    assert(metrics.accuracy ~== metrics.weightedRecall absTol delta)\n+    val weight0 = 4.0 / 9\n+    val weight1 = 4.0 / 9\n+    val weight2 = 1.0 / 9\n+    assert(metrics.weightedTruePositiveRate ~==\n+      (weight0 * tpRate0 + weight1 * tpRate1 + weight2 * tpRate2) absTol delta)\n+    assert(metrics.weightedFalsePositiveRate ~==\n+      (weight0 * fpRate0 + weight1 * fpRate1 + weight2 * fpRate2) absTol delta)\n+    assert(metrics.weightedPrecision ~==\n+      (weight0 * precision0 + weight1 * precision1 + weight2 * precision2) absTol delta)\n+    assert(metrics.weightedRecall ~==\n+      (weight0 * recall0 + weight1 * recall1 + weight2 * recall2) absTol delta)\n+    assert(metrics.weightedFMeasure ~==\n+      (weight0 * f1measure0 + weight1 * f1measure1 + weight2 * f1measure2) absTol delta)\n+    assert(metrics.weightedFMeasure(2.0) ~==\n+      (weight0 * f2measure0 + weight1 * f2measure1 + weight2 * f2measure2) absTol delta)\n+    assert(metrics.labels === labels)\n+  }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.asML ~== confusionMatrix.asML relTol delta)\n+    assert(metrics.truePositiveRate(0.0) ~== tpRate0 absTol delta)\n+    assert(metrics.truePositiveRate(1.0) ~== tpRate1 absTol delta)\n+    assert(metrics.truePositiveRate(2.0)  ~==  tpRate2 absTol delta)\n+    assert(metrics.falsePositiveRate(0.0)  ~==  fpRate0 absTol delta)\n+    assert(metrics.falsePositiveRate(1.0)  ~==  fpRate1 absTol delta)\n+    assert(metrics.falsePositiveRate(2.0)  ~==  fpRate2 absTol delta)\n+    assert(metrics.precision(0.0)  ~==  precision0 absTol delta)\n+    assert(metrics.precision(1.0)  ~==  precision1 absTol delta)\n+    assert(metrics.precision(2.0)  ~==  precision2 absTol delta)\n+    assert(metrics.recall(0.0)  ~==  recall0 absTol delta)\n+    assert(metrics.recall(1.0)  ~==  recall1 absTol delta)\n+    assert(metrics.recall(2.0)  ~==  recall2 absTol delta)\n+    assert(metrics.fMeasure(0.0)  ~==  f1measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0)  ~==  f1measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0)  ~==  f1measure2 absTol delta)\n+    assert(metrics.fMeasure(0.0, 2.0)  ~==  f2measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0, 2.0)  ~==  f2measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0, 2.0)  ~==  f2measure2 absTol delta)\n \n-    assert(math.abs(metrics.accuracy -\n-      (2.0 + 3.0 + 1.0) / ((2 + 3 + 1) + (1 + 1 + 1))) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n-    assert(math.abs(metrics.weightedTruePositiveRate -\n-      ((4.0 / 9) * tpRate0 + (4.0 / 9) * tpRate1 + (1.0 / 9) * tpRate2)) < delta)\n-    assert(math.abs(metrics.weightedFalsePositiveRate -\n-      ((4.0 / 9) * fpRate0 + (4.0 / 9) * fpRate1 + (1.0 / 9) * fpRate2)) < delta)\n-    assert(math.abs(metrics.weightedPrecision -\n-      ((4.0 / 9) * precision0 + (4.0 / 9) * precision1 + (1.0 / 9) * precision2)) < delta)\n-    assert(math.abs(metrics.weightedRecall -\n-      ((4.0 / 9) * recall0 + (4.0 / 9) * recall1 + (1.0 / 9) * recall2)) < delta)\n-    assert(math.abs(metrics.weightedFMeasure -\n-      ((4.0 / 9) * f1measure0 + (4.0 / 9) * f1measure1 + (1.0 / 9) * f1measure2)) < delta)\n-    assert(math.abs(metrics.weightedFMeasure(2.0) -\n-      ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n-    assert(metrics.labels.sameElements(labels))\n+    assert(metrics.accuracy  ~==\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.precision absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.recall absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.fMeasure absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.weightedRecall absTol delta)\n+    val weight0 = (2 * w1 + 1 * w2 + 1 * w1) / tw\n+    val weight1 = (1 * w2 + 2 * w1 + 1 * w2) / tw\n+    val weight2 = 1 * w2 / tw\n+    assert(metrics.weightedTruePositiveRate  ~==\n+      (weight0 * tpRate0 + weight1 * tpRate1 + weight2 * tpRate2) absTol delta)\n+    assert(metrics.weightedFalsePositiveRate  ~==\n+      (weight0 * fpRate0 + weight1 * fpRate1 + weight2 * fpRate2) absTol delta)\n+    assert(metrics.weightedPrecision  ~==\n+      (weight0 * precision0 + weight1 * precision1 + weight2 * precision2) absTol delta)\n+    assert(metrics.weightedRecall  ~==\n+      (weight0 * recall0 + weight1 * recall1 + weight2 * recall2) absTol delta)\n+    assert(metrics.weightedFMeasure  ~==\n+      (weight0 * f1measure0 + weight1 * f1measure1 + weight2 * f1measure2) absTol delta)\n+    assert(metrics.weightedFMeasure(2.0)  ~==\n+      (weight0 * f2measure0 + weight1 * f2measure1 + weight2 * f2measure2) absTol delta)"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "good idea, I've replaced absTol with relTol, done",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-05-01T04:10:44Z",
    "diffHunk": "@@ -55,44 +60,128 @@ class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n     val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n     val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n \n-    assert(metrics.confusionMatrix.toArray.sameElements(confusionMatrix.toArray))\n-    assert(math.abs(metrics.truePositiveRate(0.0) - tpRate0) < delta)\n-    assert(math.abs(metrics.truePositiveRate(1.0) - tpRate1) < delta)\n-    assert(math.abs(metrics.truePositiveRate(2.0) - tpRate2) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(0.0) - fpRate0) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(1.0) - fpRate1) < delta)\n-    assert(math.abs(metrics.falsePositiveRate(2.0) - fpRate2) < delta)\n-    assert(math.abs(metrics.precision(0.0) - precision0) < delta)\n-    assert(math.abs(metrics.precision(1.0) - precision1) < delta)\n-    assert(math.abs(metrics.precision(2.0) - precision2) < delta)\n-    assert(math.abs(metrics.recall(0.0) - recall0) < delta)\n-    assert(math.abs(metrics.recall(1.0) - recall1) < delta)\n-    assert(math.abs(metrics.recall(2.0) - recall2) < delta)\n-    assert(math.abs(metrics.fMeasure(0.0) - f1measure0) < delta)\n-    assert(math.abs(metrics.fMeasure(1.0) - f1measure1) < delta)\n-    assert(math.abs(metrics.fMeasure(2.0) - f1measure2) < delta)\n-    assert(math.abs(metrics.fMeasure(0.0, 2.0) - f2measure0) < delta)\n-    assert(math.abs(metrics.fMeasure(1.0, 2.0) - f2measure1) < delta)\n-    assert(math.abs(metrics.fMeasure(2.0, 2.0) - f2measure2) < delta)\n+    assert(metrics.confusionMatrix.asML ~== confusionMatrix.asML relTol delta)\n+    assert(metrics.truePositiveRate(0.0) ~== tpRate0 absTol delta)\n+    assert(metrics.truePositiveRate(1.0) ~== tpRate1 absTol delta)\n+    assert(metrics.truePositiveRate(2.0) ~== tpRate2 absTol delta)\n+    assert(metrics.falsePositiveRate(0.0) ~== fpRate0 absTol delta)\n+    assert(metrics.falsePositiveRate(1.0) ~== fpRate1 absTol delta)\n+    assert(metrics.falsePositiveRate(2.0) ~== fpRate2 absTol delta)\n+    assert(metrics.precision(0.0) ~== precision0 absTol delta)\n+    assert(metrics.precision(1.0) ~== precision1 absTol delta)\n+    assert(metrics.precision(2.0) ~== precision2 absTol delta)\n+    assert(metrics.recall(0.0) ~== recall0 absTol delta)\n+    assert(metrics.recall(1.0) ~== recall1 absTol delta)\n+    assert(metrics.recall(2.0) ~== recall2 absTol delta)\n+    assert(metrics.fMeasure(0.0) ~== f1measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0) ~== f1measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0) ~== f1measure2 absTol delta)\n+    assert(metrics.fMeasure(0.0, 2.0) ~== f2measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0, 2.0) ~== f2measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0, 2.0) ~== f2measure2 absTol delta)\n+\n+    assert(metrics.accuracy ~==\n+      (2.0 + 3.0 + 1.0) / ((2 + 3 + 1) + (1 + 1 + 1)) absTol delta)\n+    assert(metrics.accuracy ~== metrics.precision absTol delta)\n+    assert(metrics.accuracy ~== metrics.recall absTol delta)\n+    assert(metrics.accuracy ~== metrics.fMeasure absTol delta)\n+    assert(metrics.accuracy ~== metrics.weightedRecall absTol delta)\n+    val weight0 = 4.0 / 9\n+    val weight1 = 4.0 / 9\n+    val weight2 = 1.0 / 9\n+    assert(metrics.weightedTruePositiveRate ~==\n+      (weight0 * tpRate0 + weight1 * tpRate1 + weight2 * tpRate2) absTol delta)\n+    assert(metrics.weightedFalsePositiveRate ~==\n+      (weight0 * fpRate0 + weight1 * fpRate1 + weight2 * fpRate2) absTol delta)\n+    assert(metrics.weightedPrecision ~==\n+      (weight0 * precision0 + weight1 * precision1 + weight2 * precision2) absTol delta)\n+    assert(metrics.weightedRecall ~==\n+      (weight0 * recall0 + weight1 * recall1 + weight2 * recall2) absTol delta)\n+    assert(metrics.weightedFMeasure ~==\n+      (weight0 * f1measure0 + weight1 * f1measure1 + weight2 * f1measure2) absTol delta)\n+    assert(metrics.weightedFMeasure(2.0) ~==\n+      (weight0 * f2measure0 + weight1 * f2measure1 + weight2 * f2measure2) absTol delta)\n+    assert(metrics.labels === labels)\n+  }\n+\n+  test(\"Multiclass evaluation metrics with weights\") {\n+    /*\n+     * Confusion matrix for 3-class classification with total 9 instances with 2 weights:\n+     * |2 * w1|1 * w2         |1 * w1| true class0 (4 instances)\n+     * |1 * w2|2 * w1 + 1 * w2|0     | true class1 (4 instances)\n+     * |0     |0              |1 * w2| true class2 (1 instance)\n+     */\n+    val w1 = 2.2\n+    val w2 = 1.5\n+    val tw = 2.0 * w1 + 1.0 * w2 + 1.0 * w1 + 1.0 * w2 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2\n+    val confusionMatrix = Matrices.dense(3, 3,\n+      Array(2 * w1, 1 * w2, 0, 1 * w2, 2 * w1 + 1 * w2, 0, 1 * w1, 0, 1 * w2))\n+    val labels = Array(0.0, 1.0, 2.0)\n+    val predictionAndLabelsWithWeights = sc.parallelize(\n+      Seq((0.0, 0.0, w1), (0.0, 1.0, w2), (0.0, 0.0, w1), (1.0, 0.0, w2),\n+        (1.0, 1.0, w1), (1.0, 1.0, w2), (1.0, 1.0, w1), (2.0, 2.0, w2),\n+        (2.0, 0.0, w1)), 2)\n+    val metrics = new MulticlassMetrics(predictionAndLabelsWithWeights)\n+    val tpRate0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val tpRate1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val tpRate2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val fpRate0 = (1.0 * w2) / (tw - (2.0 * w1 + 1.0 * w2 + 1.0 * w1))\n+    val fpRate1 = (1.0 * w2) / (tw - (1.0 * w2 + 2.0 * w1 + 1.0 * w2))\n+    val fpRate2 = (1.0 * w1) / (tw - (1.0 * w2))\n+    val precision0 = (2.0 * w1) / (2 * w1 + 1 * w2)\n+    val precision1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val precision2 = (1.0 * w2) / (1 * w1 + 1 * w2)\n+    val recall0 = (2.0 * w1) / (2.0 * w1 + 1.0 * w2 + 1.0 * w1)\n+    val recall1 = (2.0 * w1 + 1.0 * w2) / (2.0 * w1 + 1.0 * w2 + 1.0 * w2)\n+    val recall2 = (1.0 * w2) / (1.0 * w2 + 0)\n+    val f1measure0 = 2 * precision0 * recall0 / (precision0 + recall0)\n+    val f1measure1 = 2 * precision1 * recall1 / (precision1 + recall1)\n+    val f1measure2 = 2 * precision2 * recall2 / (precision2 + recall2)\n+    val f2measure0 = (1 + 2 * 2) * precision0 * recall0 / (2 * 2 * precision0 + recall0)\n+    val f2measure1 = (1 + 2 * 2) * precision1 * recall1 / (2 * 2 * precision1 + recall1)\n+    val f2measure2 = (1 + 2 * 2) * precision2 * recall2 / (2 * 2 * precision2 + recall2)\n+\n+    assert(metrics.confusionMatrix.asML ~== confusionMatrix.asML relTol delta)\n+    assert(metrics.truePositiveRate(0.0) ~== tpRate0 absTol delta)\n+    assert(metrics.truePositiveRate(1.0) ~== tpRate1 absTol delta)\n+    assert(metrics.truePositiveRate(2.0)  ~==  tpRate2 absTol delta)\n+    assert(metrics.falsePositiveRate(0.0)  ~==  fpRate0 absTol delta)\n+    assert(metrics.falsePositiveRate(1.0)  ~==  fpRate1 absTol delta)\n+    assert(metrics.falsePositiveRate(2.0)  ~==  fpRate2 absTol delta)\n+    assert(metrics.precision(0.0)  ~==  precision0 absTol delta)\n+    assert(metrics.precision(1.0)  ~==  precision1 absTol delta)\n+    assert(metrics.precision(2.0)  ~==  precision2 absTol delta)\n+    assert(metrics.recall(0.0)  ~==  recall0 absTol delta)\n+    assert(metrics.recall(1.0)  ~==  recall1 absTol delta)\n+    assert(metrics.recall(2.0)  ~==  recall2 absTol delta)\n+    assert(metrics.fMeasure(0.0)  ~==  f1measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0)  ~==  f1measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0)  ~==  f1measure2 absTol delta)\n+    assert(metrics.fMeasure(0.0, 2.0)  ~==  f2measure0 absTol delta)\n+    assert(metrics.fMeasure(1.0, 2.0)  ~==  f2measure1 absTol delta)\n+    assert(metrics.fMeasure(2.0, 2.0)  ~==  f2measure2 absTol delta)\n \n-    assert(math.abs(metrics.accuracy -\n-      (2.0 + 3.0 + 1.0) / ((2 + 3 + 1) + (1 + 1 + 1))) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.precision) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.recall) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.fMeasure) < delta)\n-    assert(math.abs(metrics.accuracy - metrics.weightedRecall) < delta)\n-    assert(math.abs(metrics.weightedTruePositiveRate -\n-      ((4.0 / 9) * tpRate0 + (4.0 / 9) * tpRate1 + (1.0 / 9) * tpRate2)) < delta)\n-    assert(math.abs(metrics.weightedFalsePositiveRate -\n-      ((4.0 / 9) * fpRate0 + (4.0 / 9) * fpRate1 + (1.0 / 9) * fpRate2)) < delta)\n-    assert(math.abs(metrics.weightedPrecision -\n-      ((4.0 / 9) * precision0 + (4.0 / 9) * precision1 + (1.0 / 9) * precision2)) < delta)\n-    assert(math.abs(metrics.weightedRecall -\n-      ((4.0 / 9) * recall0 + (4.0 / 9) * recall1 + (1.0 / 9) * recall2)) < delta)\n-    assert(math.abs(metrics.weightedFMeasure -\n-      ((4.0 / 9) * f1measure0 + (4.0 / 9) * f1measure1 + (1.0 / 9) * f1measure2)) < delta)\n-    assert(math.abs(metrics.weightedFMeasure(2.0) -\n-      ((4.0 / 9) * f2measure0 + (4.0 / 9) * f2measure1 + (1.0 / 9) * f2measure2)) < delta)\n-    assert(metrics.labels.sameElements(labels))\n+    assert(metrics.accuracy  ~==\n+      (2.0 * w1 + 2.0 * w1 + 1.0 * w2 + 1.0 * w2) / tw absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.precision absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.recall absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.fMeasure absTol delta)\n+    assert(metrics.accuracy  ~==  metrics.weightedRecall absTol delta)\n+    val weight0 = (2 * w1 + 1 * w2 + 1 * w1) / tw\n+    val weight1 = (1 * w2 + 2 * w1 + 1 * w2) / tw\n+    val weight2 = 1 * w2 / tw\n+    assert(metrics.weightedTruePositiveRate  ~==\n+      (weight0 * tpRate0 + weight1 * tpRate1 + weight2 * tpRate2) absTol delta)\n+    assert(metrics.weightedFalsePositiveRate  ~==\n+      (weight0 * fpRate0 + weight1 * fpRate1 + weight2 * fpRate2) absTol delta)\n+    assert(metrics.weightedPrecision  ~==\n+      (weight0 * precision0 + weight1 * precision1 + weight2 * precision2) absTol delta)\n+    assert(metrics.weightedRecall  ~==\n+      (weight0 * recall0 + weight1 * recall1 + weight2 * recall2) absTol delta)\n+    assert(metrics.weightedFMeasure  ~==\n+      (weight0 * f1measure0 + weight1 * f1measure1 + weight2 * f1measure2) absTol delta)\n+    assert(metrics.weightedFMeasure(2.0)  ~==\n+      (weight0 * f2measure0 + weight1 * f2measure1 + weight2 * f2measure2) absTol delta)"
  }],
  "prId": 17086
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "`private`?",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-11-05T23:13:58Z",
    "diffHunk": "@@ -18,10 +18,14 @@\n package org.apache.spark.mllib.evaluation\n \n import org.apache.spark.SparkFunSuite\n-import org.apache.spark.mllib.linalg.Matrices\n+import org.apache.spark.ml.linalg.Matrices\n+import org.apache.spark.ml.util.TestingUtils._\n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n+\n+  val delta = 1e-7"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done!",
    "commit": "50864497d013ba7f8a160d5142b0cfdd41f00f8d",
    "createdAt": "2018-11-06T03:49:18Z",
    "diffHunk": "@@ -18,10 +18,14 @@\n package org.apache.spark.mllib.evaluation\n \n import org.apache.spark.SparkFunSuite\n-import org.apache.spark.mllib.linalg.Matrices\n+import org.apache.spark.ml.linalg.Matrices\n+import org.apache.spark.ml.util.TestingUtils._\n import org.apache.spark.mllib.util.MLlibTestSparkContext\n \n class MulticlassMetricsSuite extends SparkFunSuite with MLlibTestSparkContext {\n+\n+  val delta = 1e-7"
  }],
  "prId": 17086
}]