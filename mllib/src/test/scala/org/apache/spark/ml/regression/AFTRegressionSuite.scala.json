[{
  "comments": [{
    "author": {
      "login": "rotationsymmetry"
    },
    "body": "ditto: put an `assert` statement for `expected`?\n",
    "commit": "aa37878c50ef6e7722a615298240ba6e61ea083c",
    "createdAt": "2015-09-09T20:19:13Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.regression\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.feature.OneHotEncoder\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.MLTestingUtils\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.random.{ExponentialGenerator, WeibullGenerator}\n+import org.apache.spark.mllib.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+\n+import scala.util.Random\n+\n+case class AFTExamplePoint(stage: Double, time: Double, age: Int, year: Int, censored: Double)\n+\n+case class AFTPoint(features: Vector, censored: Double, label: Double)\n+\n+class AFTRegressionSuite extends SparkFunSuite with MLlibTestSparkContext {\n+\n+  @transient var datasetUnivariate: DataFrame = _\n+  @transient var datasetMultivariate: DataFrame = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    datasetUnivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        1, Array(5.5), Array(0.8), 1000, 42, 1.0, 2.0)))\n+    datasetMultivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        2, Array(0.9, -1.3), Array(0.7, 1.2), 1000, 42, 1.5, 2.5)))\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new AFTRegression)\n+    val model = new AFTRegressionModel(\"aftReg\", Vectors.dense(0.0), 0.0, 0.0)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"aft regression: default params\") {\n+    val aftr = new AFTRegression\n+    assert(aftr.getLabelCol === \"label\")\n+    assert(aftr.getFeaturesCol === \"features\")\n+    assert(aftr.getPredictionCol === \"prediction\")\n+    assert(aftr.getFitIntercept)\n+    val model = aftr.fit(datasetUnivariate)\n+\n+    // copied model must have the same parent.\n+    MLTestingUtils.checkCopy(model)\n+\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getQuantileCol == \"quantile\")\n+    assert(model.intercept !== 0.0)\n+    assert(model.hasParent)\n+  }\n+\n+  def generateAFTInput(\n+      numFeatures: Int,\n+      xMean: Array[Double],\n+      xVariance: Array[Double],\n+      nPoints: Int,\n+      seed: Int,\n+      alpha: Double,\n+      beta: Double): Seq[AFTPoint] = {\n+\n+    def censored(x: Double, y: Double): Double = {\n+      if (x <= y) 1.0 else 0.0\n+    }\n+\n+    val weibull = new WeibullGenerator(alpha, beta)\n+    weibull.setSeed(seed)\n+\n+    val exponential = new ExponentialGenerator(2.0)\n+    exponential.setSeed(seed)\n+\n+    val rnd = new Random(seed)\n+    val x = Array.fill[Array[Double]](nPoints)(\n+      Array.fill[Double](numFeatures)(rnd.nextDouble()))\n+\n+    x.foreach { v =>\n+      var i = 0\n+      val len = v.length\n+      while (i < len) {\n+        v(i) = (v(i) - 0.5) * math.sqrt(12.0 * xVariance(i)) + xMean(i)\n+        i += 1\n+      }\n+    }\n+    val y = (1 to nPoints).map { i =>\n+      (weibull.nextValue(), exponential.nextValue())\n+    }\n+\n+    y.zip(x).map { p =>\n+      AFTPoint(Vectors.dense(p._2), censored(p._1._1, p._1._2), p._1._1)\n+    }\n+  }\n+\n+  test(\"aft regression with univariate\") {\n+    val trainer = new AFTRegression\n+    val model = trainer.fit(datasetUnivariate)\n+\n+    /*\n+       Using the following R code to load the data and train the model using survival package.\n+\n+       > library(\"survival\")\n+       > data <- read.csv(\"path\", header=FALSE, stringsAsFactors=FALSE)\n+       > features <- as.matrix(data.frame(as.numeric(data$V1)))\n+       > censored <- as.numeric(data$V2)\n+       > label <- as.numeric(data$V3)\n+       > sr.fit <- survreg(Surv(label, censored)~features, dist='weibull')\n+       > summary(sr.fit)\n+\n+       survreg(formula = Surv(label, censored) ~ features, dist = \"weibull\")\n+                    Value Std. Error      z        p\n+       (Intercept)  1.759     0.4141  4.247 2.16e-05\n+       features    -0.039     0.0735 -0.531 5.96e-01\n+       Log(scale)   0.344     0.0379  9.073 1.16e-19\n+\n+       Scale= 1.41\n+\n+       Weibull distribution\n+       Loglik(model)= -1152.2   Loglik(intercept only)= -1152.3\n+           Chisq= 0.28 on 1 degrees of freedom, p= 0.6\n+       Number of Newton-Raphson Iterations: 5\n+       n= 1000\n+     */\n+    val weightsR = Vectors.dense(-0.039)\n+    val interceptR = 1.759\n+    val scaleR = 1.41\n+\n+    assert(model.intercept ~== interceptR relTol 1E-3)\n+    assert(model.weights ~= weightsR relTol 1E-3)\n+    assert(model.scale ~= scaleR relTol 1E-3)\n+\n+    val features = Vectors.dense(4.675290165370009)\n+    val quantile = Vectors.dense(Array(0.1, 0.5, 0.9))\n+    val expected = model.predict(features, quantile)\n+  }\n+\n+  test(\"aft regression with multivariate\") {\n+    val trainer = new AFTRegression\n+    val model = trainer.fit(datasetMultivariate)\n+\n+    /*\n+       Using the following R code to load the data and train the model using survival package.\n+\n+       > library(\"survival\")\n+       > data <- read.csv(\"path\", header=FALSE, stringsAsFactors=FALSE)\n+       > features <- as.matrix(data.frame(as.numeric(data$V1), as.numeric(data$V2)))\n+       > censored <- as.numeric(data$V3)\n+       > label <- as.numeric(data$V4)\n+       > sr.fit <- survreg(Surv(label, censored)~features, dist='weibull')\n+       > summary(sr.fit)\n+\n+                                     Value Std. Error      z        p\n+       (Intercept)                  1.9206     0.1057 18.171 8.78e-74\n+       featuresas.numeric.data.V1. -0.0844     0.0611 -1.381 1.67e-01\n+       featuresas.numeric.data.V2.  0.0677     0.0468  1.447 1.48e-01\n+       Log(scale)                  -0.0236     0.0436 -0.542 5.88e-01\n+\n+       Scale= 0.977\n+\n+       Weibull distribution\n+       Loglik(model)= -1070.7   Loglik(intercept only)= -1072.7\n+           Chisq= 3.91 on 2 degrees of freedom, p= 0.14\n+       Number of Newton-Raphson Iterations: 5\n+       n= 1000\n+     */\n+    val weightsR = Vectors.dense(-0.0844, 0.0677)\n+    val interceptR = 1.9206\n+    val scaleR = 0.977\n+\n+    assert(model.intercept ~== interceptR relTol 1E-3)\n+    assert(model.weights ~= weightsR relTol 1E-3)\n+    assert(model.scale ~= scaleR relTol 1E-3)\n+\n+    val features = Vectors.dense(1.109175828579902, -0.5315711415960551)\n+    val quantile = Vectors.dense(Array(0.1, 0.5, 0.9))\n+    val expected = model.predict(features, quantile)"
  }],
  "prId": 8611
}, {
  "comments": [{
    "author": {
      "login": "rotationsymmetry"
    },
    "body": "put an `assert` statement for `expected`?\n",
    "commit": "aa37878c50ef6e7722a615298240ba6e61ea083c",
    "createdAt": "2015-09-09T20:20:01Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.regression\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.feature.OneHotEncoder\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.MLTestingUtils\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.random.{ExponentialGenerator, WeibullGenerator}\n+import org.apache.spark.mllib.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+\n+import scala.util.Random\n+\n+case class AFTExamplePoint(stage: Double, time: Double, age: Int, year: Int, censored: Double)\n+\n+case class AFTPoint(features: Vector, censored: Double, label: Double)\n+\n+class AFTRegressionSuite extends SparkFunSuite with MLlibTestSparkContext {\n+\n+  @transient var datasetUnivariate: DataFrame = _\n+  @transient var datasetMultivariate: DataFrame = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    datasetUnivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        1, Array(5.5), Array(0.8), 1000, 42, 1.0, 2.0)))\n+    datasetMultivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        2, Array(0.9, -1.3), Array(0.7, 1.2), 1000, 42, 1.5, 2.5)))\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new AFTRegression)\n+    val model = new AFTRegressionModel(\"aftReg\", Vectors.dense(0.0), 0.0, 0.0)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"aft regression: default params\") {\n+    val aftr = new AFTRegression\n+    assert(aftr.getLabelCol === \"label\")\n+    assert(aftr.getFeaturesCol === \"features\")\n+    assert(aftr.getPredictionCol === \"prediction\")\n+    assert(aftr.getFitIntercept)\n+    val model = aftr.fit(datasetUnivariate)\n+\n+    // copied model must have the same parent.\n+    MLTestingUtils.checkCopy(model)\n+\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getQuantileCol == \"quantile\")\n+    assert(model.intercept !== 0.0)\n+    assert(model.hasParent)\n+  }\n+\n+  def generateAFTInput(\n+      numFeatures: Int,\n+      xMean: Array[Double],\n+      xVariance: Array[Double],\n+      nPoints: Int,\n+      seed: Int,\n+      alpha: Double,\n+      beta: Double): Seq[AFTPoint] = {\n+\n+    def censored(x: Double, y: Double): Double = {\n+      if (x <= y) 1.0 else 0.0\n+    }\n+\n+    val weibull = new WeibullGenerator(alpha, beta)\n+    weibull.setSeed(seed)\n+\n+    val exponential = new ExponentialGenerator(2.0)\n+    exponential.setSeed(seed)\n+\n+    val rnd = new Random(seed)\n+    val x = Array.fill[Array[Double]](nPoints)(\n+      Array.fill[Double](numFeatures)(rnd.nextDouble()))\n+\n+    x.foreach { v =>\n+      var i = 0\n+      val len = v.length\n+      while (i < len) {\n+        v(i) = (v(i) - 0.5) * math.sqrt(12.0 * xVariance(i)) + xMean(i)\n+        i += 1\n+      }\n+    }\n+    val y = (1 to nPoints).map { i =>\n+      (weibull.nextValue(), exponential.nextValue())\n+    }\n+\n+    y.zip(x).map { p =>\n+      AFTPoint(Vectors.dense(p._2), censored(p._1._1, p._1._2), p._1._1)\n+    }\n+  }\n+\n+  test(\"aft regression with univariate\") {\n+    val trainer = new AFTRegression\n+    val model = trainer.fit(datasetUnivariate)\n+\n+    /*\n+       Using the following R code to load the data and train the model using survival package.\n+\n+       > library(\"survival\")\n+       > data <- read.csv(\"path\", header=FALSE, stringsAsFactors=FALSE)\n+       > features <- as.matrix(data.frame(as.numeric(data$V1)))\n+       > censored <- as.numeric(data$V2)\n+       > label <- as.numeric(data$V3)\n+       > sr.fit <- survreg(Surv(label, censored)~features, dist='weibull')\n+       > summary(sr.fit)\n+\n+       survreg(formula = Surv(label, censored) ~ features, dist = \"weibull\")\n+                    Value Std. Error      z        p\n+       (Intercept)  1.759     0.4141  4.247 2.16e-05\n+       features    -0.039     0.0735 -0.531 5.96e-01\n+       Log(scale)   0.344     0.0379  9.073 1.16e-19\n+\n+       Scale= 1.41\n+\n+       Weibull distribution\n+       Loglik(model)= -1152.2   Loglik(intercept only)= -1152.3\n+           Chisq= 0.28 on 1 degrees of freedom, p= 0.6\n+       Number of Newton-Raphson Iterations: 5\n+       n= 1000\n+     */\n+    val weightsR = Vectors.dense(-0.039)\n+    val interceptR = 1.759\n+    val scaleR = 1.41\n+\n+    assert(model.intercept ~== interceptR relTol 1E-3)\n+    assert(model.weights ~= weightsR relTol 1E-3)\n+    assert(model.scale ~= scaleR relTol 1E-3)\n+\n+    val features = Vectors.dense(4.675290165370009)\n+    val quantile = Vectors.dense(Array(0.1, 0.5, 0.9))\n+    val expected = model.predict(features, quantile)"
  }],
  "prId": 8611
}, {
  "comments": [{
    "author": {
      "login": "rotationsymmetry"
    },
    "body": "make this private?\n",
    "commit": "aa37878c50ef6e7722a615298240ba6e61ea083c",
    "createdAt": "2015-09-09T22:34:55Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.regression\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.feature.OneHotEncoder\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.MLTestingUtils\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.random.{ExponentialGenerator, WeibullGenerator}\n+import org.apache.spark.mllib.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+\n+import scala.util.Random\n+\n+case class AFTExamplePoint(stage: Double, time: Double, age: Int, year: Int, censored: Double)\n+\n+case class AFTPoint(features: Vector, censored: Double, label: Double)"
  }],
  "prId": 8611
}, {
  "comments": [{
    "author": {
      "login": "rotationsymmetry"
    },
    "body": "make this private?\n",
    "commit": "aa37878c50ef6e7722a615298240ba6e61ea083c",
    "createdAt": "2015-09-09T22:35:02Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.regression\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.feature.OneHotEncoder\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.MLTestingUtils\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.random.{ExponentialGenerator, WeibullGenerator}\n+import org.apache.spark.mllib.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+\n+import scala.util.Random\n+\n+case class AFTExamplePoint(stage: Double, time: Double, age: Int, year: Int, censored: Double)"
  }],
  "prId": 8611
}, {
  "comments": [{
    "author": {
      "login": "rotationsymmetry"
    },
    "body": "Add test cases for `fitIntercept` is `true` or `false`.\n",
    "commit": "aa37878c50ef6e7722a615298240ba6e61ea083c",
    "createdAt": "2015-09-10T07:19:02Z",
    "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.regression\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.feature.OneHotEncoder\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.MLTestingUtils\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.random.{ExponentialGenerator, WeibullGenerator}\n+import org.apache.spark.mllib.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+\n+import scala.util.Random\n+\n+case class AFTExamplePoint(stage: Double, time: Double, age: Int, year: Int, censored: Double)\n+\n+case class AFTPoint(features: Vector, censored: Double, label: Double)\n+\n+class AFTRegressionSuite extends SparkFunSuite with MLlibTestSparkContext {\n+\n+  @transient var datasetUnivariate: DataFrame = _\n+  @transient var datasetMultivariate: DataFrame = _\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+    datasetUnivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        1, Array(5.5), Array(0.8), 1000, 42, 1.0, 2.0)))\n+    datasetMultivariate = sqlContext.createDataFrame(\n+      sc.parallelize(generateAFTInput(\n+        2, Array(0.9, -1.3), Array(0.7, 1.2), 1000, 42, 1.5, 2.5)))\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new AFTRegression)\n+    val model = new AFTRegressionModel(\"aftReg\", Vectors.dense(0.0), 0.0, 0.0)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"aft regression: default params\") {\n+    val aftr = new AFTRegression\n+    assert(aftr.getLabelCol === \"label\")\n+    assert(aftr.getFeaturesCol === \"features\")\n+    assert(aftr.getPredictionCol === \"prediction\")\n+    assert(aftr.getFitIntercept)\n+    val model = aftr.fit(datasetUnivariate)\n+\n+    // copied model must have the same parent.\n+    MLTestingUtils.checkCopy(model)\n+\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getQuantileCol == \"quantile\")\n+    assert(model.intercept !== 0.0)\n+    assert(model.hasParent)\n+  }\n+\n+  def generateAFTInput(\n+      numFeatures: Int,\n+      xMean: Array[Double],\n+      xVariance: Array[Double],\n+      nPoints: Int,\n+      seed: Int,\n+      alpha: Double,\n+      beta: Double): Seq[AFTPoint] = {\n+\n+    def censored(x: Double, y: Double): Double = {\n+      if (x <= y) 1.0 else 0.0\n+    }\n+\n+    val weibull = new WeibullGenerator(alpha, beta)\n+    weibull.setSeed(seed)\n+\n+    val exponential = new ExponentialGenerator(2.0)\n+    exponential.setSeed(seed)\n+\n+    val rnd = new Random(seed)\n+    val x = Array.fill[Array[Double]](nPoints)(\n+      Array.fill[Double](numFeatures)(rnd.nextDouble()))\n+\n+    x.foreach { v =>\n+      var i = 0\n+      val len = v.length\n+      while (i < len) {\n+        v(i) = (v(i) - 0.5) * math.sqrt(12.0 * xVariance(i)) + xMean(i)\n+        i += 1\n+      }\n+    }\n+    val y = (1 to nPoints).map { i =>\n+      (weibull.nextValue(), exponential.nextValue())\n+    }\n+\n+    y.zip(x).map { p =>\n+      AFTPoint(Vectors.dense(p._2), censored(p._1._1, p._1._2), p._1._1)\n+    }\n+  }\n+\n+  test(\"aft regression with univariate\") {\n+    val trainer = new AFTRegression\n+    val model = trainer.fit(datasetUnivariate)\n+\n+    /*\n+       Using the following R code to load the data and train the model using survival package.\n+\n+       > library(\"survival\")\n+       > data <- read.csv(\"path\", header=FALSE, stringsAsFactors=FALSE)\n+       > features <- as.matrix(data.frame(as.numeric(data$V1)))\n+       > censored <- as.numeric(data$V2)\n+       > label <- as.numeric(data$V3)\n+       > sr.fit <- survreg(Surv(label, censored)~features, dist='weibull')\n+       > summary(sr.fit)\n+\n+       survreg(formula = Surv(label, censored) ~ features, dist = \"weibull\")\n+                    Value Std. Error      z        p\n+       (Intercept)  1.759     0.4141  4.247 2.16e-05\n+       features    -0.039     0.0735 -0.531 5.96e-01\n+       Log(scale)   0.344     0.0379  9.073 1.16e-19\n+\n+       Scale= 1.41\n+\n+       Weibull distribution\n+       Loglik(model)= -1152.2   Loglik(intercept only)= -1152.3\n+           Chisq= 0.28 on 1 degrees of freedom, p= 0.6\n+       Number of Newton-Raphson Iterations: 5\n+       n= 1000\n+     */\n+    val weightsR = Vectors.dense(-0.039)\n+    val interceptR = 1.759\n+    val scaleR = 1.41\n+\n+    assert(model.intercept ~== interceptR relTol 1E-3)\n+    assert(model.weights ~= weightsR relTol 1E-3)\n+    assert(model.scale ~= scaleR relTol 1E-3)\n+\n+    val features = Vectors.dense(4.675290165370009)\n+    val quantile = Vectors.dense(Array(0.1, 0.5, 0.9))\n+    val expected = model.predict(features, quantile)\n+  }\n+\n+  test(\"aft regression with multivariate\") {"
  }],
  "prId": 8611
}]