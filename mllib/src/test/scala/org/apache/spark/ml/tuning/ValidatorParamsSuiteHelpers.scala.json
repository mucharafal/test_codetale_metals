[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "fix indentation",
    "commit": "6a7162dfbefbc900cc103f6fd7d7df5510cf2154",
    "createdAt": "2017-07-14T21:08:03Z",
    "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tuning\n+\n+import java.io.File\n+import java.nio.file.{Files, StandardCopyOption}\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.param.{ParamMap, ParamPair, Params}\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, Identifiable, MLReader, MLWritable}\n+\n+object ValidatorParamsSuiteHelpers extends SparkFunSuite with DefaultReadWriteTest {\n+  /**\n+   * Assert sequences of estimatorParamMaps are identical.\n+   * If the values for a parameter are not directly comparable with ===\n+   * and are instead Params types themselves then their corresponding paramMaps\n+   * are compared against each other.\n+   */\n+  def compareParamMaps(pMaps: Array[ParamMap], pMaps2: Array[ParamMap]): Unit = {\n+    assert(pMaps.length === pMaps2.length)\n+    pMaps.zip(pMaps2).foreach { case (pMap, pMap2) =>\n+      assert(pMap.size === pMap2.size)\n+      pMap.toSeq.foreach { case ParamPair(p, v) =>\n+        assert(pMap2.contains(p))\n+        val otherParam = pMap2(p)\n+        v match {\n+          case estimator: Params =>\n+            otherParam match {\n+              case estimator2: Params =>\n+                val estimatorParamMap = Array(estimator.extractParamMap())\n+                val estimatorParamMap2 = Array(estimator2.extractParamMap())\n+                compareParamMaps(estimatorParamMap, estimatorParamMap2)\n+              case other =>\n+                throw new AssertionError(s\"Expected parameter of type Params but\" +\n+                  s\" found ${otherParam.getClass.getName}\")\n+            }\n+          case _ =>\n+            assert(otherParam === v)\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * When nested estimators (ex. OneVsRest) are saved within meta-algorithms such as\n+   * CrossValidator and TrainValidationSplit, relative paths should be used to store\n+   * the path of the estimator so that if the parent directory changes, loading the\n+   * model still works.\n+   */\n+  def testFileMove[T <: Params with MLWritable](instance: T): Unit = {\n+    val uid = instance.uid\n+    val subdirName = Identifiable.randomUID(\"test\")\n+\n+    val subdir = new File(tempDir, subdirName)\n+    val subDirWithUid = new File(subdir, uid)\n+\n+    instance.save(subDirWithUid.getPath)\n+\n+    val newSubdirName = Identifiable.randomUID(\"test_moved\")\n+    val newSubdir = new File(tempDir, newSubdirName)\n+    val newSubdirWithUid = new File(newSubdir, uid)\n+\n+    Files.createDirectory(newSubdir.toPath)\n+    Files.createDirectory(newSubdirWithUid.toPath)\n+    Files.move(subDirWithUid.toPath, newSubdirWithUid.toPath, StandardCopyOption.ATOMIC_MOVE)\n+\n+    val loader = instance.getClass.getMethod(\"read\")\n+                  .invoke(null).asInstanceOf[MLReader[T]]"
  }],
  "prId": 18428
}]