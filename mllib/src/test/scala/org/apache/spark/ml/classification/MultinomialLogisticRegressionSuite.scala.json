[{
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "I found that it requires many iterations for the OWLQN solver to converge closely with glmnet. This causes the test to take a significant amount of time. \n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-06-21T03:30:25Z",
    "diffHunk": "@@ -0,0 +1,1001 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1).saveAsTextFile(\"target/tmp/LogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+    test(\"params\") {\n+      ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+      val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+        Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+      ParamsSuite.checkParams(model)\n+    }\n+\n+    test(\"multinomial logistic regression: default params\") {\n+      val mlr = new MultinomialLogisticRegression\n+      assert(mlr.getLabelCol === \"label\")\n+      assert(mlr.getFeaturesCol === \"features\")\n+      assert(mlr.getPredictionCol === \"prediction\")\n+      assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+      assert(mlr.getProbabilityCol === \"probability\")\n+      assert(!mlr.isDefined(mlr.weightCol))\n+      assert(!mlr.isDefined(mlr.thresholds))\n+      assert(mlr.getFitIntercept)\n+      assert(mlr.getStandardization)\n+      val model = mlr.fit(dataset)\n+      model.transform(dataset)\n+        .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+        .collect()\n+      assert(model.getFeaturesCol === \"features\")\n+      assert(model.getPredictionCol === \"prediction\")\n+      assert(model.getRawPredictionCol === \"rawPrediction\")\n+      assert(model.getProbabilityCol === \"probability\")\n+      assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+      assert(model.hasParent)\n+    }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)",
    "line": 244
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "extra line\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-13T02:32:36Z",
    "diffHunk": "@@ -0,0 +1,1001 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1).saveAsTextFile(\"target/tmp/LogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+    test(\"params\") {\n+      ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+      val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+        Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+      ParamsSuite.checkParams(model)\n+    }\n+\n+    test(\"multinomial logistic regression: default params\") {\n+      val mlr = new MultinomialLogisticRegression\n+      assert(mlr.getLabelCol === \"label\")\n+      assert(mlr.getFeaturesCol === \"features\")\n+      assert(mlr.getPredictionCol === \"prediction\")\n+      assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+      assert(mlr.getProbabilityCol === \"probability\")\n+      assert(!mlr.isDefined(mlr.weightCol))\n+      assert(!mlr.isDefined(mlr.thresholds))\n+      assert(mlr.getFitIntercept)\n+      assert(mlr.getStandardization)\n+      val model = mlr.fit(dataset)\n+      model.transform(dataset)\n+        .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+        .collect()\n+      assert(model.getFeaturesCol === \"features\")\n+      assert(model.getPredictionCol === \"prediction\")\n+      assert(model.getRawPredictionCol === \"rawPrediction\")\n+      assert(model.getProbabilityCol === \"probability\")\n+      assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+      assert(model.hasParent)\n+    }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "done\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:01:27Z",
    "diffHunk": "@@ -0,0 +1,1001 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1).saveAsTextFile(\"target/tmp/LogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+    test(\"params\") {\n+      ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+      val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+        Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+      ParamsSuite.checkParams(model)\n+    }\n+\n+    test(\"multinomial logistic regression: default params\") {\n+      val mlr = new MultinomialLogisticRegression\n+      assert(mlr.getLabelCol === \"label\")\n+      assert(mlr.getFeaturesCol === \"features\")\n+      assert(mlr.getPredictionCol === \"prediction\")\n+      assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+      assert(mlr.getProbabilityCol === \"probability\")\n+      assert(!mlr.isDefined(mlr.weightCol))\n+      assert(!mlr.isDefined(mlr.thresholds))\n+      assert(mlr.getFitIntercept)\n+      assert(mlr.getStandardization)\n+      val model = mlr.fit(dataset)\n+      model.transform(dataset)\n+        .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+        .collect()\n+      assert(model.getFeaturesCol === \"features\")\n+      assert(model.getPredictionCol === \"prediction\")\n+      assert(model.getRawPredictionCol === \"rawPrediction\")\n+      assert(model.getProbabilityCol === \"probability\")\n+      assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+      assert(model.hasParent)\n+    }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }"
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "add one line\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T01:56:34Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "done\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:00:36Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }"
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "TODO in followup: `test(\"binary logistic regression with intercept with strong L1 regularization\")` should give you the intercepts we computed in the initialization. But we have smoothing, so I don't know how difference will they be.\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T01:58:47Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "Added a placeholder for the test\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:00:58Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+"
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Let's test if the intercepts are always centered in all the previous tests in case we miss something. Test if the coefficients are centered when no regularization in all the previous tests.\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T02:02:48Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)",
    "line": 890
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "done\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:00:28Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)",
    "line": 890
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "move it up to the same line\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T02:03:55Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)\n+  }\n+\n+  test(\"numClasses specified in metadata/inferred\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+\n+    // specify more classes than unique label values\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(4).toMetadata()\n+    val df = dataset.select(dataset(\"label\").as(\"label\", labelMeta), dataset(\"features\"))\n+    val model1 = mlr.fit(df)\n+    assert(model1.numClasses === 4)\n+    assert(model1.intercepts.size === 4)\n+\n+    // specify two classes when there are really three\n+    val labelMeta1 = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(2).toMetadata()\n+    val df1 = dataset.select(dataset(\"label\").as(\"label\", labelMeta1), dataset(\"features\"))\n+    val thrown = intercept[IllegalArgumentException] {\n+      mlr.fit(df1)\n+    }\n+    assert(thrown.getMessage.contains(\n+      \"less than the number of unique labels\"))"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "done\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:00:23Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)\n+  }\n+\n+  test(\"numClasses specified in metadata/inferred\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+\n+    // specify more classes than unique label values\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(4).toMetadata()\n+    val df = dataset.select(dataset(\"label\").as(\"label\", labelMeta), dataset(\"features\"))\n+    val model1 = mlr.fit(df)\n+    assert(model1.numClasses === 4)\n+    assert(model1.intercepts.size === 4)\n+\n+    // specify two classes when there are really three\n+    val labelMeta1 = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(2).toMetadata()\n+    val df1 = dataset.select(dataset(\"label\").as(\"label\", labelMeta1), dataset(\"features\"))\n+    val thrown = intercept[IllegalArgumentException] {\n+      mlr.fit(df1)\n+    }\n+    assert(thrown.getMessage.contains(\n+      \"less than the number of unique labels\"))"
  }],
  "prId": 13796
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "remove extra line\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T02:10:24Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)\n+  }\n+\n+  test(\"numClasses specified in metadata/inferred\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+\n+    // specify more classes than unique label values\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(4).toMetadata()\n+    val df = dataset.select(dataset(\"label\").as(\"label\", labelMeta), dataset(\"features\"))\n+    val model1 = mlr.fit(df)\n+    assert(model1.numClasses === 4)\n+    assert(model1.intercepts.size === 4)\n+\n+    // specify two classes when there are really three\n+    val labelMeta1 = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(2).toMetadata()\n+    val df1 = dataset.select(dataset(\"label\").as(\"label\", labelMeta1), dataset(\"features\"))\n+    val thrown = intercept[IllegalArgumentException] {\n+      mlr.fit(df1)\n+    }\n+    assert(thrown.getMessage.contains(\n+      \"less than the number of unique labels\"))\n+\n+    // mlr should infer the number of classes if not specified\n+    val model3 = mlr.fit(dataset)\n+    assert(model3.numClasses === 3)\n+  }\n+\n+  test(\"all labels the same\") {\n+    val constantData = spark.createDataFrame(Seq(\n+      LabeledPoint(4.0, Vectors.dense(0.0)),\n+      LabeledPoint(4.0, Vectors.dense(1.0)),\n+      LabeledPoint(4.0, Vectors.dense(2.0)))\n+    )\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(6).toMetadata()\n+    val constantDataWithMetadata = constantData\n+      .select(constantData(\"label\").as(\"label\", labelMeta), constantData(\"features\"))\n+    val mlr = new MultinomialLogisticRegression\n+    val model = mlr.fit(constantData)\n+    val results = model.transform(constantData)\n+    results.select(\"rawPrediction\", \"probability\", \"prediction\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector, pred: Double) =>\n+        assert(raw === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, Double.PositiveInfinity)))\n+        assert(prob === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, 1.0)))\n+        assert(pred === 4.0)\n+    }\n+\n+    // ensure that the correct value is predicted when numClasses passed through metadata\n+    val modelWithMetadata = mlr.fit(constantDataWithMetadata)\n+    val resultsWithMetadata = modelWithMetadata.transform(constantDataWithMetadata)\n+    resultsWithMetadata.select(\"rawPrediction\", \"probability\", \"prediction\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector, pred: Double) =>\n+        assert(raw === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, Double.PositiveInfinity, 0.0)))\n+        assert(prob === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, 1.0, 0.0)))\n+        assert(pred === 4.0)\n+    }\n+    // TODO: check num iters is zero when it become available in the model\n+  }\n+\n+  test(\"weighted data\") {\n+    val numClasses = 5\n+    val numPoints = 40\n+    val outlierData = MLTestingUtils.genClassificationInstancesWithWeightedOutliers(spark,\n+      numClasses, numPoints)\n+    val testData = spark.createDataFrame(Array.tabulate[LabeledPoint](numClasses) { i =>\n+      LabeledPoint(i.toDouble, Vectors.dense(i.toDouble))\n+    })\n+    val mlr = new MultinomialLogisticRegression().setWeightCol(\"weight\")\n+    val model = mlr.fit(outlierData)\n+    val results = model.transform(testData).select(\"label\", \"prediction\").collect()\n+\n+    // check that the predictions are the one to one mapping\n+    results.foreach { case Row(label: Double, pred: Double) =>\n+      assert(label === pred)\n+    }\n+    val (overSampledData, weightedData) =\n+      MLTestingUtils.genEquivalentOversampledAndWeightedInstances(outlierData, \"label\", \"features\",\n+        42L)\n+    val weightedModel = mlr.fit(weightedData)\n+    val overSampledModel = mlr.setWeightCol(\"\").fit(overSampledData)\n+    assert(weightedModel.coefficients ~== overSampledModel.coefficients relTol 0.01)\n+  }\n+\n+  test(\"thresholds prediction\") {\n+    val mlr = new MultinomialLogisticRegression\n+    val model = mlr.fit(dataset)\n+    val basePredictions = model.transform(dataset).select(\"prediction\").collect()\n+\n+    // should predict all zeros\n+    model.setThresholds(Array(1, 1000, 1000))\n+    val zeroPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(zeroPredictions.forall(_.getDouble(0) === 0.0))\n+\n+    // should predict all ones\n+    model.setThresholds(Array(1000, 1, 1000))\n+    val onePredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(onePredictions.forall(_.getDouble(0) === 1.0))\n+\n+    // should predict all twos\n+    model.setThresholds(Array(1000, 1000, 1))\n+    val twoPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(twoPredictions.forall(_.getDouble(0) === 2.0))\n+\n+    // constant threshold scaling is the same as no thresholds\n+    model.setThresholds(Array(1000, 1000, 1000))\n+    val scaledPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(scaledPredictions.zip(basePredictions).forall { case (scaled, base) =>\n+      scaled.getDouble(0) === base.getDouble(0)\n+    })\n+"
  }, {
    "author": {
      "login": "sethah"
    },
    "body": "done\n",
    "commit": "fc2aa95dc89cae21d9d66d47598ddb37b787202b",
    "createdAt": "2016-08-19T03:00:06Z",
    "diffHunk": "@@ -0,0 +1,1016 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.classification.LogisticRegressionSuite._\n+import org.apache.spark.ml.feature.LabeledPoint\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param.ParamsSuite\n+import org.apache.spark.ml.util.{DefaultReadWriteTest, MLTestingUtils}\n+import org.apache.spark.ml.util.TestingUtils._\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+import org.apache.spark.sql.{DataFrame, Dataset, Row}\n+\n+class MultinomialLogisticRegressionSuite\n+  extends SparkFunSuite with MLlibTestSparkContext with DefaultReadWriteTest {\n+\n+  @transient var dataset: Dataset[_] = _\n+  @transient var multinomialDataset: DataFrame = _\n+  private val eps: Double = 1e-5\n+\n+  override def beforeAll(): Unit = {\n+    super.beforeAll()\n+\n+    dataset = {\n+      val nPoints = 100\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077,\n+        -0.16624, -0.84355, -0.048509)\n+\n+      val xMean = Array(5.843, 3.057)\n+      val xVariance = Array(0.6856, 0.1899)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+\n+    multinomialDataset = {\n+      val nPoints = 10000\n+      val coefficients = Array(\n+        -0.57997, 0.912083, -0.371077, -0.819866, 2.688191,\n+        -0.16624, -0.84355, -0.048509, -0.301789, 4.170682)\n+\n+      val xMean = Array(5.843, 3.057, 3.758, 1.199)\n+      val xVariance = Array(0.6856, 0.1899, 3.116, 0.581)\n+\n+      val testData = generateMultinomialLogisticInput(\n+        coefficients, xMean, xVariance, addIntercept = true, nPoints, 42)\n+\n+      val df = spark.createDataFrame(sc.parallelize(testData, 4))\n+      df.cache()\n+      df\n+    }\n+  }\n+\n+  /**\n+   * Enable the ignored test to export the dataset into CSV format,\n+   * so we can validate the training accuracy compared with R's glmnet package.\n+   */\n+  ignore(\"export test data into CSV format\") {\n+    val rdd = multinomialDataset.rdd.map { case Row(label: Double, features: Vector) =>\n+      label + \",\" + features.toArray.mkString(\",\")\n+    }.repartition(1)\n+    rdd.saveAsTextFile(\"target/tmp/MultinomialLogisticRegressionSuite/multinomialDataset\")\n+  }\n+\n+  test(\"params\") {\n+    ParamsSuite.checkParams(new MultinomialLogisticRegression)\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(2, 1, Array(0.0, 0.0)), Vectors.dense(0.0, 0.0), 2)\n+    ParamsSuite.checkParams(model)\n+  }\n+\n+  test(\"multinomial logistic regression: default params\") {\n+    val mlr = new MultinomialLogisticRegression\n+    assert(mlr.getLabelCol === \"label\")\n+    assert(mlr.getFeaturesCol === \"features\")\n+    assert(mlr.getPredictionCol === \"prediction\")\n+    assert(mlr.getRawPredictionCol === \"rawPrediction\")\n+    assert(mlr.getProbabilityCol === \"probability\")\n+    assert(!mlr.isDefined(mlr.weightCol))\n+    assert(!mlr.isDefined(mlr.thresholds))\n+    assert(mlr.getFitIntercept)\n+    assert(mlr.getStandardization)\n+    val model = mlr.fit(dataset)\n+    model.transform(dataset)\n+      .select(\"label\", \"probability\", \"prediction\", \"rawPrediction\")\n+      .collect()\n+    assert(model.getFeaturesCol === \"features\")\n+    assert(model.getPredictionCol === \"prediction\")\n+    assert(model.getRawPredictionCol === \"rawPrediction\")\n+    assert(model.getProbabilityCol === \"probability\")\n+    assert(model.intercepts !== Vectors.dense(0.0, 0.0))\n+    assert(model.hasParent)\n+  }\n+\n+  test(\"multinomial logistic regression with intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true).setMaxIter(100)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       > library(\"glmnet\")\n+       > data <- read.csv(\"path\", header=FALSE)\n+       > label = as.factor(data$V1)\n+       > features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       > coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -2.24493379\n+        V2  0.25096771\n+        V3 -0.03915938\n+        V4  0.14766639\n+        V5  0.36810817\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.3778931\n+        V2 -0.3327489\n+        V3  0.8893666\n+        V4 -0.2306948\n+        V5 -0.4442330\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            1.86704066\n+        V2  0.08178121\n+        V3 -0.85020722\n+        V4  0.08302840\n+        V5  0.07612480\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.2509677, -0.0391594, 0.1476664, 0.3681082,\n+      -0.3327489, 0.8893666, -0.2306948, -0.4442330,\n+      0.0817812, -0.8502072, 0.0830284, 0.0761248), isTransposed = true)\n+    val interceptsR = Vectors.dense(-2.2449338, 0.3778931, 1.8670407)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts ~== interceptsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept without regularization\") {\n+\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.0).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Using the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0, lambda = 0,\n+        intercept=F))\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+            .\n+        V2  0.06992464\n+        V3 -0.36562784\n+        V4  0.12142680\n+        V5  0.32052211\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2 -0.3036269\n+        V3  0.9449630\n+        V4 -0.2271038\n+        V5 -0.4364839\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            .\n+        V2  0.2337022\n+        V3 -0.5793351\n+        V4  0.1056770\n+        V5  0.1159618\n+     */\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0699246, -0.3656278, 0.1214268, 0.3205221,\n+      -0.3036269, 0.9449630, -0.2271038, -0.4364839,\n+      0.2337022, -0.5793351, 0.1056770, 0.1159618), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L1 regularization\") {\n+\n+    // use tighter constraints because OWL-QN solver takes longer to converge\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+\n+    /*\n+       Use the following R code to load the data and train the model using glmnet package.\n+       library(\"glmnet\")\n+       data <- read.csv(\"path\", header=FALSE)\n+       label = as.factor(data$V1)\n+       features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+       coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+        lambda = 0.05, standardization=T))\n+       coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+        standardization=F))\n+       > coefficientsStd\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.68988825\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  0.09404023\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2303499\n+        V2 -0.1232443\n+        V3  0.3258380\n+        V4 -0.1564688\n+        V5 -0.2053965\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.9202381\n+        V2  .\n+        V3 -0.4803856\n+        V4  .\n+        V5  .\n+\n+       > coefficients\n+        $`0`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+           -0.44893320\n+        V2  .\n+        V3  .\n+        V4  0.01933812\n+        V5  0.03666044\n+\n+        $`1`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+            0.7376760\n+        V2 -0.0577182\n+        V3  .\n+        V4 -0.2081718\n+        V5 -0.1304592\n+\n+        $`2`\n+        5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+           -0.2887428\n+        V2  .\n+        V3  .\n+        V4  .\n+        V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.09404023,\n+      -0.1232443, 0.3258380, -0.1564688, -0.2053965,\n+      0.0, -0.4803856, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.68988825, -0.2303499, 0.9202381)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.01933812, 0.03666044,\n+      -0.0577182, 0.0, -0.2081718, -0.1304592,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.44893320, 0.7376760, -0.2887428)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.02)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.1)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.02)\n+    assert(model2.intercepts ~== interceptsR relTol 0.1)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L1 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(1.0).setRegParam(0.05).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 1,\n+      lambda = 0.05, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 1, lambda = 0.05,\n+      intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.01525105\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1502410\n+      V3  0.5134658\n+      V4 -0.1601146\n+      V5 -0.2500232\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         .\n+      V2 0.003301875\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2  .\n+      V3  0.1943624\n+      V4 -0.1902577\n+      V5 -0.1028789\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.01525105,\n+      -0.1502410, 0.5134658, -0.1601146, -0.2500232,\n+      0.003301875, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.1943624, -0.1902577, -0.1028789,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.70040424\n+      V2  0.17576070\n+      V3  0.01527894\n+      V4  0.10216108\n+      V5  0.26099531\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.2438590\n+      V2 -0.2238875\n+      V3  0.5967610\n+      V4 -0.1555496\n+      V5 -0.3010479\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          1.45654525\n+      V2  0.04812679\n+      V3 -0.61203992\n+      V4  0.05338850\n+      V5  0.04005258\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -1.65488543\n+      V2  0.15715048\n+      V3  0.01992903\n+      V4  0.12428858\n+      V5  0.22130317\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          1.1297533\n+      V2 -0.1974768\n+      V3  0.2776373\n+      V4 -0.1869445\n+      V5 -0.2510320\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.52513212\n+      V2  0.04032627\n+      V3 -0.29756637\n+      V4  0.06265594\n+      V5  0.02972883\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.17576070, 0.01527894, 0.10216108, 0.26099531,\n+      -0.2238875, 0.5967610, -0.1555496, -0.3010479,\n+      0.04812679, -0.61203992, 0.05338850, 0.04005258), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-1.70040424, 0.2438590, 1.45654525)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.15715048, 0.01992903, 0.12428858, 0.22130317,\n+      -0.1974768, 0.2776373, -0.1869445, -0.2510320,\n+      0.04032627, -0.29756637, 0.06265594, 0.02972883), isTransposed = true)\n+    val interceptsR = Vectors.dense(-1.65488543, 1.1297533, 0.52513212)\n+\n+    assert(model1.coefficients ~== coefficientsRStd relTol 0.05)\n+    assert(model1.intercepts ~== interceptsRStd relTol 0.05)\n+    assert(model2.coefficients ~== coefficientsR relTol 0.05)\n+    assert(model2.intercepts ~== interceptsR relTol 0.05)\n+  }\n+\n+  test(\"multinomial logistic regression without intercept with L2 regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(true)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.0).setRegParam(0.1).setStandardization(false)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.03904171\n+      V3 -0.23354322\n+      V4  0.08288096\n+      V5  0.22706393\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.2061848\n+      V3  0.6341398\n+      V4 -0.1530059\n+      V5 -0.2958455\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.16714312\n+      V3 -0.40059658\n+      V4  0.07012496\n+      V5  0.06878158\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                   s0\n+          .\n+      V2 -0.005704542\n+      V3 -0.144466409\n+      V4  0.092080736\n+      V5  0.182927657\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2 -0.08469036\n+      V3  0.38996748\n+      V4 -0.16468436\n+      V5 -0.22522976\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  0.09039490\n+      V3 -0.24550107\n+      V4  0.07260362\n+      V5  0.04230210\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.03904171, -0.23354322, 0.08288096, 0.2270639,\n+      -0.2061848, 0.6341398, -0.1530059, -0.2958455,\n+      0.16714312, -0.40059658, 0.07012496, 0.06878158), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      -0.005704542, -0.144466409, 0.092080736, 0.182927657,\n+      -0.08469036, 0.38996748, -0.16468436, -0.22522976,\n+      0.0903949, -0.24550107, 0.07260362, 0.0423021), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"multinomial logistic regression with intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(true)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=T, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                    s0\n+         -0.5521819483\n+      V2  0.0003092611\n+      V3  .\n+      V4  .\n+      V5  0.0913818490\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.27531989\n+      V2 -0.09790029\n+      V3  0.28502034\n+      V4 -0.12416487\n+      V5 -0.16513373\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          0.8275018\n+      V2  .\n+      V3 -0.4044859\n+      V4  .\n+      V5  .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+         -0.39876213\n+      V2  .\n+      V3  .\n+      V4  0.02547520\n+      V5  0.03893991\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          0.61089869\n+      V2 -0.04224269\n+      V3  .\n+      V4 -0.18923970\n+      V5 -0.09104249\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         -0.2121366\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0003092611, 0.0, 0.0, 0.091381849,\n+      -0.09790029, 0.28502034, -0.12416487, -0.16513373,\n+      0.0, -0.4044859, 0.0, 0.0), isTransposed = true)\n+    val interceptsRStd = Vectors.dense(-0.5521819483, -0.27531989, 0.8275018)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0254752, 0.03893991,\n+      -0.04224269, 0.0, -0.1892397, -0.09104249,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+    val interceptsR = Vectors.dense(-0.39876213, 0.61089869, -0.2121366)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts ~== interceptsRStd absTol 0.01)\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts ~== interceptsR absTol 0.01)\n+  }\n+  test(\"multinomial logistic regression without intercept with elasticnet regularization\") {\n+    val trainer1 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(true)\n+      .setMaxIter(300).setTol(1e-10)\n+    val trainer2 = (new MultinomialLogisticRegression).setFitIntercept(false)\n+      .setElasticNetParam(0.5).setRegParam(0.1).setStandardization(false)\n+      .setMaxIter(300).setTol(1e-10)\n+\n+    val model1 = trainer1.fit(multinomialDataset)\n+    val model2 = trainer2.fit(multinomialDataset)\n+    /*\n+      Use the following R code to load the data and train the model using glmnet package.\n+      library(\"glmnet\")\n+      data <- read.csv(\"path\", header=FALSE)\n+      label = as.factor(data$V1)\n+      features = as.matrix(data.frame(data$V2, data$V3, data$V4, data$V5))\n+      coefficientsStd = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=T))\n+      coefficients = coef(glmnet(features, label, family=\"multinomial\", alpha = 0.5,\n+      lambda = 0.1, intercept=F, standardization=F))\n+      > coefficientsStd\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 .\n+      V3 .\n+      V4 .\n+      V5 0.03543706\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+          .\n+      V2 -0.1187387\n+      V3  0.4025482\n+      V4 -0.1270969\n+      V5 -0.1918386\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                 s0\n+         .\n+      V2 0.00774365\n+      V3 .\n+      V4 .\n+      V5 .\n+\n+      > coefficients\n+      $`0`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+\n+      $`1`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+                  s0\n+          .\n+      V2  .\n+      V3  0.14666497\n+      V4 -0.16570638\n+      V5 -0.05982875\n+\n+      $`2`\n+      5 x 1 sparse Matrix of class \"dgCMatrix\"\n+         s0\n+          .\n+      V2  .\n+      V3  .\n+      V4  .\n+      V5  .\n+     */\n+    val coefficientsRStd = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.03543706,\n+      -0.1187387, 0.4025482, -0.1270969, -0.1918386,\n+      0.0, 0.0, 0.0, 0.00774365), isTransposed = true)\n+\n+    val coefficientsR = new DenseMatrix(3, 4, Array(\n+      0.0, 0.0, 0.0, 0.0,\n+      0.0, 0.14666497, -0.16570638, -0.05982875,\n+      0.0, 0.0, 0.0, 0.0), isTransposed = true)\n+\n+    assert(model1.coefficients ~== coefficientsRStd absTol 0.01)\n+    assert(model1.intercepts.toArray === Array.fill(3)(0.0))\n+    assert(model2.coefficients ~== coefficientsR absTol 0.01)\n+    assert(model2.intercepts.toArray === Array.fill(3)(0.0))\n+  }\n+\n+  test(\"prediction\") {\n+    val model = new MultinomialLogisticRegressionModel(\"mLogReg\",\n+      Matrices.dense(3, 2, Array(0.0, 0.0, 0.0, 1.0, 2.0, 3.0)),\n+      Vectors.dense(0.0, 0.0, 0.0), 3)\n+    val overFlowData = spark.createDataFrame(Seq(\n+      LabeledPoint(1.0, Vectors.dense(0.0, 1000.0)),\n+      LabeledPoint(1.0, Vectors.dense(0.0, -1.0))\n+    ))\n+    val results = model.transform(overFlowData).select(\"rawPrediction\", \"probability\").collect()\n+\n+    // probabilities are correct when margins have to be adjusted\n+    val raw1 = results(0).getAs[Vector](0)\n+    val prob1 = results(0).getAs[Vector](1)\n+    assert(raw1 === Vectors.dense(1000.0, 2000.0, 3000.0))\n+    assert(prob1 ~== Vectors.dense(0.0, 0.0, 1.0) absTol eps)\n+\n+    // probabilities are correct when margins don't have to be adjusted\n+    val raw2 = results(1).getAs[Vector](0)\n+    val prob2 = results(1).getAs[Vector](1)\n+    assert(raw2 === Vectors.dense(-1.0, -2.0, -3.0))\n+    assert(prob2 ~== Vectors.dense(0.66524096, 0.24472847, 0.09003057) relTol eps)\n+  }\n+\n+  test(\"multinomial logistic regression: Predictor, Classifier methods\") {\n+    val mlr = new MultinomialLogisticRegression\n+\n+    val model = mlr.fit(dataset)\n+    assert(model.numClasses === 3)\n+    val numFeatures = dataset.select(\"features\").first().getAs[Vector](0).size\n+    assert(model.numFeatures === numFeatures)\n+\n+    val results = model.transform(dataset)\n+    // check that raw prediction is coefficients dot features + intercept\n+    results.select(\"rawPrediction\", \"features\").collect().foreach {\n+      case Row(raw: Vector, features: Vector) =>\n+        assert(raw.size === 3)\n+        val margins = Array.tabulate(3) { k =>\n+          var margin = 0.0\n+          features.foreachActive { (index, value) =>\n+            margin += value * model.coefficients(k, index)\n+          }\n+          margin += model.intercepts(k)\n+          margin\n+        }\n+        assert(raw ~== Vectors.dense(margins) relTol eps)\n+    }\n+\n+    // Compare rawPrediction with probability\n+    results.select(\"rawPrediction\", \"probability\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector) =>\n+        assert(raw.size === 3)\n+        assert(prob.size === 3)\n+        val max = raw.toArray.max\n+        val subtract = if (max > 0) max else 0.0\n+        val sum = raw.toArray.map(x => math.exp(x - subtract)).sum\n+        val probFromRaw0 = math.exp(raw(0) - subtract) / sum\n+        val probFromRaw1 = math.exp(raw(1) - subtract) / sum\n+        assert(prob(0) ~== probFromRaw0 relTol eps)\n+        assert(prob(1) ~== probFromRaw1 relTol eps)\n+        assert(prob(2) ~== 1.0 - probFromRaw1 - probFromRaw0 relTol eps)\n+    }\n+\n+    // Compare prediction with probability\n+    results.select(\"prediction\", \"probability\").collect().foreach {\n+      case Row(pred: Double, prob: Vector) =>\n+        val predFromProb = prob.toArray.zipWithIndex.maxBy(_._1)._2\n+        assert(pred == predFromProb)\n+    }\n+  }\n+\n+  test(\"multinomial logistic regression coefficients should be centered\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+    val model = mlr.fit(dataset)\n+    assert(model.intercepts.toArray.sum ~== 0.0 absTol 1e-6)\n+    assert(model.coefficients.toArray.sum ~== 0.0 absTol 1e-6)\n+  }\n+\n+  test(\"numClasses specified in metadata/inferred\") {\n+    val mlr = new MultinomialLogisticRegression().setMaxIter(1)\n+\n+    // specify more classes than unique label values\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(4).toMetadata()\n+    val df = dataset.select(dataset(\"label\").as(\"label\", labelMeta), dataset(\"features\"))\n+    val model1 = mlr.fit(df)\n+    assert(model1.numClasses === 4)\n+    assert(model1.intercepts.size === 4)\n+\n+    // specify two classes when there are really three\n+    val labelMeta1 = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(2).toMetadata()\n+    val df1 = dataset.select(dataset(\"label\").as(\"label\", labelMeta1), dataset(\"features\"))\n+    val thrown = intercept[IllegalArgumentException] {\n+      mlr.fit(df1)\n+    }\n+    assert(thrown.getMessage.contains(\n+      \"less than the number of unique labels\"))\n+\n+    // mlr should infer the number of classes if not specified\n+    val model3 = mlr.fit(dataset)\n+    assert(model3.numClasses === 3)\n+  }\n+\n+  test(\"all labels the same\") {\n+    val constantData = spark.createDataFrame(Seq(\n+      LabeledPoint(4.0, Vectors.dense(0.0)),\n+      LabeledPoint(4.0, Vectors.dense(1.0)),\n+      LabeledPoint(4.0, Vectors.dense(2.0)))\n+    )\n+    val labelMeta = NominalAttribute.defaultAttr.withName(\"label\").withNumValues(6).toMetadata()\n+    val constantDataWithMetadata = constantData\n+      .select(constantData(\"label\").as(\"label\", labelMeta), constantData(\"features\"))\n+    val mlr = new MultinomialLogisticRegression\n+    val model = mlr.fit(constantData)\n+    val results = model.transform(constantData)\n+    results.select(\"rawPrediction\", \"probability\", \"prediction\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector, pred: Double) =>\n+        assert(raw === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, Double.PositiveInfinity)))\n+        assert(prob === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, 1.0)))\n+        assert(pred === 4.0)\n+    }\n+\n+    // ensure that the correct value is predicted when numClasses passed through metadata\n+    val modelWithMetadata = mlr.fit(constantDataWithMetadata)\n+    val resultsWithMetadata = modelWithMetadata.transform(constantDataWithMetadata)\n+    resultsWithMetadata.select(\"rawPrediction\", \"probability\", \"prediction\").collect().foreach {\n+      case Row(raw: Vector, prob: Vector, pred: Double) =>\n+        assert(raw === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, Double.PositiveInfinity, 0.0)))\n+        assert(prob === Vectors.dense(Array(0.0, 0.0, 0.0, 0.0, 1.0, 0.0)))\n+        assert(pred === 4.0)\n+    }\n+    // TODO: check num iters is zero when it become available in the model\n+  }\n+\n+  test(\"weighted data\") {\n+    val numClasses = 5\n+    val numPoints = 40\n+    val outlierData = MLTestingUtils.genClassificationInstancesWithWeightedOutliers(spark,\n+      numClasses, numPoints)\n+    val testData = spark.createDataFrame(Array.tabulate[LabeledPoint](numClasses) { i =>\n+      LabeledPoint(i.toDouble, Vectors.dense(i.toDouble))\n+    })\n+    val mlr = new MultinomialLogisticRegression().setWeightCol(\"weight\")\n+    val model = mlr.fit(outlierData)\n+    val results = model.transform(testData).select(\"label\", \"prediction\").collect()\n+\n+    // check that the predictions are the one to one mapping\n+    results.foreach { case Row(label: Double, pred: Double) =>\n+      assert(label === pred)\n+    }\n+    val (overSampledData, weightedData) =\n+      MLTestingUtils.genEquivalentOversampledAndWeightedInstances(outlierData, \"label\", \"features\",\n+        42L)\n+    val weightedModel = mlr.fit(weightedData)\n+    val overSampledModel = mlr.setWeightCol(\"\").fit(overSampledData)\n+    assert(weightedModel.coefficients ~== overSampledModel.coefficients relTol 0.01)\n+  }\n+\n+  test(\"thresholds prediction\") {\n+    val mlr = new MultinomialLogisticRegression\n+    val model = mlr.fit(dataset)\n+    val basePredictions = model.transform(dataset).select(\"prediction\").collect()\n+\n+    // should predict all zeros\n+    model.setThresholds(Array(1, 1000, 1000))\n+    val zeroPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(zeroPredictions.forall(_.getDouble(0) === 0.0))\n+\n+    // should predict all ones\n+    model.setThresholds(Array(1000, 1, 1000))\n+    val onePredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(onePredictions.forall(_.getDouble(0) === 1.0))\n+\n+    // should predict all twos\n+    model.setThresholds(Array(1000, 1000, 1))\n+    val twoPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(twoPredictions.forall(_.getDouble(0) === 2.0))\n+\n+    // constant threshold scaling is the same as no thresholds\n+    model.setThresholds(Array(1000, 1000, 1000))\n+    val scaledPredictions = model.transform(dataset).select(\"prediction\").collect()\n+    assert(scaledPredictions.zip(basePredictions).forall { case (scaled, base) =>\n+      scaled.getDouble(0) === base.getDouble(0)\n+    })\n+"
  }],
  "prId": 13796
}]