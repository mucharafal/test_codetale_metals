[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I don't think this is a problem, just curious: the order of terms in an interaction doesn't matter, but I wonder if we handle the case that say a:c and c:a are generated, and only return a:c? might be worth one test case somewhere.",
    "commit": "e911ae0da8437b3574cfa3ac70679d6c85156c7e",
    "createdAt": "2019-06-02T13:32:59Z",
    "diffHunk": "@@ -90,12 +90,48 @@ class RFormulaParserSuite extends SparkFunSuite {\n \n   test(\"parse interactions\") {\n     checkParse(\"y ~ a:b\", \"y\", Seq(\"a:b\"))\n+    checkParse(\"y ~ a:b + b:a\", \"y\", Seq(\"a:b\"))\n     checkParse(\"y ~ ._a:._x\", \"y\", Seq(\"._a:._x\"))\n     checkParse(\"y ~ foo:bar\", \"y\", Seq(\"foo:bar\"))\n     checkParse(\"y ~ a : b : c\", \"y\", Seq(\"a:b:c\"))\n     checkParse(\"y ~ q + a:b:c + b:c + c:d + z\", \"y\", Seq(\"q\", \"a:b:c\", \"b:c\", \"c:d\", \"z\"))\n   }\n \n+  test(\"parse factor cross\") {\n+    checkParse(\"y ~ a*b\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ a*b + b*a\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ ._a*._x\", \"y\", Seq(\"._a\", \"._x\", \"._a:._x\"))\n+    checkParse(\"y ~ foo*bar\", \"y\", Seq(\"foo\", \"bar\", \"foo:bar\"))\n+    checkParse(\"y ~ a * b * c\", \"y\", Seq(\"a\", \"b\", \"a:b\", \"c\", \"a:c\", \"b:c\", \"a:b:c\"))\n+  }\n+\n+  test(\"interaction distributive\") {\n+    checkParse(\"y ~ (a + b):c\", \"y\", Seq(\"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c:(a + b)\", \"y\", Seq(\"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"factor cross distributive\") {\n+    checkParse(\"y ~ (a + b)*c\", \"y\", Seq(\"a\", \"b\", \"c\", \"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c*(a + b)\", \"y\", Seq(\"c\", \"a\", \"b\", \"c:a\", \"c:b\"))",
    "line": 26
  }, {
    "author": {
      "login": "ozancicek"
    },
    "body": "Yes that's right, if we end up generating `a:c` and `c:a`, only `a:c` should return. I've added some checks for that on lines 93 and 102 on RFormulaParserSuite.scala. Do you have additional test cases in mind or are those good enough?  ",
    "commit": "e911ae0da8437b3574cfa3ac70679d6c85156c7e",
    "createdAt": "2019-06-03T09:09:14Z",
    "diffHunk": "@@ -90,12 +90,48 @@ class RFormulaParserSuite extends SparkFunSuite {\n \n   test(\"parse interactions\") {\n     checkParse(\"y ~ a:b\", \"y\", Seq(\"a:b\"))\n+    checkParse(\"y ~ a:b + b:a\", \"y\", Seq(\"a:b\"))\n     checkParse(\"y ~ ._a:._x\", \"y\", Seq(\"._a:._x\"))\n     checkParse(\"y ~ foo:bar\", \"y\", Seq(\"foo:bar\"))\n     checkParse(\"y ~ a : b : c\", \"y\", Seq(\"a:b:c\"))\n     checkParse(\"y ~ q + a:b:c + b:c + c:d + z\", \"y\", Seq(\"q\", \"a:b:c\", \"b:c\", \"c:d\", \"z\"))\n   }\n \n+  test(\"parse factor cross\") {\n+    checkParse(\"y ~ a*b\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ a*b + b*a\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ ._a*._x\", \"y\", Seq(\"._a\", \"._x\", \"._a:._x\"))\n+    checkParse(\"y ~ foo*bar\", \"y\", Seq(\"foo\", \"bar\", \"foo:bar\"))\n+    checkParse(\"y ~ a * b * c\", \"y\", Seq(\"a\", \"b\", \"a:b\", \"c\", \"a:c\", \"b:c\", \"a:b:c\"))\n+  }\n+\n+  test(\"interaction distributive\") {\n+    checkParse(\"y ~ (a + b):c\", \"y\", Seq(\"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c:(a + b)\", \"y\", Seq(\"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"factor cross distributive\") {\n+    checkParse(\"y ~ (a + b)*c\", \"y\", Seq(\"a\", \"b\", \"c\", \"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c*(a + b)\", \"y\", Seq(\"c\", \"a\", \"b\", \"c:a\", \"c:b\"))",
    "line": 26
  }],
  "prId": 24764
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Finally just wondering about corner cases... what does `(a+b)^1` or `^0` give?",
    "commit": "e911ae0da8437b3574cfa3ac70679d6c85156c7e",
    "createdAt": "2019-06-02T13:33:57Z",
    "diffHunk": "@@ -90,12 +90,48 @@ class RFormulaParserSuite extends SparkFunSuite {\n \n   test(\"parse interactions\") {\n     checkParse(\"y ~ a:b\", \"y\", Seq(\"a:b\"))\n+    checkParse(\"y ~ a:b + b:a\", \"y\", Seq(\"a:b\"))\n     checkParse(\"y ~ ._a:._x\", \"y\", Seq(\"._a:._x\"))\n     checkParse(\"y ~ foo:bar\", \"y\", Seq(\"foo:bar\"))\n     checkParse(\"y ~ a : b : c\", \"y\", Seq(\"a:b:c\"))\n     checkParse(\"y ~ q + a:b:c + b:c + c:d + z\", \"y\", Seq(\"q\", \"a:b:c\", \"b:c\", \"c:d\", \"z\"))\n   }\n \n+  test(\"parse factor cross\") {\n+    checkParse(\"y ~ a*b\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ a*b + b*a\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ ._a*._x\", \"y\", Seq(\"._a\", \"._x\", \"._a:._x\"))\n+    checkParse(\"y ~ foo*bar\", \"y\", Seq(\"foo\", \"bar\", \"foo:bar\"))\n+    checkParse(\"y ~ a * b * c\", \"y\", Seq(\"a\", \"b\", \"a:b\", \"c\", \"a:c\", \"b:c\", \"a:b:c\"))\n+  }\n+\n+  test(\"interaction distributive\") {\n+    checkParse(\"y ~ (a + b):c\", \"y\", Seq(\"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c:(a + b)\", \"y\", Seq(\"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"factor cross distributive\") {\n+    checkParse(\"y ~ (a + b)*c\", \"y\", Seq(\"a\", \"b\", \"c\", \"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c*(a + b)\", \"y\", Seq(\"c\", \"a\", \"b\", \"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"parse power\") {\n+    val schema = (new StructType)\n+      .add(\"a\", \"int\", true)\n+      .add(\"b\", \"long\", false)\n+      .add(\"c\", \"string\", true)\n+      .add(\"d\", \"string\", true)\n+    checkParse(\"a ~ (a + b)^2\", \"a\", Seq(\"a\", \"b\", \"a:b\"))",
    "line": 35
  }, {
    "author": {
      "login": "ozancicek"
    },
    "body": "The regex match of ^ operator (line 287 on RFormulaParser.scala) is like this;\r\n\r\n`term ~ \"^\" ~ \"^[1-9]\\\\d*\".r`\r\n\r\nIt only matches numbers larger than 0. So if there is a term with `^0`, directly an exception is raised with `Could not parse formula` message. `^1` terms returns itself, so `(a+b)^1=a+b`\r\n",
    "commit": "e911ae0da8437b3574cfa3ac70679d6c85156c7e",
    "createdAt": "2019-06-03T09:03:50Z",
    "diffHunk": "@@ -90,12 +90,48 @@ class RFormulaParserSuite extends SparkFunSuite {\n \n   test(\"parse interactions\") {\n     checkParse(\"y ~ a:b\", \"y\", Seq(\"a:b\"))\n+    checkParse(\"y ~ a:b + b:a\", \"y\", Seq(\"a:b\"))\n     checkParse(\"y ~ ._a:._x\", \"y\", Seq(\"._a:._x\"))\n     checkParse(\"y ~ foo:bar\", \"y\", Seq(\"foo:bar\"))\n     checkParse(\"y ~ a : b : c\", \"y\", Seq(\"a:b:c\"))\n     checkParse(\"y ~ q + a:b:c + b:c + c:d + z\", \"y\", Seq(\"q\", \"a:b:c\", \"b:c\", \"c:d\", \"z\"))\n   }\n \n+  test(\"parse factor cross\") {\n+    checkParse(\"y ~ a*b\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ a*b + b*a\", \"y\", Seq(\"a\", \"b\", \"a:b\"))\n+    checkParse(\"y ~ ._a*._x\", \"y\", Seq(\"._a\", \"._x\", \"._a:._x\"))\n+    checkParse(\"y ~ foo*bar\", \"y\", Seq(\"foo\", \"bar\", \"foo:bar\"))\n+    checkParse(\"y ~ a * b * c\", \"y\", Seq(\"a\", \"b\", \"a:b\", \"c\", \"a:c\", \"b:c\", \"a:b:c\"))\n+  }\n+\n+  test(\"interaction distributive\") {\n+    checkParse(\"y ~ (a + b):c\", \"y\", Seq(\"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c:(a + b)\", \"y\", Seq(\"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"factor cross distributive\") {\n+    checkParse(\"y ~ (a + b)*c\", \"y\", Seq(\"a\", \"b\", \"c\", \"a:c\", \"b:c\"))\n+    checkParse(\"y ~ c*(a + b)\", \"y\", Seq(\"c\", \"a\", \"b\", \"c:a\", \"c:b\"))\n+  }\n+\n+  test(\"parse power\") {\n+    val schema = (new StructType)\n+      .add(\"a\", \"int\", true)\n+      .add(\"b\", \"long\", false)\n+      .add(\"c\", \"string\", true)\n+      .add(\"d\", \"string\", true)\n+    checkParse(\"a ~ (a + b)^2\", \"a\", Seq(\"a\", \"b\", \"a:b\"))",
    "line": 35
  }],
  "prId": 24764
}]