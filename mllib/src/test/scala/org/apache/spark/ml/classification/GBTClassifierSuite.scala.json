[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Let's also assert `modelWithoutValidation.numTrees == numIter`.  That's true now, but I could imagine it changing later on if we add a convergence tolerance to the algorithm.",
    "commit": "532f0d8a873032a87eb73e1e585e322275cb1678",
    "createdAt": "2018-05-07T22:29:30Z",
    "diffHunk": "@@ -365,6 +366,50 @@ class GBTClassifierSuite extends MLTest with DefaultReadWriteTest {\n     assert(mostImportantFeature !== mostIF)\n   }\n \n+  test(\"runWithValidation stops early and performs better on a validation dataset\") {\n+    val validationIndicatorCol = \"validationIndicator\"\n+    val trainDF = trainData.toDF().withColumn(validationIndicatorCol, lit(false))\n+    val validationDF = validationData.toDF().withColumn(validationIndicatorCol, lit(true))\n+\n+    val numIter = 20\n+    for (lossType <- GBTClassifier.supportedLossTypes) {\n+      val gbt = new GBTClassifier()\n+        .setSeed(123)\n+        .setMaxDepth(2)\n+        .setLossType(lossType)\n+        .setMaxIter(numIter)\n+      val modelWithoutValidation = gbt.fit(trainDF)\n+\n+      gbt.setValidationIndicatorCol(validationIndicatorCol)\n+      val modelWithValidation = gbt.fit(trainDF.union(validationDF))\n+\n+      // early stop\n+      assert(modelWithValidation.numTrees < numIter)"
  }],
  "prId": 21129
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "It'd be nice to have this be strictly true. Is it not?",
    "commit": "532f0d8a873032a87eb73e1e585e322275cb1678",
    "createdAt": "2018-05-07T22:43:32Z",
    "diffHunk": "@@ -365,6 +366,50 @@ class GBTClassifierSuite extends MLTest with DefaultReadWriteTest {\n     assert(mostImportantFeature !== mostIF)\n   }\n \n+  test(\"runWithValidation stops early and performs better on a validation dataset\") {\n+    val validationIndicatorCol = \"validationIndicator\"\n+    val trainDF = trainData.toDF().withColumn(validationIndicatorCol, lit(false))\n+    val validationDF = validationData.toDF().withColumn(validationIndicatorCol, lit(true))\n+\n+    val numIter = 20\n+    for (lossType <- GBTClassifier.supportedLossTypes) {\n+      val gbt = new GBTClassifier()\n+        .setSeed(123)\n+        .setMaxDepth(2)\n+        .setLossType(lossType)\n+        .setMaxIter(numIter)\n+      val modelWithoutValidation = gbt.fit(trainDF)\n+\n+      gbt.setValidationIndicatorCol(validationIndicatorCol)\n+      val modelWithValidation = gbt.fit(trainDF.union(validationDF))\n+\n+      // early stop\n+      assert(modelWithValidation.numTrees < numIter)\n+\n+      val (errorWithoutValidation, errorWithValidation) = {\n+        val remappedRdd = validationData.map(x => new LabeledPoint(2 * x.label - 1, x.features))\n+        (GradientBoostedTrees.computeError(remappedRdd, modelWithoutValidation.trees,\n+          modelWithoutValidation.treeWeights, modelWithoutValidation.getOldLossType),\n+          GradientBoostedTrees.computeError(remappedRdd, modelWithValidation.trees,\n+            modelWithValidation.treeWeights, modelWithValidation.getOldLossType))\n+      }\n+      assert(errorWithValidation <= errorWithoutValidation)"
  }],
  "prId": 21129
}]