[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "trees --> validateTrees\nsame for treeWeights\n",
    "commit": "62735ee71dd5156f239c7acf1818400680c4351e",
    "createdAt": "2016-04-06T20:35:05Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.mllib.tree.{GradientBoostedTreesSuite => OldGBTSuite}\n+import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.impurity.Variance\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, LogLoss, SquaredError}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+/**\n+ * Test suite for [[GradientBoostedTrees]].\n+ */\n+class GradientBoostedTreesSuite extends SparkFunSuite with MLlibTestSparkContext with Logging {\n+\n+  test(\"runWithValidation stops early and performs better on a validation dataset\") {\n+    // Set numIterations large enough so that it stops early.\n+    val numIterations = 20\n+    val trainRdd = sc.parallelize(OldGBTSuite.trainData, 2)\n+    val validateRdd = sc.parallelize(OldGBTSuite.validateData, 2)\n+    val trainDF = sqlContext.createDataFrame(trainRdd)\n+    val validateDF = sqlContext.createDataFrame(validateRdd)\n+\n+    val algos = Array(Regression, Regression, Classification)\n+    val losses = Array(SquaredError, AbsoluteError, LogLoss)\n+    algos.zip(losses).foreach { case (algo, loss) =>\n+      val treeStrategy = new Strategy(algo = algo, impurity = Variance, maxDepth = 2,\n+        categoricalFeaturesInfo = Map.empty)\n+      val boostingStrategy =\n+        new BoostingStrategy(treeStrategy, loss, numIterations, validationTol = 0.0)\n+      val (validateTrees, validateTreeWeights) = GradientBoostedTrees\n+        .runWithValidation(trainRdd, validateRdd, boostingStrategy, 42L)\n+      val numTrees = validateTrees.length\n+      assert(numTrees !== numIterations)\n+\n+      // Test that it performs better on the validation dataset.\n+      val (trees, treeWeights) = GradientBoostedTrees.run(trainRdd, boostingStrategy, 42L)\n+      val (errorWithoutValidation, errorWithValidation) = {\n+        if (algo == Classification) {\n+          val remappedRdd = validateRdd.map(x => new LabeledPoint(2 * x.label - 1, x.features))\n+          (GradientBoostedTrees.computeError(remappedRdd, trees, treeWeights, loss),\n+            GradientBoostedTrees.computeError(remappedRdd, trees, treeWeights, loss))"
  }],
  "prId": 12050
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "trees --> validateTrees\nsame for treeWeights\n",
    "commit": "62735ee71dd5156f239c7acf1818400680c4351e",
    "createdAt": "2016-04-06T20:35:06Z",
    "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.SparkFunSuite\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.mllib.tree.{GradientBoostedTreesSuite => OldGBTSuite}\n+import org.apache.spark.mllib.tree.configuration.{BoostingStrategy, Strategy}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.impurity.Variance\n+import org.apache.spark.mllib.tree.loss.{AbsoluteError, LogLoss, SquaredError}\n+import org.apache.spark.mllib.util.MLlibTestSparkContext\n+\n+/**\n+ * Test suite for [[GradientBoostedTrees]].\n+ */\n+class GradientBoostedTreesSuite extends SparkFunSuite with MLlibTestSparkContext with Logging {\n+\n+  test(\"runWithValidation stops early and performs better on a validation dataset\") {\n+    // Set numIterations large enough so that it stops early.\n+    val numIterations = 20\n+    val trainRdd = sc.parallelize(OldGBTSuite.trainData, 2)\n+    val validateRdd = sc.parallelize(OldGBTSuite.validateData, 2)\n+    val trainDF = sqlContext.createDataFrame(trainRdd)\n+    val validateDF = sqlContext.createDataFrame(validateRdd)\n+\n+    val algos = Array(Regression, Regression, Classification)\n+    val losses = Array(SquaredError, AbsoluteError, LogLoss)\n+    algos.zip(losses).foreach { case (algo, loss) =>\n+      val treeStrategy = new Strategy(algo = algo, impurity = Variance, maxDepth = 2,\n+        categoricalFeaturesInfo = Map.empty)\n+      val boostingStrategy =\n+        new BoostingStrategy(treeStrategy, loss, numIterations, validationTol = 0.0)\n+      val (validateTrees, validateTreeWeights) = GradientBoostedTrees\n+        .runWithValidation(trainRdd, validateRdd, boostingStrategy, 42L)\n+      val numTrees = validateTrees.length\n+      assert(numTrees !== numIterations)\n+\n+      // Test that it performs better on the validation dataset.\n+      val (trees, treeWeights) = GradientBoostedTrees.run(trainRdd, boostingStrategy, 42L)\n+      val (errorWithoutValidation, errorWithValidation) = {\n+        if (algo == Classification) {\n+          val remappedRdd = validateRdd.map(x => new LabeledPoint(2 * x.label - 1, x.features))\n+          (GradientBoostedTrees.computeError(remappedRdd, trees, treeWeights, loss),\n+            GradientBoostedTrees.computeError(remappedRdd, trees, treeWeights, loss))\n+        } else {\n+          (GradientBoostedTrees.computeError(validateRdd, trees, treeWeights, loss),\n+            GradientBoostedTrees.computeError(validateRdd, trees, treeWeights, loss))"
  }],
  "prId": 12050
}]