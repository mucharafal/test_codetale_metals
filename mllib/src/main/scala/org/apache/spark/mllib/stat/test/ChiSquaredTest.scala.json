[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`Chi` -> `chi`\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-08T07:59:20Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the Chi-squared test for the input RDDs using the specified method."
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: `ChiSquaredTest` -> `ChiSqTest` (to match the public method names)\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-08T07:59:23Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the Chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSquaredTest extends Logging {"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This could be done in a single pass (or in batches if numCols is large):\n\n```\ndata.flatMap { p =>\n  // assume dense vectors\n  p.features.toArray.view.zipWithIndex { case (f, j) =>\n    (j, p, f)\n  }\n}.countByValue()\n```\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-08T07:59:27Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the Chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSquaredTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSquaredTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSquaredTestResult](numCols)\n+    var labels = Array[Double]()\n+    var col = 0\n+    while (col < numCols) {"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "could be initialized as a null\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:18Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`indexOf` runs in linear time. Shall we change `features` to a feature to index map?\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:20Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "ditto: use a map instead of linear lookup\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:22Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We don't need to worry about this case. Having that many categories in chi-square tests is not common and it is against the assumption of chi-square test. 1000 is already very large.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:25Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector)."
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we return a test result rejecting the null instead of throw an exception? If the expected probability is zero but the observed count is not, then it is a clear clue to reject the null. This is what R returns:\n\n```\n> chisq.test(c(5, 0, 3), p = c(0, 0.6, 0.4))\n\n    Chi-squared test for given probabilities\n\ndata:  c(5, 0, 3)\nX-squared = Inf, df = 2, p-value < 2.2e-16\n```\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:30Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "What do we do if both observed and expected are 0?  R gives\n\n```\nchisq.test(c(0, 0, 3), p = c(0, 0.6, 0.4))\n\n    Chi-squared test for given probabilities\n\ndata:  c(0, 0, 3)\nX-squared = NaN, df = 2, p-value = NA\n```\n\neven though the statistic is technically undefined in both cases. FWIW commons-math3 throws an exception for 0 values in `expected`.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T06:47:56Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "It is undefined (because of 0/0) if both are zeros. But if observed > 0 and expected = 0, the statistic is observed / expected -> Inf and p-value should be 0.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T07:41:04Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Right. But do we want to return a result with statistic and p-value = NaN or do we want to throw an exception in that case? My question was more around whether we want to have consistent behaviors for both cases.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T07:46:39Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "The first case is a valid test so we should return a result with `pValue = 0`. But the second case is not valid because 0/0 is undefined. I prefer throwing an exception in the second case.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T15:30:40Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "nit: `else__` -> `else_`\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:53Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This adds complexity to the implementation. As mentioned above, it is not common to have many categories in a chi-square test. We can create the expected vector and use it.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:22:57Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Okay. I'll simplify the logic here and log a warning if `observed.size` is too big, say `> 1000`?\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T06:50:29Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "sounds good.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T07:25:23Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {"
  }],
  "prId": 1733
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "it may be nice to output the column index or row index here\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-09T03:23:03Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {\n+      // Assume uniform distribution\n+      if (scale == 1.0) _ => 1.0 / size else _ => scale / size\n+    } else {\n+      if (scale == 1.0) (i: Int) => expected(i) else (i: Int) => scale * expected(i)\n+    }\n+\n+    // compute chi-squared statistic\n+    var statistic = 0.0\n+    var j = 0\n+    while (j < observed.size) {\n+      val obs = observed(j)\n+      if (obs != 0.0) {\n+        statistic += method.chiSqFunc(obs, getExpected(j))\n+      }\n+      j += 1\n+    }\n+    val df = size - 1\n+    val pValue = chiSquareComplemented(df, statistic)\n+    new ChiSqTestResult(pValue, df, statistic, PEARSON.name, NullHypothesis.goodnessOfFit.toString)\n+  }\n+\n+  /*\n+   * Pearon's independence test on the input contingency matrix.\n+   * TODO: optimize for SparseMatrix when it becomes supported.\n+   */\n+  def chiSquaredMatrix(counts: Matrix, methodName:String = PEARSON.name): ChiSqTestResult = {\n+    val method = methodFromString(methodName)\n+    val numRows = counts.numRows\n+    val numCols = counts.numCols\n+\n+    // get row and column sums\n+    val colSums = new Array[Double](numCols)\n+    val rowSums = new Array[Double](numRows)\n+    val colMajorArr = counts.toArray\n+    var i = 0\n+    while (i < colMajorArr.size) {\n+      val elem = colMajorArr(i)\n+      if (elem < 0.0) {\n+        throw new IllegalArgumentException(\"Contingency table cannot contain negative entries.\")\n+      }\n+      colSums(i / numRows) += elem\n+      rowSums(i % numRows) += elem\n+      i += 1\n+    }\n+    if (!colSums.forall(_ > 0.0) || !rowSums.forall(_ > 0.0)) {\n+      throw new IllegalArgumentException(\"Chi square statistic cannot be computed for input matrix \""
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Since we're returning `statistic = Double.NaN` for when `expected = 0.0` for the GOF test, do we also want to do the same thing here instead of throwing an exception?\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-11T19:45:33Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {\n+      // Assume uniform distribution\n+      if (scale == 1.0) _ => 1.0 / size else _ => scale / size\n+    } else {\n+      if (scale == 1.0) (i: Int) => expected(i) else (i: Int) => scale * expected(i)\n+    }\n+\n+    // compute chi-squared statistic\n+    var statistic = 0.0\n+    var j = 0\n+    while (j < observed.size) {\n+      val obs = observed(j)\n+      if (obs != 0.0) {\n+        statistic += method.chiSqFunc(obs, getExpected(j))\n+      }\n+      j += 1\n+    }\n+    val df = size - 1\n+    val pValue = chiSquareComplemented(df, statistic)\n+    new ChiSqTestResult(pValue, df, statistic, PEARSON.name, NullHypothesis.goodnessOfFit.toString)\n+  }\n+\n+  /*\n+   * Pearon's independence test on the input contingency matrix.\n+   * TODO: optimize for SparseMatrix when it becomes supported.\n+   */\n+  def chiSquaredMatrix(counts: Matrix, methodName:String = PEARSON.name): ChiSqTestResult = {\n+    val method = methodFromString(methodName)\n+    val numRows = counts.numRows\n+    val numCols = counts.numCols\n+\n+    // get row and column sums\n+    val colSums = new Array[Double](numCols)\n+    val rowSums = new Array[Double](numRows)\n+    val colMajorArr = counts.toArray\n+    var i = 0\n+    while (i < colMajorArr.size) {\n+      val elem = colMajorArr(i)\n+      if (elem < 0.0) {\n+        throw new IllegalArgumentException(\"Contingency table cannot contain negative entries.\")\n+      }\n+      colSums(i / numRows) += elem\n+      rowSums(i % numRows) += elem\n+      i += 1\n+    }\n+    if (!colSums.forall(_ > 0.0) || !rowSums.forall(_ > 0.0)) {\n+      throw new IllegalArgumentException(\"Chi square statistic cannot be computed for input matrix \""
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "For this case, if there are empty rows or columns, both observed and expected are 0.0, so we should throw an exception.\n\nBtw, for the case when `expected = 0` and `observed > 0`, the result should be `statistics = Inf` and `pValue = 0.0`.\n",
    "commit": "cafb3a773cb7efd1280c62dfc4749d0c23ec8e2b",
    "createdAt": "2014-08-11T22:34:39Z",
    "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+import cern.jet.stat.Probability.chiSquareComplemented\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector, Vectors}\n+import org.apache.spark.mllib.regression.LabeledPoint\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Conduct the chi-squared test for the input RDDs using the specified method.\n+ * Goodness-of-fit test is conducted on two `Vectors`, whereas test of independence is conducted\n+ * on an input of type `Matrix` in which independence between columns is assessed.\n+ * We also provide a method for computing the chi-squared statistic between each feature and the\n+ * label for an input `RDD[LabeledPoint]`, return an `Array[ChiSquaredTestResult]` of size =\n+ * number of features in the inpuy RDD.\n+ *\n+ * Supported methods for goodness of fit: `pearson` (default)\n+ * Supported methods for independence: `pearson` (default)\n+ *\n+ * More information on Chi-squared test: http://en.wikipedia.org/wiki/Chi-squared_test\n+ */\n+private[stat] object ChiSqTest extends Logging {\n+\n+  /**\n+   * @param name String name for the method.\n+   * @param chiSqFunc Function for computing the statistic given the observed and expected counts.\n+   */\n+  case class Method(name: String, chiSqFunc: (Double, Double) => Double)\n+\n+  // Pearson's chi-squared test: http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test\n+  val PEARSON = new Method(\"pearson\", (observed: Double, expected: Double) => {\n+    val dev = observed - expected\n+    dev * dev / expected\n+  })\n+\n+  // Null hypothesis for the two different types of chi-squared tests to be included in the result.\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val goodnessOfFit = Value(\"observed follows the same distribution as expected.\")\n+    val independence = Value(\"observations in each column are statistically independent.\")\n+  }\n+\n+  // Method identification based on input methodName string\n+  private def methodFromString(methodName: String): Method = {\n+    methodName match {\n+      case PEARSON.name => PEARSON\n+      case _ => throw new IllegalArgumentException(\"Unrecognized method for Chi squared test.\")\n+    }\n+  }\n+\n+  /**\n+   * Conduct Pearson's independence test for each feature against the label across the input RDD.\n+   * The contingency table is constructed from the raw (feature, label) pairs and used to conduct\n+   * the independence test.\n+   * Returns an array containing the ChiSquaredTestResult for every feature against the label.\n+   */\n+  def chiSquaredFeatures(data: RDD[LabeledPoint],\n+      methodName: String = PEARSON.name): Array[ChiSqTestResult] = {\n+    val numCols = data.first().features.size\n+    val results = new Array[ChiSqTestResult](numCols)\n+    var labels = Array[Double]()\n+    // At most 100 columns at a time\n+    val batchSize = 100\n+    var batch = 0\n+    while (batch * batchSize < numCols) {\n+      // The following block of code can be cleaned up and made public as\n+      // chiSquared(data: RDD[(V1, V2)])\n+      val startCol = batch * batchSize\n+      val endCol = startCol + math.min(batchSize, numCols - startCol)\n+      val pairCounts = data.flatMap { p =>\n+        // assume dense vectors\n+        p.features.toArray.slice(startCol, endCol).zipWithIndex.map { case (feature, col) =>\n+          (col, feature, p.label)\n+        }\n+      }.countByValue()\n+\n+      if (labels.size == 0) {\n+        // Do this only once for the first column since labels are invariant across features.\n+        labels = pairCounts.keys.filter(_._1 == startCol).map(_._3).toArray.distinct\n+      }\n+      val numLabels = labels.size\n+      pairCounts.keys.groupBy(_._1).map { case (col, keys) =>\n+        val features = keys.map(_._2).toArray.distinct\n+        val numRows = features.size\n+        val contingency = new BDM(numRows, numLabels, new Array[Double](numRows * numLabels))\n+        keys.foreach { case (_, feature, label) =>\n+          val i = features.indexOf(feature)\n+          val j = labels.indexOf(label)\n+          contingency(i, j) += pairCounts((col, feature, label))\n+        }\n+        results(col) = chiSquaredMatrix(Matrices.fromBreeze(contingency), methodName)\n+      }\n+      batch += 1\n+    }\n+    results\n+  }\n+\n+  /*\n+   * Pearon's goodness of fit test on the input observed and expected counts/relative frequencies.\n+   * Uniform distribution is assumed when `expected` is not passed in.\n+   */\n+  def chiSquared(observed: Vector,\n+      expected: Vector = Vectors.dense(Array[Double]()),\n+      methodName: String = PEARSON.name): ChiSqTestResult = {\n+\n+    // Validate input arguments\n+    val method = methodFromString(methodName)\n+    if (expected.size != 0 && observed.size != expected.size) {\n+      throw new IllegalArgumentException(\"observed and expected must be of the same size.\")\n+    }\n+    val size = observed.size\n+    // Avoid calling toArray on input vectors to avoid memory blow up\n+    // (esp if size = Int.MaxValue for a SparseVector).\n+    // Check positivity and collect sums\n+    var obsSum = 0.0\n+    var expSum = if (expected.size == 0.0) 1.0 else 0.0\n+    var i = 0\n+    while (i < size) {\n+      val obs = observed(i)\n+      if (obs < 0.0) {\n+        throw new IllegalArgumentException(\"Values in observed must be nonnegative.\")\n+      }\n+      obsSum += obs\n+      if (expected.size > 0) {\n+        val exp = expected(i)\n+        if (exp <= 0.0) {\n+          throw new IllegalArgumentException(\"Values in expected must be positive.\")\n+        }\n+        expSum += exp\n+      }\n+      i += 1\n+    }\n+\n+    // Determine the scaling factor for expected\n+    val scale = if (math.abs(obsSum - expSum) < 1e-7) 1.0 else  obsSum / expSum\n+    val getExpected: (Int) => Double = if (expected.size == 0) {\n+      // Assume uniform distribution\n+      if (scale == 1.0) _ => 1.0 / size else _ => scale / size\n+    } else {\n+      if (scale == 1.0) (i: Int) => expected(i) else (i: Int) => scale * expected(i)\n+    }\n+\n+    // compute chi-squared statistic\n+    var statistic = 0.0\n+    var j = 0\n+    while (j < observed.size) {\n+      val obs = observed(j)\n+      if (obs != 0.0) {\n+        statistic += method.chiSqFunc(obs, getExpected(j))\n+      }\n+      j += 1\n+    }\n+    val df = size - 1\n+    val pValue = chiSquareComplemented(df, statistic)\n+    new ChiSqTestResult(pValue, df, statistic, PEARSON.name, NullHypothesis.goodnessOfFit.toString)\n+  }\n+\n+  /*\n+   * Pearon's independence test on the input contingency matrix.\n+   * TODO: optimize for SparseMatrix when it becomes supported.\n+   */\n+  def chiSquaredMatrix(counts: Matrix, methodName:String = PEARSON.name): ChiSqTestResult = {\n+    val method = methodFromString(methodName)\n+    val numRows = counts.numRows\n+    val numCols = counts.numCols\n+\n+    // get row and column sums\n+    val colSums = new Array[Double](numCols)\n+    val rowSums = new Array[Double](numRows)\n+    val colMajorArr = counts.toArray\n+    var i = 0\n+    while (i < colMajorArr.size) {\n+      val elem = colMajorArr(i)\n+      if (elem < 0.0) {\n+        throw new IllegalArgumentException(\"Contingency table cannot contain negative entries.\")\n+      }\n+      colSums(i / numRows) += elem\n+      rowSums(i % numRows) += elem\n+      i += 1\n+    }\n+    if (!colSums.forall(_ > 0.0) || !rowSums.forall(_ > 0.0)) {\n+      throw new IllegalArgumentException(\"Chi square statistic cannot be computed for input matrix \""
  }],
  "prId": 1733
}]