[{
  "comments": [{
    "author": {
      "login": "coderxiang"
    },
    "body": "is `fromPMMLTree` a better name here?\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-10T18:56:04Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def getPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "fromPMMLTree sounds good. Will make the change.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-10T19:01:14Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def getPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "Actually this method takes MLLib tree and returns a PMML tree. So should we call it toPMMLTree ?\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-10T19:06:32Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def getPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {"
  }, {
    "author": {
      "login": "coderxiang"
    },
    "body": "sounds good!\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-10T19:59:41Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def getPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "Changes done !\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-10T23:11:11Z",
    "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def getPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "selvinsource"
    },
    "body": "getMiningFieldsForTreeRec is very similar to getDataFieldsForTreeRec, couldn't you merge these?\nAlso, I am not sure you even need getMiningFieldsForTreeRec, you could create the mining fields from the data fields you already have, usually (in the models I exported) the field names were the same for mining fields and data fields.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-22T10:52:35Z",
    "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def toPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(mllibTreeModel.algo)\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(getMiningFieldsForTree(mllibTreeModel).asJava)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withNode(buildStub(mllibTreeModel.topNode))\n+      .withMiningSchema(miningSchema)\n+\n+    treeModel\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(rootNode: Node): PMMLNode = {\n+    // get rootPMML node for the MLLib node\n+    val rootPMMLNode = createNode(rootNode)\n+\n+    if (!rootNode.isLeaf) {\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStub(rootNode.leftNode.get)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStub(rootNode.rightNode.get)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+    }\n+\n+    rootPMMLNode\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node): Option[Predicate] = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+      val split = node.split.get\n+      val featureType = split.featureType\n+      val fieldName = FieldName.create(\"field_\" + split.feature.toString)\n+      featureType match {\n+        case FeatureType.Continuous => {\n+          val value = split.threshold.toString\n+          Some(\n+            new SimplePredicate(fieldName, SimplePredicate.Operator.LESS_OR_EQUAL)\n+              .withValue(value)\n+          )\n+        }\n+        case FeatureType.Categorical => {\n+          if (split.categories.length > 1) {\n+            val predicates: List[Predicate] =\n+              for (category <- split.categories)\n+                yield\n+                new SimplePredicate(fieldName, SimplePredicate.Operator.EQUAL)\n+                  .withValue(category.toString)\n+\n+            val compoundPredicate = new CompoundPredicate()\n+              .withBooleanOperator(CompoundPredicate.BooleanOperator.OR)\n+              .withPredicates(predicates.asJava)\n+\n+            Some(compoundPredicate)\n+\n+          }\n+          else {\n+            val value = split.categories(0).toString\n+            Some(new SimplePredicate(fieldName, SimplePredicate.Operator.EQUAL).withValue(value))\n+          }\n+        }\n+      }\n+    }\n+    else {\n+      None\n+    }\n+\n+  }\n+\n+  /** Create equivalent PMML node for given mlLib node. */\n+  private def createNode(mlLibNode: Node): PMMLNode = {\n+    val node = new PMMLNode()\n+      .withId(mlLibNode.id.toString)\n+      .withScore(mlLibNode.predict.predict.toString)\n+\n+    val predicate = getPredicate(mlLibNode)\n+    if (predicate.isDefined) {\n+      node.withPredicate(predicate.get)\n+    }\n+\n+    node\n+  }\n+\n+  /** Get PMML mining function type for given mlLib Algo. */\n+  private def getPMMLMiningFunctionType(mlLibAlgo: Algo): MiningFunctionType = {\n+    mlLibAlgo match {\n+      case Algo.Classification => MiningFunctionType.CLASSIFICATION\n+      case Algo.Regression => MiningFunctionType.REGRESSION\n+    }\n+  }\n+\n+  /** Get PMML datafield based on the mllib split feature. */\n+  private def getDataField(mllibNode: Node): Option[DataField] = {\n+    if (!mllibNode.isLeaf && mllibNode.split.isDefined) {\n+      val split = mllibNode.split.get\n+      val dataField = new DataField()\n+        .withName(FieldName.create(\"field_\" + split.feature.toString))\n+        .withDataType(DataType.fromValue(split.threshold.getClass.getSimpleName.toLowerCase))\n+        .withOpType(OpType.fromValue(split.featureType.toString.toLowerCase))\n+\n+      split.featureType match {\n+        case FeatureType.Continuous => dataField.withOpType(OpType.CONTINUOUS)\n+        case FeatureType.Categorical => {\n+          dataField.withOpType(OpType.CATEGORICAL)\n+          val categories = split.categories\n+            .map(category => new org.dmg.pmml.Value(category.toString)).asJava\n+          dataField.withValues(categories)\n+        }\n+      }\n+\n+      Some(dataField)\n+    }\n+    else {\n+      None\n+    }\n+  }\n+\n+  /** Get PMML Mining field based on Mllib node split feature. */\n+  private def getMiningField(mllibNode: Node): Option[MiningField] = {\n+    if (!mllibNode.isLeaf && mllibNode.split.isDefined) {\n+      val split = mllibNode.split.get\n+\n+      val miningField = new MiningField()\n+        .withName(FieldName.create(\"field_\" + split.feature.toString))\n+        .withUsageType(FieldUsageType.ACTIVE)\n+\n+      Some(miningField)\n+    }\n+    else {\n+      None\n+    }\n+\n+  }\n+\n+  /** Get distinct PMML mining fields list for a given mlLib decision tree model. */\n+  def getMiningFieldsForTree(treeModel: DecisionTreeModel): List[MiningField] = {\n+\n+    @tailrec\n+    def getMiningFieldsForTreeRec(\n+                                   nodeList: List[Node],\n+                                   miningFlds: List[MiningField]): List[MiningField] = {\n+\n+      nodeList match {\n+        case Nil => miningFlds\n+        case nd :: ls if (nd.isLeaf) => miningFlds\n+        case nd :: ls if (!nd.isLeaf && nd.split.isDefined) => {\n+          val ndList = MutableList[Node]()\n+          if (nd.leftNode.isDefined) {\n+            ndList += nd.leftNode.get\n+          }\n+\n+          if (nd.rightNode.isDefined) {\n+            ndList += nd.rightNode.get\n+          }\n+\n+          getMiningFieldsForTreeRec(ndList.toList, miningFlds :+ getMiningField(nd).get)\n+\n+        }\n+      }\n+    }\n+\n+    val miningFields = getMiningFieldsForTreeRec(List(treeModel.topNode), List[MiningField]())"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "selvinsource"
    },
    "body": "Here you are recreating the Field Name, once again, couldn't you get from the DataFields?\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-22T10:53:47Z",
    "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def toPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(mllibTreeModel.algo)\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(getMiningFieldsForTree(mllibTreeModel).asJava)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withNode(buildStub(mllibTreeModel.topNode))\n+      .withMiningSchema(miningSchema)\n+\n+    treeModel\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(rootNode: Node): PMMLNode = {\n+    // get rootPMML node for the MLLib node\n+    val rootPMMLNode = createNode(rootNode)\n+\n+    if (!rootNode.isLeaf) {\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStub(rootNode.leftNode.get)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStub(rootNode.rightNode.get)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+    }\n+\n+    rootPMMLNode\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node): Option[Predicate] = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+      val split = node.split.get\n+      val featureType = split.featureType\n+      val fieldName = FieldName.create(\"field_\" + split.feature.toString)"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "selvinsource"
    },
    "body": "We could add\n.withSplitCharacteristic(SplitCharacteristic.BINARY_SPLIT)\nfor completeness, as far as I understand MLlib uses a binary split.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-08-22T10:55:56Z",
    "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object TreeModelUtils {\n+\n+\n+  def toPMMLTree(mllibTreeModel: DecisionTreeModel, modelName: String): TreeModel = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(mllibTreeModel.algo)\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(getMiningFieldsForTree(mllibTreeModel).asJava)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withNode(buildStub(mllibTreeModel.topNode))"
  }],
  "prId": 7842
}]