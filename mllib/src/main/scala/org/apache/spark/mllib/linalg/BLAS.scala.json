[{
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "How about `SparseMatrix` and `SparseVector`? To make the consistent naming, we can use `dmA`, `smA`, `dvx`, and `svx`.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T04:44:27Z",
    "diffHunk": "@@ -473,13 +473,16 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (sparse: SparseMatrix, dx: DenseVector) =>\n+          gemv(alpha, sparse, dx, beta, y)\n+        case (dense: DenseMatrix, dx: DenseVector) =>\n+          gemv(alpha, dense, dx, beta, y)\n+        case (dense: DenseMatrix, sx: SparseVector) =>\n+          gemv(alpha, dense, sx, beta, y)\n         case _ =>"
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "If you don't really want to add `SparseMatrix` and `SparseVector`, the type safety will be broken when you call with this configuration. Previously, this function is totally type safe in compile time, and no way to get into \"case _\".\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T04:57:26Z",
    "diffHunk": "@@ -473,13 +473,16 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (sparse: SparseMatrix, dx: DenseVector) =>\n+          gemv(alpha, sparse, dx, beta, y)\n+        case (dense: DenseMatrix, dx: DenseVector) =>\n+          gemv(alpha, dense, dx, beta, y)\n+        case (dense: DenseMatrix, sx: SparseVector) =>\n+          gemv(alpha, dense, sx, beta, y)\n         case _ =>"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "all should be `val`\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T04:50:42Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size\n+    var xValues = x.values\n+"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`xIndices.length` when you try to get the size of native scala Array. `size` will call `length` which is another jvm call.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T04:59:42Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "are you using this?\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T05:00:56Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`if (A.isTransposed)` and change the order of code.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T05:02:21Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size\n+    var xValues = x.values\n+\n+    scal(beta, y)\n+\n+    if (!A.isTransposed) {"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "extra space. please also fix the one in \n\n```\n  private def gemv(\n      alpha: Double,\n      A: DenseMatrix,\n      x: DenseVector,\n      beta: Double,\n      y: DenseVector): Unit =  {\n```\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T05:04:01Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`y.values` is slow. Do `val yValues = y.values`\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T05:05:49Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size\n+    var xValues = x.values\n+\n+    scal(beta, y)\n+\n+    if (!A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        y.values(rowCounterForA) += sum * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto \n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T05:16:42Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size\n+    var xValues = x.values\n+\n+    scal(beta, y)\n+\n+    if (!A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        y.values(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        y.values(rowCounterForA) += sum * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Why we should check it?\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T16:05:58Z",
    "diffHunk": "@@ -500,6 +503,55 @@ private[spark] object BLAS extends Serializable with Logging {\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and SparseVector x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit =  {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    var colCounterForA = 0\n+\n+    var xIndices = x.indices\n+    var xNnz = xIndices.size\n+    var xValues = x.values\n+\n+    scal(beta, y)"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "Actually, each element of yValues is looped through here, let's change it to\n\n```\nyValues(rowCounterForA) += sum * alpha + beta * yValues(rowCounterForA) \n```\n\nand then have the following code before this block\n\n```\nif (alpha == 0.0) {\n  scal(beta, y)\n  return\n}\n```\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T18:25:08Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "ditto\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T18:26:01Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "scal(beta, y)\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T18:47:02Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0"
  }, {
    "author": {
      "login": "viirya"
    },
    "body": "Do we need to check `if (beta != 0.0)` here? I think we should do the scaling even `beta` is 0.0 as it will clear out `y`.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-18T06:27:26Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0"
  }, {
    "author": {
      "login": "dbtsai"
    },
    "body": "You are right.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-18T07:01:33Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "```\nif (alpha == 0.0) {\n  scal(beta, y)\n  return\n}\n```\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T18:47:58Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "```\nyValues(rowCounterForA) += sum * alpha + beta * yValues(rowCounterForA) \n```\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T18:48:58Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`xVal` will be easily to read as `xValues`. simply make it as `xTemp`\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T20:18:53Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0\n+      while (colCounterForA < nA && k < xNnz) {\n+        if (xIndices(k) == colCounterForA) {\n+          var i = Acols(colCounterForA)\n+          val indEnd = Acols(colCounterForA + 1)\n+\n+          val xVal = xValues(k) * alpha"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "`yValues(Arows(i)) += Avals(i) * xTemp`\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T20:19:24Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0\n+      while (colCounterForA < nA && k < xNnz) {\n+        if (xIndices(k) == colCounterForA) {\n+          var i = Acols(colCounterForA)\n+          val indEnd = Acols(colCounterForA + 1)\n+\n+          val xVal = xValues(k) * alpha\n+          while (i < indEnd) {\n+            val rowIndex = Arows(i)\n+            yValues(rowIndex) += Avals(i) * xVal"
  }],
  "prId": 6209
}, {
  "comments": [{
    "author": {
      "login": "dbtsai"
    },
    "body": "I checked the logic, and it looks correct. Great.\n",
    "commit": "ce0bb8b8016d58eecd00d6f210a213f686e0e062",
    "createdAt": "2015-05-17T20:20:34Z",
    "diffHunk": "@@ -473,44 +473,161 @@ private[spark] object BLAS extends Serializable with Logging {\n     if (alpha == 0.0) {\n       logDebug(\"gemv: alpha is equal to 0. Returning y.\")\n     } else {\n-      A match {\n-        case sparse: SparseMatrix =>\n-          gemv(alpha, sparse, x, beta, y)\n-        case dense: DenseMatrix =>\n-          gemv(alpha, dense, x, beta, y)\n+      (A, x) match {\n+        case (smA: SparseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, smA, dvx, beta, y)\n+        case (smA: SparseMatrix, svx: SparseVector) =>\n+          gemv(alpha, smA, svx, beta, y)\n+        case (dmA: DenseMatrix, dvx: DenseVector) =>\n+          gemv(alpha, dmA, dvx, beta, y)\n+        case (dmA: DenseMatrix, svx: SparseVector) =>\n+          gemv(alpha, dmA, svx, beta, y)\n         case _ =>\n-          throw new IllegalArgumentException(s\"gemv doesn't support matrix type ${A.getClass}.\")\n+          throw new IllegalArgumentException(s\"gemv doesn't support running on matrix type \" +\n+            s\"${A.getClass} and vector type ${x.getClass}.\")\n       }\n     }\n   }\n \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `DenseMatrix` A.\n+   * For `DenseMatrix` A and `DenseVector` x.\n    */\n   private def gemv(\n       alpha: Double,\n       A: DenseMatrix,\n       x: DenseVector,\n       beta: Double,\n-      y: DenseVector): Unit =  {\n+      y: DenseVector): Unit = {\n     val tStrA = if (A.isTransposed) \"T\" else \"N\"\n     val mA = if (!A.isTransposed) A.numRows else A.numCols\n     val nA = if (!A.isTransposed) A.numCols else A.numRows\n     nativeBLAS.dgemv(tStrA, mA, nA, alpha, A.values, mA, x.values, 1, beta,\n       y.values, 1)\n   }\n+ \n+  /**\n+   * y := alpha * A * x + beta * y\n+   * For `DenseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: DenseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+    val xValues = x.values\n+    val yValues = y.values\n+\n+    scal(beta, y)\n \n+    if (A.isTransposed) {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) + rowCounterForA * nA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    } else {\n+      var rowCounterForA = 0\n+      while (rowCounterForA < mA) {\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz) {\n+          sum += xValues(k) * Avals(xIndices(k) * mA + rowCounterForA)\n+          k += 1\n+        }\n+        yValues(rowCounterForA) += sum * alpha\n+        rowCounterForA += 1\n+      }\n+    }\n+  }\n+ \n   /**\n    * y := alpha * A * x + beta * y\n-   * For `SparseMatrix` A.\n+   * For `SparseMatrix` A and `SparseVector` x.\n+   */\n+  private def gemv(\n+      alpha: Double,\n+      A: SparseMatrix,\n+      x: SparseVector,\n+      beta: Double,\n+      y: DenseVector): Unit = {\n+    val xValues = x.values\n+    val xIndices = x.indices\n+    val xNnz = xIndices.length\n+\n+    val yValues = y.values\n+\n+    val mA: Int = A.numRows\n+    val nA: Int = A.numCols\n+\n+    val Avals = A.values\n+    val Arows = if (!A.isTransposed) A.rowIndices else A.colPtrs\n+    val Acols = if (!A.isTransposed) A.colPtrs else A.rowIndices\n+\n+    scal(beta, y)\n+\n+    if (A.isTransposed) {\n+      var rowCounter = 0\n+      while (rowCounter < mA) {\n+        var i = Arows(rowCounter)\n+        val indEnd = Arows(rowCounter + 1)\n+        var sum = 0.0\n+        var k = 0\n+        while (k < xNnz && i < indEnd) {\n+          if (xIndices(k) == Acols(i)) {\n+            sum += Avals(i) * xValues(k)\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        yValues(rowCounter) += sum * alpha\n+        rowCounter += 1\n+      }\n+    } else {\n+      var colCounterForA = 0\n+      var k = 0\n+      while (colCounterForA < nA && k < xNnz) {\n+        if (xIndices(k) == colCounterForA) {\n+          var i = Acols(colCounterForA)\n+          val indEnd = Acols(colCounterForA + 1)\n+\n+          val xVal = xValues(k) * alpha\n+          while (i < indEnd) {\n+            val rowIndex = Arows(i)\n+            yValues(rowIndex) += Avals(i) * xVal\n+            i += 1\n+          }\n+          k += 1\n+        }\n+        colCounterForA += 1\n+      }",
    "line": 171
  }],
  "prId": 6209
}]