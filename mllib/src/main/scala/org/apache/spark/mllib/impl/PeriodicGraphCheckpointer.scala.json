[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Should users be responsible for materializing graphs? If users doesn't materialize graphs, then `removeCheckpointFile` will happen before the RDDs get checkpointed.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T03:23:45Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "What would you vote for?\n- PeriodicGraphCheckpointer calls count() on vertices and edges\n- PeriodicGraphCheckpointer stays as is, where it tries to remove checkpoints but does not fail if they do not exist.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T04:27:45Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I think we should update the documentation and put a note about this. Users are responsible for materializing graphs at proper time and we track the last checkpoint.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T06:21:06Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "Will do\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T06:34:38Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:"
  }],
  "prId": 4047
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "use `{{{ ... }}}` for code in doc\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T03:23:48Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:\n+ *  - Persist new graph (if not yet persisted), and put in queue of persisted graphs.\n+ *  - Unpersist graphs from queue until there are at most 3 persisted graphs.\n+ *  - If using checkpointing and the checkpoint interval has been reached,\n+ *     - Checkpoint the new graph, and put in a queue of checkpointed graphs.\n+ *     - Remove older checkpoints.\n+ *\n+ * WARNINGS:\n+ *  - This class should NOT be copied (since copies may conflict on which Graphs should be\n+ *    checkpointed).\n+ *  - This class removes checkpoint files once later graphs have been checkpointed.\n+ *    However, references to the older graphs will still return isCheckpointed = true.\n+ *\n+ * Example usage:\n+ *  val (graph1, graph2, graph3, ...) = ..."
  }],
  "prId": 4047
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This should work on normal RDDs as well. Let's put a TODO here. Otherwise, this seems to be a little strange to live under `mllib`.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T03:24:12Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:\n+ *  - Persist new graph (if not yet persisted), and put in queue of persisted graphs.\n+ *  - Unpersist graphs from queue until there are at most 3 persisted graphs.\n+ *  - If using checkpointing and the checkpoint interval has been reached,\n+ *     - Checkpoint the new graph, and put in a queue of checkpointed graphs.\n+ *     - Remove older checkpoints.\n+ *\n+ * WARNINGS:\n+ *  - This class should NOT be copied (since copies may conflict on which Graphs should be\n+ *    checkpointed).\n+ *  - This class removes checkpoint files once later graphs have been checkpointed.\n+ *    However, references to the older graphs will still return isCheckpointed = true.\n+ *\n+ * Example usage:\n+ *  val (graph1, graph2, graph3, ...) = ...\n+ *  val cp = new PeriodicGraphCheckpointer(graph, dir, 2)\n+ *  // persisted: graph1\n+ *  cp.updateGraph(graph2)\n+ *  // persisted: graph1, graph2\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph3)\n+ *  // persisted: graph1, graph2, graph3\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph4)\n+ *  // persisted: graph2, graph3, graph4\n+ *  // checkpointed: graph4\n+ *  cp.updateGraph(graph5)\n+ *  // persisted: graph3, graph4, graph5\n+ *  // checkpointed: graph4\n+ *\n+ * @param currentGraph  Initial graph\n+ * @param checkpointDir The directory for storing checkpoint files\n+ * @param checkpointInterval Graphs will be checkpointed at this interval\n+ * @tparam VD  Vertex descriptor type\n+ * @tparam ED  Edge descriptor type\n+ */\n+private[mllib] class PeriodicGraphCheckpointer[VD, ED]("
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I agree; almost the same code should work (except it's not clear if Graph should have exactly the same behavior since it has 2 RDDs).  It's also unclear if all use cases will want the same intervals between persisting/unpersisting.  I'll make a TODO and a JIRA.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T03:53:51Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:\n+ *  - Persist new graph (if not yet persisted), and put in queue of persisted graphs.\n+ *  - Unpersist graphs from queue until there are at most 3 persisted graphs.\n+ *  - If using checkpointing and the checkpoint interval has been reached,\n+ *     - Checkpoint the new graph, and put in a queue of checkpointed graphs.\n+ *     - Remove older checkpoints.\n+ *\n+ * WARNINGS:\n+ *  - This class should NOT be copied (since copies may conflict on which Graphs should be\n+ *    checkpointed).\n+ *  - This class removes checkpoint files once later graphs have been checkpointed.\n+ *    However, references to the older graphs will still return isCheckpointed = true.\n+ *\n+ * Example usage:\n+ *  val (graph1, graph2, graph3, ...) = ...\n+ *  val cp = new PeriodicGraphCheckpointer(graph, dir, 2)\n+ *  // persisted: graph1\n+ *  cp.updateGraph(graph2)\n+ *  // persisted: graph1, graph2\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph3)\n+ *  // persisted: graph1, graph2, graph3\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph4)\n+ *  // persisted: graph2, graph3, graph4\n+ *  // checkpointed: graph4\n+ *  cp.updateGraph(graph5)\n+ *  // persisted: graph3, graph4, graph5\n+ *  // checkpointed: graph4\n+ *\n+ * @param currentGraph  Initial graph\n+ * @param checkpointDir The directory for storing checkpoint files\n+ * @param checkpointInterval Graphs will be checkpointed at this interval\n+ * @tparam VD  Vertex descriptor type\n+ * @tparam ED  Edge descriptor type\n+ */\n+private[mllib] class PeriodicGraphCheckpointer[VD, ED]("
  }],
  "prId": 4047
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "See my previous comment about setting `checkpointDir`.\n",
    "commit": "77e8814073c10ee8f8753eb68412b1b86450af31",
    "createdAt": "2015-02-03T03:24:15Z",
    "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.impl\n+\n+import scala.collection.mutable\n+\n+import org.apache.hadoop.fs.{Path, FileSystem}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.graphx.Graph\n+import org.apache.spark.storage.StorageLevel\n+\n+\n+/**\n+ * This class helps with persisting and checkpointing Graphs.\n+ *\n+ * This class maintains a FIFO queue of Graphs, each of which is persisted and some of which are\n+ * checkpointed.  Once one Graph has been checkpointed, then previous RDDs are unpersisted and their\n+ * checkpoint files are removed.\n+ *\n+ * Users should call [[PeriodicGraphCheckpointer.updateGraph()]] when a new graph has been created,\n+ * before the graph has been materialized.  When called, this does the following:\n+ *  - Persist new graph (if not yet persisted), and put in queue of persisted graphs.\n+ *  - Unpersist graphs from queue until there are at most 3 persisted graphs.\n+ *  - If using checkpointing and the checkpoint interval has been reached,\n+ *     - Checkpoint the new graph, and put in a queue of checkpointed graphs.\n+ *     - Remove older checkpoints.\n+ *\n+ * WARNINGS:\n+ *  - This class should NOT be copied (since copies may conflict on which Graphs should be\n+ *    checkpointed).\n+ *  - This class removes checkpoint files once later graphs have been checkpointed.\n+ *    However, references to the older graphs will still return isCheckpointed = true.\n+ *\n+ * Example usage:\n+ *  val (graph1, graph2, graph3, ...) = ...\n+ *  val cp = new PeriodicGraphCheckpointer(graph, dir, 2)\n+ *  // persisted: graph1\n+ *  cp.updateGraph(graph2)\n+ *  // persisted: graph1, graph2\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph3)\n+ *  // persisted: graph1, graph2, graph3\n+ *  // checkpointed: graph2\n+ *  cp.updateGraph(graph4)\n+ *  // persisted: graph2, graph3, graph4\n+ *  // checkpointed: graph4\n+ *  cp.updateGraph(graph5)\n+ *  // persisted: graph3, graph4, graph5\n+ *  // checkpointed: graph4\n+ *\n+ * @param currentGraph  Initial graph\n+ * @param checkpointDir The directory for storing checkpoint files\n+ * @param checkpointInterval Graphs will be checkpointed at this interval\n+ * @tparam VD  Vertex descriptor type\n+ * @tparam ED  Edge descriptor type\n+ */\n+private[mllib] class PeriodicGraphCheckpointer[VD, ED](\n+    var currentGraph: Graph[VD, ED],\n+    val checkpointDir: Option[String],\n+    val checkpointInterval: Int) extends Logging {\n+\n+  /** FIFO queue of past checkpointed RDDs */\n+  private val checkpointQueue = mutable.Queue[Graph[VD, ED]]()\n+\n+  /** FIFO queue of past persisted RDDs */\n+  private val persistedQueue = mutable.Queue[Graph[VD, ED]]()\n+\n+  /** Number of times [[updateGraph()]] has been called */\n+  private var updateCount = 0\n+\n+  /**\n+   * Spark Context for the Graphs given to this checkpointer.\n+   * NOTE: This code assumes that only one SparkContext is used for the given graphs.\n+   */\n+  private val sc = currentGraph.vertices.sparkContext\n+\n+  // If a checkpoint directory is given, and there's no prior checkpoint directory,\n+  // then set the checkpoint directory with the given one.\n+  if (checkpointDir.nonEmpty && sc.getCheckpointDir.isEmpty) {",
    "line": 106
  }],
  "prId": 4047
}]