[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`ArrayBuffer(firstEntry._1._2)`\n",
    "commit": "733def40ce50b55b96f6b5e9dcea4a9a7f7f8ad0",
    "createdAt": "2014-08-01T03:28:06Z",
    "diffHunk": "@@ -89,20 +89,17 @@ private[stat] object SpearmanCorrelation extends Correlation with Logging {\n     val ranks: RDD[(Long, Double)] = sorted.mapPartitions { iter =>\n       // add an extra element to signify the end of the list so that flatMap can flush the last\n       // batch of duplicates\n-      val padded = iter ++\n-        Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n-      var lastVal = 0.0\n-      var firstRank = 0.0\n-      val idBuffer = new ArrayBuffer[Long]()\n+      val padded = iter ++ Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n+      val firstEntry = padded.next()\n+      var lastVal = firstEntry._1._1\n+      var firstRank = firstEntry._2.toDouble\n+      val idBuffer = new ArrayBuffer[Long]() += firstEntry._1._2"
  }],
  "prId": 1710
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Where is `Long.MinValue` used?\n",
    "commit": "733def40ce50b55b96f6b5e9dcea4a9a7f7f8ad0",
    "createdAt": "2014-08-01T03:30:15Z",
    "diffHunk": "@@ -89,20 +89,17 @@ private[stat] object SpearmanCorrelation extends Correlation with Logging {\n     val ranks: RDD[(Long, Double)] = sorted.mapPartitions { iter =>\n       // add an extra element to signify the end of the list so that flatMap can flush the last\n       // batch of duplicates\n-      val padded = iter ++\n-        Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n-      var lastVal = 0.0\n-      var firstRank = 0.0\n-      val idBuffer = new ArrayBuffer[Long]()\n+      val padded = iter ++ Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n+      val firstEntry = padded.next()\n+      var lastVal = firstEntry._1._1\n+      var firstRank = firstEntry._2.toDouble\n+      val idBuffer = new ArrayBuffer[Long]() += firstEntry._1._2\n       padded.flatMap { case ((v, id), rank) =>\n-        if (v  == lastVal && id != Long.MinValue) {\n+        if (v == lastVal && id != Long.MinValue) {"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "oops that's supposed to be `-1L`\n",
    "commit": "733def40ce50b55b96f6b5e9dcea4a9a7f7f8ad0",
    "createdAt": "2014-08-01T03:33:56Z",
    "diffHunk": "@@ -89,20 +89,17 @@ private[stat] object SpearmanCorrelation extends Correlation with Logging {\n     val ranks: RDD[(Long, Double)] = sorted.mapPartitions { iter =>\n       // add an extra element to signify the end of the list so that flatMap can flush the last\n       // batch of duplicates\n-      val padded = iter ++\n-        Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n-      var lastVal = 0.0\n-      var firstRank = 0.0\n-      val idBuffer = new ArrayBuffer[Long]()\n+      val padded = iter ++ Iterator[((Double, Long), Long)](((Double.NaN, -1L), -1L))\n+      val firstEntry = padded.next()\n+      var lastVal = firstEntry._1._1\n+      var firstRank = firstEntry._2.toDouble\n+      val idBuffer = new ArrayBuffer[Long]() += firstEntry._1._2\n       padded.flatMap { case ((v, id), rank) =>\n-        if (v  == lastVal && id != Long.MinValue) {\n+        if (v == lastVal && id != Long.MinValue) {"
  }],
  "prId": 1710
}]