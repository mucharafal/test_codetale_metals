[{
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "This would probably be clearer if LabelCounter had a + method that would always return a new object, and you could do `agg.ScanLeft(new LabelCounter)(_ + _)`. But maybe it's okay as is.\n",
    "commit": "a05941db7fac61222ac23e69e78f86e165e41ad2",
    "createdAt": "2014-04-10T05:24:06Z",
    "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.evaluation.binary\n+\n+import org.apache.spark.rdd.{UnionRDD, RDD}\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.evaluation.AreaUnderCurve\n+import org.apache.spark.Logging\n+\n+/**\n+ * Implementation of [[org.apache.spark.mllib.evaluation.binary.BinaryConfusionMatrix]].\n+ *\n+ * @param count label counter for labels with scores greater than or equal to the current score\n+ * @param totalCount label counter for all labels\n+ */\n+private case class BinaryConfusionMatrixImpl(\n+    count: LabelCounter,\n+    totalCount: LabelCounter) extends BinaryConfusionMatrix with Serializable {\n+\n+  /** number of true positives */\n+  override def tp: Long = count.numPositives\n+\n+  /** number of false positives */\n+  override def fp: Long = count.numNegatives\n+\n+  /** number of false negatives */\n+  override def fn: Long = totalCount.numPositives - count.numPositives\n+\n+  /** number of true negatives */\n+  override def tn: Long = totalCount.numNegatives - count.numNegatives\n+\n+  /** number of positives */\n+  override def p: Long = totalCount.numPositives\n+\n+  /** number of negatives */\n+  override def n: Long = totalCount.numNegatives\n+}\n+\n+/**\n+ * Evaluator for binary classification.\n+ *\n+ * @param scoreAndLabels an RDD of (score, label) pairs.\n+ */\n+class BinaryClassificationMetrics(scoreAndLabels: RDD[(Double, Double)])\n+    extends Serializable with Logging {\n+\n+  private lazy val (\n+      cumCounts: RDD[(Double, LabelCounter)],\n+      confusions: RDD[(Double, BinaryConfusionMatrix)]) = {\n+    // Create a bin for each distinct score value, count positives and negatives within each bin,\n+    // and then sort by score values in descending order.\n+    val counts = scoreAndLabels.combineByKey(\n+      createCombiner = (label: Double) => new LabelCounter(0L, 0L) += label,\n+      mergeValue = (c: LabelCounter, label: Double) => c += label,\n+      mergeCombiners = (c1: LabelCounter, c2: LabelCounter) => c1 += c2\n+    ).sortByKey(ascending = false)\n+    val agg = counts.values.mapPartitions({ iter =>\n+      val agg = new LabelCounter()\n+      iter.foreach(agg += _)\n+      Iterator(agg)\n+    }, preservesPartitioning = true).collect()\n+    val partitionwiseCumCounts =\n+      agg.scanLeft(new LabelCounter())((agg: LabelCounter, c: LabelCounter) => agg.clone() += c)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Actually there was one ... but scalastyle doesn't allow `def +(` because it asks for a space after `+`.\n",
    "commit": "a05941db7fac61222ac23e69e78f86e165e41ad2",
    "createdAt": "2014-04-10T05:26:31Z",
    "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.evaluation.binary\n+\n+import org.apache.spark.rdd.{UnionRDD, RDD}\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.evaluation.AreaUnderCurve\n+import org.apache.spark.Logging\n+\n+/**\n+ * Implementation of [[org.apache.spark.mllib.evaluation.binary.BinaryConfusionMatrix]].\n+ *\n+ * @param count label counter for labels with scores greater than or equal to the current score\n+ * @param totalCount label counter for all labels\n+ */\n+private case class BinaryConfusionMatrixImpl(\n+    count: LabelCounter,\n+    totalCount: LabelCounter) extends BinaryConfusionMatrix with Serializable {\n+\n+  /** number of true positives */\n+  override def tp: Long = count.numPositives\n+\n+  /** number of false positives */\n+  override def fp: Long = count.numNegatives\n+\n+  /** number of false negatives */\n+  override def fn: Long = totalCount.numPositives - count.numPositives\n+\n+  /** number of true negatives */\n+  override def tn: Long = totalCount.numNegatives - count.numNegatives\n+\n+  /** number of positives */\n+  override def p: Long = totalCount.numPositives\n+\n+  /** number of negatives */\n+  override def n: Long = totalCount.numNegatives\n+}\n+\n+/**\n+ * Evaluator for binary classification.\n+ *\n+ * @param scoreAndLabels an RDD of (score, label) pairs.\n+ */\n+class BinaryClassificationMetrics(scoreAndLabels: RDD[(Double, Double)])\n+    extends Serializable with Logging {\n+\n+  private lazy val (\n+      cumCounts: RDD[(Double, LabelCounter)],\n+      confusions: RDD[(Double, BinaryConfusionMatrix)]) = {\n+    // Create a bin for each distinct score value, count positives and negatives within each bin,\n+    // and then sort by score values in descending order.\n+    val counts = scoreAndLabels.combineByKey(\n+      createCombiner = (label: Double) => new LabelCounter(0L, 0L) += label,\n+      mergeValue = (c: LabelCounter, label: Double) => c += label,\n+      mergeCombiners = (c1: LabelCounter, c2: LabelCounter) => c1 += c2\n+    ).sortByKey(ascending = false)\n+    val agg = counts.values.mapPartitions({ iter =>\n+      val agg = new LabelCounter()\n+      iter.foreach(agg += _)\n+      Iterator(agg)\n+    }, preservesPartitioning = true).collect()\n+    val partitionwiseCumCounts =\n+      agg.scanLeft(new LabelCounter())((agg: LabelCounter, c: LabelCounter) => agg.clone() += c)"
  }],
  "prId": 364
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Probably want to call this cumulativeCounts to make it a bit clearer\n",
    "commit": "a05941db7fac61222ac23e69e78f86e165e41ad2",
    "createdAt": "2014-04-10T05:26:10Z",
    "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.evaluation.binary\n+\n+import org.apache.spark.rdd.{UnionRDD, RDD}\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.evaluation.AreaUnderCurve\n+import org.apache.spark.Logging\n+\n+/**\n+ * Implementation of [[org.apache.spark.mllib.evaluation.binary.BinaryConfusionMatrix]].\n+ *\n+ * @param count label counter for labels with scores greater than or equal to the current score\n+ * @param totalCount label counter for all labels\n+ */\n+private case class BinaryConfusionMatrixImpl(\n+    count: LabelCounter,\n+    totalCount: LabelCounter) extends BinaryConfusionMatrix with Serializable {\n+\n+  /** number of true positives */\n+  override def tp: Long = count.numPositives\n+\n+  /** number of false positives */\n+  override def fp: Long = count.numNegatives\n+\n+  /** number of false negatives */\n+  override def fn: Long = totalCount.numPositives - count.numPositives\n+\n+  /** number of true negatives */\n+  override def tn: Long = totalCount.numNegatives - count.numNegatives\n+\n+  /** number of positives */\n+  override def p: Long = totalCount.numPositives\n+\n+  /** number of negatives */\n+  override def n: Long = totalCount.numNegatives\n+}\n+\n+/**\n+ * Evaluator for binary classification.\n+ *\n+ * @param scoreAndLabels an RDD of (score, label) pairs.\n+ */\n+class BinaryClassificationMetrics(scoreAndLabels: RDD[(Double, Double)])\n+    extends Serializable with Logging {\n+\n+  private lazy val (\n+      cumCounts: RDD[(Double, LabelCounter)],"
  }],
  "prId": 364
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Just a minor question, do you want to call these numTruePositives or just truePositives? Anyway I'm happy to merge it as is, just felt truePositives would be shorter.\n",
    "commit": "a05941db7fac61222ac23e69e78f86e165e41ad2",
    "createdAt": "2014-04-10T22:15:41Z",
    "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.evaluation.binary\n+\n+import org.apache.spark.rdd.{UnionRDD, RDD}\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.evaluation.AreaUnderCurve\n+import org.apache.spark.Logging\n+\n+/**\n+ * Implementation of [[org.apache.spark.mllib.evaluation.binary.BinaryConfusionMatrix]].\n+ *\n+ * @param count label counter for labels with scores greater than or equal to the current score\n+ * @param totalCount label counter for all labels\n+ */\n+private case class BinaryConfusionMatrixImpl(\n+    count: LabelCounter,\n+    totalCount: LabelCounter) extends BinaryConfusionMatrix with Serializable {\n+\n+  /** number of true positives */\n+  override def numTruePositives: Long = count.numPositives",
    "line": 36
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "It is shorter but does not have the exact meaning. Similarly, I prefer numCols instead of cols in matrix.\n",
    "commit": "a05941db7fac61222ac23e69e78f86e165e41ad2",
    "createdAt": "2014-04-11T03:11:10Z",
    "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.evaluation.binary\n+\n+import org.apache.spark.rdd.{UnionRDD, RDD}\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.evaluation.AreaUnderCurve\n+import org.apache.spark.Logging\n+\n+/**\n+ * Implementation of [[org.apache.spark.mllib.evaluation.binary.BinaryConfusionMatrix]].\n+ *\n+ * @param count label counter for labels with scores greater than or equal to the current score\n+ * @param totalCount label counter for all labels\n+ */\n+private case class BinaryConfusionMatrixImpl(\n+    count: LabelCounter,\n+    totalCount: LabelCounter) extends BinaryConfusionMatrix with Serializable {\n+\n+  /** number of true positives */\n+  override def numTruePositives: Long = count.numPositives",
    "line": 36
  }],
  "prId": 364
}]