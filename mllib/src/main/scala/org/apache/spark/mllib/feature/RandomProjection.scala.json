[{
  "comments": [{
    "author": {
      "login": "karlhigley"
    },
    "body": "It seems like this could introduce duplicate entries in the CoordinateMatrix created in `computeRPMatrix()` below.  CoordinateMatrix allows the dimensions to be specified as constructor params, which might be preferable.\n",
    "commit": "2c0d8c2ac1e738fa73ee4dc8b09fca55b7eb584a",
    "createdAt": "2015-06-22T15:46:51Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.feature\n+\n+import org.apache.spark.mllib.linalg.Matrix\n+import org.apache.spark.mllib.linalg.distributed.{BlockMatrix, RowMatrix, CoordinateMatrix, MatrixEntry}\n+import org.apache.spark.rdd.RDD\n+import scala.collection.mutable\n+import breeze.stats.distributions.{Uniform, Binomial}\n+import org.apache.spark.SparkContext\n+import org.apache.spark.ml.param.{ParamMap}\n+import org.apache.spark.sql.Row\n+\n+class RandomProjection(intrinsicDimension: Int) {\n+\n+  /**\n+   * recursive implementation of random, non repeating list\n+   * @param data\n+   * @param maxValue\n+   * @return\n+   */\n+  def nonRepeatingRandomItem(data: mutable.MutableList[Int], maxValue: Int): Int = {\n+    val rand = Uniform(0.0, maxValue).draw().toInt\n+    if (data.contains(rand)) nonRepeatingRandomItem(data, maxValue)\n+    else rand\n+  }\n+\n+  /**\n+   * generate list of non repeating, random values\n+   * @param nonZeroRange\n+   * @param maxValue\n+   * @return\n+   */\n+  def drawNonZeroIndices(nonZeroRange: Range, maxValue: Int): List[Int] = {\n+    val nonZeroIndices = mutable.MutableList[Int]()\n+    nonZeroRange map { j =>\n+      nonZeroIndices += nonRepeatingRandomItem(nonZeroIndices, maxValue)\n+    }\n+    nonZeroIndices.toList\n+  }\n+\n+  /**\n+   * draw values\n+   * @param nonZeroRange\n+   * @return\n+   */\n+  def drawNonZeroValues(nonZeroRange: Range): IndexedSeq[Double] = {\n+    nonZeroRange map { _ =>\n+      // random value, either -1 or 1\n+      new Binomial(1, 0.5).draw().toDouble * 2 - 1\n+    }\n+  }\n+\n+  /**\n+   * @param value\n+   * @param density\n+   * @param newDimensions\n+   * @return\n+   */\n+  def scaleNonZeroRandomValue(value: Double, density: Double, newDimensions: Int): Double = {\n+    Math.sqrt(1 / density) / Math.sqrt(newDimensions) * value\n+  }\n+\n+  /**\n+   * in RP, one row refers to one dimension of the intrinsic\n+   * @param origDimensions\n+   * @param density\n+   * @return\n+   */\n+  def computeRPRows(origDimensions: Int, density: Double): List[MatrixEntry] = {\n+    // one row for each dimension of the dataset\n+    val rows = 0 until origDimensions map { rowIndex =>\n+\n+      /**\n+       * flip coin 'origDimensions' times with a probability of 'density' and count\n+       */\n+      val nonZero = new Binomial(intrinsicDimension, density).sample()\n+      val nonZeroRange = 0 until nonZero\n+\n+      val nonZeroIndices = drawNonZeroIndices(nonZeroRange, intrinsicDimension)\n+      val nonZeroValues = drawNonZeroValues(nonZeroRange)\n+\n+      require(nonZeroValues.length == nonZeroIndices.length,\n+              \"nonZero values and indices must have same length\")\n+\n+      val merged = nonZeroIndices.zip(nonZeroValues).map { item =>\n+        val colIndex = item._1\n+        // scale each value\n+        val value = scaleNonZeroRandomValue(value = item._2, density, origDimensions)\n+        new MatrixEntry(rowIndex, colIndex, value)\n+      }\n+      merged.toList\n+    }\n+\n+    /**\n+     * make sure the matrix has the correct dimension while initializing it with the\n+     * required dimensions\n+     */\n+    val initialSize = List(new MatrixEntry(origDimensions - 1, intrinsicDimension - 1, 0.0))"
  }, {
    "author": {
      "login": "sebastian-alfers"
    },
    "body": "@karlhigley thanks for that! Added dimensions to the constructor\n",
    "commit": "2c0d8c2ac1e738fa73ee4dc8b09fca55b7eb584a",
    "createdAt": "2015-06-23T13:08:36Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.feature\n+\n+import org.apache.spark.mllib.linalg.Matrix\n+import org.apache.spark.mllib.linalg.distributed.{BlockMatrix, RowMatrix, CoordinateMatrix, MatrixEntry}\n+import org.apache.spark.rdd.RDD\n+import scala.collection.mutable\n+import breeze.stats.distributions.{Uniform, Binomial}\n+import org.apache.spark.SparkContext\n+import org.apache.spark.ml.param.{ParamMap}\n+import org.apache.spark.sql.Row\n+\n+class RandomProjection(intrinsicDimension: Int) {\n+\n+  /**\n+   * recursive implementation of random, non repeating list\n+   * @param data\n+   * @param maxValue\n+   * @return\n+   */\n+  def nonRepeatingRandomItem(data: mutable.MutableList[Int], maxValue: Int): Int = {\n+    val rand = Uniform(0.0, maxValue).draw().toInt\n+    if (data.contains(rand)) nonRepeatingRandomItem(data, maxValue)\n+    else rand\n+  }\n+\n+  /**\n+   * generate list of non repeating, random values\n+   * @param nonZeroRange\n+   * @param maxValue\n+   * @return\n+   */\n+  def drawNonZeroIndices(nonZeroRange: Range, maxValue: Int): List[Int] = {\n+    val nonZeroIndices = mutable.MutableList[Int]()\n+    nonZeroRange map { j =>\n+      nonZeroIndices += nonRepeatingRandomItem(nonZeroIndices, maxValue)\n+    }\n+    nonZeroIndices.toList\n+  }\n+\n+  /**\n+   * draw values\n+   * @param nonZeroRange\n+   * @return\n+   */\n+  def drawNonZeroValues(nonZeroRange: Range): IndexedSeq[Double] = {\n+    nonZeroRange map { _ =>\n+      // random value, either -1 or 1\n+      new Binomial(1, 0.5).draw().toDouble * 2 - 1\n+    }\n+  }\n+\n+  /**\n+   * @param value\n+   * @param density\n+   * @param newDimensions\n+   * @return\n+   */\n+  def scaleNonZeroRandomValue(value: Double, density: Double, newDimensions: Int): Double = {\n+    Math.sqrt(1 / density) / Math.sqrt(newDimensions) * value\n+  }\n+\n+  /**\n+   * in RP, one row refers to one dimension of the intrinsic\n+   * @param origDimensions\n+   * @param density\n+   * @return\n+   */\n+  def computeRPRows(origDimensions: Int, density: Double): List[MatrixEntry] = {\n+    // one row for each dimension of the dataset\n+    val rows = 0 until origDimensions map { rowIndex =>\n+\n+      /**\n+       * flip coin 'origDimensions' times with a probability of 'density' and count\n+       */\n+      val nonZero = new Binomial(intrinsicDimension, density).sample()\n+      val nonZeroRange = 0 until nonZero\n+\n+      val nonZeroIndices = drawNonZeroIndices(nonZeroRange, intrinsicDimension)\n+      val nonZeroValues = drawNonZeroValues(nonZeroRange)\n+\n+      require(nonZeroValues.length == nonZeroIndices.length,\n+              \"nonZero values and indices must have same length\")\n+\n+      val merged = nonZeroIndices.zip(nonZeroValues).map { item =>\n+        val colIndex = item._1\n+        // scale each value\n+        val value = scaleNonZeroRandomValue(value = item._2, density, origDimensions)\n+        new MatrixEntry(rowIndex, colIndex, value)\n+      }\n+      merged.toList\n+    }\n+\n+    /**\n+     * make sure the matrix has the correct dimension while initializing it with the\n+     * required dimensions\n+     */\n+    val initialSize = List(new MatrixEntry(origDimensions - 1, intrinsicDimension - 1, 0.0))"
  }],
  "prId": 6613
}]