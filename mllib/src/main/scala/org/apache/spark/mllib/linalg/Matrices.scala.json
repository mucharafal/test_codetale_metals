[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "organize imports\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:22:51Z",
    "diffHunk": "@@ -17,10 +17,11 @@\n \n package org.apache.spark.mllib.linalg\n \n-import java.util.{Random, Arrays}\n-\n import breeze.linalg.{Matrix => BM, DenseMatrix => BDM, CSCMatrix => BSM}\n \n+import java.util.{Random, Arrays}\n+import scala.collection.mutable.ArrayBuffer"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Should comment on the behavior for sparse matrices, for example, `map(_+ 1)`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:22:53Z",
    "diffHunk": "@@ -80,6 +81,12 @@ sealed trait Matrix extends Serializable {\n \n   /** A human readable representation of the matrix */\n   override def toString: String = toBreeze.toString()\n+\n+  /** Map the values of this matrix using a function. Generates a new matrix. */"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Ditto. What happens when there are non-presenting zero values?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:22:55Z",
    "diffHunk": "@@ -80,6 +81,12 @@ sealed trait Matrix extends Serializable {\n \n   /** A human readable representation of the matrix */\n   override def toString: String = toBreeze.toString()\n+\n+  /** Map the values of this matrix using a function. Generates a new matrix. */\n+  private[mllib] def map(f: Double => Double): Matrix\n+\n+  /** Update all the values of this matrix using the function f. Performed in-place. */\n+  private[mllib] def update(f: Double => Double): Matrix"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Is it handled inside the constructor of `SparseMatrix`?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:23:00Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {"
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "Right now, it's not. Currently users can supply zero values during the construction of SparseMatrix. Two things:\n1) Should I add a check in the constructor of SparseMatrix?\n2) Should I transform genRand into something like .toSparse() inside DenseMatrix, and add a .toDense() inside SparseMatrix? (I actually had these two methods in my multi model training repo)\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-16T07:34:39Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "space before `{` (and please fix other places)\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:23:02Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol){\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol){"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`density = 0.0` and `density = 1.0` should be valid.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:23:04Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol){\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol){\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density > 0.0 && density < 1.0, \"density must be a double in the range \" +\n+      s\"0.0 < d < 1.0. Currently, density: $density\")"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`DenseMatrix`?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:23:06Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol){\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol){\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density > 0.0 && density < 1.0, \"density must be a double in the range \" +\n+      s\"0.0 < d < 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextDouble())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density > 0.0 && density < 1.0, \"density must be a double in the range \" +\n+      s\"0.0 < d < 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextGaussian())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `DenseMatrix` format from the supplied values."
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "Good catch!\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-16T07:24:55Z",
    "diffHunk": "@@ -197,6 +295,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if ( v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol){\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol){\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density > 0.0 && density < 1.0, \"density must be a double in the range \" +\n+      s\"0.0 < d < 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextDouble())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density > 0.0 && density < 1.0, \"density must be a double in the range \" +\n+      s\"0.0 < d < 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextGaussian())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `DenseMatrix` format from the supplied values."
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Is it the same behavior as in MATLAB? (Sorry I don't have MATLAB installed.)\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-15T23:23:11Z",
    "diffHunk": "@@ -313,15 +593,145 @@ object Matrices {\n    * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a dense matrix."
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "MATLAB does it the other way around. If one matrix is sparse, then the final matrix turns out to be sparse as well.\nThat's why I added the note. Should I make it consistent with MATLAB?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-16T07:22:38Z",
    "diffHunk": "@@ -313,15 +593,145 @@ object Matrices {\n    * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a dense matrix."
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I like the MATLAB approach better. Usually a sparse matrix is very sparse, while a dense component is quite small, for example,\n\n```\nA^T A  A^T\nA      I\n```\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-16T19:40:20Z",
    "diffHunk": "@@ -313,15 +593,145 @@ object Matrices {\n    * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a dense matrix."
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "Okay, will do.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-16T20:32:05Z",
    "diffHunk": "@@ -313,15 +593,145 @@ object Matrices {\n    * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a dense matrix."
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`eye(n)` -> `zeros(n, n)`\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:46Z",
    "diffHunk": "@@ -123,6 +135,97 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.DenseMatrix]].\n+ */\n+object DenseMatrix {\n+\n+  /**\n+   * Generate a `DenseMatrix` consisting of zeros.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   */\n+  def zeros(numRows: Int, numCols: Int): DenseMatrix =\n+    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+\n+  /**\n+   * Generate a `DenseMatrix` consisting of ones.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   */\n+  def ones(numRows: Int, numCols: Int): DenseMatrix =\n+    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+\n+  /**\n+   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def eye(n: Int): DenseMatrix = {\n+    val identity = DenseMatrix.zeros(n, n)\n+    var i = 0\n+    while (i < n) {\n+      identity.update(i, i, 1.0)\n+      i += 1\n+    }\n+    identity\n+  }\n+\n+  /**\n+   * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param rng a random number generator\n+   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def rand(numRows: Int, numCols: Int, rng: Random): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n+  }\n+\n+  /**\n+   * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param rng a random number generator\n+   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def randn(numRows: Int, numCols: Int, rng: Random): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n+   * @param vector a `Vector` that will form the values on the diagonal of the matrix\n+   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   *         on the diagonal\n+   */\n+  def diag(vector: Vector): DenseMatrix = {\n+    val n = vector.size\n+    val matrix = DenseMatrix.eye(n)"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is a little confusing. First of all, there is no randomness. Secondly, the doc doesn't describe how the values gets fill-in. Is it supposed to be a method in `DenseMatrix` called `toSparse`?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:49Z",
    "diffHunk": "@@ -197,6 +300,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand("
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`sprand` is not generated this way, which has `O(m * n)` complexity. Please check MATLAB's implementation of octave's.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:51Z",
    "diffHunk": "@@ -197,6 +300,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if (v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol) {\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol) {\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Ditto. `O(m * n)` is too expensive.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:54Z",
    "diffHunk": "@@ -197,6 +300,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if (v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol) {\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol) {\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextDouble())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The logic could be simplified by adding a factory method that takes a sparse matrix in the coordinate list (COO) format and turns it into CSC. Then `diag` just calls that method.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:56Z",
    "diffHunk": "@@ -197,6 +300,171 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a SparseMatrix given an Array[Double] of size numRows * numCols. The number of\n+    * non-zeros in `raw` is provided for efficiency. */\n+  private def genRand(\n+      numRows: Int,\n+      numCols: Int,\n+      raw: Array[Double],\n+      nonZero: Int): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer(nonZero)\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer(nonZero)\n+\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    raw.foreach { v =>\n+      val r = i % numRows\n+      val c = (i - r) / numRows\n+      if (v != 0.0) {\n+        sRows.append(r)\n+        sparseA.append(v)\n+        while (c != lastCol) {\n+          sCols.append(nnz)\n+          lastCol += 1\n+        }\n+        nnz += 1\n+      }\n+      i += 1\n+    }\n+    while (numCols > lastCol) {\n+      sCols.append(sparseA.length)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, sCols.toArray, sRows.toArray, sparseA.toArray)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextDouble())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = numRows * numCols\n+    val rawA = new Array[Double](length)\n+    var nnz = 0\n+    for (i <- 0 until length) {\n+      val p = rng.nextDouble()\n+      if (p <= density) {\n+        rawA.update(i, rng.nextGaussian())\n+        nnz += 1\n+      }\n+    }\n+    genRand(numRows, numCols, rawA, nnz)\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `SparseMatrix` format from the supplied values.\n+   * @param vector a `Vector` that will form the values on the diagonal of the matrix\n+   * @return Square `SparseMatrix` with size `values.length` x `values.length` and non-zero\n+   *         `values` on the diagonal\n+   */\n+  def diag(vector: Vector): SparseMatrix = {\n+    val n = vector.size\n+    vector match {\n+      case sVec: SparseVector =>\n+        val rows = sVec.indices"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It is nice to put all operators under `Matrices`. Then maybe we can mark the ones under `SparkMatrix` and `DenseMatrix` private.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:37:58Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)",
    "line": 374
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "I specifically don't want to mark them private, otherwise the user will have to always write `.asInstanceOf[SparseMatrix]`. We could mark it `private[mllib]` and still use them, but not having `.asInstanceOf` everywhere, especially while writing tests on spark-shell is a very nice convenience.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T07:06:40Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)",
    "line": 374
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I see your point. The reason we didn't return the exact type in `Vectors` and `Matrices` was because RDD is not covariant. But maybe we should return the exact types that and let algorithms take a generic `RDD[T]` with `T` extending `Vector`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T19:09:57Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)",
    "line": 374
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "What if the input is an empty array? The behavior should be documented.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:38:01Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`isDense` -> `hasDense`? Same for `isSparse`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:38:02Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var isDense = false"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`matrices.flatMap(_.toArray)` should return an `Array[Double]` already. `matrices.map(_.toArray).flatten` may be more efficient but I'm not sure.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:38:05Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var isDense = false\n+    var isSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => isSparse = true\n+        case dense: DenseMatrix => isDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!isSparse && isDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray).toArray)"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This could be simplified if we add `toSparse` to `DenseMatrix` and put a factory method for COO input.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:38:06Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var isDense = false\n+    var isSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => isSparse = true\n+        case dense: DenseMatrix => isDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!isSparse && isDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray).toArray)\n+    } else {\n+      val allColPtrs: Array[(Int, Int)] = Array((0, 0)) ++"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "See my comments for `horzcat`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-17T22:38:22Z",
    "diffHunk": "@@ -256,72 +524,297 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var isDense = false\n+    var isSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => isSparse = true\n+        case dense: DenseMatrix => isDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!isSparse && isDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray).toArray)\n+    } else {\n+      val allColPtrs: Array[(Int, Int)] = Array((0, 0)) ++\n+        matrices.zipWithIndex.flatMap { case (mat, ind) =>\n+          mat match {\n+            case spMat: SparseMatrix =>\n+              val ptr = spMat.colPtrs\n+              ptr.slice(1, ptr.length).map(p => (ind, p))\n+            case dnMat: DenseMatrix =>\n+              val colSize = dnMat.numCols\n+              var j = 0\n+              val rowSize = dnMat.numRows\n+              val ptr = new ArrayBuffer[(Int, Int)](colSize)\n+              var nnz = 0\n+              val vals = dnMat.values\n+              while (j < colSize) {\n+                var i = j * rowSize\n+                val indEnd = (j + 1) * rowSize\n+                while (i < indEnd) {\n+                  if (vals(i) != 0.0) nnz += 1\n+                  i += 1\n+                }\n+                j += 1\n+                ptr.append((ind, nnz))\n+              }\n+              ptr\n+          }\n+        }\n+      var counter = 0\n+      var lastIndex = 0\n+      var lastPtr = 0\n+      val adjustedPtrs = allColPtrs.map { case (ind, p) =>\n+        if (ind != lastIndex) {\n+          counter += lastPtr\n+          lastIndex = ind\n+        }\n+        lastPtr = p\n+        counter + p\n+      }\n+      val valsAndIndices: Array[(Int, Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          spMat.rowIndices.zip(spMat.values)\n+        case dnMat: DenseMatrix =>\n+          val colSize = dnMat.numCols\n+          var j = 0\n+          val rowSize = dnMat.numRows\n+          val data = new ArrayBuffer[(Int, Double)]()\n+          val vals = dnMat.values\n+          while (j < colSize) {\n+            val indStart = j * rowSize\n+            var i = 0\n+            while (i < rowSize) {\n+              val index = indStart + i\n+              if (vals(index) != 0.0) data.append((i, vals(index)))\n+              i += 1\n+            }\n+            j += 1\n+          }\n+          data\n+      }\n+      new SparseMatrix(numRows, numCols, adjustedPtrs,\n+        valsAndIndices.map(_._1), valsAndIndices.map(_._2))\n+    }\n+  }\n+\n+  /**\n+   * Vertically concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were vertically concatenated\n+   */\n+  def vertcat(matrices: Array[Matrix]): Matrix = {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Please use `ArrayBuilder` instead because `ArrayBuffer` is not specialized for primitive types, unfortunately.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:08Z",
    "diffHunk": "@@ -123,6 +135,126 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `SparseMatrix` from the given `DenseMatrix`. */\n+  def toSparse(): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer()"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If we already know the size, we don't need a buffer. Btw, it would be nice if we use the same naming as in `SparseVector` for consistency, `colPtrs` in this case.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:10Z",
    "diffHunk": "@@ -123,6 +135,126 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `SparseMatrix` from the given `DenseMatrix`. */\n+  def toSparse(): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer()\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Is it simpler to use two while loops with a counter?\n\n```\nvar i = 0\nvar j = 0\nvar idx = 0\nwhile (j < n) {\n  while (i < m) {\n    if (values(idx) != 0) {\n     ...\n    }\n    i += 1\n    idx += 1\n  }\n  ...\n  j += 1\n}\n```\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:12Z",
    "diffHunk": "@@ -123,6 +135,126 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `SparseMatrix` from the given `DenseMatrix`. */\n+  def toSparse(): SparseMatrix = {\n+    val sparseA: ArrayBuffer[Double] = new ArrayBuffer()\n+    val sCols: ArrayBuffer[Int] = new ArrayBuffer(numCols + 1)\n+    val sRows: ArrayBuffer[Int] = new ArrayBuffer()\n+    var i = 0\n+    var nnz = 0\n+    var lastCol = -1\n+    values.foreach { v =>"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`(Int, Int, Double)` should be sufficient and it saves one object.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:16Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: COO doesn't have this restriction. We should sort the input entries, which could be done in a separate PR.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:19Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {\n+    val colPtrs = new ArrayBuffer[Int](numCols + 1)\n+    colPtrs.append(0)\n+    var nnz = 0\n+    var lastCol = 0\n+    val values = entries.map { case ((i, j), v) =>\n+      while (j != lastCol) {\n+        colPtrs.append(nnz)\n+        lastCol += 1\n+        if (lastCol > numCols) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: It may be cleaner if we just use this function to generate the skeleton and fill in values inside `sprandn` and `sprand`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:38Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {\n+    val colPtrs = new ArrayBuffer[Int](numCols + 1)\n+    colPtrs.append(0)\n+    var nnz = 0\n+    var lastCol = 0\n+    val values = entries.map { case ((i, j), v) =>\n+      while (j != lastCol) {\n+        colPtrs.append(nnz)\n+        lastCol += 1\n+        if (lastCol > numCols) {\n+          throw new IndexOutOfBoundsException(\"Please make sure that the entries array is \" +\n+            \"sorted by COLUMN index first and then by row index.\")\n+        }\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs.append(nnz)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, entries.map(_._1._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,"
  }, {
    "author": {
      "login": "brkyvz"
    },
    "body": "That's possible. This is how MATLAB does it, calls \"rand\" and fills it according to \"sprand\" or \"sprandn\". I thought it looked more functional this way, get over with it with just one loop.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T08:28:09Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {\n+    val colPtrs = new ArrayBuffer[Int](numCols + 1)\n+    colPtrs.append(0)\n+    var nnz = 0\n+    var lastCol = 0\n+    val values = entries.map { case ((i, j), v) =>\n+      while (j != lastCol) {\n+        colPtrs.append(nnz)\n+        lastCol += 1\n+        if (lastCol > numCols) {\n+          throw new IndexOutOfBoundsException(\"Please make sure that the entries array is \" +\n+            \"sorted by COLUMN index first and then by row index.\")\n+        }\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs.append(nnz)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, entries.map(_._1._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "It is harder to read this way. Also, if we generate the skeleton first, we don't need to handle dynamic values array. Having everything in one loop is not a goal, and it doesn't always give us performance gain.\n\n``` scala\ndef genRandPattern(numRows, numCols, density, rng): SparseMatrix {\n  ...\n}\n\ndef sprand(numRows, numCols, density, rng): SparseMatrix {\n  val mat = genRandPattern(numRows, numCols, density, rng)\n  // fill-in the values with rng.nextDouble\n}\n```\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:00Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {\n+    val colPtrs = new ArrayBuffer[Int](numCols + 1)\n+    colPtrs.append(0)\n+    var nnz = 0\n+    var lastCol = 0\n+    val values = entries.map { case ((i, j), v) =>\n+      while (j != lastCol) {\n+        colPtrs.append(nnz)\n+        lastCol += 1\n+        if (lastCol > numCols) {\n+          throw new IndexOutOfBoundsException(\"Please make sure that the entries array is \" +\n+            \"sorted by COLUMN index first and then by row index.\")\n+        }\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs.append(nnz)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, entries.map(_._1._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If `density` is close to `1`, it is hard to end this while loop. We can combine this approach with selection-rejection to achieve `O(nnz)` complexity:\n\nhttps://github.com/mengxr/spark-sampling/blob/master/src/main/scala/org/apache/spark/sampling/RDDSamplingFunctions.scala#L98\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:39Z",
    "diffHunk": "@@ -197,6 +331,145 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples. Array must be sorted first by *column* index and then by row\n+   * index.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of ((row, column), value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[((Int, Int), Double)]): SparseMatrix = {\n+    val colPtrs = new ArrayBuffer[Int](numCols + 1)\n+    colPtrs.append(0)\n+    var nnz = 0\n+    var lastCol = 0\n+    val values = entries.map { case ((i, j), v) =>\n+      while (j != lastCol) {\n+        colPtrs.append(nnz)\n+        lastCol += 1\n+        if (lastCol > numCols) {\n+          throw new IndexOutOfBoundsException(\"Please make sure that the entries array is \" +\n+            \"sorted by COLUMN index first and then by row index.\")\n+        }\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs.append(nnz)\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, entries.map(_._1._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,\n+      density: Double,\n+      rng: Random,\n+      method: Random => Double): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = math.ceil(numRows * numCols * density).toInt\n+    val entries = Map[(Int, Int), Double]()\n+    var i = 0\n+    while (i < length) {\n+      var rowIndex = rng.nextInt(numRows)\n+      var colIndex = rng.nextInt(numCols)\n+      while (entries.contains((rowIndex, colIndex))) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: It is good to put `matrices.size == 0`(or `matrices.isEmpty`) branch before `matrices.size == 1`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:43Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`hasDense` is not needed. If `hasSparse` is false, all matrices are dense.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:44Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasDense = false"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The zip operation creates a temp array. For sparse matrices, it is more consistent to use the standard loop:\n\n``` scala\nwhile (j < numCols) {\n  var idx = colPtrs(j)\n  while (idx < colPtrs(j + 1)) {\n    val i = rowIndices(idx)\n    val v = values(idx)\n    ...\n    idx += 1\n  }\n  j += 1\n}\n```\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:46Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasDense = false\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => hasDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse && hasDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[((Int, Int), Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          var cnt = 0\n+          val ptr = spMat.colPtrs\n+          val data = spMat.rowIndices.zip(spMat.values).map { case (i, v) =>"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Same here. This is expensive because it creates multiple temp arrays. Using two while loops should be sufficient.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:48Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasDense = false\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => hasDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse && hasDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[((Int, Int), Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          var cnt = 0\n+          val ptr = spMat.colPtrs\n+          val data = spMat.rowIndices.zip(spMat.values).map { case (i, v) =>\n+            cnt += 1\n+            if (cnt <= ptr(j + 1)) {\n+              ((i, j + startCol), v)\n+            } else {\n+              while (ptr(j + 1) < cnt) {\n+                j += 1\n+              }\n+              ((i, j + startCol), v)\n+            }\n+          }\n+          startCol += spMat.numCols\n+          data\n+        case dnMat: DenseMatrix =>\n+          val nnzValues = dnMat.values.zipWithIndex.filter(v => v._1 != 0.0)"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`hasDense` is not necessary.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:50Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasDense = false\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => hasDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse && hasDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[((Int, Int), Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          var cnt = 0\n+          val ptr = spMat.colPtrs\n+          val data = spMat.rowIndices.zip(spMat.values).map { case (i, v) =>\n+            cnt += 1\n+            if (cnt <= ptr(j + 1)) {\n+              ((i, j + startCol), v)\n+            } else {\n+              while (ptr(j + 1) < cnt) {\n+                j += 1\n+              }\n+              ((i, j + startCol), v)\n+            }\n+          }\n+          startCol += spMat.numCols\n+          data\n+        case dnMat: DenseMatrix =>\n+          val nnzValues = dnMat.values.zipWithIndex.filter(v => v._1 != 0.0)\n+          val data = nnzValues.map { case (v, i) =>\n+            val rowIndex = i % dnMat.numRows\n+            val colIndex = i / dnMat.numRows\n+            ((rowIndex, colIndex + startCol), v)\n+          }\n+          startCol += dnMat.numCols\n+          data\n+      }\n+      SparseMatrix.fromCOO(numRows, numCols, entries)\n+    }\n+  }\n+\n+  /**\n+   * Vertically concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were vertically concatenated\n+   */\n+  def vertcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numCols = matrices(0).numCols\n+    var colsMatch = true\n+    var hasDense = false"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Same issues here.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-18T20:56:51Z",
    "diffHunk": "@@ -256,72 +529,222 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasDense = false\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => hasDense = true\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse && hasDense) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[((Int, Int), Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          var cnt = 0\n+          val ptr = spMat.colPtrs\n+          val data = spMat.rowIndices.zip(spMat.values).map { case (i, v) =>\n+            cnt += 1\n+            if (cnt <= ptr(j + 1)) {\n+              ((i, j + startCol), v)\n+            } else {\n+              while (ptr(j + 1) < cnt) {\n+                j += 1\n+              }\n+              ((i, j + startCol), v)\n+            }\n+          }\n+          startCol += spMat.numCols\n+          data\n+        case dnMat: DenseMatrix =>\n+          val nnzValues = dnMat.values.zipWithIndex.filter(v => v._1 != 0.0)\n+          val data = nnzValues.map { case (v, i) =>\n+            val rowIndex = i % dnMat.numRows\n+            val colIndex = i / dnMat.numRows\n+            ((rowIndex, colIndex + startCol), v)\n+          }\n+          startCol += dnMat.numCols\n+          data\n+      }\n+      SparseMatrix.fromCOO(numRows, numCols, entries)\n+    }\n+  }\n+\n+  /**\n+   * Vertically concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were vertically concatenated\n+   */\n+  def vertcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.size == 1) {\n+      return matrices(0)\n+    } else if (matrices.size == 0) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    }\n+    val numCols = matrices(0).numCols\n+    var colsMatch = true\n+    var hasDense = false\n+    var hasSparse = false\n+    var numRows = 0\n+    var valsLength = 0\n+    matrices.foreach { mat =>\n+      if (numCols != mat.numCols) colsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix =>\n+          hasSparse = true\n+          valsLength += sparse.values.length\n+        case dense: DenseMatrix =>\n+          hasDense = true\n+          valsLength += dense.values.length\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numRows += mat.numRows\n+\n+    }\n+    require(colsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse && hasDense) {\n+      val matData = matrices.zipWithIndex.flatMap { case (mat, ind) =>\n+        val values = mat.toArray\n+        for (j <- 0 until numCols) yield (j, ind,\n+          values.slice(j * mat.numRows, (j + 1) * mat.numRows))\n+      }.sortBy(x => (x._1, x._2))\n+      new DenseMatrix(numRows, numCols, matData.flatMap(_._3))\n+    } else {\n+      var startRow = 0\n+      val entries: Array[((Int, Int), Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It iterates over a full 2-d grid. We can update `colPtrs` after each `while (i < numRows)` block.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:33:46Z",
    "diffHunk": "@@ -123,6 +135,130 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `SparseMatrix` from the given `DenseMatrix`. */\n+  def toSparse(): SparseMatrix = {\n+    val spVals: ArrayBuilder[Double] = new ArrayBuilder.ofDouble\n+    val colPtrs: Array[Int] = new Array[Int](numCols + 1)\n+    val rowIndices: ArrayBuilder[Int] = new ArrayBuilder.ofInt\n+    var nnz = 0\n+    var lastCol = -1\n+    var j = 0\n+    while (j < numCols) {\n+      var i = 0\n+      val indStart = j * numRows\n+      while (i < numRows) {\n+        val v = values(indStart + i)\n+        if (v != 0.0) {\n+          rowIndices += i\n+          spVals += v\n+          while (j != lastCol) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This check is not necessary. At the end of the `while (j < numCols)` loop, `j = numCols + 1`. So it is `colPtrs(j) = nnz`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:33:49Z",
    "diffHunk": "@@ -123,6 +135,130 @@ class DenseMatrix(val numRows: Int, val numCols: Int, val values: Array[Double])\n   }\n \n   override def copy = new DenseMatrix(numRows, numCols, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) = new DenseMatrix(numRows, numCols, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): DenseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `SparseMatrix` from the given `DenseMatrix`. */\n+  def toSparse(): SparseMatrix = {\n+    val spVals: ArrayBuilder[Double] = new ArrayBuilder.ofDouble\n+    val colPtrs: Array[Int] = new Array[Int](numCols + 1)\n+    val rowIndices: ArrayBuilder[Int] = new ArrayBuilder.ofInt\n+    var nnz = 0\n+    var lastCol = -1\n+    var j = 0\n+    while (j < numCols) {\n+      var i = 0\n+      val indStart = j * numRows\n+      while (i < numRows) {\n+        val v = values(indStart + i)\n+        if (v != 0.0) {\n+          rowIndices += i\n+          spVals += v\n+          while (j != lastCol) {\n+            colPtrs(lastCol + 1) = nnz\n+            lastCol += 1\n+          }\n+          nnz += 1\n+        }\n+        i += 1\n+      }\n+      j += 1\n+    }\n+    while (numCols > lastCol) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "What's the behavior if there are duplicate coordinates in the input? This should be documented. In MATLAB's `sparse`, \"Any elements of s that have duplicate values of i and j are added together.\"\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:33:54Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We can add a check on `j >=0`. If there is `j = -2` in the input, we get a dead loop.\n\nIt is a little hard to read if we put the `colPtrs` construction code inside the map. We are separate the code. There is no performance penalty.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:33:56Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {\n+    val sortedEntries = entries.sortBy(v => (v._2, v._1))\n+    val colPtrs = new Array[Int](numCols + 1)\n+    var nnz = 0\n+    var lastCol = -1\n+    val values = sortedEntries.map { case (i, j, v) =>\n+      while (j != lastCol) {"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "indices out of bound\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:02Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {\n+    val sortedEntries = entries.sortBy(v => (v._2, v._1))\n+    val colPtrs = new Array[Int](numCols + 1)\n+    var nnz = 0\n+    var lastCol = -1\n+    val values = sortedEntries.map { case (i, j, v) =>\n+      while (j != lastCol) {\n+        colPtrs(lastCol + 1) = nnz\n+        lastCol += 1\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs(lastCol + 1) = nnz\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, sortedEntries.map(_._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,\n+      density: Double,\n+      rng: Random,\n+      method: Random => Double): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = math.ceil(numRows * numCols * density).toInt\n+    val entries = MutableMap[(Int, Int), Double]()\n+    var i = 0\n+    if (density == 0.0) {\n+      return new SparseMatrix(numRows, numCols, new Array[Int](numCols + 1),\n+        Array[Int](), Array[Double]())\n+    } else if (density == 1.0) {\n+      return new SparseMatrix(numRows, numCols, (0 to numRows * numCols by numRows).toArray,"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Using a map here is not optimal. The sampled entries are ordered. We can construct `rowIndices` and `colPtrs` directly.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:04Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {\n+    val sortedEntries = entries.sortBy(v => (v._2, v._1))\n+    val colPtrs = new Array[Int](numCols + 1)\n+    var nnz = 0\n+    var lastCol = -1\n+    val values = sortedEntries.map { case (i, j, v) =>\n+      while (j != lastCol) {\n+        colPtrs(lastCol + 1) = nnz\n+        lastCol += 1\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs(lastCol + 1) = nnz\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, sortedEntries.map(_._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,\n+      density: Double,\n+      rng: Random,\n+      method: Random => Double): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = math.ceil(numRows * numCols * density).toInt\n+    val entries = MutableMap[(Int, Int), Double]()\n+    var i = 0\n+    if (density == 0.0) {\n+      return new SparseMatrix(numRows, numCols, new Array[Int](numCols + 1),\n+        Array[Int](), Array[Double]())\n+    } else if (density == 1.0) {\n+      return new SparseMatrix(numRows, numCols, (0 to numRows * numCols by numRows).toArray,\n+        (0 until numRows * numCols).toArray, Array.fill(numRows * numCols)(method(rng)))\n+    }\n+    // Expected number of iterations is less than 1.5 * length\n+    if (density < 0.34) {\n+      while (i < length) {\n+        var rowIndex = rng.nextInt(numRows)\n+        var colIndex = rng.nextInt(numCols)\n+        while (entries.contains((rowIndex, colIndex))) {\n+          rowIndex = rng.nextInt(numRows)\n+          colIndex = rng.nextInt(numCols)\n+        }\n+        entries += (rowIndex, colIndex) -> method(rng)\n+        i += 1\n+      }\n+    } else { // selection - rejection method\n+      var j = 0\n+      val pool = numRows * numCols\n+      // loop over columns so that the sort in fromCOO requires less sorting\n+      while (i < length && j < numCols) {\n+        var passedInPool = j * numRows\n+        var r = 0\n+        while (i < length && r < numRows) {\n+          if (rng.nextDouble() < 1.0 * (length - i) / (pool - passedInPool)) {\n+            entries += (r, j) -> method(rng)"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is only used once. Maybe we don't need to declare a val for it.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:06Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {\n+    val sortedEntries = entries.sortBy(v => (v._2, v._1))\n+    val colPtrs = new Array[Int](numCols + 1)\n+    var nnz = 0\n+    var lastCol = -1\n+    val values = sortedEntries.map { case (i, j, v) =>\n+      while (j != lastCol) {\n+        colPtrs(lastCol + 1) = nnz\n+        lastCol += 1\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs(lastCol + 1) = nnz\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, sortedEntries.map(_._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,\n+      density: Double,\n+      rng: Random,\n+      method: Random => Double): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = math.ceil(numRows * numCols * density).toInt\n+    val entries = MutableMap[(Int, Int), Double]()\n+    var i = 0\n+    if (density == 0.0) {\n+      return new SparseMatrix(numRows, numCols, new Array[Int](numCols + 1),\n+        Array[Int](), Array[Double]())\n+    } else if (density == 1.0) {\n+      return new SparseMatrix(numRows, numCols, (0 to numRows * numCols by numRows).toArray,\n+        (0 until numRows * numCols).toArray, Array.fill(numRows * numCols)(method(rng)))\n+    }\n+    // Expected number of iterations is less than 1.5 * length\n+    if (density < 0.34) {\n+      while (i < length) {\n+        var rowIndex = rng.nextInt(numRows)\n+        var colIndex = rng.nextInt(numCols)\n+        while (entries.contains((rowIndex, colIndex))) {\n+          rowIndex = rng.nextInt(numRows)\n+          colIndex = rng.nextInt(numCols)\n+        }\n+        entries += (rowIndex, colIndex) -> method(rng)\n+        i += 1\n+      }\n+    } else { // selection - rejection method\n+      var j = 0\n+      val pool = numRows * numCols\n+      // loop over columns so that the sort in fromCOO requires less sorting\n+      while (i < length && j < numCols) {\n+        var passedInPool = j * numRows\n+        var r = 0\n+        while (i < length && r < numRows) {\n+          if (rng.nextDouble() < 1.0 * (length - i) / (pool - passedInPool)) {\n+            entries += (r, j) -> method(rng)\n+            i += 1\n+          }\n+          r += 1\n+          passedInPool += 1\n+        }\n+        j += 1\n+      }\n+    }\n+    SparseMatrix.fromCOO(numRows, numCols, entries.toArray.map(v => (v._1._1, v._1._2, v._2)))\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers. The number of non-zero\n+   * elements equal the ceiling of `numRows` x `numCols` x `density`\n+   *\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    def method(rand: Random): Double = rand.nextDouble()\n+    genRandMatrix(numRows, numCols, density, rng, method)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    def method(rand: Random): Double = rand.nextGaussian()\n+    genRandMatrix(numRows, numCols, density, rng, method)\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `SparseMatrix` format from the supplied values.\n+   * @param vector a `Vector` that will form the values on the diagonal of the matrix\n+   * @return Square `SparseMatrix` with size `values.length` x `values.length` and non-zero\n+   *         `values` on the diagonal\n+   */\n+  def diag(vector: Vector): SparseMatrix = {\n+    val n = vector.size\n+    vector match {\n+      case sVec: SparseVector =>\n+        val indices = sVec.indices"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`values` -> `entries`?\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:08Z",
    "diffHunk": "@@ -197,6 +335,167 @@ class SparseMatrix(\n   }\n \n   override def copy = new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.clone())\n+\n+  private[mllib] def map(f: Double => Double) =\n+    new SparseMatrix(numRows, numCols, colPtrs, rowIndices, values.map(f))\n+\n+  private[mllib] def update(f: Double => Double): SparseMatrix = {\n+    val len = values.length\n+    var i = 0\n+    while (i < len) {\n+      values(i) = f(values(i))\n+      i += 1\n+    }\n+    this\n+  }\n+\n+  /** Generate a `DenseMatrix` from the given `SparseMatrix`. */\n+  def toDense(): DenseMatrix = {\n+    new DenseMatrix(numRows, numCols, toArray)\n+  }\n+}\n+\n+/**\n+ * Factory methods for [[org.apache.spark.mllib.linalg.SparseMatrix]].\n+ */\n+object SparseMatrix {\n+\n+  /**\n+   * Generate a `SparseMatrix` from Coordinate List (COO) format. Input must be an array of\n+   * (row, column, value) tuples.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param entries Array of (row, column, value) tuples\n+   * @return The corresponding `SparseMatrix`\n+   */\n+  def fromCOO(numRows: Int, numCols: Int, entries: Array[(Int, Int, Double)]): SparseMatrix = {\n+    val sortedEntries = entries.sortBy(v => (v._2, v._1))\n+    val colPtrs = new Array[Int](numCols + 1)\n+    var nnz = 0\n+    var lastCol = -1\n+    val values = sortedEntries.map { case (i, j, v) =>\n+      while (j != lastCol) {\n+        colPtrs(lastCol + 1) = nnz\n+        lastCol += 1\n+      }\n+      nnz += 1\n+      v\n+    }\n+    while (numCols > lastCol) {\n+      colPtrs(lastCol + 1) = nnz\n+      lastCol += 1\n+    }\n+    new SparseMatrix(numRows, numCols, colPtrs.toArray, sortedEntries.map(_._1), values)\n+  }\n+\n+  /**\n+   * Generate an Identity Matrix in `SparseMatrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `SparseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): SparseMatrix = {\n+    new SparseMatrix(n, n, (0 to n).toArray, (0 until n).toArray, Array.fill(n)(1.0))\n+  }\n+\n+  /** Generates a `SparseMatrix` with a given random number generator and `method`, which\n+    * specifies the distribution. */\n+  private def genRandMatrix(\n+      numRows: Int,\n+      numCols: Int,\n+      density: Double,\n+      rng: Random,\n+      method: Random => Double): SparseMatrix = {\n+    require(density >= 0.0 && density <= 1.0, \"density must be a double in the range \" +\n+      s\"0.0 <= d <= 1.0. Currently, density: $density\")\n+    val length = math.ceil(numRows * numCols * density).toInt\n+    val entries = MutableMap[(Int, Int), Double]()\n+    var i = 0\n+    if (density == 0.0) {\n+      return new SparseMatrix(numRows, numCols, new Array[Int](numCols + 1),\n+        Array[Int](), Array[Double]())\n+    } else if (density == 1.0) {\n+      return new SparseMatrix(numRows, numCols, (0 to numRows * numCols by numRows).toArray,\n+        (0 until numRows * numCols).toArray, Array.fill(numRows * numCols)(method(rng)))\n+    }\n+    // Expected number of iterations is less than 1.5 * length\n+    if (density < 0.34) {\n+      while (i < length) {\n+        var rowIndex = rng.nextInt(numRows)\n+        var colIndex = rng.nextInt(numCols)\n+        while (entries.contains((rowIndex, colIndex))) {\n+          rowIndex = rng.nextInt(numRows)\n+          colIndex = rng.nextInt(numCols)\n+        }\n+        entries += (rowIndex, colIndex) -> method(rng)\n+        i += 1\n+      }\n+    } else { // selection - rejection method\n+      var j = 0\n+      val pool = numRows * numCols\n+      // loop over columns so that the sort in fromCOO requires less sorting\n+      while (i < length && j < numCols) {\n+        var passedInPool = j * numRows\n+        var r = 0\n+        while (i < length && r < numRows) {\n+          if (rng.nextDouble() < 1.0 * (length - i) / (pool - passedInPool)) {\n+            entries += (r, j) -> method(rng)\n+            i += 1\n+          }\n+          r += 1\n+          passedInPool += 1\n+        }\n+        j += 1\n+      }\n+    }\n+    SparseMatrix.fromCOO(numRows, numCols, entries.toArray.map(v => (v._1._1, v._1._2, v._2)))\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. uniform random numbers. The number of non-zero\n+   * elements equal the ceiling of `numRows` x `numCols` x `density`\n+   *\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    def method(rand: Random): Double = rand.nextDouble()\n+    genRandMatrix(numRows, numCols, density, rng, method)\n+  }\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `SparseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): SparseMatrix = {\n+    def method(rand: Random): Double = rand.nextGaussian()\n+    genRandMatrix(numRows, numCols, density, rng, method)\n+  }\n+\n+  /**\n+   * Generate a diagonal matrix in `SparseMatrix` format from the supplied values.\n+   * @param vector a `Vector` that will form the values on the diagonal of the matrix\n+   * @return Square `SparseMatrix` with size `values.length` x `values.length` and non-zero\n+   *         `values` on the diagonal\n+   */\n+  def diag(vector: Vector): SparseMatrix = {\n+    val n = vector.size\n+    vector match {\n+      case sVec: SparseVector =>\n+        val indices = sVec.indices\n+        SparseMatrix.fromCOO(n, n, indices.zip(sVec.values).map(v => (v._1, v._1, v._2)))\n+      case dVec: DenseVector =>\n+        val values = dVec.values.zipWithIndex"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This could be moved inside the `foreach` block. Then we can remove `rowsMatch`.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:12Z",
    "diffHunk": "@@ -256,72 +555,244 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.isEmpty) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    } else if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => // empty on purpose\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Ditto.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:15Z",
    "diffHunk": "@@ -256,72 +555,244 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.isEmpty) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    } else if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => // empty on purpose\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[(Int, Int, Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          val colPtrs = spMat.colPtrs\n+          val rowIndices = spMat.rowIndices\n+          val values = spMat.values\n+          val data = new Array[(Int, Int, Double)](values.length)\n+          val nCols = spMat.numCols\n+          while (j < nCols) {\n+            var idx = colPtrs(j)\n+            while (idx < colPtrs(j + 1)) {\n+              val i = rowIndices(idx)\n+              val v = values(idx)\n+              data(idx) = (i, j + startCol, v)\n+              idx += 1\n+            }\n+            j += 1\n+          }\n+          startCol += nCols\n+          data\n+        case dnMat: DenseMatrix =>\n+          val data = new ArrayBuffer[(Int, Int, Double)]()\n+          var j = 0\n+          val nCols = dnMat.numCols\n+          val nRows = dnMat.numRows\n+          val values = dnMat.values\n+          while (j < nCols) {\n+            var i = 0\n+            val indStart = j * nRows\n+            while (i < nRows) {\n+              val v = values(indStart + i)\n+              if (v != 0.0) {\n+                data.append((i, j + startCol, v))\n+              }\n+              i += 1\n+            }\n+            j += 1\n+          }\n+          startCol += nCols\n+          data\n+      }\n+      SparseMatrix.fromCOO(numRows, numCols, entries)\n+    }\n+  }\n+\n+  /**\n+   * Vertically concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were vertically concatenated\n+   */\n+  def vertcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.isEmpty) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    } else if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numCols = matrices(0).numCols\n+    var colsMatch = true\n+    var hasSparse = false\n+    var numRows = 0\n+    var valsLength = 0\n+    matrices.foreach { mat =>\n+      if (numCols != mat.numCols) colsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix =>\n+          hasSparse = true\n+          valsLength += sparse.values.length\n+        case dense: DenseMatrix =>\n+          valsLength += dense.values.length\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numRows += mat.numRows\n+\n+    }\n+    require(colsMatch, \"The number of rows of the matrices in this sequence, don't match!\")"
  }],
  "prId": 3319
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "In this case, we should allocate memory first, and then fill-in its values. Sorting is unnecessary.\n",
    "commit": "b0354f616f7f49ee9b19f6b8e5d0dc775b05dba2",
    "createdAt": "2014-12-19T18:34:16Z",
    "diffHunk": "@@ -256,72 +555,244 @@ object Matrices {\n    * Generate a `DenseMatrix` consisting of zeros.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of zeros\n+   * @return `Matrix` with size `numRows` x `numCols` and values of zeros\n    */\n-  def zeros(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, new Array[Double](numRows * numCols))\n+  def zeros(numRows: Int, numCols: Int): Matrix = DenseMatrix.zeros(numRows, numCols)\n \n   /**\n    * Generate a `DenseMatrix` consisting of ones.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values of ones\n+   * @return `Matrix` with size `numRows` x `numCols` and values of ones\n    */\n-  def ones(numRows: Int, numCols: Int): Matrix =\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(1.0))\n+  def ones(numRows: Int, numCols: Int): Matrix = DenseMatrix.ones(numRows, numCols)\n \n   /**\n-   * Generate an Identity Matrix in `DenseMatrix` format.\n+   * Generate a dense Identity Matrix in `Matrix` format.\n    * @param n number of rows and columns of the matrix\n-   * @return `DenseMatrix` with size `n` x `n` and values of ones on the diagonal\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n    */\n-  def eye(n: Int): Matrix = {\n-    val identity = Matrices.zeros(n, n)\n-    var i = 0\n-    while (i < n){\n-      identity.update(i, i, 1.0)\n-      i += 1\n-    }\n-    identity\n-  }\n+  def eye(n: Int): Matrix = DenseMatrix.eye(n)\n+\n+  /**\n+   * Generate a sparse Identity Matrix in `Matrix` format.\n+   * @param n number of rows and columns of the matrix\n+   * @return `Matrix` with size `n` x `n` and values of ones on the diagonal\n+   */\n+  def speye(n: Int): Matrix = SparseMatrix.speye(n)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. uniform random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n    */\n-  def rand(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextDouble()))\n-  }\n+  def rand(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.rand(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in U(0, 1)\n+   */\n+  def sprand(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprand(numRows, numCols, density, rng)\n \n   /**\n    * Generate a `DenseMatrix` consisting of i.i.d. gaussian random numbers.\n    * @param numRows number of rows of the matrix\n    * @param numCols number of columns of the matrix\n    * @param rng a random number generator\n-   * @return `DenseMatrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n    */\n-  def randn(numRows: Int, numCols: Int, rng: Random): Matrix = {\n-    new DenseMatrix(numRows, numCols, Array.fill(numRows * numCols)(rng.nextGaussian()))\n-  }\n+  def randn(numRows: Int, numCols: Int, rng: Random): Matrix =\n+    DenseMatrix.randn(numRows, numCols, rng)\n+\n+  /**\n+   * Generate a `SparseMatrix` consisting of i.i.d. gaussian random numbers.\n+   * @param numRows number of rows of the matrix\n+   * @param numCols number of columns of the matrix\n+   * @param density the desired density for the matrix\n+   * @param rng a random number generator\n+   * @return `Matrix` with size `numRows` x `numCols` and values in N(0, 1)\n+   */\n+  def sprandn(numRows: Int, numCols: Int, density: Double, rng: Random): Matrix =\n+    SparseMatrix.sprandn(numRows, numCols, density, rng)\n \n   /**\n    * Generate a diagonal matrix in `DenseMatrix` format from the supplied values.\n    * @param vector a `Vector` tat will form the values on the diagonal of the matrix\n-   * @return Square `DenseMatrix` with size `values.length` x `values.length` and `values`\n+   * @return Square `Matrix` with size `values.length` x `values.length` and `values`\n    *         on the diagonal\n    */\n-  def diag(vector: Vector): Matrix = {\n-    val n = vector.size\n-    val matrix = Matrices.eye(n)\n-    val values = vector.toArray\n-    var i = 0\n-    while (i < n) {\n-      matrix.update(i, i, values(i))\n-      i += 1\n+  def diag(vector: Vector): Matrix = DenseMatrix.diag(vector)\n+\n+  /**\n+   * Horizontally concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were horizontally concatenated\n+   */\n+  def horzcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.isEmpty) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    } else if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numRows = matrices(0).numRows\n+    var rowsMatch = true\n+    var hasSparse = false\n+    var numCols = 0\n+    matrices.foreach { mat =>\n+      if (numRows != mat.numRows) rowsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix => hasSparse = true\n+        case dense: DenseMatrix => // empty on purpose\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numCols += mat.numCols\n+    }\n+    require(rowsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse) {\n+      new DenseMatrix(numRows, numCols, matrices.flatMap(_.toArray))\n+    } else {\n+      var startCol = 0\n+      val entries: Array[(Int, Int, Double)] = matrices.flatMap {\n+        case spMat: SparseMatrix =>\n+          var j = 0\n+          val colPtrs = spMat.colPtrs\n+          val rowIndices = spMat.rowIndices\n+          val values = spMat.values\n+          val data = new Array[(Int, Int, Double)](values.length)\n+          val nCols = spMat.numCols\n+          while (j < nCols) {\n+            var idx = colPtrs(j)\n+            while (idx < colPtrs(j + 1)) {\n+              val i = rowIndices(idx)\n+              val v = values(idx)\n+              data(idx) = (i, j + startCol, v)\n+              idx += 1\n+            }\n+            j += 1\n+          }\n+          startCol += nCols\n+          data\n+        case dnMat: DenseMatrix =>\n+          val data = new ArrayBuffer[(Int, Int, Double)]()\n+          var j = 0\n+          val nCols = dnMat.numCols\n+          val nRows = dnMat.numRows\n+          val values = dnMat.values\n+          while (j < nCols) {\n+            var i = 0\n+            val indStart = j * nRows\n+            while (i < nRows) {\n+              val v = values(indStart + i)\n+              if (v != 0.0) {\n+                data.append((i, j + startCol, v))\n+              }\n+              i += 1\n+            }\n+            j += 1\n+          }\n+          startCol += nCols\n+          data\n+      }\n+      SparseMatrix.fromCOO(numRows, numCols, entries)\n+    }\n+  }\n+\n+  /**\n+   * Vertically concatenate a sequence of matrices. The returned matrix will be in the format\n+   * the matrices are supplied in. Supplying a mix of dense and sparse matrices will result in\n+   * a sparse matrix. If the Array is empty, an empty `DenseMatrix` will be returned.\n+   * @param matrices array of matrices\n+   * @return a single `Matrix` composed of the matrices that were vertically concatenated\n+   */\n+  def vertcat(matrices: Array[Matrix]): Matrix = {\n+    if (matrices.isEmpty) {\n+      return new DenseMatrix(0, 0, Array[Double]())\n+    } else if (matrices.size == 1) {\n+      return matrices(0)\n+    }\n+    val numCols = matrices(0).numCols\n+    var colsMatch = true\n+    var hasSparse = false\n+    var numRows = 0\n+    var valsLength = 0\n+    matrices.foreach { mat =>\n+      if (numCols != mat.numCols) colsMatch = false\n+      mat match {\n+        case sparse: SparseMatrix =>\n+          hasSparse = true\n+          valsLength += sparse.values.length\n+        case dense: DenseMatrix =>\n+          valsLength += dense.values.length\n+        case _ => throw new IllegalArgumentException(\"Unsupported matrix format. Expected \" +\n+          s\"SparseMatrix or DenseMatrix. Instead got: ${mat.getClass}\")\n+      }\n+      numRows += mat.numRows\n+\n+    }\n+    require(colsMatch, \"The number of rows of the matrices in this sequence, don't match!\")\n+\n+    if (!hasSparse) {\n+      val matData = matrices.zipWithIndex.flatMap { case (mat, ind) =>\n+        val values = mat.toArray\n+        for (j <- 0 until numCols) yield (j, ind,"
  }],
  "prId": 3319
}]