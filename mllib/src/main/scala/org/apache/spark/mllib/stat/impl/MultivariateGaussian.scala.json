[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "I'd add a check here to make sure that the dimensions of mu, sigma match up.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:47:34Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n "
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Maybe mu, sigma should be named mean, covariance here to match the getter methods (since these named parameters are part of the public API).  (Or those could be renamed; either is OK with me.)\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:47:50Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n   /**\n+   * Public constructor\n+   * \n+   * @param mu The mean vector of the distribution\n+   * @param sigma The covariance matrix of the distribution\n+   */\n+  def this(mu: Vector, sigma: Matrix) = {"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "I'd include \"mu\" in the doc since it's such a common variable name.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:13Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n   /**\n+   * Public constructor\n+   * \n+   * @param mu The mean vector of the distribution\n+   * @param sigma The covariance matrix of the distribution\n+   */\n+  def this(mu: Vector, sigma: Matrix) = {\n+    this(mu.toBreeze.toDenseVector, sigma.toBreeze.toDenseMatrix)\n+  }\n+  \n+  /**\n    * Compute distribution dependent constants:\n    *    rootSigmaInv = D^(-1/2) * U, where sigma = U * D * U.t\n-   *    u = (2*pi)^(-k/2) * det(sigma)^(-1/2) \n+   *    u = log((2*pi)^(-k/2) * det(sigma)^(-1/2)) \n    */\n   private val (rootSigmaInv: DBM[Double], u: Double) = calculateCovarianceConstants\n   \n+  /** Return the mean vector for this distribution */"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Exclude parentheses () since it's just an accessor method\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:15Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n   /**\n+   * Public constructor\n+   * \n+   * @param mu The mean vector of the distribution\n+   * @param sigma The covariance matrix of the distribution\n+   */\n+  def this(mu: Vector, sigma: Matrix) = {\n+    this(mu.toBreeze.toDenseVector, sigma.toBreeze.toDenseMatrix)\n+  }\n+  \n+  /**\n    * Compute distribution dependent constants:\n    *    rootSigmaInv = D^(-1/2) * U, where sigma = U * D * U.t\n-   *    u = (2*pi)^(-k/2) * det(sigma)^(-1/2) \n+   *    u = log((2*pi)^(-k/2) * det(sigma)^(-1/2)) \n    */\n   private val (rootSigmaInv: DBM[Double], u: Double) = calculateCovarianceConstants\n   \n+  /** Return the mean vector for this distribution */\n+  def getMean(): Vector = {"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "ditto: \"sigma\" in doc\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:19Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n   /**\n+   * Public constructor\n+   * \n+   * @param mu The mean vector of the distribution\n+   * @param sigma The covariance matrix of the distribution\n+   */\n+  def this(mu: Vector, sigma: Matrix) = {\n+    this(mu.toBreeze.toDenseVector, sigma.toBreeze.toDenseMatrix)\n+  }\n+  \n+  /**\n    * Compute distribution dependent constants:\n    *    rootSigmaInv = D^(-1/2) * U, where sigma = U * D * U.t\n-   *    u = (2*pi)^(-k/2) * det(sigma)^(-1/2) \n+   *    u = log((2*pi)^(-k/2) * det(sigma)^(-1/2)) \n    */\n   private val (rootSigmaInv: DBM[Double], u: Double) = calculateCovarianceConstants\n   \n+  /** Return the mean vector for this distribution */\n+  def getMean(): Vector = {\n+    Vectors.fromBreeze(mu)\n+  }\n+  \n+  /** Return the covariance matrix for this distribution */"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Exclude parentheses () since it's just an accessor method\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:20Z",
    "diffHunk": "@@ -30,22 +31,57 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n   /**\n+   * Public constructor\n+   * \n+   * @param mu The mean vector of the distribution\n+   * @param sigma The covariance matrix of the distribution\n+   */\n+  def this(mu: Vector, sigma: Matrix) = {\n+    this(mu.toBreeze.toDenseVector, sigma.toBreeze.toDenseMatrix)\n+  }\n+  \n+  /**\n    * Compute distribution dependent constants:\n    *    rootSigmaInv = D^(-1/2) * U, where sigma = U * D * U.t\n-   *    u = (2*pi)^(-k/2) * det(sigma)^(-1/2) \n+   *    u = log((2*pi)^(-k/2) * det(sigma)^(-1/2)) \n    */\n   private val (rootSigmaInv: DBM[Double], u: Double) = calculateCovarianceConstants\n   \n+  /** Return the mean vector for this distribution */\n+  def getMean(): Vector = {\n+    Vectors.fromBreeze(mu)\n+  }\n+  \n+  /** Return the covariance matrix for this distribution */\n+  def getCovariance(): Matrix = {"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "By the way, in Scala doc (here and elsewhere), I believe the correct way to write exponents is to have an opening ^ and closing ^ around the exponent:\n\n```\ndet(sigma)^(-1/2)^\n```\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:29Z",
    "diffHunk": "@@ -54,7 +90,7 @@ private[mllib] class MultivariateGaussian(\n    * where k is length of the mean vector.\n    * \n    * We here compute distribution-fixed parts \n-   *  (2*pi)^(-k/2) * det(sigma)^(-1/2)\n+   *  log((2*pi)^(-k/2) * det(sigma)^(-1/2))"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "This should skip the log(pow(\"stuff\")) combination and just have \"stuff\" (with the log moved inside of \"stuff\"), in order to skip the math.pow call.\nAlso, since you'll need log(pdetSigma), you can compute that from the beginning, using a sum instead of multiplying in line 124.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-07T22:48:32Z",
    "diffHunk": "@@ -91,7 +127,7 @@ private[mllib] class MultivariateGaussian(\n       // by inverting the square root of all non-zero values\n       val pinvS = diag(new DBV(d.map(v => if (v > tol) math.sqrt(1.0 / v) else 0.0).toArray))\n     \n-      (pinvS * u, math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5))\n+      (pinvS * u, math.log(math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5)))"
  }, {
    "author": {
      "login": "tgaloppo"
    },
    "body": "Calculating log(pdetSigma) that way will incur a performance penalty (calling log for each singular value), but it is probably more numerically stable.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-08T00:33:55Z",
    "diffHunk": "@@ -91,7 +127,7 @@ private[mllib] class MultivariateGaussian(\n       // by inverting the square root of all non-zero values\n       val pinvS = diag(new DBV(d.map(v => if (v > tol) math.sqrt(1.0 / v) else 0.0).toArray))\n     \n-      (pinvS * u, math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5))\n+      (pinvS * u, math.log(math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5)))"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "True, it will be slower, but I assume eigSym will dominate the running time.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-08T20:08:52Z",
    "diffHunk": "@@ -91,7 +127,7 @@ private[mllib] class MultivariateGaussian(\n       // by inverting the square root of all non-zero values\n       val pinvS = diag(new DBV(d.map(v => if (v > tol) math.sqrt(1.0 / v) else 0.0).toArray))\n     \n-      (pinvS * u, math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5))\n+      (pinvS * u, math.log(math.pow(2.0 * math.Pi, -mu.length / 2.0) * math.pow(pdetSigma, -0.5)))"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "This is fine, but you can also use `require` for checking input arguments (since that throws `IllegalArgumentException` and is a bit shorter).\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-08T20:14:04Z",
    "diffHunk": "@@ -30,33 +31,72 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], \n     val sigma: DBM[Double]) extends Serializable {\n \n+  if (sigma.cols != sigma.rows) {"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "`map(math.log(_))` can be simplified to `map(math.log)`\nAlso, `reduce(_ + _)` can be replaced with `sum`\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-08T20:14:07Z",
    "diffHunk": "@@ -84,14 +124,14 @@ private[mllib] class MultivariateGaussian(\n     val tol = MLUtils.EPSILON * max(d) * d.length\n     \n     try {\n-      // pseudo-determinant is product of all non-zero singular values\n-      val pdetSigma = d.activeValuesIterator.filter(_ > tol).reduce(_ * _)\n+      // log(pseudo-determinant) is sum of the logs of all non-zero singular values\n+      val logPseudoDetSigma = d.activeValuesIterator.filter(_ > tol).map(math.log(_)).reduce(_ + _)"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Remove space after `{` and before `}`.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-09T18:38:20Z",
    "diffHunk": "@@ -19,6 +19,7 @@ package org.apache.spark.mllib.stat.impl\n \n import breeze.linalg.{DenseVector => DBV, DenseMatrix => DBM, diag, max, eigSym}\n \n+import org.apache.spark.mllib.linalg.{ Vectors, Vector, Matrices, Matrix }"
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If we want to make it public, should it still under `stat.impl`? Maybe is it good to put it under `stat.distribution` and mark it as `@DeveloperApi` since we don't have a `Distribution` trait yet.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-09T18:38:22Z",
    "diffHunk": "@@ -30,33 +31,67 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] ("
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "+1\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-09T18:55:49Z",
    "diffHunk": "@@ -30,33 +31,67 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] ("
  }],
  "prId": 3923
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Those are public fields of the class. We should not expose breeze types.\n",
    "commit": "2b1558727af2a28c7c3aa675fbdb040cd17fee01",
    "createdAt": "2015-01-09T18:38:24Z",
    "diffHunk": "@@ -30,33 +31,67 @@ import org.apache.spark.mllib.util.MLUtils\n  * @param mu The mean vector of the distribution\n  * @param sigma The covariance matrix of the distribution\n  */\n-private[mllib] class MultivariateGaussian(\n+class MultivariateGaussian private[mllib] (\n     val mu: DBV[Double], "
  }],
  "prId": 3923
}]