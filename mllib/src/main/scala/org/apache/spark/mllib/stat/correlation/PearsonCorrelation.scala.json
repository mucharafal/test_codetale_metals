[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "private[mllib] or [stat]\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-12T23:21:58Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {"
  }],
  "prId": 1367
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`cov` is local and has random access. Updating its diagonal is cheap.\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-12T23:22:20Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix"
  }],
  "prId": 1367
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "dspr is for rank-1 symmetric update, which is irrelevant to the operation here.\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-12T23:22:25Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix\n+\n+    // TODO: use blas.dspr instead to compute the correlation matrix"
  }],
  "prId": 1367
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`covariance` -> `corr`\n\nNote that `cov(i, i)` could be zero.\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-12T23:22:28Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix\n+\n+    // TODO: use blas.dspr instead to compute the correlation matrix\n+    // if the covariance matrix comes in the upper triangular form for free\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val covariance = cov(i, j) / (sigma * cov(i, i))"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "What do you want returned when cov(i, i) is zero? Double.NaN? 0.0? \n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-14T19:18:26Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix\n+\n+    // TODO: use blas.dspr instead to compute the correlation matrix\n+    // if the covariance matrix comes in the upper triangular form for free\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val covariance = cov(i, j) / (sigma * cov(i, i))"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "I think the most honest result is NaN. R will return an error for example. You will get that already as the result of 0.0 / 0.0 in the JVM. It's worth documenting!\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-14T19:35:35Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix\n+\n+    // TODO: use blas.dspr instead to compute the correlation matrix\n+    // if the covariance matrix comes in the upper triangular form for free\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val covariance = cov(i, j) / (sigma * cov(i, i))"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Agree with @srowen : set NaN and generate a warning message. Btw, R returns a warning message instead of an error.\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-16T18:54:21Z",
    "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+object PearsonCorrelation extends Correlation {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the pearson correlation matrix from the covariance matrix\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      cov(i, i) = math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+    // or we could put the stddev in its own array to trade space for one less pass over the matrix\n+\n+    // TODO: use blas.dspr instead to compute the correlation matrix\n+    // if the covariance matrix comes in the upper triangular form for free\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val covariance = cov(i, j) / (sigma * cov(i, i))"
  }],
  "prId": 1367
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Using `10e-12` is not very common. Did you mean `1e-12` or `1e-11`?\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-18T21:27:45Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+private[stat] object PearsonCorrelation extends Correlation with Logging {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets. NaN if either vector has 0 variance.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j. 0 covariance results in a correlation value of Double.NaN.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix from the covariance matrix.\n+   * 0 covariance results in a correlation value of Double.NaN.\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      // TODO remove once covariance numerical issue resolved.\n+      cov(i, i) = if (closeToZero(cov(i, i))) 0.0 else math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    var containNaN = false\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val corr = if (sigma == 0.0 || cov(i, i) == 0.0) {\n+          containNaN = true\n+          Double.NaN\n+        } else {\n+          cov(i, j) / (sigma * cov(i, i))\n+        }\n+        cov(i, j) = corr\n+        cov(j, i) = corr\n+        i += 1\n+      }\n+      j += 1\n+    }\n+\n+    // put 1.0 on the diagonals\n+    i = 0\n+    while (i < n) {\n+      cov(i, i) = 1.0\n+      i +=1\n+    }\n+\n+    if (containNaN) {\n+      logWarning(\"Pearson correlation matrix contains NaN values.\")\n+    }\n+\n+    Matrices.fromBreeze(cov)\n+  }\n+\n+  private def closeToZero(value: Double, threshhold: Double = 10e-12): Boolean = {"
  }],
  "prId": 1367
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`math.abs(value)`\n",
    "commit": "c0dd7dc1851c2f3c33c7c76ecf235f5eaf289b10",
    "createdAt": "2014-07-18T21:28:14Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.correlation\n+\n+import breeze.linalg.{DenseMatrix => BDM}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Matrices, Matrix, Vector}\n+import org.apache.spark.mllib.linalg.distributed.RowMatrix\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Compute Pearson correlation for two RDDs of the type RDD[Double] or the correlation matrix\n+ * for an RDD of the type RDD[Vector].\n+ *\n+ * Definition of Pearson correlation can be found at\n+ * http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient\n+ */\n+private[stat] object PearsonCorrelation extends Correlation with Logging {\n+\n+  /**\n+   * Compute the Pearson correlation for two datasets. NaN if either vector has 0 variance.\n+   */\n+  override def computeCorrelation(x: RDD[Double], y: RDD[Double]): Double = {\n+    computeCorrelationWithMatrixImpl(x, y)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix S, for the input matrix, where S(i, j) is the\n+   * correlation between column i and j. 0 covariance results in a correlation value of Double.NaN.\n+   */\n+  override def computeCorrelationMatrix(X: RDD[Vector]): Matrix = {\n+    val rowMatrix = new RowMatrix(X)\n+    val cov = rowMatrix.computeCovariance()\n+    computeCorrelationMatrixFromCovariance(cov)\n+  }\n+\n+  /**\n+   * Compute the Pearson correlation matrix from the covariance matrix.\n+   * 0 covariance results in a correlation value of Double.NaN.\n+   */\n+  def computeCorrelationMatrixFromCovariance(covarianceMatrix: Matrix): Matrix = {\n+    val cov = covarianceMatrix.toBreeze.asInstanceOf[BDM[Double]]\n+    val n = cov.cols\n+\n+    // Compute the standard deviation on the diagonals first\n+    var i = 0\n+    while (i < n) {\n+      // TODO remove once covariance numerical issue resolved.\n+      cov(i, i) = if (closeToZero(cov(i, i))) 0.0 else math.sqrt(cov(i, i))\n+      i +=1\n+    }\n+\n+    // Loop through columns since cov is column major\n+    var j = 0\n+    var sigma = 0.0\n+    var containNaN = false\n+    while (j < n) {\n+      sigma = cov(j, j)\n+      i = 0\n+      while (i < j) {\n+        val corr = if (sigma == 0.0 || cov(i, i) == 0.0) {\n+          containNaN = true\n+          Double.NaN\n+        } else {\n+          cov(i, j) / (sigma * cov(i, i))\n+        }\n+        cov(i, j) = corr\n+        cov(j, i) = corr\n+        i += 1\n+      }\n+      j += 1\n+    }\n+\n+    // put 1.0 on the diagonals\n+    i = 0\n+    while (i < n) {\n+      cov(i, i) = 1.0\n+      i +=1\n+    }\n+\n+    if (containNaN) {\n+      logWarning(\"Pearson correlation matrix contains NaN values.\")\n+    }\n+\n+    Matrices.fromBreeze(cov)\n+  }\n+\n+  private def closeToZero(value: Double, threshhold: Double = 10e-12): Boolean = {\n+    math.abs(value - 0.0) <= threshhold"
  }],
  "prId": 1367
}]