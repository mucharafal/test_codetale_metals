[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`if (d < Zero)` (space after `if` and no space after `(`)\n",
    "commit": "35da8e9e188e669460000d5799d061ecc3ca150f",
    "createdAt": "2014-10-06T21:49:59Z",
    "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.clustering.metrics\n+\n+import breeze.linalg.{DenseVector => BDV, SparseVector => BSV, Vector => BV}\n+import org.apache.spark.mllib.base.{Centroid, FPoint, PointOps, Infinity, Zero}\n+import org.apache.spark.mllib.linalg.{DenseVector, SparseVector, Vector}\n+\n+\n+/**\n+ * Euclidean distance measure\n+ *\n+ * This is the slow implementation of the squared Euclidean distance function,\n+ * shown here simply for clarity.\n+ */\n+class EuclideanOps extends PointOps[FPoint, FPoint] with Serializable {\n+\n+  type C = FPoint\n+  type P = FPoint\n+\n+  val epsilon = 1e-4\n+\n+  def distance(p: P, c: C, upperBound: Double = Infinity): Double = {\n+    val d = p.inh.zip(c.inh).foldLeft(Zero) {\n+      case (d: Double, (a: Double, b: Double)) => d + (a - b) * (a - b)\n+    }\n+    if( d < Zero) Zero else d"
  }],
  "prId": 2634
}]