[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Since the row indices are irrelevant to the computation, we should provide users a simpler interface:\n\n```\n/** Returns (U, \\Sigma, V) */\ndef tallAndSkinnySVD(data: RDD[Array[Double]]): (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n ...\n}\n```\n\nIt is safe to always return U because it won't trigger a job until it is used somewhere else.\n\nIn this way, the current interface can be implemented as a simple wrapper:\n\n```\nval svd = tallAndSkinnySVD(matrix.rows.map(row => row.data))\nval U = svd.U.zip(matrix.rows.map(row => row.index)).map(...)\nreturn ...\n```\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-10T21:11:19Z",
    "diffHunk": "@@ -142,17 +155,138 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * All input and output is expected in DenseMatrix format\n+ *\n+ * @param matrix sparse matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three sparse matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: DenseMatrix, k: Int, computeU: Boolean): DenseMatrixSVD = {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Should have 3 spaces before `*`.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T20:22:21Z",
    "diffHunk": "@@ -38,12 +39,27 @@ class SVD {\n     this\n   }\n \n-   /**\n-   * Compute SVD using the current set parameters\n+  /**\n+   * Should U be computed?\n    */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n+  * Compute SVD using the current set parameters"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T23:55:26Z",
    "diffHunk": "@@ -38,12 +39,27 @@ class SVD {\n     this\n   }\n \n-   /**\n-   * Compute SVD using the current set parameters\n+  /**\n+   * Should U be computed?\n    */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n+  * Compute SVD using the current set parameters"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Put `m` and `n` in the error msg.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:18:11Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:00:49Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Put `k` and `n` in the error msg.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:18:25Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:00:54Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If `u` is already there, why not returning it?\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:21:03Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "u won't be computed if it isn't returned, null is returned so the user doesn't inadvertently touch u and cause a job, even though they don't want it computed.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:03:51Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Needs a note on how `V` is stored.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:21:55Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Added\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:05:41Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Put `k` and `n` in the error msg.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:22:30Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Added\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:06:33Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Move `:` to the next line.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:23:15Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : "
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T02:07:00Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : "
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Do not use `for` for performance critical computation.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:23:46Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "replaced with while\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:00:12Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "You don't need an n-by-n block per row. One per partition would be sufficient.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:25:28Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done per partition now using mapParitions\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:00:28Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Do not use `for` loops.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:25:56Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "replaced with while\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:00:41Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "move this line to the one above.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:26:07Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:03:23Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The RCOND value should be configurable instead of fixed at `1e-9`.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:27:12Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:04:38Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Why not just return non-zero sigmas? It is certainly legal to call `svd(A, 3)` on a rank-2 matrix `A` and users will be surprised to see an exception.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:29:07Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:04:58Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`boardcast` has no positive effect here.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:30:19Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")\n+    }\n+\n+    val sigma = sigmas.take(k)\n+\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, k)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = sc.broadcast(Array.tabulate(n, k)((i, j) => V.get(i, j) / sigma(j))).value"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Removed broadcast\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T04:18:47Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")\n+    }\n+\n+    val sigma = sigmas.take(k)\n+\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, k)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = sc.broadcast(Array.tabulate(n, k)((i, j) => V.get(i, j) / sigma(j))).value"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "How about using the double matrix `V` and calling DGEMV?\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-18T21:33:44Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")\n+    }\n+\n+    val sigma = sigmas.take(k)\n+\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, k)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = sc.broadcast(Array.tabulate(n, k)((i, j) => V.get(i, j) / sigma(j))).value\n+     \n+    val retU = matrix.map{x =>\n+      val row = Array.ofDim[Double](k)\n+      for(j <- 0 until k) {"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done, should be a little bit faster\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T05:27:02Z",
    "diffHunk": "@@ -142,17 +155,175 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n   }\n \n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix\")\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k)\n+    \n+    // prep u for returning\n+    val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+    if(computeU) {\n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ def denseSVD(matrix: RDD[Array[Double]], k: Int) : \n+     (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Must request up to n singular values\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.map{\n+        row => \n+          val miniata = Array.ofDim[Double](n, n)\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             miniata(i)(j) += row(i) * row(j)\n+          }\n+        miniata \n+    }.fold(Array.ofDim[Double](n, n)){\n+      (a, b) =>\n+          for(i <- 0 until n) for(j <- 0 until n) {\n+             a(i)(j) += b(i)(j)\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)\n+\n+    if (sigmas.size < k) {\n+      throw new Exception(\"Not enough singular values to return\")\n+    }\n+\n+    val sigma = sigmas.take(k)\n+\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, k)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = sc.broadcast(Array.tabulate(n, k)((i, j) => V.get(i, j) / sigma(j))).value\n+     \n+    val retU = matrix.map{x =>\n+      val row = Array.ofDim[Double](k)\n+      for(j <- 0 until k) {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "no need to declare the type here \n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:16:22Z",
    "diffHunk": "@@ -29,6 +29,8 @@ import org.jblas.{DoubleMatrix, Singular, MatrixFunctions}\n  */\n class SVD {\n   private var k: Int = 1\n+  private var computeU: Boolean = true"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Staying consistent\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:30:31Z",
    "diffHunk": "@@ -29,6 +29,8 @@ import org.jblas.{DoubleMatrix, Singular, MatrixFunctions}\n  */\n class SVD {\n   private var k: Int = 1\n+  private var computeU: Boolean = true"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Sorry, my bad here. `RCOND` (reciprocal condition number) is used in LAPACK. It is not an absolute value but relative to the largest singular value. We should give the method a more precise name instead of `setRCOND`. I would suggest `setReciprocalConditionNumber` and explain what it is in the doc.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:23:13Z",
    "diffHunk": "@@ -38,18 +40,49 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * How small of a singular value is considered zero?\n+   */\n+  def setRCOND(rcond: Double): SVD = {"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done. I documented it as \"Singular values smaller than this value are considered zero\" because that's the assumption to avoid diving by small singular values.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:50:15Z",
    "diffHunk": "@@ -38,18 +40,49 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * How small of a singular value is considered zero?\n+   */\n+  def setRCOND(rcond: Double): SVD = {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "add a space after map\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:23:58Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+          var i = 0\n+          while(i < n) {\n+            var j = 0 \n+            while(j < n) {\n+              a(i)(j) += b(i)(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))\n+     \n+    if (computeU) {\n+      val retU = matrix.map{ x =>"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:51:05Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+          var i = 0\n+          while(i < n) {\n+            var j = 0 \n+            while(j < n) {\n+              a(i)(j) += b(i)(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+    val sc = matrix.sparkContext\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))\n+     \n+    if (computeU) {\n+      val retU = matrix.map{ x =>"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "Document what the return value is ... it is hard to read from the type signature.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:25:15Z",
    "diffHunk": "@@ -38,18 +40,49 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * How small of a singular value is considered zero?\n+   */\n+  def setRCOND(rcond: Double): SVD = {\n+    this.RCOND = rcond\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n   def compute(matrix: SparseMatrix) : MatrixSVD = {\n     SVD.sparseSVD(matrix, k)\n   }\n+\n+  /**\n+   * Compute SVD using the current set parameters\n+   */\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    SVD.denseSVD(matrix, k, computeU, RCOND)\n+  }\n+\n+  /**\n+   * Compute SVD using the current set parameters\n+   */\n+  def compute(matrix: RDD[Array[Double]]) :"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:00:46Z",
    "diffHunk": "@@ -38,18 +40,49 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * How small of a singular value is considered zero?\n+   */\n+  def setRCOND(rcond: Double): SVD = {\n+    this.RCOND = rcond\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n   def compute(matrix: SparseMatrix) : MatrixSVD = {\n     SVD.sparseSVD(matrix, k)\n   }\n+\n+  /**\n+   * Compute SVD using the current set parameters\n+   */\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    SVD.denseSVD(matrix, k, computeU, RCOND)\n+  }\n+\n+  /**\n+   * Compute SVD using the current set parameters\n+   */\n+  def compute(matrix: RDD[Array[Double]]) :"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "add a space after mapParititons, put iter on the same line, and only indent the body using two spaces\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:26:42Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{"
  }, {
    "author": {
      "login": "rxin"
    },
    "body": "and do u mind declare the type of fullata explicitly here? it is not super obvious to non-ml person what the dimension structure is. \n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:27:49Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:04:27Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "fix the indent here\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:27:10Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:04:38Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "this sc seems unused?\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:28:20Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+          var i = 0\n+          while(i < n) {\n+            var j = 0 \n+            while(j < n) {\n+              a(i)(j) += b(i)(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+    val sc = matrix.sparkContext"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Indeed, removed\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:06:16Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{\n+                  case (row, i) => MatrixRow(i, row) }, m, k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions{\n+        iter => \n+          val miniata = Array.ofDim[Double](n, n)\n+          while(iter.hasNext) {\n+            val row = iter.next \n+            var i = 0\n+            while(i < n) {\n+              var j = 0\n+              while(j < n) {\n+                miniata(i)(j) += row(i) * row(j)\n+                j += 1\n+              }\n+              i += 1\n+            }\n+         }\n+         List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+          var i = 0\n+          while(i < n) {\n+            var j = 0 \n+            while(j < n) {\n+              a(i)(j) += b(i)(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+    val sc = matrix.sparkContext"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "the way this is indented is hard to read... perhaps\n\n``` scala\nval retU = TallSkinnyDenseMatrix(\n  u.zip(rowIndices).map { case (row, i) => MatrixRow(i, row) },\n  m,\n  k)\n```\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T07:30:38Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "OK\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:07:24Z",
    "diffHunk": "@@ -142,17 +172,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(u.zip(rowIndices).map{"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`vsinv` is only used when `U` is requested.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:23:02Z",
    "diffHunk": "@@ -142,17 +177,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(\n+        u.zip(rowIndices).map {case (row, i) => MatrixRow(i, row) },\n+        m,\n+        k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Moved inside\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:25:18Z",
    "diffHunk": "@@ -142,17 +177,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(\n+        u.zip(rowIndices).map {case (row, i) => MatrixRow(i, row) },\n+        m,\n+        k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    // Compute U as U = A V S^-1\n+    // Compute VS^-1\n+    val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The threshold is not correct. It should be relative to the largest singular value. Please see my previous comment about RCOND.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:27:19Z",
    "diffHunk": "@@ -142,17 +177,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(\n+        u.zip(rowIndices).map {case (row, i) => MatrixRow(i, row) },\n+        m,\n+        k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "I don't want to be using relative condition number here, I just want an absolute lower bound on the smallest singular value considered nonzero so we don't run into issues when dividing by it. I will rename the rcond instance variable too, but that's it.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T08:29:37Z",
    "diffHunk": "@@ -142,17 +177,189 @@ object SVD {\n     val vsirdd = sc.makeRDD(Array.tabulate(V.rows, sigma.length)\n                 { (i,j) => ((i, j), V.get(i,j) / sigma(j))  }.flatten)\n \n-    // Multiply A by VS^-1\n-    val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n-    val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n-    val retUdata = aCols.join(bRows).map( {case (key, ( (rowInd, rowVal), (colInd, colVal)))\n-        => ((rowInd, colInd), rowVal*colVal)}).reduceByKey(_ + _)\n-          .map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n-    val retU = SparseMatrix(retUdata, m, sigma.length)\n-   \n-    MatrixSVD(retU, retS, retV)  \n+    if (computeU) {\n+      // Multiply A by VS^-1\n+      val aCols = data.map(entry => (entry.j, (entry.i, entry.mval)))\n+      val bRows = vsirdd.map(entry => (entry._1._1, (entry._1._2, entry._2)))\n+      val retUdata = aCols.join(bRows).map {\n+        case (key, ( (rowInd, rowVal), (colInd, colVal)) ) => \n+          ((rowInd, colInd), rowVal * colVal)\n+      }.reduceByKey(_ + _).map{ case ((row, col), mval) => MatrixEntry(row, col, mval)}\n+      \n+      val retU = SparseMatrix(retUdata, m, sigma.length)\n+      MatrixSVD(retU, retS, retV)  \n+    } else {\n+      MatrixSVD(null, retS, retV)\n+    }\n+  }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rcond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: TallSkinnyDenseMatrix, k: Int,\n+              computeU: Boolean, rcond: Double): TallSkinnyMatrixSVD = {\n+    val rows = matrix.rows\n+    val m = matrix.m\n+    val n = matrix.n\n+    val sc = matrix.rows.sparkContext\n+\n+    if (m < n || m <= 0 || n <= 0) {\n+      throw new IllegalArgumentException(\"Expecting a tall and skinny matrix m=\" + m + \" n=\" + n)\n+    }\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\"Request up to n singular values n=\" + n + \" k=\" + k)\n+    }\n+\n+    val rowIndices = matrix.rows.map(_.i)\n+\n+    // compute SVD\n+    val (u, sigma, v) = denseSVD(matrix.rows.map(_.data), k, computeU, rcond)\n+    \n+    if(computeU) {\n+      // prep u for returning\n+      val retU = TallSkinnyDenseMatrix(\n+        u.zip(rowIndices).map {case (row, i) => MatrixRow(i, row) },\n+        m,\n+        k)\n+    \n+      TallSkinnyMatrixSVD(retU, sigma, v)\n+    } else {\n+      TallSkinnyMatrixSVD(null, sigma, v)\n+    }\n+ }\n+\n+/**\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @return Three matrices: U, S, V such that A = USV^T\n+ */\n+ private def denseSVD(matrix: RDD[Array[Double]], k: Int,\n+                      computeU: Boolean, rcond: Double) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular valuesi k=\" + k + \" n= \" + n)\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > rcond)"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The default value needs to be documented somewhere.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:16:35Z",
    "diffHunk": "@@ -23,12 +23,13 @@ import org.apache.spark.rdd.RDD\n \n import org.jblas.{DoubleMatrix, Singular, MatrixFunctions}\n \n-\n /**\n  * Class used to obtain singular value decompositions\n  */\n class SVD {\n   private var k: Int = 1\n+  private var computeU: Boolean = true\n+  private var rCond: Double = 1e-9"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:20:45Z",
    "diffHunk": "@@ -23,12 +23,13 @@ import org.apache.spark.rdd.RDD\n \n import org.jblas.{DoubleMatrix, Singular, MatrixFunctions}\n \n-\n /**\n  * Class used to obtain singular value decompositions\n  */\n class SVD {\n   private var k: Int = 1\n+  private var computeU: Boolean = true\n+  private var rCond: Double = 1e-9"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "What `relative` means is not very clear. The following is copied from LAPACK:\n\n> RCOND is used to determine the effective rank of A. Singular values S(i) <= RCOND*S(1) are treated as zero.\n\nWe can say \"Sets the reciprocal condition number (`rcond`). All singular values smaller than `rcond * sigma(0)` are treated as zero, where `sigma(0)` is the largest singular value.\"\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:22:30Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:25:30Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "use `[[...]]` in the doc to reference another class or method.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:24:23Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation "
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:25:33Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation "
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "\"paramter\" -> \"parameter\"\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:26:00Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description."
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "what does `for computeU = true` mean here?\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:26:32Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true."
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Stale comment, removed\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:27:44Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true."
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It sounds like we are computing `A^T A` via `V^T S^2 V^T`. It is possible that my understanding of the sentence is wrong.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:30:33Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "Doesn't like it to me, this is fine.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:35:45Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "this definition needs update.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:32:15Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rCond smallest singular value considered nonzero"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "updated\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:36:03Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rCond smallest singular value considered nonzero"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "sigma is an array.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:33:18Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rCond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "updated\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:36:45Z",
    "diffHunk": "@@ -38,20 +39,113 @@ class SVD {\n     this\n   }\n \n-   /**\n+  /**\n+   * Singular values smaller than this value\n+   * relative to the largest singular value are considered zero\n+   */\n+  def setReciprocalConditionNumber(smallS: Double): SVD = {\n+    this.rCond = smallS\n+    this\n+  }\n+\n+  /**\n+   * Should U be computed?\n+   */\n+  def setComputeU(compU: Boolean): SVD = {\n+    this.computeU = compU\n+    this\n+  }\n+\n+  /**\n    * Compute SVD using the current set parameters\n    */\n-  def compute(matrix: SparseMatrix) : MatrixSVD = {\n-    SVD.sparseSVD(matrix, k)\n+  def compute(matrix: TallSkinnyDenseMatrix) : TallSkinnyMatrixSVD = {\n+    denseSVD(matrix)\n   }\n-}\n \n+  /**\n+   * Compute SVD using the current set parameters\n+   * Returns (U, S, V)  such that A = USV^T \n+   * U is a row-by-row dense matrix\n+   * S is a simple double array of singular values\n+   * V is a 2d array matrix\n+   * See denseSVD for more documentation \n+   */\n+  def compute(matrix: RDD[Array[Double]]) :\n+    (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+      denseSVD(matrix)\n+  }\n+\n+  /**\n+  * Compute SVD with default parameter for computeU = true.\n+  * See full paramter definition of sparseSVD for more description.\n+  *\n+  * @param matrix sparse matrix to factorize\n+  * @return Three sparse matrices: U, S, V such that A = USV^T\n+  */\n+  def compute(matrix: SparseMatrix): MatrixSVD = {\n+    sparseSVD(matrix)\n+  }\n \n /**\n- * Top-level methods for calling Singular Value Decomposition\n- * NOTE: All matrices are in 0-indexed sparse format RDD[((int, int), value)]\n+ * Singular Value Decomposition for Tall and Skinny matrices.\n+ * Given an m x n matrix A, this will compute matrices U, S, V such that\n+ * A = U * S * V'\n+ * \n+ * There is no restriction on m, but we require n^2 doubles to fit in memory.\n+ * Further, n should be less than m.\n+ * \n+ * The decomposition is computed by first computing A'A = V S^2 V',\n+ * computing svd locally on that (since n x n is small),\n+ * from which we recover S and V. \n+ * Then we compute U via easy matrix multiplication\n+ * as U =  A * V * S^-1\n+ * \n+ * Only the k largest singular values and associated vectors are found.\n+ * If there are k such values, then the dimensions of the return will be:\n+ *\n+ * S is k x k and diagonal, holding the singular values on diagonal\n+ * U is m x k and satisfies U'U = eye(k)\n+ * V is n x k and satisfies V'V = eye(k)\n+ *\n+ * @param matrix dense matrix to factorize\n+ * @param k Recover k singular values and vectors\n+ * @param computeU gives the option of skipping the U computation\n+ * @param rCond smallest singular value considered nonzero\n+ * @return Three dense matrices: U, S, V such that A = USV^T"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "indentation is wrong.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:35:58Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next "
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "fixed\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:41:02Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next "
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`Iterator(miniata)`\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:37:12Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "changed, this is nitpick\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:41:32Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "put a space after `while`\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:37:34Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "done\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:41:57Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "use `localAtA`?\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:38:22Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)"
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "changed, this is a nitpick\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:44:05Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)"
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "n^2 -> `O(n^2)`\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:39:55Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x / svd(1).get(0) > rCond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    if (computeU) {\n+      // Compute U as U = A V S^-1\n+      // Compute VS^-1\n+      val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))\n+      val retU = matrix.map { x =>\n+        val v = new DoubleMatrix(Array(x))\n+        v.mmul(vsinv).data\n+      }\n+      (retU, sigma, retV)\n+    } else {\n+      (null, sigma, retV)\n+    }\n+  }\n+\n+ /**\n+  * Singular Value Decomposition for Tall and Skinny sparse matrices.\n+  * Given an m x n matrix A, this will compute matrices U, S, V such that\n+  * A = U * S * V'\n+  * \n+  * There is no restriction on m, but we require n^2 doubles to fit in memory."
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "changed\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:46:01Z",
    "diffHunk": "@@ -73,19 +170,110 @@ object SVD {\n  * U is m x k and satisfies U'U = eye(k)\n  * V is n x k and satisfies V'V = eye(k)\n  *\n- * All input and output is expected in sparse matrix format, 0-indexed\n- * as tuples of the form ((i,j),value) all in RDDs using the\n- * SparseMatrix class\n+ * The return values are as lean as possible: an RDD of rows for U,\n+ * a simple array for sigma, and a dense 2d matrix array for V\n  *\n- * @param matrix sparse matrix to factorize\n+ * @param matrix dense matrix to factorize\n  * @param k Recover k singular values and vectors\n- * @return Three sparse matrices: U, S, V such that A = USV^T\n+ * @return Three matrices: U, S, V such that A = USV^T\n  */\n-  def sparseSVD(\n-      matrix: SparseMatrix,\n-      k: Int)\n-    : MatrixSVD =\n-  {\n+ private def denseSVD(matrix: RDD[Array[Double]]) : \n+               (RDD[Array[Double]], Array[Double], Array[Array[Double]])  = {\n+    val n = matrix.first.size\n+\n+    if (k < 1 || k > n) {\n+      throw new IllegalArgumentException(\n+        \"Request up to n singular values k=$k n=$n\")\n+    }\n+\n+    // Compute A^T A\n+    val fullata = matrix.mapPartitions { iter => \n+      val miniata = Array.ofDim[Double](n, n)\n+      while(iter.hasNext) {\n+          val row = iter.next \n+          var i = 0\n+          while(i < n) {\n+            var j = 0\n+            while(j < n) {\n+              miniata(i)(j) += row(i) * row(j)\n+              j += 1\n+            }\n+            i += 1\n+          }\n+      }\n+      List(miniata).iterator\n+    }.fold(Array.ofDim[Double](n, n)) { (a, b) =>\n+      var i = 0\n+      while(i < n) {\n+        var j = 0 \n+        while(j < n) {\n+          a(i)(j) += b(i)(j)\n+          j += 1\n+        }\n+        i += 1\n+      }\n+      a\n+    }\n+\n+    // Construct jblas A^T A locally\n+    val ata = new DoubleMatrix(fullata)\n+\n+    // Since A^T A is small, we can compute its SVD directly\n+    val svd = Singular.sparseSVD(ata)\n+    val V = svd(0)\n+    val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x / svd(1).get(0) > rCond)\n+\n+    val sk = Math.min(k, sigmas.size)\n+    val sigma = sigmas.take(sk)\n+\n+    // prepare V for returning\n+    val retV = Array.tabulate(n, sk)((i, j) => V.get(i, j))\n+\n+    if (computeU) {\n+      // Compute U as U = A V S^-1\n+      // Compute VS^-1\n+      val vsinv = new DoubleMatrix(Array.tabulate(n, sk)((i, j) => V.get(i, j) / sigma(j)))\n+      val retU = matrix.map { x =>\n+        val v = new DoubleMatrix(Array(x))\n+        v.mmul(vsinv).data\n+      }\n+      (retU, sigma, retV)\n+    } else {\n+      (null, sigma, retV)\n+    }\n+  }\n+\n+ /**\n+  * Singular Value Decomposition for Tall and Skinny sparse matrices.\n+  * Given an m x n matrix A, this will compute matrices U, S, V such that\n+  * A = U * S * V'\n+  * \n+  * There is no restriction on m, but we require n^2 doubles to fit in memory."
  }],
  "prId": 88
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is not related to this PR. Let's put a note to update the threshold.\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:42:07Z",
    "diffHunk": "@@ -119,7 +307,7 @@ object SVD {\n     val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)",
    "line": 325
  }, {
    "author": {
      "login": "rezazadeh"
    },
    "body": "added note\n",
    "commit": "e298700a69316d9d32bcd1ce3157f22acc4bb585",
    "createdAt": "2014-03-19T21:46:46Z",
    "diffHunk": "@@ -119,7 +307,7 @@ object SVD {\n     val sigmas = MatrixFunctions.sqrt(svd(1)).toArray.filter(x => x > 1e-9)",
    "line": 325
  }],
  "prId": 88
}]