[{
  "comments": [{
    "author": {
      "login": "manishamde"
    },
    "body": "Shouldn't the class name start with lower case according to Scala conventions? Also `treeEnsembleModels.scala` might be more appropriate.\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T01:44:16Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*"
  }],
  "prId": 3374
}, {
  "comments": [{
    "author": {
      "login": "manishamde"
    },
    "body": "I think the TODO can be removed.\n",
    "commit": "70972515085245957df9601e425141746f268c4b",
    "createdAt": "2014-11-20T02:06:33Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.tree.model\n+\n+import org.apache.spark.api.java.JavaRDD\n+\n+import scala.collection.mutable\n+\n+import com.github.fommil.netlib.BLAS.{getInstance => blas}\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.mllib.linalg.Vector\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.configuration.EnsembleCombiningStrategy._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * :: Experimental ::\n+ * Represents a random forest model.\n+ *\n+ * @param algo algorithm for the ensemble model, either Classification or Regression\n+ * @param trees tree ensembles\n+ */\n+@Experimental\n+class RandomForestModel(override val algo: Algo, override val trees: Array[DecisionTreeModel])\n+  extends TreeEnsembleModel(algo, trees, Array.fill(trees.size)(1.0),\n+    combiningStrategy = if (algo == Classification) Vote else Average) {\n+\n+  require(trees.forall(_.algo == algo))\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * Represents a gradient boosted trees model.\n+ *\n+ * @param algo algorithm for the ensemble model, either Classification or Regression\n+ * @param trees tree ensembles\n+ * @param treeWeights tree ensemble weights\n+ */\n+@Experimental\n+class GradientBoostedTreesModel(\n+    override val algo: Algo,\n+    override val trees: Array[DecisionTreeModel],\n+    override val treeWeights: Array[Double])\n+  extends TreeEnsembleModel(algo, trees, treeWeights, combiningStrategy = Sum) {\n+\n+  require(trees.size == treeWeights.size)\n+}\n+\n+/**\n+ * Represents a tree ensemble model.\n+ *\n+ * @param algo algorithm for the ensemble model, either Classification or Regression\n+ * @param trees tree ensembles\n+ * @param treeWeights tree ensemble weights\n+ * @param combiningStrategy strategy for combining the predictions, not used for regression.\n+ */\n+private[tree] sealed class TreeEnsembleModel(\n+    protected val algo: Algo,\n+    protected val trees: Array[DecisionTreeModel],\n+    protected val treeWeights: Array[Double],\n+    protected val combiningStrategy: EnsembleCombiningStrategy) extends Serializable {\n+\n+  require(numTrees > 0, \"TreeEnsembleModel cannot be created without trees.\")\n+\n+  private val sumWeights = math.max(treeWeights.sum, 1e-15)\n+\n+  /**\n+   * Predicts for a single data point using the weighted sum of ensemble predictions.\n+   *\n+   * @param features array representing a single data point\n+   * @return predicted category from the trained model\n+   */\n+  private def predictBySumming(features: Vector): Double = {\n+    val treePredictions = trees.map(learner => learner.predict(features))\n+    blas.ddot(numTrees, treePredictions, 1, treeWeights, 1)\n+  }\n+\n+  /**\n+   * Classifies a single data point based on (weighted) majority votes.\n+   */\n+  private def predictByVoting(features: Vector): Double = {\n+    val votes = mutable.Map.empty[Int, Double]\n+    trees.view.zip(treeWeights).foreach { case (tree, weight) =>\n+      val prediction = tree.predict(features).toInt\n+      votes(prediction) = votes.getOrElse(prediction, 0.0) + weight\n+    }\n+    votes.maxBy(_._2)._1\n+  }\n+\n+  /**\n+   * Predict values for a single data point using the model trained.\n+   *\n+   * @param features array representing a single data point\n+   * @return predicted category from the trained model\n+   */\n+  def predict(features: Vector): Double = {\n+    (algo, combiningStrategy) match {\n+      case (Regression, Sum) =>\n+        predictBySumming(features)\n+      case (Regression, Average) =>\n+        predictBySumming(features) / sumWeights\n+      case (Classification, Sum) => // binary classification\n+        val prediction = predictBySumming(features)\n+        // TODO: predicted labels are +1 or -1 for GBT. Need a better way to store this info.\n+        if (prediction > 0.0) 1.0 else 0.0\n+      case (Classification, Vote) =>\n+        predictByVoting(features)\n+      case _ =>\n+        throw new IllegalArgumentException(\n+          \"TreeEnsembleModel given unsupported (algo, combiningStrategy) combination: \" +\n+            s\"($algo, $combiningStrategy).\")\n+    }\n+  }\n+\n+  /**\n+   * Predict values for the given data set.\n+   *\n+   * @param features RDD representing data points to be predicted\n+   * @return RDD[Double] where each entry contains the corresponding prediction\n+   */\n+  def predict(features: RDD[Vector]): RDD[Double] = features.map(x => predict(x))\n+\n+  /**\n+   * Java-friendly version of [[org.apache.spark.mllib.tree.model.TreeEnsembleModel#predict]].\n+   */\n+  def predict(features: JavaRDD[Vector]): JavaRDD[java.lang.Double] = {\n+    predict(features.rdd).toJavaRDD().asInstanceOf[JavaRDD[java.lang.Double]]\n+  }\n+\n+  /**\n+   * Print a summary of the model.\n+   */\n+  override def toString: String = {\n+    algo match {\n+      case Classification =>\n+        s\"TreeEnsembleModel classifier with $numTrees trees\\n\"\n+      case Regression =>\n+        s\"TreeEnsembleModel regressor with $numTrees trees\\n\"\n+      case _ => throw new IllegalArgumentException(\n+        s\"TreeEnsembleModel given unknown algo parameter: $algo.\")\n+    }\n+  }\n+\n+  /**\n+   * Print the full model to a string.\n+   */\n+  def toDebugString: String = {\n+    val header = toString + \"\\n\"\n+    header + trees.zipWithIndex.map { case (tree, treeIndex) =>\n+      s\"  Tree $treeIndex:\\n\" + tree.topNode.subtreeToString(4)\n+    }.fold(\"\")(_ + _)\n+  }\n+\n+  /**\n+   * Get number of trees in forest.\n+   */\n+  def numTrees: Int = trees.size\n+\n+  // TODO: Remove these helpers methods once class is generalized to support any base learning"
  }],
  "prId": 3374
}]