[{
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "I think it should be public. Some people may want to customize it.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T02:05:52Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "@mengxr suggested to make it private in this release to be able to modify it if needed and make public in the next one. \n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T08:49:32Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "OK, I see. This is understandable. \n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T09:33:20Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {"
  }, {
    "author": {
      "login": "hhbyyh"
    },
    "body": "I'm not sure I understand the benefit of separating the Layer and LayerModel this way. Can we have a unified Layer, just by moving the getInstance methods to LayerModel and rename it to Layer?\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-28T14:03:16Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "We need a separate lightweight instance for holding the Layer properties, so we can pass it easily through the network to executors on each iteration. We don't want to pass LayerModels because they contain weights and weights are transmitted by the GradientDescent or LBFGS broadcast/treeAggregate routines. Does it answer your question?\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-28T14:29:03Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {"
  }],
  "prId": 7621
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "Here can be more abstract? `setOptimizer` looks good. SGD  and L-BFGS  related code can be placed in a utility class.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T09:48:18Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)\n+    Vectors.dense(result.last.toArray)\n+  }\n+}\n+\n+/**\n+ * Fabric for feed forward ANN models\n+ */\n+private[ann] object FeedForwardModel {\n+\n+  /**\n+   * Creates a model from a topology and weights\n+   * @param topology topology\n+   * @param weights weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, weights: Vector): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(weights, offset)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+\n+  /**\n+   * Creates a model given a topology and seed\n+   * @param topology topology\n+   * @param seed seed for generating the weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, seed: Long = 11L): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(seed)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+}\n+\n+/**\n+ * Neural network gradient. Does nothing but calling Model's gradient\n+ * @param topology topology\n+ * @param dataStacker data stacker\n+ */\n+private[ann] class ANNGradient(topology: Topology, dataStacker: DataStacker) extends Gradient {\n+\n+  override def compute(data: Vector, label: Double, weights: Vector): (Vector, Double) = {\n+    val gradient = Vectors.zeros(weights.size)\n+    val loss = compute(data, label, weights, gradient)\n+    (gradient, loss)\n+  }\n+\n+  override def compute(data: Vector, label: Double, weights: Vector,\n+                       cumGradient: Vector): Double = {\n+    val (input, target, realBatchSize) = dataStacker.unstack(data)\n+    val model = topology.getInstance(weights)\n+    model.computeGradient(input, target, cumGradient, realBatchSize)\n+  }\n+}\n+\n+/**\n+ * Class that stacks the training samples RDD[(Vector, Vector)] in one vector allowing them to pass\n+ * through Optimizer/Gradient interfaces and thus allowing batch computations.\n+ * Can unstack the training samples into matrices.\n+ * @param stackSize stack size\n+ * @param inputSize size of the input vectors\n+ * @param outputSize size of the output vectors\n+ */\n+private[ann] class DataStacker(stackSize: Int, inputSize: Int, outputSize: Int)\n+  extends Serializable {\n+\n+  /**\n+   * Stacks the data\n+   * @param data RDD of vector pairs\n+   * @return RDD of double (always zero) and vector that contains the stacked vectors\n+   */\n+  def stack(data: RDD[(Vector, Vector)]): RDD[(Double, Vector)] = {\n+    val stackedData = if (stackSize == 1) {\n+      data.map(v =>\n+        (0.0,\n+          Vectors.fromBreeze(BDV.vertcat(\n+            v._1.toBreeze.toDenseVector,\n+            v._2.toBreeze.toDenseVector))\n+          ))\n+    } else {\n+      data.mapPartitions { it =>\n+        it.grouped(stackSize).map { seq =>\n+          val size = seq.size\n+          val bigVector = new Array[Double](inputSize * size + outputSize * size)\n+          var i = 0\n+          seq.foreach { case (in, out) =>\n+            System.arraycopy(in.toArray, 0, bigVector, i * inputSize, inputSize)\n+            System.arraycopy(out.toArray, 0, bigVector,\n+              inputSize * size + i * outputSize, outputSize)\n+            i += 1\n+          }\n+          (0.0, Vectors.dense(bigVector))\n+        }\n+      }\n+    }\n+    stackedData\n+  }\n+\n+  /**\n+   * Unstack the stacked vectors into matrices for batch operations\n+   * @param data stacked vector\n+   * @return pair of matrices holding input and output data and the real stack size\n+   */\n+  def unstack(data: Vector): (BDM[Double], BDM[Double], Int) = {\n+    val arrData = data.toArray\n+    val realStackSize = arrData.length / (inputSize + outputSize)\n+    val input = new BDM(inputSize, realStackSize, arrData)\n+    val target = new BDM(outputSize, realStackSize, arrData, inputSize * realStackSize)\n+    (input, target, realStackSize)\n+  }\n+}\n+\n+/**\n+ * Simple updater\n+ */\n+private[ann] class ANNUpdater extends Updater {\n+\n+  override def compute(weightsOld: Vector,\n+                       gradient: Vector,\n+                       stepSize: Double,\n+                       iter: Int,\n+                       regParam: Double): (Vector, Double) = {\n+    val thisIterStepSize = stepSize\n+    val brzWeights: BV[Double] = weightsOld.toBreeze.toDenseVector\n+    brzAxpy(-thisIterStepSize, gradient.toBreeze, brzWeights)\n+    (Vectors.fromBreeze(brzWeights), 0)\n+  }\n+}\n+\n+/**\n+ * Llib-style trainer class that trains a network given the data and topology\n+ * @param topology topology of ANN\n+ * @param inputSize input size\n+ * @param outputSize output size\n+ */\n+class FeedForwardTrainer (topology: Topology, val inputSize: Int,\n+                          val outputSize: Int) extends Serializable {\n+\n+  // TODO: what if we need to pass random seed?\n+  private var _weights = topology.getInstance(11L).weights()\n+  private var _stackSize = 1\n+  private var dataStacker = new DataStacker(_stackSize, inputSize, outputSize)\n+  private var _gradient: Gradient = new ANNGradient(topology, dataStacker)\n+  private var _updater: Updater = new ANNUpdater()\n+  private var optimizer: Optimizer = LBFGSOptimizer.setConvergenceTol(1e-4).setNumIterations(100)\n+\n+  /**\n+   * Returns weights\n+   * @return weights\n+   */\n+  def getWeights: Vector = _weights\n+\n+  /**\n+   * Sets weights\n+   * @param value weights\n+   * @return trainer\n+   */\n+  def setWeights(value: Vector): FeedForwardTrainer = {\n+    _weights = value\n+    this\n+  }\n+\n+  /**\n+   * Sets the stack size\n+   * @param value stack size\n+   * @return trainer\n+   */\n+  def setStackSize(value: Int): FeedForwardTrainer = {\n+    _stackSize = value\n+    dataStacker = new DataStacker(value, inputSize, outputSize)\n+    this\n+  }\n+\n+  /**\n+   * Sets the SGD optimizer\n+   * @return SGD optimizer\n+   */\n+  def SGDOptimizer: GradientDescent = {\n+    val sgd = new GradientDescent(_gradient, _updater)\n+    optimizer = sgd\n+    sgd\n+  }\n+\n+  /**\n+   * Sets the LBFGS optimizer\n+   * @return LBGS optimizer\n+   */\n+  def LBFGSOptimizer: LBFGS = {"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "@witgo Could you elaborate on this? Do you suggest a pair of `setOptimizer` to set the optimizer and `getOptimizer` to set its properties? What should be the signatures (method's parameters)?\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T15:33:40Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)\n+    Vectors.dense(result.last.toArray)\n+  }\n+}\n+\n+/**\n+ * Fabric for feed forward ANN models\n+ */\n+private[ann] object FeedForwardModel {\n+\n+  /**\n+   * Creates a model from a topology and weights\n+   * @param topology topology\n+   * @param weights weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, weights: Vector): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(weights, offset)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+\n+  /**\n+   * Creates a model given a topology and seed\n+   * @param topology topology\n+   * @param seed seed for generating the weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, seed: Long = 11L): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(seed)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+}\n+\n+/**\n+ * Neural network gradient. Does nothing but calling Model's gradient\n+ * @param topology topology\n+ * @param dataStacker data stacker\n+ */\n+private[ann] class ANNGradient(topology: Topology, dataStacker: DataStacker) extends Gradient {\n+\n+  override def compute(data: Vector, label: Double, weights: Vector): (Vector, Double) = {\n+    val gradient = Vectors.zeros(weights.size)\n+    val loss = compute(data, label, weights, gradient)\n+    (gradient, loss)\n+  }\n+\n+  override def compute(data: Vector, label: Double, weights: Vector,\n+                       cumGradient: Vector): Double = {\n+    val (input, target, realBatchSize) = dataStacker.unstack(data)\n+    val model = topology.getInstance(weights)\n+    model.computeGradient(input, target, cumGradient, realBatchSize)\n+  }\n+}\n+\n+/**\n+ * Class that stacks the training samples RDD[(Vector, Vector)] in one vector allowing them to pass\n+ * through Optimizer/Gradient interfaces and thus allowing batch computations.\n+ * Can unstack the training samples into matrices.\n+ * @param stackSize stack size\n+ * @param inputSize size of the input vectors\n+ * @param outputSize size of the output vectors\n+ */\n+private[ann] class DataStacker(stackSize: Int, inputSize: Int, outputSize: Int)\n+  extends Serializable {\n+\n+  /**\n+   * Stacks the data\n+   * @param data RDD of vector pairs\n+   * @return RDD of double (always zero) and vector that contains the stacked vectors\n+   */\n+  def stack(data: RDD[(Vector, Vector)]): RDD[(Double, Vector)] = {\n+    val stackedData = if (stackSize == 1) {\n+      data.map(v =>\n+        (0.0,\n+          Vectors.fromBreeze(BDV.vertcat(\n+            v._1.toBreeze.toDenseVector,\n+            v._2.toBreeze.toDenseVector))\n+          ))\n+    } else {\n+      data.mapPartitions { it =>\n+        it.grouped(stackSize).map { seq =>\n+          val size = seq.size\n+          val bigVector = new Array[Double](inputSize * size + outputSize * size)\n+          var i = 0\n+          seq.foreach { case (in, out) =>\n+            System.arraycopy(in.toArray, 0, bigVector, i * inputSize, inputSize)\n+            System.arraycopy(out.toArray, 0, bigVector,\n+              inputSize * size + i * outputSize, outputSize)\n+            i += 1\n+          }\n+          (0.0, Vectors.dense(bigVector))\n+        }\n+      }\n+    }\n+    stackedData\n+  }\n+\n+  /**\n+   * Unstack the stacked vectors into matrices for batch operations\n+   * @param data stacked vector\n+   * @return pair of matrices holding input and output data and the real stack size\n+   */\n+  def unstack(data: Vector): (BDM[Double], BDM[Double], Int) = {\n+    val arrData = data.toArray\n+    val realStackSize = arrData.length / (inputSize + outputSize)\n+    val input = new BDM(inputSize, realStackSize, arrData)\n+    val target = new BDM(outputSize, realStackSize, arrData, inputSize * realStackSize)\n+    (input, target, realStackSize)\n+  }\n+}\n+\n+/**\n+ * Simple updater\n+ */\n+private[ann] class ANNUpdater extends Updater {\n+\n+  override def compute(weightsOld: Vector,\n+                       gradient: Vector,\n+                       stepSize: Double,\n+                       iter: Int,\n+                       regParam: Double): (Vector, Double) = {\n+    val thisIterStepSize = stepSize\n+    val brzWeights: BV[Double] = weightsOld.toBreeze.toDenseVector\n+    brzAxpy(-thisIterStepSize, gradient.toBreeze, brzWeights)\n+    (Vectors.fromBreeze(brzWeights), 0)\n+  }\n+}\n+\n+/**\n+ * Llib-style trainer class that trains a network given the data and topology\n+ * @param topology topology of ANN\n+ * @param inputSize input size\n+ * @param outputSize output size\n+ */\n+class FeedForwardTrainer (topology: Topology, val inputSize: Int,\n+                          val outputSize: Int) extends Serializable {\n+\n+  // TODO: what if we need to pass random seed?\n+  private var _weights = topology.getInstance(11L).weights()\n+  private var _stackSize = 1\n+  private var dataStacker = new DataStacker(_stackSize, inputSize, outputSize)\n+  private var _gradient: Gradient = new ANNGradient(topology, dataStacker)\n+  private var _updater: Updater = new ANNUpdater()\n+  private var optimizer: Optimizer = LBFGSOptimizer.setConvergenceTol(1e-4).setNumIterations(100)\n+\n+  /**\n+   * Returns weights\n+   * @return weights\n+   */\n+  def getWeights: Vector = _weights\n+\n+  /**\n+   * Sets weights\n+   * @param value weights\n+   * @return trainer\n+   */\n+  def setWeights(value: Vector): FeedForwardTrainer = {\n+    _weights = value\n+    this\n+  }\n+\n+  /**\n+   * Sets the stack size\n+   * @param value stack size\n+   * @return trainer\n+   */\n+  def setStackSize(value: Int): FeedForwardTrainer = {\n+    _stackSize = value\n+    dataStacker = new DataStacker(value, inputSize, outputSize)\n+    this\n+  }\n+\n+  /**\n+   * Sets the SGD optimizer\n+   * @return SGD optimizer\n+   */\n+  def SGDOptimizer: GradientDescent = {\n+    val sgd = new GradientDescent(_gradient, _updater)\n+    optimizer = sgd\n+    sgd\n+  }\n+\n+  /**\n+   * Sets the LBFGS optimizer\n+   * @return LBGS optimizer\n+   */\n+  def LBFGSOptimizer: LBFGS = {"
  }, {
    "author": {
      "login": "witgo"
    },
    "body": "We can refer to the [LogisticRegressionWithLBFGS](https://github.com/apache/spark/blob/master/mllib/src/main/scala/org/apache/spark/mllib/classification/LogisticRegression.scala#L342) and [LogisticRegressionWithSGD](https://github.com/apache/spark/blob/master/mllib/src/main/scala/org/apache/spark/mllib/classification/LogisticRegression.scala#L216)\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T15:56:37Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)\n+    Vectors.dense(result.last.toArray)\n+  }\n+}\n+\n+/**\n+ * Fabric for feed forward ANN models\n+ */\n+private[ann] object FeedForwardModel {\n+\n+  /**\n+   * Creates a model from a topology and weights\n+   * @param topology topology\n+   * @param weights weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, weights: Vector): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(weights, offset)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+\n+  /**\n+   * Creates a model given a topology and seed\n+   * @param topology topology\n+   * @param seed seed for generating the weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, seed: Long = 11L): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(seed)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+}\n+\n+/**\n+ * Neural network gradient. Does nothing but calling Model's gradient\n+ * @param topology topology\n+ * @param dataStacker data stacker\n+ */\n+private[ann] class ANNGradient(topology: Topology, dataStacker: DataStacker) extends Gradient {\n+\n+  override def compute(data: Vector, label: Double, weights: Vector): (Vector, Double) = {\n+    val gradient = Vectors.zeros(weights.size)\n+    val loss = compute(data, label, weights, gradient)\n+    (gradient, loss)\n+  }\n+\n+  override def compute(data: Vector, label: Double, weights: Vector,\n+                       cumGradient: Vector): Double = {\n+    val (input, target, realBatchSize) = dataStacker.unstack(data)\n+    val model = topology.getInstance(weights)\n+    model.computeGradient(input, target, cumGradient, realBatchSize)\n+  }\n+}\n+\n+/**\n+ * Class that stacks the training samples RDD[(Vector, Vector)] in one vector allowing them to pass\n+ * through Optimizer/Gradient interfaces and thus allowing batch computations.\n+ * Can unstack the training samples into matrices.\n+ * @param stackSize stack size\n+ * @param inputSize size of the input vectors\n+ * @param outputSize size of the output vectors\n+ */\n+private[ann] class DataStacker(stackSize: Int, inputSize: Int, outputSize: Int)\n+  extends Serializable {\n+\n+  /**\n+   * Stacks the data\n+   * @param data RDD of vector pairs\n+   * @return RDD of double (always zero) and vector that contains the stacked vectors\n+   */\n+  def stack(data: RDD[(Vector, Vector)]): RDD[(Double, Vector)] = {\n+    val stackedData = if (stackSize == 1) {\n+      data.map(v =>\n+        (0.0,\n+          Vectors.fromBreeze(BDV.vertcat(\n+            v._1.toBreeze.toDenseVector,\n+            v._2.toBreeze.toDenseVector))\n+          ))\n+    } else {\n+      data.mapPartitions { it =>\n+        it.grouped(stackSize).map { seq =>\n+          val size = seq.size\n+          val bigVector = new Array[Double](inputSize * size + outputSize * size)\n+          var i = 0\n+          seq.foreach { case (in, out) =>\n+            System.arraycopy(in.toArray, 0, bigVector, i * inputSize, inputSize)\n+            System.arraycopy(out.toArray, 0, bigVector,\n+              inputSize * size + i * outputSize, outputSize)\n+            i += 1\n+          }\n+          (0.0, Vectors.dense(bigVector))\n+        }\n+      }\n+    }\n+    stackedData\n+  }\n+\n+  /**\n+   * Unstack the stacked vectors into matrices for batch operations\n+   * @param data stacked vector\n+   * @return pair of matrices holding input and output data and the real stack size\n+   */\n+  def unstack(data: Vector): (BDM[Double], BDM[Double], Int) = {\n+    val arrData = data.toArray\n+    val realStackSize = arrData.length / (inputSize + outputSize)\n+    val input = new BDM(inputSize, realStackSize, arrData)\n+    val target = new BDM(outputSize, realStackSize, arrData, inputSize * realStackSize)\n+    (input, target, realStackSize)\n+  }\n+}\n+\n+/**\n+ * Simple updater\n+ */\n+private[ann] class ANNUpdater extends Updater {\n+\n+  override def compute(weightsOld: Vector,\n+                       gradient: Vector,\n+                       stepSize: Double,\n+                       iter: Int,\n+                       regParam: Double): (Vector, Double) = {\n+    val thisIterStepSize = stepSize\n+    val brzWeights: BV[Double] = weightsOld.toBreeze.toDenseVector\n+    brzAxpy(-thisIterStepSize, gradient.toBreeze, brzWeights)\n+    (Vectors.fromBreeze(brzWeights), 0)\n+  }\n+}\n+\n+/**\n+ * Llib-style trainer class that trains a network given the data and topology\n+ * @param topology topology of ANN\n+ * @param inputSize input size\n+ * @param outputSize output size\n+ */\n+class FeedForwardTrainer (topology: Topology, val inputSize: Int,\n+                          val outputSize: Int) extends Serializable {\n+\n+  // TODO: what if we need to pass random seed?\n+  private var _weights = topology.getInstance(11L).weights()\n+  private var _stackSize = 1\n+  private var dataStacker = new DataStacker(_stackSize, inputSize, outputSize)\n+  private var _gradient: Gradient = new ANNGradient(topology, dataStacker)\n+  private var _updater: Updater = new ANNUpdater()\n+  private var optimizer: Optimizer = LBFGSOptimizer.setConvergenceTol(1e-4).setNumIterations(100)\n+\n+  /**\n+   * Returns weights\n+   * @return weights\n+   */\n+  def getWeights: Vector = _weights\n+\n+  /**\n+   * Sets weights\n+   * @param value weights\n+   * @return trainer\n+   */\n+  def setWeights(value: Vector): FeedForwardTrainer = {\n+    _weights = value\n+    this\n+  }\n+\n+  /**\n+   * Sets the stack size\n+   * @param value stack size\n+   * @return trainer\n+   */\n+  def setStackSize(value: Int): FeedForwardTrainer = {\n+    _stackSize = value\n+    dataStacker = new DataStacker(value, inputSize, outputSize)\n+    this\n+  }\n+\n+  /**\n+   * Sets the SGD optimizer\n+   * @return SGD optimizer\n+   */\n+  def SGDOptimizer: GradientDescent = {\n+    val sgd = new GradientDescent(_gradient, _updater)\n+    optimizer = sgd\n+    sgd\n+  }\n+\n+  /**\n+   * Sets the LBFGS optimizer\n+   * @return LBGS optimizer\n+   */\n+  def LBFGSOptimizer: LBFGS = {"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "According to my observations, Spark developers have moved away from from the \"one optimizer per class\" paradigm. @mengxr correct me please if I am wrong. \n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-27T09:41:21Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)\n+    Vectors.dense(result.last.toArray)\n+  }\n+}\n+\n+/**\n+ * Fabric for feed forward ANN models\n+ */\n+private[ann] object FeedForwardModel {\n+\n+  /**\n+   * Creates a model from a topology and weights\n+   * @param topology topology\n+   * @param weights weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, weights: Vector): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(weights, offset)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+\n+  /**\n+   * Creates a model given a topology and seed\n+   * @param topology topology\n+   * @param seed seed for generating the weights\n+   * @return model\n+   */\n+  def apply(topology: FeedForwardTopology, seed: Long = 11L): FeedForwardModel = {\n+    val layers = topology.layers\n+    val layerModels = new Array[LayerModel](layers.length)\n+    var offset = 0\n+    for(i <- 0 until layers.length){\n+      layerModels(i) = layers(i).getInstance(seed)\n+      offset += layerModels(i).size\n+    }\n+    new FeedForwardModel(layerModels, topology)\n+  }\n+}\n+\n+/**\n+ * Neural network gradient. Does nothing but calling Model's gradient\n+ * @param topology topology\n+ * @param dataStacker data stacker\n+ */\n+private[ann] class ANNGradient(topology: Topology, dataStacker: DataStacker) extends Gradient {\n+\n+  override def compute(data: Vector, label: Double, weights: Vector): (Vector, Double) = {\n+    val gradient = Vectors.zeros(weights.size)\n+    val loss = compute(data, label, weights, gradient)\n+    (gradient, loss)\n+  }\n+\n+  override def compute(data: Vector, label: Double, weights: Vector,\n+                       cumGradient: Vector): Double = {\n+    val (input, target, realBatchSize) = dataStacker.unstack(data)\n+    val model = topology.getInstance(weights)\n+    model.computeGradient(input, target, cumGradient, realBatchSize)\n+  }\n+}\n+\n+/**\n+ * Class that stacks the training samples RDD[(Vector, Vector)] in one vector allowing them to pass\n+ * through Optimizer/Gradient interfaces and thus allowing batch computations.\n+ * Can unstack the training samples into matrices.\n+ * @param stackSize stack size\n+ * @param inputSize size of the input vectors\n+ * @param outputSize size of the output vectors\n+ */\n+private[ann] class DataStacker(stackSize: Int, inputSize: Int, outputSize: Int)\n+  extends Serializable {\n+\n+  /**\n+   * Stacks the data\n+   * @param data RDD of vector pairs\n+   * @return RDD of double (always zero) and vector that contains the stacked vectors\n+   */\n+  def stack(data: RDD[(Vector, Vector)]): RDD[(Double, Vector)] = {\n+    val stackedData = if (stackSize == 1) {\n+      data.map(v =>\n+        (0.0,\n+          Vectors.fromBreeze(BDV.vertcat(\n+            v._1.toBreeze.toDenseVector,\n+            v._2.toBreeze.toDenseVector))\n+          ))\n+    } else {\n+      data.mapPartitions { it =>\n+        it.grouped(stackSize).map { seq =>\n+          val size = seq.size\n+          val bigVector = new Array[Double](inputSize * size + outputSize * size)\n+          var i = 0\n+          seq.foreach { case (in, out) =>\n+            System.arraycopy(in.toArray, 0, bigVector, i * inputSize, inputSize)\n+            System.arraycopy(out.toArray, 0, bigVector,\n+              inputSize * size + i * outputSize, outputSize)\n+            i += 1\n+          }\n+          (0.0, Vectors.dense(bigVector))\n+        }\n+      }\n+    }\n+    stackedData\n+  }\n+\n+  /**\n+   * Unstack the stacked vectors into matrices for batch operations\n+   * @param data stacked vector\n+   * @return pair of matrices holding input and output data and the real stack size\n+   */\n+  def unstack(data: Vector): (BDM[Double], BDM[Double], Int) = {\n+    val arrData = data.toArray\n+    val realStackSize = arrData.length / (inputSize + outputSize)\n+    val input = new BDM(inputSize, realStackSize, arrData)\n+    val target = new BDM(outputSize, realStackSize, arrData, inputSize * realStackSize)\n+    (input, target, realStackSize)\n+  }\n+}\n+\n+/**\n+ * Simple updater\n+ */\n+private[ann] class ANNUpdater extends Updater {\n+\n+  override def compute(weightsOld: Vector,\n+                       gradient: Vector,\n+                       stepSize: Double,\n+                       iter: Int,\n+                       regParam: Double): (Vector, Double) = {\n+    val thisIterStepSize = stepSize\n+    val brzWeights: BV[Double] = weightsOld.toBreeze.toDenseVector\n+    brzAxpy(-thisIterStepSize, gradient.toBreeze, brzWeights)\n+    (Vectors.fromBreeze(brzWeights), 0)\n+  }\n+}\n+\n+/**\n+ * Llib-style trainer class that trains a network given the data and topology\n+ * @param topology topology of ANN\n+ * @param inputSize input size\n+ * @param outputSize output size\n+ */\n+class FeedForwardTrainer (topology: Topology, val inputSize: Int,\n+                          val outputSize: Int) extends Serializable {\n+\n+  // TODO: what if we need to pass random seed?\n+  private var _weights = topology.getInstance(11L).weights()\n+  private var _stackSize = 1\n+  private var dataStacker = new DataStacker(_stackSize, inputSize, outputSize)\n+  private var _gradient: Gradient = new ANNGradient(topology, dataStacker)\n+  private var _updater: Updater = new ANNUpdater()\n+  private var optimizer: Optimizer = LBFGSOptimizer.setConvergenceTol(1e-4).setNumIterations(100)\n+\n+  /**\n+   * Returns weights\n+   * @return weights\n+   */\n+  def getWeights: Vector = _weights\n+\n+  /**\n+   * Sets weights\n+   * @param value weights\n+   * @return trainer\n+   */\n+  def setWeights(value: Vector): FeedForwardTrainer = {\n+    _weights = value\n+    this\n+  }\n+\n+  /**\n+   * Sets the stack size\n+   * @param value stack size\n+   * @return trainer\n+   */\n+  def setStackSize(value: Int): FeedForwardTrainer = {\n+    _stackSize = value\n+    dataStacker = new DataStacker(value, inputSize, outputSize)\n+    this\n+  }\n+\n+  /**\n+   * Sets the SGD optimizer\n+   * @return SGD optimizer\n+   */\n+  def SGDOptimizer: GradientDescent = {\n+    val sgd = new GradientDescent(_gradient, _updater)\n+    optimizer = sgd\n+    sgd\n+  }\n+\n+  /**\n+   * Sets the LBFGS optimizer\n+   * @return LBGS optimizer\n+   */\n+  def LBFGSOptimizer: LBFGS = {"
  }],
  "prId": 7621
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "The code creates a new array:\n\n``` scala\n  def toDenseMatrix: DenseMatrix[V] = {\n     copy.asDenseMatrix\n  }\n\n  def copy: DenseVector[V] = {\n    implicit val man = ClassTag[V](data.getClass.getComponentType.asInstanceOf[Class[V]])\n    val r = new DenseVector(new Array[V](length))\n    r := this\n    r\n  }\n\n```\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T10:04:55Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "@witgo Indeed! Thanks for the snippet.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T15:23:56Z",
    "diffHunk": "@@ -0,0 +1,856 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {\n+  override def getInstance(weights: Vector): TopologyModel = FeedForwardModel(this, weights)\n+\n+  override def getInstance(seed: Long): TopologyModel = FeedForwardModel(this, seed)\n+}\n+\n+/**\n+ * Factory for some of the frequently-used topologies\n+ */\n+object FeedForwardTopology {\n+  /**\n+   * Creates a feed forward topology from the array of layers\n+   * @param layers array of layers\n+   * @return feed forward topology\n+   */\n+  def apply(layers: Array[Layer]): FeedForwardTopology = {\n+    new FeedForwardTopology(layers)\n+  }\n+\n+  /**\n+   * Creates a multi-layer perceptron\n+   * @param layerSizes sizes of layers including input and output size\n+   * @param softmax wether to use SoftMax or Sigmoid function for an output layer.\n+   *                Softmax is default\n+   * @return multilayer perceptron topology\n+   */\n+  def multiLayerPerceptron(layerSizes: Array[Int], softmax: Boolean = true): FeedForwardTopology = {\n+    val layers = new Array[Layer]((layerSizes.length - 1) * 2)\n+    for(i <- 0 until layerSizes.length - 1){\n+      layers(i * 2) = new AffineLayer(layerSizes(i), layerSizes(i + 1))\n+      layers(i * 2 + 1) =\n+        if (softmax && i == layerSizes.length - 2) {\n+          new FunctionalLayer(new SoftmaxFunction())\n+        } else {\n+          new FunctionalLayer(new SigmoidFunction())\n+        }\n+    }\n+    FeedForwardTopology(layers)\n+  }\n+}\n+\n+/**\n+ * Model of Feed Forward Neural Network.\n+ * Implements forward, gradient computation and can return weights in vector format.\n+ * @param layerModels models of layers\n+ * @param topology topology of the network\n+ */\n+class FeedForwardModel private(val layerModels: Array[LayerModel],\n+                       val topology: FeedForwardTopology) extends TopologyModel {\n+  override def forward(data: BDM[Double]): Array[BDM[Double]] = {\n+    val outputs = new Array[BDM[Double]](layerModels.length)\n+    outputs(0) = layerModels(0).eval(data)\n+    for(i <- 1 until layerModels.length){\n+      outputs(i) = layerModels(i).eval(outputs(i-1))\n+    }\n+    outputs\n+  }\n+\n+  override def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      realBatchSize: Int): Double = {\n+    val outputs = forward(data)\n+    val deltas = new Array[BDM[Double]](layerModels.length)\n+    val L = layerModels.length - 1\n+    val (newE, newError) = layerModels.last match {\n+      case flm: FunctionalLayerModel => flm.error(outputs.last, target)\n+      case _ =>\n+        throw new UnsupportedOperationException(\"Non-functional layer not supported at the top\")\n+    }\n+    deltas(L) = new BDM[Double](0, 0)\n+    deltas(L - 1) = newE\n+    for (i <- (L - 2) to (0, -1)) {\n+      deltas(i) = layerModels(i + 1).prevDelta(deltas(i + 1), outputs(i + 1))\n+    }\n+    val grads = new Array[Array[Double]](layerModels.length)\n+    for (i <- 0 until layerModels.length) {\n+      val input = if (i==0) data else outputs(i - 1)\n+      grads(i) = layerModels(i).grad(deltas(i), input)\n+    }\n+    // update cumGradient\n+    val cumGradientArray = cumGradient.toArray\n+    var offset = 0\n+    // TODO: extract roll\n+    for (i <- 0 until grads.length) {\n+      val gradArray = grads(i)\n+      var k = 0\n+      while (k < gradArray.length) {\n+        cumGradientArray(offset + k) += gradArray(k)\n+        k += 1\n+      }\n+      offset += gradArray.length\n+    }\n+    newError\n+  }\n+\n+  // TODO: do we really need to copy the weights? they should be read-only\n+  override def weights(): Vector = {\n+    // TODO: extract roll\n+    var size = 0\n+    for(i <- 0 until layerModels.length) {\n+      size += layerModels(i).size\n+    }\n+    val array = new Array[Double](size)\n+    var offset = 0\n+    for(i <- 0 until layerModels.length) {\n+      val layerWeights = layerModels(i).weights().toArray\n+      System.arraycopy(layerWeights, 0, array, offset, layerWeights.length)\n+      offset += layerWeights.length\n+    }\n+    Vectors.dense(array)\n+  }\n+\n+  override def predict(data: Vector): Vector = {\n+    val result = forward(data.toBreeze.toDenseVector.toDenseMatrix.t)"
  }],
  "prId": 7621
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "  This formula should be related to specific activation function?  It is not suitable for `ReLu`\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-24T15:47:32Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "Yes, you are correct. We can add the formula in the new PR with ReLU. The topology model fabric `FeedForwardModel.apply` needs to be modified in order to run the new formula if it there is a ReLU layer on top of AffineLayer.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-27T09:33:18Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }"
  }],
  "prId": 7621
}, {
  "comments": [{
    "author": {
      "login": "hhbyyh"
    },
    "body": "It's possible that prevDelta needs to get some properties from the next layer. (at least for CNN). I'm not sure if it's a special (rare) requirement. Of course there's some workaround,  yet it will be handy if there's a reference to the next layer.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-28T14:43:34Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+"
  }, {
    "author": {
      "login": "avulanov"
    },
    "body": "Could you elaborate on which properties are needed from the next layer? @witgo pointed that weights initialization in AffineLayer depends on the next FunctionalLayer layer https://github.com/apache/spark/pull/7621/files#r35435404. The latter can be handled in the ANN fabric.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-28T14:55:17Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+"
  }, {
    "author": {
      "login": "hhbyyh"
    },
    "body": "the number of feature maps in the next layer\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-29T06:59:42Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+"
  }],
  "prId": 7621
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "package private. Please make sure that we only expose public APIs in `MultilayerPerceptron*`.\n",
    "commit": "4806b6fa75d12002c1e19d929c23c7153a0bedd3",
    "createdAt": "2015-07-28T19:29:15Z",
    "diffHunk": "@@ -0,0 +1,857 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.ann\n+\n+import breeze.linalg.{*, DenseMatrix => BDM, DenseVector => BDV, Vector => BV, axpy => brzAxpy,\n+sum => Bsum}\n+import breeze.numerics.{log => Blog, sigmoid => Bsigmoid}\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+import org.apache.spark.mllib.optimization._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.random.XORShiftRandom\n+\n+/**\n+ * Trait that holds Layer properties, that are needed to instantiate it.\n+ * Implements Layer instantiation.\n+ *\n+ */\n+private[ann] trait Layer extends Serializable {\n+  /**\n+   * Returns the instance of the layer based on weights provided\n+   * @param weights vector with layer weights\n+   * @param position position of weights in the vector\n+   * @return the layer model\n+   */\n+  def getInstance(weights: Vector, position: Int): LayerModel\n+\n+  /**\n+   * Returns the instance of the layer with random generated weights\n+   * @param seed seed\n+   * @return the layer model\n+   */\n+  def getInstance(seed: Long): LayerModel\n+}\n+\n+/**\n+ * Trait that holds Layer weights (or parameters).\n+ * Implements functions needed for forward propagation, computing delta and gradient.\n+ * Can return weights in Vector format.\n+ */\n+private[ann] trait LayerModel extends Serializable {\n+  /**\n+   * number of weights\n+   */\n+  val size: Int\n+\n+  /**\n+   * Evaluates the data (process the data through the layer)\n+   * @param data data\n+   * @return processed data\n+   */\n+  def eval(data: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the delta for back propagation\n+   * @param nextDelta delta of the next layer\n+   * @param input input data\n+   * @return delta\n+   */\n+  def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double]\n+\n+  /**\n+   * Computes the gradient\n+   * @param delta delta for this layer\n+   * @param input input data\n+   * @return gradient\n+   */\n+  def grad(delta: BDM[Double], input: BDM[Double]): Array[Double]\n+\n+  /**\n+   * Returns weights for the layer in a single vector\n+   * @return layer weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Layer properties of affine transformations, that is y=A*x+b\n+ * @param numIn number of inputs\n+ * @param numOut number of outputs\n+ */\n+private[ann] class AffineLayer(val numIn: Int, val numOut: Int) extends Layer {\n+\n+  override def getInstance(weights: Vector, position: Int): LayerModel = {\n+    AffineLayerModel(this, weights, position)\n+  }\n+\n+  override def getInstance(seed: Long = 11L): LayerModel = {\n+    AffineLayerModel(this, seed)\n+  }\n+}\n+\n+/**\n+ * Model of Affine layer y=A*x+b\n+ * @param w weights (matrix A)\n+ * @param b bias (vector b)\n+ */\n+private[ann] class AffineLayerModel private(w: BDM[Double], b: BDV[Double]) extends LayerModel {\n+  val size = w.size + b.length\n+  val gwb = new Array[Double](size)\n+  private lazy val gw: BDM[Double] = new BDM[Double](w.rows, w.cols, gwb)\n+  private lazy val gb: BDV[Double] = new BDV[Double](gwb, w.size)\n+  private var z: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var ones: BDV[Double] = null\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (z == null || z.cols != data.cols) z = new BDM[Double](w.rows, data.cols)\n+    z(::, *) := b\n+    BreezeUtil.dgemm(1.0, w, data, 1.0, z)\n+    z\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](w.cols, nextDelta.cols)\n+    BreezeUtil.dgemm(1.0, w.t, nextDelta, 0.0, d)\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = {\n+    BreezeUtil.dgemm(1.0 / input.cols, delta, input.t, 0.0, gw)\n+    if (ones == null || ones.length != delta.cols) ones = BDV.ones[Double](delta.cols)\n+    BreezeUtil.dgemv(1.0 / input.cols, delta, ones, 0.0, gb)\n+    gwb\n+  }\n+\n+  override def weights(): Vector = AffineLayerModel.roll(w, b)\n+}\n+\n+/**\n+ * Fabric for Affine layer models\n+ */\n+private[ann] object AffineLayerModel {\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param weights vector with weights\n+   * @param position position of weights in the vector\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, weights: Vector, position: Int): AffineLayerModel = {\n+    val (w, b) = unroll(weights, position, layer.numIn, layer.numOut)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Creates a model of Affine layer\n+   * @param layer layer properties\n+   * @param seed seed\n+   * @return model of Affine layer\n+   */\n+  def apply(layer: AffineLayer, seed: Long): AffineLayerModel = {\n+    val (w, b) = randomWeights(layer.numIn, layer.numOut, seed)\n+    new AffineLayerModel(w, b)\n+  }\n+\n+  /**\n+   * Unrolls the weights from the vector\n+   * @param weights vector with weights\n+   * @param position position of weights for this layer\n+   * @param numIn number of layer inputs\n+   * @param numOut number of layer outputs\n+   * @return matrix A and vector b\n+   */\n+  def unroll(weights: Vector, position: Int,\n+             numIn: Int, numOut: Int): (BDM[Double], BDV[Double]) = {\n+    val weightsCopy = weights.toArray\n+    // TODO: the array is not copied to BDMs, make sure this is OK!\n+    val a = new BDM[Double](numOut, numIn, weightsCopy, position)\n+    val b = new BDV[Double](weightsCopy, position + (numOut * numIn), 1, numOut)\n+    (a, b)\n+  }\n+\n+  /**\n+   * Roll the layer weights into a vector\n+   * @param a matrix A\n+   * @param b vector b\n+   * @return vector of weights\n+   */\n+  def roll(a: BDM[Double], b: BDV[Double]): Vector = {\n+    val result = new Array[Double](a.size + b.length)\n+    // TODO: make sure that we need to copy!\n+    System.arraycopy(a.toArray, 0, result, 0, a.size)\n+    System.arraycopy(b.toArray, 0, result, a.size, b.length)\n+    Vectors.dense(result)\n+  }\n+\n+  /**\n+   * Generate random weights for the layer\n+   * @param numIn number of inputs\n+   * @param numOut number of outputs\n+   * @param seed seed\n+   * @return (matrix A, vector b)\n+   */\n+  def randomWeights(numIn: Int, numOut: Int, seed: Long = 11L): (BDM[Double], BDV[Double]) = {\n+    val rand: XORShiftRandom = new XORShiftRandom(seed)\n+    val weights = BDM.fill[Double](numOut, numIn){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    val bias = BDV.fill[Double](numOut){ (rand.nextDouble * 4.8 - 2.4) / numIn }\n+    (weights, bias)\n+  }\n+}\n+\n+/**\n+ * Trait for functions and their derivatives for functional layers\n+ */\n+private[ann] trait ActivationFunction extends Serializable {\n+\n+  /**\n+   * Implements a function\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def eval(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a derivative of a function (needed for the back propagation)\n+   * @param x input data\n+   * @param y output data\n+   */\n+  def derivative(x: BDM[Double], y: BDM[Double]): Unit\n+\n+  /**\n+   * Implements a cross entropy error of a function.\n+   * Needed if the functional layer that contains this function is the output layer\n+   * of the network.\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return cross-entropy\n+   */\n+  def crossEntropy(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+\n+  /**\n+   * Implements a mean squared error of a function\n+   * @param target target output\n+   * @param output computed output\n+   * @param result intermediate result\n+   * @return mean squared error\n+   */\n+  def squared(target: BDM[Double], output: BDM[Double], result: BDM[Double]): Double\n+}\n+\n+/**\n+ * Implements in-place application of functions\n+ */\n+private[ann] object ActivationFunction {\n+\n+  def apply(x: BDM[Double], y: BDM[Double], func: Double => Double): Unit = {\n+    var i = 0\n+    while (i < x.rows) {\n+      var j = 0\n+      while (j < x.cols) {\n+        y(i, j) = func(x(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+  def apply(x1: BDM[Double], x2: BDM[Double], y: BDM[Double],\n+            func: (Double, Double) => Double): Unit = {\n+    var i = 0\n+    while (i < x1.rows) {\n+      var j = 0\n+      while (j < x1.cols) {\n+        y(i, j) = func(x1(i, j), x2(i, j))\n+        j += 1\n+      }\n+      i += 1\n+    }\n+  }\n+\n+}\n+\n+/**\n+ * Implements SoftMax activation function\n+ */\n+private[ann] class SoftmaxFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    var j = 0\n+    // find max value to make sure later that exponent is computable\n+    while (j < x.cols) {\n+      var i = 0\n+      var max = Double.MinValue\n+      while (i < x.rows) {\n+        if (x(i, j) > max) {\n+          max = x(i, j)\n+        }\n+        i += 1\n+      }\n+      var sum = 0.0\n+      i = 0\n+      while (i < x.rows) {\n+        val res = Math.exp(x(i, j) - max)\n+        y(i, j) = res\n+        sum += res\n+        i += 1\n+      }\n+      i = 0\n+      while (i < x.rows) {\n+        y(i, j) /= sum\n+        i += 1\n+      }\n+      j += 1\n+    }\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    throw new UnsupportedOperationException(\"Sorry, squared error is not defined for SoftMax.\")\n+  }\n+}\n+\n+/**\n+ * Implements Sigmoid activation function\n+ */\n+private[ann] class SigmoidFunction extends ActivationFunction {\n+  override def eval(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def s(z: Double): Double = Bsigmoid(z)\n+    ActivationFunction(x, y, s)\n+  }\n+\n+  override def crossEntropy(output: BDM[Double], target: BDM[Double],\n+                            result: BDM[Double]): Double = {\n+    def m(o: Double, t: Double): Double = o - t\n+    ActivationFunction(output, target, result, m)\n+    -Bsum( target :* Blog(output)) / output.cols\n+  }\n+\n+  override def derivative(x: BDM[Double], y: BDM[Double]): Unit = {\n+    def sd(z: Double): Double = (1 - z) * z\n+    ActivationFunction(x, y, sd)\n+  }\n+\n+  override def squared(output: BDM[Double], target: BDM[Double], result: BDM[Double]): Double = {\n+    // TODO: make it readable\n+    def m(o: Double, t: Double): Double = (o - t)\n+    ActivationFunction(output, target, result, m)\n+    val e = Bsum(result :* result) / 2 / output.cols\n+    def m2(x: Double, o: Double) = x * (o - o * o)\n+    ActivationFunction(result, output, result, m2)\n+    e\n+  }\n+}\n+\n+/**\n+ * Functional layer properties, y = f(x)\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayer (val activationFunction: ActivationFunction) extends Layer {\n+  override def getInstance(weights: Vector, position: Int): LayerModel = getInstance(0L)\n+\n+  override def getInstance(seed: Long): LayerModel =\n+    FunctionalLayerModel(this)\n+}\n+\n+/**\n+ * Functional layer model. Holds no weights.\n+ * @param activationFunction activation function\n+ */\n+private[ann] class FunctionalLayerModel private (val activationFunction: ActivationFunction\n+                                     ) extends LayerModel {\n+  val size = 0\n+\n+  private var f: BDM[Double] = null\n+  private var d: BDM[Double] = null\n+  private var e: BDM[Double] = null\n+  private lazy val dg = new Array[Double](0)\n+\n+  override def eval(data: BDM[Double]): BDM[Double] = {\n+    if (f == null || f.cols != data.cols) f = new BDM[Double](data.rows, data.cols)\n+    activationFunction.eval(data, f)\n+    f\n+  }\n+\n+  override def prevDelta(nextDelta: BDM[Double], input: BDM[Double]): BDM[Double] = {\n+    if (d == null || d.cols != nextDelta.cols) d = new BDM[Double](nextDelta.rows, nextDelta.cols)\n+    activationFunction.derivative(input, d)\n+    d :*= nextDelta\n+    d\n+  }\n+\n+  override def grad(delta: BDM[Double], input: BDM[Double]): Array[Double] = dg\n+\n+  override def weights(): Vector = Vectors.dense(new Array[Double](0))\n+\n+  def crossEntropy(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.crossEntropy(output, target, e)\n+    (e, error)\n+  }\n+\n+  def squared(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    if (e == null || e.cols != output.cols) e = new BDM[Double](output.rows, output.cols)\n+    val error = activationFunction.squared(output, target, e)\n+    (e, error)\n+  }\n+\n+  def error(output: BDM[Double], target: BDM[Double]): (BDM[Double], Double) = {\n+    // TODO: allow user pick error\n+    activationFunction match {\n+      case sigmoid: SigmoidFunction => squared(output, target)\n+      case softmax: SoftmaxFunction => crossEntropy(output, target)\n+    }\n+  }\n+}\n+\n+/**\n+ * Fabric of functional layer models\n+ */\n+private[ann] object FunctionalLayerModel {\n+  def apply(layer: FunctionalLayer): FunctionalLayerModel =\n+    new FunctionalLayerModel(layer.activationFunction)\n+}\n+\n+/**\n+ * Trait for the artificial neural network (ANN) topology properties\n+ */\n+private[ann] trait Topology extends Serializable{\n+  def getInstance(weights: Vector): TopologyModel\n+  def getInstance(seed: Long): TopologyModel\n+}\n+\n+/**\n+ * Trait for ANN topology model\n+ */\n+private[ann] trait TopologyModel extends Serializable{\n+  /**\n+   * Forward propagation\n+   * @param data input data\n+   * @return array of outputs for each of the layers\n+   */\n+  def forward(data: BDM[Double]): Array[BDM[Double]]\n+\n+  /**\n+   * Prediction of the model\n+   * @param data input data\n+   * @return prediction\n+   */\n+  def predict(data: Vector): Vector\n+\n+  /**\n+   * Computes gradient for the network\n+   * @param data input data\n+   * @param target target output\n+   * @param cumGradient cumulative gradient\n+   * @param blockSize block size\n+   * @return error\n+   */\n+  def computeGradient(data: BDM[Double], target: BDM[Double], cumGradient: Vector,\n+                      blockSize: Int): Double\n+\n+  /**\n+   * Returns the weights of the ANN\n+   * @return weights\n+   */\n+  def weights(): Vector\n+}\n+\n+/**\n+ * Feed forward ANN\n+ * @param layers\n+ */\n+class FeedForwardTopology private(val layers: Array[Layer]) extends Topology {"
  }],
  "prId": 7621
}]