[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`ArrayBuilder` is better than `ArrayBuffer` for `Int`. The latter is not specialized for `Int` and hence has boxing/unboxing overhead. But here, we may want to consider `List` to avoid re-allocating buffers. The cost is that we have to inverse the list (maybe not), e.g., https://github.com/apache/spark/blob/master/mllib/src/main/scala/org/apache/spark/mllib/fpm/FPTree.scala#L72.\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T16:57:41Z",
    "diffHunk": "@@ -42,22 +44,20 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n   def run(\n       minCount: Long,\n       maxPatternLength: Int,\n-      prefix: Array[Int],\n-      projectedDatabase: Array[Array[Int]]): Array[(Array[Int], Long)] = {\n+      prefix: ArrayBuffer[Int],"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "OK\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T18:58:52Z",
    "diffHunk": "@@ -42,22 +44,20 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n   def run(\n       minCount: Long,\n       maxPatternLength: Int,\n-      prefix: Array[Int],\n-      projectedDatabase: Array[Array[Int]]): Array[(Array[Int], Long)] = {\n+      prefix: ArrayBuffer[Int],"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "organize imports\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T16:57:59Z",
    "diffHunk": "@@ -20,6 +20,8 @@ package org.apache.spark.mllib.fpm\n import org.apache.spark.Logging\n import org.apache.spark.annotation.Experimental\n \n+import scala.collection.mutable.ArrayBuffer"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "OK\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T18:58:54Z",
    "diffHunk": "@@ -20,6 +20,8 @@ package org.apache.spark.mllib.fpm\n import org.apache.spark.Logging\n import org.apache.spark.annotation.Experimental\n \n+import scala.collection.mutable.ArrayBuffer"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We should do projection one by one. Pseudocode:\n\n``` scala\nfrequentItems.flatMap { p =>\n  val projected = project(database, p) // returns Array[Array[Int]]\n  getFrequentPatterns(projected, minCount) // returns Iterator[(List[Int], Long)]\n    .map { case (pattern, count) =>\n      (p :: pattern, count)\n    }\n}\n```\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T17:03:36Z",
    "diffHunk": "@@ -86,28 +86,30 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n       minCount: Long,\n       sequences: Array[Array[Int]]): Array[(Int, Long)] = {\n     sequences.flatMap(_.distinct)\n-      .groupBy(x => x)\n-      .mapValues(_.length.toLong)\n+      .foldRight(Map[Int, Long]().withDefaultValue(0L)) { case (item, ctr) =>\n+        ctr + (item -> (ctr(item) + 1))\n+      }\n       .filter(_._2 >= minCount)\n       .toArray\n   }\n \n   /**\n    * Get the frequent prefixes' projected database.\n-   * @param prePrefix the frequent prefixes' prefix\n-   * @param frequentPrefixes frequent prefixes\n-   * @param sequences sequences data\n-   * @return prefixes and projected database\n+   * @param prefix the frequent prefixes' prefix\n+   * @param frequentPrefixes frequent next prefixes\n+   * @param projDB projected database for given prefix\n+   * @return extensions of prefix by one item and corresponding projected databases\n    */\n   private def getPatternAndProjectedDatabase(\n-      prePrefix: Array[Int],\n+      prefix: ArrayBuffer[Int],\n       frequentPrefixes: Array[Int],\n-      sequences: Array[Array[Int]]): Array[(Array[Int], Array[Array[Int]])] = {\n-    val filteredProjectedDatabase = sequences\n-      .map(x => x.filter(frequentPrefixes.contains(_)))\n-    frequentPrefixes.map { x =>\n-      val sub = filteredProjectedDatabase.map(y => getSuffix(x, y)).filter(_.nonEmpty)\n-      (prePrefix ++ Array(x), sub)\n+      projDB: Array[Array[Int]]): Array[(ArrayBuffer[Int], Array[Array[Int]])] = {"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "OK\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-13T21:51:02Z",
    "diffHunk": "@@ -86,28 +86,30 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n       minCount: Long,\n       sequences: Array[Array[Int]]): Array[(Int, Long)] = {\n     sequences.flatMap(_.distinct)\n-      .groupBy(x => x)\n-      .mapValues(_.length.toLong)\n+      .foldRight(Map[Int, Long]().withDefaultValue(0L)) { case (item, ctr) =>\n+        ctr + (item -> (ctr(item) + 1))\n+      }\n       .filter(_._2 >= minCount)\n       .toArray\n   }\n \n   /**\n    * Get the frequent prefixes' projected database.\n-   * @param prePrefix the frequent prefixes' prefix\n-   * @param frequentPrefixes frequent prefixes\n-   * @param sequences sequences data\n-   * @return prefixes and projected database\n+   * @param prefix the frequent prefixes' prefix\n+   * @param frequentPrefixes frequent next prefixes\n+   * @param projDB projected database for given prefix\n+   * @return extensions of prefix by one item and corresponding projected databases\n    */\n   private def getPatternAndProjectedDatabase(\n-      prePrefix: Array[Int],\n+      prefix: ArrayBuffer[Int],\n       frequentPrefixes: Array[Int],\n-      sequences: Array[Array[Int]]): Array[(Array[Int], Array[Array[Int]])] = {\n-    val filteredProjectedDatabase = sequences\n-      .map(x => x.filter(frequentPrefixes.contains(_)))\n-    frequentPrefixes.map { x =>\n-      val sub = filteredProjectedDatabase.map(y => getSuffix(x, y)).filter(_.nonEmpty)\n-      (prePrefix ++ Array(x), sub)\n+      projDB: Array[Array[Int]]): Array[(ArrayBuffer[Int], Array[Array[Int]])] = {"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`database` should be an `Array[Array[Int]]`. We need multiple access to it. The return type should be `Iterator[(List[Int], Long)]`.\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-14T19:01:35Z",
    "diffHunk": "@@ -42,33 +42,36 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n   def run(\n       minCount: Long,\n       maxPatternLength: Int,\n-      prefix: Array[Int],\n-      projectedDatabase: Array[Array[Int]]): Array[(Array[Int], Long)] = {\n-    val frequentPrefixAndCounts = getFreqItemAndCounts(minCount, projectedDatabase)\n-    val frequentPatternAndCounts = frequentPrefixAndCounts\n-      .map(x => (prefix ++ Array(x._1), x._2))\n-    val prefixProjectedDatabases = getPatternAndProjectedDatabase(\n-      prefix, frequentPrefixAndCounts.map(_._1), projectedDatabase)\n+      prefix: List[Int],\n+      database: Iterable[Array[Int]]): Iterator[(Array[Int], Long)] = {"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We don't need to reverse in `LocalPrefixSpan`. This happens in the distributed `PrefixSpan`.\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-14T19:01:37Z",
    "diffHunk": "@@ -42,33 +42,36 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n   def run(\n       minCount: Long,\n       maxPatternLength: Int,\n-      prefix: Array[Int],\n-      projectedDatabase: Array[Array[Int]]): Array[(Array[Int], Long)] = {\n-    val frequentPrefixAndCounts = getFreqItemAndCounts(minCount, projectedDatabase)\n-    val frequentPatternAndCounts = frequentPrefixAndCounts\n-      .map(x => (prefix ++ Array(x._1), x._2))\n-    val prefixProjectedDatabases = getPatternAndProjectedDatabase(\n-      prefix, frequentPrefixAndCounts.map(_._1), projectedDatabase)\n+      prefix: List[Int],\n+      database: Iterable[Array[Int]]): Iterator[(Array[Int], Long)] = {\n \n-    val continueProcess = prefixProjectedDatabases.nonEmpty && prefix.length + 1 < maxPatternLength\n-    if (continueProcess) {\n-      val nextPatterns = prefixProjectedDatabases\n-        .map(x => run(minCount, maxPatternLength, x._1, x._2))\n-        .reduce(_ ++ _)\n-      frequentPatternAndCounts ++ nextPatterns\n+    if (database.isEmpty) return Iterator.empty\n+\n+    val frequentItemAndCounts = getFreqItemAndCounts(minCount, database)\n+    val frequentItems = frequentItemAndCounts.map(_._1).toSet\n+    val frequentPatternAndCounts = frequentItemAndCounts\n+      .map { case (item, count) => ((item :: prefix).reverse.toArray, count) }"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Move this to the `if` clause.\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-14T19:01:39Z",
    "diffHunk": "@@ -42,33 +42,36 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n   def run(\n       minCount: Long,\n       maxPatternLength: Int,\n-      prefix: Array[Int],\n-      projectedDatabase: Array[Array[Int]]): Array[(Array[Int], Long)] = {\n-    val frequentPrefixAndCounts = getFreqItemAndCounts(minCount, projectedDatabase)\n-    val frequentPatternAndCounts = frequentPrefixAndCounts\n-      .map(x => (prefix ++ Array(x._1), x._2))\n-    val prefixProjectedDatabases = getPatternAndProjectedDatabase(\n-      prefix, frequentPrefixAndCounts.map(_._1), projectedDatabase)\n+      prefix: List[Int],\n+      database: Iterable[Array[Int]]): Iterator[(Array[Int], Long)] = {\n \n-    val continueProcess = prefixProjectedDatabases.nonEmpty && prefix.length + 1 < maxPatternLength\n-    if (continueProcess) {\n-      val nextPatterns = prefixProjectedDatabases\n-        .map(x => run(minCount, maxPatternLength, x._1, x._2))\n-        .reduce(_ ++ _)\n-      frequentPatternAndCounts ++ nextPatterns\n+    if (database.isEmpty) return Iterator.empty\n+\n+    val frequentItemAndCounts = getFreqItemAndCounts(minCount, database)\n+    val frequentItems = frequentItemAndCounts.map(_._1).toSet\n+    val frequentPatternAndCounts = frequentItemAndCounts\n+      .map { case (item, count) => ((item :: prefix).reverse.toArray, count) }\n+\n+    val filteredProjectedDatabase = database.map(x => x.filter(frequentItems.contains(_)))"
  }],
  "prId": 7360
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Use a mutable `Map` and then `ctr(item) += 1` here.\n",
    "commit": "59db2f599915ab957e05478d81d1d73b78e50918",
    "createdAt": "2015-07-14T19:01:41Z",
    "diffHunk": "@@ -76,38 +79,25 @@ private[fpm] object LocalPrefixSpan extends Logging with Serializable {\n     }\n   }\n \n+  def project(database: Iterable[Array[Int]], prefix: Int): Iterable[Array[Int]] = {\n+    database\n+      .map(candidateSeq => getSuffix(prefix, candidateSeq))\n+      .filter(_.nonEmpty)\n+  }\n+\n   /**\n    * Generates frequent items by filtering the input data using minimal count level.\n-   * @param minCount the absolute minimum count\n-   * @param sequences sequences data\n-   * @return array of item and count pair\n+   * @param minCount the minimum count for an item to be frequent\n+   * @param database database of sequences\n+   * @return item and count pairs\n    */\n   private def getFreqItemAndCounts(\n       minCount: Long,\n-      sequences: Array[Array[Int]]): Array[(Int, Long)] = {\n-    sequences.flatMap(_.distinct)\n-      .groupBy(x => x)\n-      .mapValues(_.length.toLong)\n+      database: Iterable[Array[Int]]): Iterable[(Int, Long)] = {\n+    database.flatMap(_.distinct)\n+      .foldRight(Map[Int, Long]().withDefaultValue(0L)) { case (item, ctr) =>\n+        ctr + (item -> (ctr(item) + 1))"
  }],
  "prId": 7360
}]