[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Mention the blocks are sparse.\n",
    "commit": "4df37fe9c06a67c42557ebf9bbc6fdd451ec3493",
    "createdAt": "2015-01-29T01:11:06Z",
    "diffHunk": "@@ -98,6 +97,59 @@ class CoordinateMatrix(\n     toIndexedRowMatrix().toRowMatrix()\n   }\n \n+  /** Converts to BlockMatrix. Creates blocks of size 1024 x 1024. */\n+  def toBlockMatrix(): BlockMatrix = {\n+    toBlockMatrix(1024, 1024)\n+  }\n+\n+  /**\n+   * Converts to BlockMatrix."
  }],
  "prId": 4256
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`math.min(m - blockRowIndex * rowsPerBlock, rowsPerBlock)`\n",
    "commit": "4df37fe9c06a67c42557ebf9bbc6fdd451ec3493",
    "createdAt": "2015-01-29T01:11:08Z",
    "diffHunk": "@@ -98,6 +97,59 @@ class CoordinateMatrix(\n     toIndexedRowMatrix().toRowMatrix()\n   }\n \n+  /** Converts to BlockMatrix. Creates blocks of size 1024 x 1024. */\n+  def toBlockMatrix(): BlockMatrix = {\n+    toBlockMatrix(1024, 1024)\n+  }\n+\n+  /**\n+   * Converts to BlockMatrix.\n+   * @param rowsPerBlock The number of rows of each block. The blocks at the bottom edge may have\n+   *                     a smaller value. Must be an integer value greater than 0.\n+   * @param colsPerBlock The number of columns of each block. The blocks at the right edge may have\n+   *                     a smaller value. Must be an integer value greater than 0.\n+   * @return a `BlockMatrix`\n+   */\n+  def toBlockMatrix(rowsPerBlock: Int, colsPerBlock: Int): BlockMatrix = {\n+    require(rowsPerBlock > 0,\n+      s\"rowsPerBlock needs to be greater than 0. rowsPerBlock: $rowsPerBlock\")\n+    require(colsPerBlock > 0,\n+      s\"colsPerBlock needs to be greater than 0. colsPerBlock: $colsPerBlock\")\n+    val m = numRows()\n+    val n = numCols()\n+    val numRowBlocks = math.ceil(m.toDouble / rowsPerBlock).toInt\n+    val numColBlocks = math.ceil(n.toDouble / colsPerBlock).toInt\n+    val partitioner = GridPartitioner(numRowBlocks, numColBlocks, entries.partitions.length)\n+\n+    val blocks: RDD[((Int, Int), Matrix)] = entries.map { entry =>\n+      val blockRowIndex = (entry.i / rowsPerBlock).toInt\n+      val blockColIndex = (entry.j / colsPerBlock).toInt\n+\n+      val rowId = entry.i % rowsPerBlock\n+      val colId = entry.j % colsPerBlock\n+\n+      ((blockRowIndex, blockColIndex), (rowId.toInt, colId.toInt, entry.value))\n+    }.groupByKey(partitioner).map { case ((blockRowIndex, blockColIndex), entry) =>\n+      val effRows =\n+        if (blockRowIndex == numRowBlocks - 1) {"
  }],
  "prId": 4256
}]