[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "count can take a predicate directly, no? or am I thinking of just plain Scala\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-17T04:48:36Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count"
  }, {
    "author": {
      "login": "schmit"
    },
    "body": "I didn't know that, but upon trying, it does not seem to work in this case.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-19T00:00:47Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count"
  }],
  "prId": 160
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think int overflow will be an issue here, even though `nPos` and `nObs` are `Long`. For massive RDDs of more than about 2 billion elements this could fail. Better to make the values `Double` to be safe since they're used that way.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-17T04:50:49Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex\n+    // sum of the positive ranks\n+    val sumPosRanks = sortedPredictionsWithIndex.filter(x => (x._1)._2 > 0).map(x => x._2 + 1).sum\n+    // if there are no positive or no negative labels, the area under the curve is not defined.\n+    // Return 0 in that case.\n+    if ((nPos > 0) && (nObs > nPos)) {\n+          (sumPosRanks - nPos * (nPos + 1) / 2) / (nPos * (nObs - nPos))",
    "line": 63
  }, {
    "author": {
      "login": "schmit"
    },
    "body": "If this is true, then that's more a general problem of count instead of this implementation, isn't it? Shouldn't the implementation for count for RDD take this into account?\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-18T23:47:20Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex\n+    // sum of the positive ranks\n+    val sumPosRanks = sortedPredictionsWithIndex.filter(x => (x._1)._2 > 0).map(x => x._2 + 1).sum\n+    // if there are no positive or no negative labels, the area under the curve is not defined.\n+    // Return 0 in that case.\n+    if ((nPos > 0) && (nObs > nPos)) {\n+          (sumPosRanks - nPos * (nPos + 1) / 2) / (nPos * (nObs - nPos))",
    "line": 63
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "No I mean that this expression will be incorrect well before the `Long` values themselves overflow:\n\n```\nscala> val nPos = 4000000000L\nnPos: Long = 4000000000\nscala> nPos * (nPos + 1) / 2\nres1: Long = -1223372034854775808\n```\n\n(Should have said that the problem occurs a little past 3B, not 2B). Sure the 64-bit integer overflows eventually but not worried about quintillions of elements just yet! but having a few billion elements is quite possible.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-19T01:26:43Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex\n+    // sum of the positive ranks\n+    val sumPosRanks = sortedPredictionsWithIndex.filter(x => (x._1)._2 > 0).map(x => x._2 + 1).sum\n+    // if there are no positive or no negative labels, the area under the curve is not defined.\n+    // Return 0 in that case.\n+    if ((nPos > 0) && (nObs > nPos)) {\n+          (sumPosRanks - nPos * (nPos + 1) / 2) / (nPos * (nObs - nPos))",
    "line": 63
  }, {
    "author": {
      "login": "schmit"
    },
    "body": "I see, thanks! Fixed it.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-19T01:36:40Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex\n+    // sum of the positive ranks\n+    val sumPosRanks = sortedPredictionsWithIndex.filter(x => (x._1)._2 > 0).map(x => x._2 + 1).sum\n+    // if there are no positive or no negative labels, the area under the curve is not defined.\n+    // Return 0 in that case.\n+    if ((nPos > 0) && (nObs > nPos)) {\n+          (sumPosRanks - nPos * (nPos + 1) / 2) / (nPos * (nObs - nPos))",
    "line": 63
  }],
  "prId": 160
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Unless I'm misreading, in this line, positive is defined as \"> 0\" but it's defined as \"== 1\" above. The former might be the safer definition.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-19T01:47:08Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count.toDouble\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count.toDouble\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex\n+    // sum of the positive ranks\n+    val sumPosRanks = sortedPredictionsWithIndex.filter(x => (x._1)._2 > 0).map(x => x._2 + 1).sum"
  }],
  "prId": 160
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Final comment I promise. There's an interesting question of what to do about ties in the keys. If all of my predictions are 0/1 for example, then the ranking of 0/1 true labels within those predictions ends up being pretty arbitrary, and so does the AUC. I don't think this formula deals with that case, and you could argue it's a degenerate case or argue it's actually somewhat common. To make it at least deterministic, maybe a secondary sort by true label? I don't know whether to be optimistic or pessimistic, and sort the positives first or last. Tough one.\n",
    "commit": "1d0d68c93ecab163f7988d593845ef4c0b42b7c1",
    "createdAt": "2014-03-19T01:51:17Z",
    "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.classification\n+\n+\n+import org.apache.spark.SparkContext\n+import org.apache.spark.SparkContext._\n+import org.apache.spark.mllib.regression._\n+import org.apache.spark.rdd.RDD\n+\n+trait BinaryClassificationModel extends ClassificationModel {\n+  /**\n+   * Return true labels and prediction scores in an RDD\n+   *\n+   * @param input RDD with labelled points to use for the evaluation\n+   * @return RDD[(Double, Double)] Contains a pair of (label, probability)\n+   *         where probability is the probability the model assigns to\n+   *         the label being 1.\n+   */ \n+  def scoreForEval(input: RDD[LabeledPoint]) : RDD[(Double, Double)] = {\n+    val predictionAndLabel = input.map { point =>\n+        val scores = score(point.features)\n+        (scores, point.label)\n+    }\n+    predictionAndLabel\n+  }\n+\n+  /**\n+   * Evaluate the performance of the model using the score assigned by the model\n+   * to observations and the true label.\n+   * Returns the Receiver operating characteristic area under the curve.\n+   * Note that we consider the prediction of a label to be 0 if the score is less than 0,\n+   * and we predict label 1 if the score is larger than 0.\n+   *\n+   * @param predictionAndLabel RDD with (score by model, true label)\n+   * @return Double Area under curve of ROC\n+   */ \n+  def areaUnderROC(predictionAndLabel: RDD[(Double, Double)]) : Double = {\n+    val nObs = predictionAndLabel.count.toDouble\n+    val nPos = predictionAndLabel.filter(x => x._2 == 1.0).count.toDouble\n+    // sort according to the predicted score and add indices\n+    val sortedPredictionsWithIndex = predictionAndLabel.sortByKey(true).zipWithIndex"
  }],
  "prId": 160
}]