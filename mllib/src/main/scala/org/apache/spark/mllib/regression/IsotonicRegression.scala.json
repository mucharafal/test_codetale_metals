[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "There are three Doubles in the input. It is necessary to explain what they are. Essentially, this is a lookup table. To make it efficient, we should store the ordered bounds in `Array[Double]` and the mapped values in another `Array[Double]`. For example,\n\n```\n[-inf, 1.0) -> [0.5]\n[1.0, 2.0) -> [1.5]\n[3.0, 4.0) -> [3.5]\n[4.0, inf) -> [4.5]\n```\n\ncan be stored as [1.0, 2.0, 3.0, 4.0] and [0.5, 1.5, 3.5, 4.5]. Then you can use binary search to find the insert index and then the mapped value quickly.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:28Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature."
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "Binary search naive tests show 10000x speedup for 100000 elements on my machine. Should also have less memory usage (i.e. http://stackoverflow.com/questions/6916843/scala-tuple-memory-overhead). I have still left `labels` as val to be directly accessible. I assume we do not want that exposed in the API?\n\nI am however not confident if the results of PAV are piecewise constant (or piecewise linear, ..). And therefore if  [1.0, 2.0] and [1.0, 2.0] should be 1 or for example 1.5 for input 1.5. I can not find a reliable source where PAV would be defined continuous function.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-23T01:16:35Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature."
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The output should be `JavaDoubleRDD` and you can use type casting instead of map:\n\n```\nJavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]])\n```\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:30Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "See my comments on building a lookup table and use binary search to find insert index.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:31Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We can do this later when we have multiple implementations for isotonic regression. We try to ask users to use builder pattern instead of static methods to train models, because the latter approach is hard to maintain. For this PR, it might be easier to expose `PoolAdjacentViolators` as `IsotonicRegression` and remove this trait.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:33Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "Trait `IsotonicRegressionAlgorighm` deleted. Do we want to keep `object IsotonicRegression` though?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-23T01:18:13Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Shall we cite the paper, which the implementation is based on?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:35Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "Apologies, updated the PR description with references. \n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T21:55:11Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Note that `for` in Scala is slower than `while`. If this is an inner loop, we should use `while`.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:38Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Is there a way to compress the storage?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:40Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "We could potentially use three `Array[Double]` instead of `Array[(Double, Double, Double)]`. That should save some storage. The algorithm does not use features, but we still need them for the current prediction functions. Other than this I will look into it and do some profiling, but I am afraid there may be no way to efficiently compress the data.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-23T01:21:52Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "We could merge those lines into one line.\n\n```\nval monotonicityConstraintHolds: (Double, Double) => Boolean =\n  (x, y) => if (isotonic) x <=y else x >= y\n```\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:41Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+      }\n+    }\n+\n+    val isotonicConstraint: (Double, Double) => Boolean = (x, y) => x <= y\n+    val antitonicConstraint: (Double, Double) => Boolean = (x, y) => x >= y\n+\n+    def monotonicityConstraint(isotonic: Boolean) =\n+      if(isotonic) isotonicConstraint else antitonicConstraint\n+\n+    val monotonicityConstraintHolds = monotonicityConstraint(isotonic)"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "Of course. I was trying to be as explicit as possible for reader's clarity. Happy to change that.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-23T01:22:49Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+      }\n+    }\n+\n+    val isotonicConstraint: (Double, Double) => Boolean = (x, y) => x <= y\n+    val antitonicConstraint: (Double, Double) => Boolean = (x, y) => x >= y\n+\n+    def monotonicityConstraint(isotonic: Boolean) =\n+      if(isotonic) isotonicConstraint else antitonicConstraint\n+\n+    val monotonicityConstraintHolds = monotonicityConstraint(isotonic)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "remove this empty line\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:43Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+      }\n+    }\n+\n+    val isotonicConstraint: (Double, Double) => Boolean = (x, y) => x <= y\n+    val antitonicConstraint: (Double, Double) => Boolean = (x, y) => x >= y\n+\n+    def monotonicityConstraint(isotonic: Boolean) =\n+      if(isotonic) isotonicConstraint else antitonicConstraint\n+\n+    val monotonicityConstraintHolds = monotonicityConstraint(isotonic)\n+\n+    var i = 0\n+"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "space before `(`\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-21T02:55:45Z",
    "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import org.apache.spark.api.java.{JavaRDD, JavaPairRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param predictions Weights computed for every feature.\n+ * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+ */\n+class IsotonicRegressionModel (\n+    val predictions: Seq[(Double, Double, Double)],\n+    val isotonic: Boolean)\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaRDD[java.lang.Double] =\n+    testData.rdd.map(_.doubleValue()).map(predict).map(new java.lang.Double(_))\n+\n+  /**\n+   * Predict a single label\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double =\n+    // Take the highest of data points smaller than our feature or data point with lowest feature\n+    (predictions.head +: predictions.filter(y => y._2 <= testData)).last._1\n+}\n+\n+/**\n+ * Base representing algorithm for isotonic regression\n+ */\n+trait IsotonicRegressionAlgorithm\n+  extends Serializable {\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel\n+}\n+\n+/**\n+ * Parallel pool adjacent violators algorithm for monotone regression\n+ */\n+class PoolAdjacentViolators private [mllib]\n+  extends IsotonicRegressionAlgorithm {\n+\n+  override def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  override protected def createModel(\n+      predictions: Seq[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegressionModel(predictions, isotonic)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators in previously processed\n+   * data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      for(i <- start to end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+      }\n+    }\n+\n+    val isotonicConstraint: (Double, Double) => Boolean = (x, y) => x <= y\n+    val antitonicConstraint: (Double, Double) => Boolean = (x, y) => x >= y\n+\n+    def monotonicityConstraint(isotonic: Boolean) =\n+      if(isotonic) isotonicConstraint else antitonicConstraint\n+\n+    val monotonicityConstraintHolds = monotonicityConstraint(isotonic)\n+\n+    var i = 0\n+\n+    while(i < in.length) {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "\"Isotonic\" -> \"isotonic\"\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:32Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Need to be more specific about `features` and `labels`. I would rename `features` to `boundaries` and mention that this is monotonic, and rename `labels` to `predictions` because this is not the original labels. The solution to an isotonic regression problem is piecewise linear. The model only needs to store the boundaries and the computed predictions. We can use linear interpolation for values fall between boundaries. For example, if\n\n```\nboundaries = [1, 2, 4, 5]\npredictions = [1.0, 3.0, 3.0, 4.0]\n```\n\nthen\n\n```\npredict(1.5) == 2.0\npredict(3.5) == 3.0\n```\n\nWe should also document the behavior on the semi-open segments, e.g., `predict(-10) == ?`. I suggest using the smallest prediction here, i.e., `predict(-10) = 1.0`.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:34Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features."
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It may be worth validating that `features` is ordered.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:37Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "I have added validations for `features` (now `boundaries`) and `labels` (now `predictions`) to be ordered and for `boundaries` and `predictions` to have the same length.\n\nCould not find an existing solution for order validation, so used the fastest available (see https://groups.google.com/forum/#!topic/scala-user/oo4nuA_3U7Q), because genericity was not required. \n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-30T12:26:54Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`JavaRDD[java.lang.Double]` -> `JavaDoubleRDD`\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:38Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD ="
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`result` -> `insertIndex`\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:40Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "There are 4 cases:\n1. hit a boundary -> return the corresponding prediction directly\n2. fall between boundaries -> linear interpolation (Note that a special case is singularity, where two boundaries are the same but their predictions are different. We can set manual rules for this case and document the behavior.)\n3. smaller than the smallest boundary -> return predictions(0)\n4. larger than the largest boundary -> return predictions.last\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:42Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "True. All of them were covered in the previous version of code (4 was the same as 2, because the function was treated as piecewise constant so we simply used the closest previous value). Refactored to be treated as piecewise linear function. \n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-30T12:19:17Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "Case 2 between boundaries now uses linear interpolation. One option was to use `breeze.interpolation.LinearInterpolator`, but since this is a simple case the naive solution I used makes the predict function ~5-20 times faster in my tests.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-30T12:30:35Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {"
  }, {
    "author": {
      "login": "zapletal-martin"
    },
    "body": "As for the special singularity case I believe this requires further considerations. Previously we just sorted the input to PAV by feature and therefore order of multiple data points with the same feature was undefined.\n\nConsider a case where features are 1, 2, 2, 3 and labels are in first case 1, 4, 2, 5 and in second case 1, 2, 4, 5. For first case the result of PAV was 1, 3, 3, 5 but in second case 1, 2, 4, 5.\n\nSimilarly for `IsotonicRegressionModel` with boundaries 1, 2, 2, 3 and predictions in first case 1, 4, 2, 5 and in second case 1, 2, 4, 5. The first model returned predict(1.5)=2.5, predict(2.5)=3.5, but the second would return 1.5 and 4.5 respectively for the same input values.\n\nThe solution I would suggest and which I implemented would be to sort input by labels if features are equal. The same would be true for the model. Therefore both PAV and the predictions of values between boundaries would be deterministic. The predictions for the boundary with multiple values would remain non-deterministic (based on `Java.util.Arrays.binarySearch()` which in this case also returns one of the correct results, but does not specify which).\n\nAnother option would be to sort the input exactly the opposite. I.e. first by feature asc and then by labels desc (for isotonic case). This would cause PAV to treat all labels with the same value of feature as violators and would assign average to all of them. \n\nI do not think I have seen this case mentioned anywhere in literature so I believe we can propose the solution we think is correct.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-30T13:15:47Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Cite the paper. Use `.` at the end of each sentence.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:44Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "merge this line with the one above\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:45Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The default argument value is not Java compatible and we don't use this kind of API in `spark.mllib`. The class `IsotonicRegression` should have a parameter called `isotonic`, similar to `k` in `KMeans`. The user code should look like:\n\n```\nval ir = new IsotonicRegression()\n  .setIsotonic(false)\nval irModel = ir.run(input)\n```\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:47Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "We can also set `isotonic` in the constructor, similar to `KMeans`.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:16:03Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Not clear about what `(Double, Double, Double)` means.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:51Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm."
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If the third parameter is not used, maybe we should remove it from the API.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:52Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Add `.` at the end. Cite the paper.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:54Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "typo?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:55Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`in` -> `input`?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:56Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "What is `result`?\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:58Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "My previous comment about data compression still applies. For each pool, we only need to store the sum of labels and the sum of weights, and the prediction is the weighted average.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:14:59Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Instead of pooling `in` in-place, I recommend creating a buffer for new segments for data compression.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:15:01Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+        i = i + 1\n+      }\n+    }\n+\n+    val monotonicityConstraintHolds: (Double, Double) => Boolean =\n+      (x, y) => if (isotonic) x <= y else x >= y\n+\n+    var i = 0\n+    while (i < in.length) {\n+      var j = i\n+\n+      // Find monotonicity violating sequence, if any\n+      while (j < in.length - 1 && !monotonicityConstraintHolds(in(j)._1, in(j + 1)._1)) {\n+        j = j + 1\n+      }\n+\n+      // If monotonicity was not violated, move to next data point\n+      if (i == j) {\n+        i = i + 1\n+      } else {\n+        // Otherwise pool the violating sequence\n+        // And check if pooling caused monotonicity violation in previously processed points\n+        while (i >= 0 && !monotonicityConstraintHolds(in(i)._1, in(i + 1)._1)) {\n+          pool(in, i, j)"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Need to doc the input types ...\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:15:03Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+        i = i + 1\n+      }\n+    }\n+\n+    val monotonicityConstraintHolds: (Double, Double) => Boolean =\n+      (x, y) => if (isotonic) x <= y else x >= y\n+\n+    var i = 0\n+    while (i < in.length) {\n+      var j = i\n+\n+      // Find monotonicity violating sequence, if any\n+      while (j < in.length - 1 && !monotonicityConstraintHolds(in(j)._1, in(j + 1)._1)) {\n+        j = j + 1\n+      }\n+\n+      // If monotonicity was not violated, move to next data point\n+      if (i == j) {\n+        i = i + 1\n+      } else {\n+        // Otherwise pool the violating sequence\n+        // And check if pooling caused monotonicity violation in previously processed points\n+        while (i >= 0 && !monotonicityConstraintHolds(in(i)._1, in(i + 1)._1)) {\n+          pool(in, i, j)\n+          i = i - 1\n+        }\n+\n+        i = j\n+      }\n+    }\n+\n+    in\n+  }\n+\n+  /**\n+   * Performs parallel pool adjacent violators algorithm\n+   * Calls Pool adjacent violators on each partition and then again on the result\n+   *\n+   * @param testData input"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "... and the result.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:15:05Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+        i = i + 1\n+      }\n+    }\n+\n+    val monotonicityConstraintHolds: (Double, Double) => Boolean =\n+      (x, y) => if (isotonic) x <= y else x >= y\n+\n+    var i = 0\n+    while (i < in.length) {\n+      var j = i\n+\n+      // Find monotonicity violating sequence, if any\n+      while (j < in.length - 1 && !monotonicityConstraintHolds(in(j)._1, in(j + 1)._1)) {\n+        j = j + 1\n+      }\n+\n+      // If monotonicity was not violated, move to next data point\n+      if (i == j) {\n+        i = i + 1\n+      } else {\n+        // Otherwise pool the violating sequence\n+        // And check if pooling caused monotonicity violation in previously processed points\n+        while (i >= 0 && !monotonicityConstraintHolds(in(i)._1, in(i + 1)._1)) {\n+          pool(in, i, j)\n+          i = i - 1\n+        }\n+\n+        i = j\n+      }\n+    }\n+\n+    in\n+  }\n+\n+  /**\n+   * Performs parallel pool adjacent violators algorithm\n+   * Calls Pool adjacent violators on each partition and then again on the result\n+   *\n+   * @param testData input\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return result"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Same Java compatibility problem. We need to overload `train` to make it compatible with Java.\n\nminor: I would like to remove the static train methods completely for easy maintenance.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:15:07Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+        i = i + 1\n+      }\n+    }\n+\n+    val monotonicityConstraintHolds: (Double, Double) => Boolean =\n+      (x, y) => if (isotonic) x <= y else x >= y\n+\n+    var i = 0\n+    while (i < in.length) {\n+      var j = i\n+\n+      // Find monotonicity violating sequence, if any\n+      while (j < in.length - 1 && !monotonicityConstraintHolds(in(j)._1, in(j + 1)._1)) {\n+        j = j + 1\n+      }\n+\n+      // If monotonicity was not violated, move to next data point\n+      if (i == j) {\n+        i = i + 1\n+      } else {\n+        // Otherwise pool the violating sequence\n+        // And check if pooling caused monotonicity violation in previously processed points\n+        while (i >= 0 && !monotonicityConstraintHolds(in(i)._1, in(i + 1)._1)) {\n+          pool(in, i, j)\n+          i = i - 1\n+        }\n+\n+        i = j\n+      }\n+    }\n+\n+    in\n+  }\n+\n+  /**\n+   * Performs parallel pool adjacent violators algorithm\n+   * Calls Pool adjacent violators on each partition and then again on the result\n+   *\n+   * @param testData input\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return result\n+   */\n+  private def parallelPoolAdjacentViolators(\n+      testData: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    val parallelStepResult = testData\n+      .sortBy(_._2)\n+      .mapPartitions(it => poolAdjacentViolators(it.toArray, isotonic).toIterator)\n+\n+    poolAdjacentViolators(parallelStepResult.collect(), isotonic)\n+  }\n+}\n+\n+/**\n+ * Top-level methods for monotone regression (either isotonic or antitonic).\n+ */\n+object IsotonicRegression {\n+\n+  /**\n+   * Train a monotone regression model given an RDD of (label, feature, weight).\n+   * Label is the dependent y value\n+   * Weight of the data point is the number of measurements. Default is 1\n+   *\n+   * @param input RDD of (label, feature, weight).\n+   *              Each point describes a row of the data\n+   *              matrix A as well as the corresponding right hand side label y\n+   *              and weight as number of measurements\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   */\n+  def train(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {"
  }],
  "prId": 3519
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This should fit in a single line.\n",
    "commit": "5a54ea45334b9ef1273a7303be0ef20b97896c92",
    "createdAt": "2015-01-27T09:15:08Z",
    "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.regression\n+\n+import java.io.Serializable\n+import java.util.Arrays.binarySearch\n+\n+import org.apache.spark.api.java.{JavaDoubleRDD, JavaRDD}\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Regression model for Isotonic regression\n+ *\n+ * @param features Array of features.\n+ * @param labels Array of labels associated to the features at the same index.\n+ */\n+class IsotonicRegressionModel (\n+    features: Array[Double],\n+    val labels: Array[Double])\n+  extends Serializable {\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: RDD[Double]): RDD[Double] =\n+    testData.map(predict)\n+\n+  /**\n+   * Predict labels for provided features\n+   * Using a piecewise constant function\n+   *\n+   * @param testData features to be labeled\n+   * @return predicted labels\n+   */\n+  def predict(testData: JavaRDD[java.lang.Double]): JavaDoubleRDD =\n+    JavaDoubleRDD.fromRDD(predict(testData.rdd.asInstanceOf[RDD[Double]]))\n+\n+  /**\n+   * Predict a single label\n+   * Using a piecewise constant function\n+   *\n+   * @param testData feature to be labeled\n+   * @return predicted label\n+   */\n+  def predict(testData: Double): Double = {\n+    val result = binarySearch(features, testData)\n+\n+    val index =\n+      if (result == -1) {\n+        0\n+      } else if (result < 0) {\n+        -result - 2\n+      } else {\n+        result\n+      }\n+\n+    labels(index)\n+  }\n+}\n+\n+/**\n+ * Isotonic regression\n+ * Currently implemented using parallel pool adjacent violators algorithm\n+ */\n+class IsotonicRegression\n+  extends Serializable {\n+\n+  /**\n+   * Run algorithm to obtain isotonic regression model\n+   *\n+   * @param input (label, feature, weight)\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  def run(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    createModel(\n+      parallelPoolAdjacentViolators(input, isotonic),\n+      isotonic)\n+  }\n+\n+  /**\n+   * Creates isotonic regression model with given parameters\n+   *\n+   * @param predictions labels estimated using isotonic regression algorithm.\n+   *                    Used for predictions on new data points.\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return isotonic regression model\n+   */\n+  protected def createModel(\n+      predictions: Array[(Double, Double, Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+\n+    val labels = predictions.map(_._1)\n+    val features = predictions.map(_._2)\n+\n+    new IsotonicRegressionModel(features, labels)\n+  }\n+\n+  /**\n+   * Performs a pool adjacent violators algorithm (PAVA)\n+   * Uses approach with single processing of data where violators\n+   * in previously processed data created by pooling are fixed immediatelly.\n+   * Uses optimization of discovering monotonicity violating sequences (blocks)\n+   * Method in situ mutates input array\n+   *\n+   * @param in input data\n+   * @param isotonic asc or desc\n+   * @return result\n+   */\n+  private def poolAdjacentViolators(\n+      in: Array[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    // Pools sub array within given bounds assigning weighted average value to all elements\n+    def pool(in: Array[(Double, Double, Double)], start: Int, end: Int): Unit = {\n+      val poolSubArray = in.slice(start, end + 1)\n+\n+      val weightedSum = poolSubArray.map(lp => lp._1 * lp._3).sum\n+      val weight = poolSubArray.map(_._3).sum\n+\n+      var i = start\n+      while (i <= end) {\n+        in(i) = (weightedSum / weight, in(i)._2, in(i)._3)\n+        i = i + 1\n+      }\n+    }\n+\n+    val monotonicityConstraintHolds: (Double, Double) => Boolean =\n+      (x, y) => if (isotonic) x <= y else x >= y\n+\n+    var i = 0\n+    while (i < in.length) {\n+      var j = i\n+\n+      // Find monotonicity violating sequence, if any\n+      while (j < in.length - 1 && !monotonicityConstraintHolds(in(j)._1, in(j + 1)._1)) {\n+        j = j + 1\n+      }\n+\n+      // If monotonicity was not violated, move to next data point\n+      if (i == j) {\n+        i = i + 1\n+      } else {\n+        // Otherwise pool the violating sequence\n+        // And check if pooling caused monotonicity violation in previously processed points\n+        while (i >= 0 && !monotonicityConstraintHolds(in(i)._1, in(i + 1)._1)) {\n+          pool(in, i, j)\n+          i = i - 1\n+        }\n+\n+        i = j\n+      }\n+    }\n+\n+    in\n+  }\n+\n+  /**\n+   * Performs parallel pool adjacent violators algorithm\n+   * Calls Pool adjacent violators on each partition and then again on the result\n+   *\n+   * @param testData input\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return result\n+   */\n+  private def parallelPoolAdjacentViolators(\n+      testData: RDD[(Double, Double, Double)],\n+      isotonic: Boolean): Array[(Double, Double, Double)] = {\n+\n+    val parallelStepResult = testData\n+      .sortBy(_._2)\n+      .mapPartitions(it => poolAdjacentViolators(it.toArray, isotonic).toIterator)\n+\n+    poolAdjacentViolators(parallelStepResult.collect(), isotonic)\n+  }\n+}\n+\n+/**\n+ * Top-level methods for monotone regression (either isotonic or antitonic).\n+ */\n+object IsotonicRegression {\n+\n+  /**\n+   * Train a monotone regression model given an RDD of (label, feature, weight).\n+   * Label is the dependent y value\n+   * Weight of the data point is the number of measurements. Default is 1\n+   *\n+   * @param input RDD of (label, feature, weight).\n+   *              Each point describes a row of the data\n+   *              matrix A as well as the corresponding right hand side label y\n+   *              and weight as number of measurements\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   */\n+  def train(\n+      input: RDD[(Double, Double, Double)],\n+      isotonic: Boolean = true): IsotonicRegressionModel = {\n+    new IsotonicRegression().run(input, isotonic)\n+  }\n+\n+  /**\n+   * Train a monotone regression model given an RDD of (label, feature, weight).\n+   * Label is the dependent y value\n+   * Weight of the data point is the number of measurements. Default is 1\n+   *\n+   * @param input RDD of (label, feature, weight).\n+   * @param isotonic isotonic (increasing) or antitonic (decreasing) sequence\n+   * @return\n+   */\n+  def train(\n+      input: JavaRDD[(java.lang.Double, java.lang.Double, java.lang.Double)],\n+      isotonic: Boolean): IsotonicRegressionModel = {\n+    new IsotonicRegression()\n+      .run(\n+        input.rdd.asInstanceOf[RDD[(Double, Double, Double)]],"
  }],
  "prId": 3519
}]