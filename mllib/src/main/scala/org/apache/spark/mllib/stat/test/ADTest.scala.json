[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Why do you need this vs math.log()\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T10:02:18Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // math.log1p calculates ln(x + 1), so subtract 1\n+  private def ln(x: Double): Double = math.log1p(x - 1)"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Woops! I don't. I don't know why I had it in my head that math.log was base 10. Changed in latest.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T17:47:39Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // math.log1p calculates ln(x + 1), so subtract 1\n+  private def ln(x: Double): Double = math.log1p(x - 1)"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "You shouldn't throw raw Exception in general. Use `require` everywhere you need arg checking\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T10:03:08Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // math.log1p calculates ln(x + 1), so subtract 1\n+  private def ln(x: Double): Double = math.log1p(x - 1)\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+        val adjVal = 2 * prevCt * adj\n+        val adjustedStat = rawStat + adjVal\n+        val cumCt = prevCt + ct\n+        (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = - 1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+      val dist = makeDist()\n+      val initAcc = (0.0, 0.0, 0.0)\n+      val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+        val y = dist.cdf(v)\n+        val a = ln(y)\n+        val b = ln(1 - y)\n+        val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+        val adjConstant = a - b\n+        (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+      }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition.\n+   * If the user provides parameters, the distribution is initialized with those values\n+   * (note that the critical values still assume that the parameters were estimated from the data,\n+   * the ability to provide the parameters is simply a convenience to avoid recomputing them\n+   * when the user already has them available). If no parameters are provided, and the distribution\n+   * is one of [normal, exponential], then the distribution is initialized with MLE values\n+   * @param distName `String` name of distribution\n+   * @param data `RDD[Double]` sample of data to analyze (and hence to use for parameter estimation\n+   *            where possible)\n+   * @param n `Double` size of data sample\n+   * @param params `Double*` Initialization parameters for distribution\n+   * @return `() => RealDistribution` function to create distribution object\n+   */\n+  def initDist(distName: String, data: RDD[Double], n: Double, params: Array[Double])\n+    : () => ADTheoreticalDist = {\n+    distName match {\n+      case \"norm\" => {\n+        val muHat = if (params.nonEmpty) params(0) else data.mean()\n+        val sdHat = if (params.length > 1) {\n+            params(1)\n+          } else {\n+            math.sqrt(data.map(x => math.pow(x - muHat, 2)).sum() / (n - 1))\n+        }\n+        () => new ADNormal(Array(muHat, sdHat))\n+      }\n+      case \"exp\" => {\n+        val meanHat = if (params.nonEmpty) params(0) else data.mean()\n+        () => new ADExponential(Array(meanHat))\n+      }\n+      case \"gumbel\" => {\n+        if (params.length < 2) {\n+          throw new Exception(\"Gumbel does not yet support parameter estimation. \" +"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "changed all the parameter checking for distributions to use require. Should the final case _ => be replaced as well? \n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T17:47:42Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // math.log1p calculates ln(x + 1), so subtract 1\n+  private def ln(x: Double): Double = math.log1p(x - 1)\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+        val adjVal = 2 * prevCt * adj\n+        val adjustedStat = rawStat + adjVal\n+        val cumCt = prevCt + ct\n+        (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = - 1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+      val dist = makeDist()\n+      val initAcc = (0.0, 0.0, 0.0)\n+      val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+        val y = dist.cdf(v)\n+        val a = ln(y)\n+        val b = ln(1 - y)\n+        val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+        val adjConstant = a - b\n+        (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+      }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition.\n+   * If the user provides parameters, the distribution is initialized with those values\n+   * (note that the critical values still assume that the parameters were estimated from the data,\n+   * the ability to provide the parameters is simply a convenience to avoid recomputing them\n+   * when the user already has them available). If no parameters are provided, and the distribution\n+   * is one of [normal, exponential], then the distribution is initialized with MLE values\n+   * @param distName `String` name of distribution\n+   * @param data `RDD[Double]` sample of data to analyze (and hence to use for parameter estimation\n+   *            where possible)\n+   * @param n `Double` size of data sample\n+   * @param params `Double*` Initialization parameters for distribution\n+   * @return `() => RealDistribution` function to create distribution object\n+   */\n+  def initDist(distName: String, data: RDD[Double], n: Double, params: Array[Double])\n+    : () => ADTheoreticalDist = {\n+    distName match {\n+      case \"norm\" => {\n+        val muHat = if (params.nonEmpty) params(0) else data.mean()\n+        val sdHat = if (params.length > 1) {\n+            params(1)\n+          } else {\n+            math.sqrt(data.map(x => math.pow(x - muHat, 2)).sum() / (n - 1))\n+        }\n+        () => new ADNormal(Array(muHat, sdHat))\n+      }\n+      case \"exp\" => {\n+        val meanHat = if (params.nonEmpty) params(0) else data.mean()\n+        () => new ADExponential(Array(meanHat))\n+      }\n+      case \"gumbel\" => {\n+        if (params.length < 2) {\n+          throw new Exception(\"Gumbel does not yet support parameter estimation. \" +"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "nit: `- 1` -> `-1`\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T21:30:52Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+        val adjVal = 2 * prevCt * adj\n+        val adjustedStat = rawStat + adjVal\n+        val cumCt = prevCt + ct\n+        (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = - 1 * n - s / n"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "Indent this block back two spaces\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T21:31:10Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+        val adjVal = 2 * prevCt * adj"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "Indent the method body back two spaces\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-08T21:31:52Z",
    "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+        val adjVal = 2 * prevCt * adj\n+        val adjustedStat = rawStat + adjVal\n+        val cumCt = prevCt + ct\n+        (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = - 1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+      val dist = makeDist()"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Does this require including the [scipy license](https://github.com/scipy/scipy/blob/master/LICENSE.txt) somewhere? \n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:09:08Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Scipy sources various journal articles directly, so alternatively we could do that instead of sourcing scipy.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:18:15Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "Sounds good, thanks\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:26:18Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Single line for easier copy+pasting\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:10:25Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Types are unnecessary here, ditto for the other scaladocs\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:13:21Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Why do you create an `Array` and convert to `iterator`? `pResult` will have type `Double, Double, Double` here so can't we just return that?\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:15:15Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Mmm. Perhaps this is my own shortcomings in Spark/Scala understanding. I was under the impression a function passed to mapPartitions (which is what I use calcPartAD for), had to be type Iterator[T] => Iterator[U]. I also want to collect all the tuples into an array of tuples, once I have traversed each partition, so Array(mytuple).iterator seemed like the way to go. Am I wrong in my thinking here?\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:32:57Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "Nope you're right; that is the signature for `mapPartitions`. It just seems like you're doing quite a bit of unnecessary type wrapping to get what you want. I'll think about it...\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:41:08Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "Any reason for using `mapPartitions` over just a plain ol `map`?\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:45:31Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "We ended up going with mapPartitions since doing so allows us to break down the AD calculation in a way that minimizes shuffles/jobs. \n\nThe AD test requires that we sort the data sample, and then calculate the CDF at each value, the calculation then takes that along with info on that value's position in the sorted sample. \n\nSo we can sort, then zipWithIndex and then map. Or we can sort, and then zip with index within each partition using mapPartitions (avoiding a job), calculate intermediate values and then adjust these once we have collected results. \n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:51:39Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "feynmanliang"
    },
    "body": "Okay. Just FYI, the `zipWithIndex` inside of `mapPartitions` will only zip the index of each element **relative to each partition**, not the absolute index across the entire `RDD`. For example:\n\n``` scala\nimport scala.util.Random\nval data = sc.parallelize(Seq.fill(25)(Random.nextInt()), 10)\ndata.sortBy(x => x).mapPartitions(x => x.zipWithIndex).collect()\n```\n\nproduces\n\n```\nArray[(Int, Int)] = Array((-2101345861,0), (-1465303359,1), (-1234277886,2), (-1158971231,0), (-1080026649,1), (-912859730,2), (-728637520,0), (-588254609,1), (-481890458,0), (-269058105,1), (-256546274,2), (51301076,0), (137298918,1), (214124348,0), (269136061,1), (300887069,2), (849083937,0), (925931238,1), (1015501058,0), (1364061078,1), (1460523181,2), (1633655860,0), (1729517453,1), (1771674310,0), (1776717198,1))\n```\n\nwhich is not the same as\n\n``` scala\ndata.sortBy(x => x).zipWithIndex.collect()\n```\n\nwhich yields\n\n```\nArray[(Int, Long)] = Array((-2101345861,0), (-1465303359,1), (-1234277886,2), (-1158971231,3), (-1080026649,4), (-912859730,5), (-728637520,6), (-588254609,7), (-481890458,8), (-269058105,9), (-256546274,10), (51301076,11), (137298918,12), (214124348,13), (269136061,14), (300887069,15), (849083937,16), (925931238,17), (1015501058,18), (1364061078,19), (1460523181,20), (1633655860,21), (1729517453,22), (1771674310,23), (1776717198,24))\n```\n\nI'm unfamiliar with your exact algorithm so I cannot comment on correctness but if you've got that handled then this makes sense.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T22:46:38Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "@feynmanliang Yep, that is indeed the approach. Zip with the relative index, and then adjust for global. Thanks for the note though. Much appreciated.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T22:50:00Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Why is `data` a parameter if it's unused by this function?\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:17:38Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition.\n+   * The user must provide parameters to initialize the distribution (note that the critical values\n+   * assume that the parameters were estimated from the data).\n+   * @param distName `String` name of distribution\n+   * @param data `RDD[Double]` sample of data to analyze (and hence to use for parameter estimation\n+   *            where possible)\n+   * @param n `Double` size of data sample\n+   * @param params `Double*` Initialization parameters for distribution\n+   * @return `() => RealDistribution` function to create distribution object\n+   */\n+  def initDist(distName: String, data: RDD[Double], n: Double, params: Array[Double])"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Thanks, missed that when we changed it. Used to be there to estimate parameters for some of the distributions. I've actually reworked some of this code, since there is no issue now with passing the ADTheoreticalDist directly, as the math3 distributions I was using are serializable in 3.4.1. I'm cleaning up before pushing the latest version.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:20:07Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition.\n+   * The user must provide parameters to initialize the distribution (note that the critical values\n+   * assume that the parameters were estimated from the data).\n+   * @param distName `String` name of distribution\n+   * @param data `RDD[Double]` sample of data to analyze (and hence to use for parameter estimation\n+   *            where possible)\n+   * @param n `Double` size of data sample\n+   * @param params `Double*` Initialization parameters for distribution\n+   * @return `() => RealDistribution` function to create distribution object\n+   */\n+  def initDist(distName: String, data: RDD[Double], n: Double, params: Array[Double])"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Why create these thunks (`() => SomeTypes`) instead of initializing the distributions directly in `testOneSample`? The closure captured by L164's `mapPartitions` will result in the entire `ADTest` object to be serialized and sent to the executors anyways (see http://erikerlandson.github.io/blog/2015/03/31/hygienic-closures-for-scala-function-serialization/ for a good explanation on how this works).\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:20:41Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition."
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Thanks for the read! I've bookmarked this page. Initially, under math3 3.1.1 the RealDistribution was not serializable. And since I used it as a member in the various distributions, I thought these had to be instantiated \"on the other side\". I've changed this in the latest version, since as you point out, I can just have the distribution directly in testOneSample and the closure takes care of it.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-09T21:36:30Z",
    "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson Darling (AD) test, similarly to the Kolmogorov Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the Kolmogorov-Smirnov test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against.\n+ * The  AD statistic is defined as -n - s/n, where\n+ * s = sum from i=1 to n of (2i + 1)(ln(z_i) + ln(1 - z_{n+1-i})\n+ * where z_i is the CDF value of the ith observation in the sorted sample.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val oneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Sourced from\n+   * http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf\n+   * https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data `RDD[Double]` data to test for a given distribution\n+   * @param distName `String` name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return Anderson-Darling test result\n+   */\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val makeDist = initDist(distName, data, n, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, makeDist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = makeDist().getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.oneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part `Iterator[Double]` a partition of the data sample to be analyzed\n+   * @param makeDist `() => ADTheoreticalDist` a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods, used in creating 1\n+   *                object per partition\n+   * @param n `Double` the total size of the data sample\n+   * @return `Iterator[(Double, Double, Double)]` The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  def calcPartAD(part: Iterator[Double], makeDist: () => ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val dist = makeDist()\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition."
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "\"in case `params` is empty\"\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T17:39:20Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return [[org.apache.spark.mllib.stat.test.ADTestResult]]\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params.toArray)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, dist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = dist.getCVs(n)\n+    new ADTestResult(ADStat, criticalVals, NullHypothesis.OneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part a partition of the data sample to be analyzed\n+   * @param dist a function to create a class that extends the\n+   *                ADTheoreticalDist trait, which requires various methods relevant to the\n+   *                Anderson-Darling test calculation\n+   * @param n the total size of the data sample\n+   * @return The first element corresponds to the\n+   *        position-independent contribution to the AD statistic, the second is the value that must\n+   *        be scaled by the number of elements in prior partitions and the third is the number of\n+   *        elements in this partition\n+   */\n+  private def calcPartAD(part: Iterator[Double], dist: ADTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a function to produce a distribution per partition.\n+   * The user must provide parameters to initialize the distribution\n+   * @param distName name of distribution\n+   * @param params Initialization parameters for distribution\n+   * @return distribution object used to calculate CDF values\n+   */\n+  private def initDist(distName: String, params: Array[Double])\n+    : ADTheoreticalDist = {\n+    distName match {\n+      case \"norm\" => {\n+        val checkedParams = validateParams(distName, params, 2, Array(0.0, 1.0))\n+        new ADNormal(checkedParams)\n+      }\n+      case \"exp\" => {\n+        val checkedParams = validateParams(distName, params, 1, Array(1.0))\n+        new ADExponential(checkedParams)\n+      }\n+      case \"gumbel\" => {\n+        val checkedParams = validateParams(distName, params, 2, Array(0.0, 1.0))\n+        new ADGumbel(checkedParams)\n+      }\n+      case \"logistic\" => {\n+        val checkedParams = validateParams(distName, params, 2, Array(0.0, 1.0))\n+        new ADLogistic(checkedParams)\n+      }\n+      case \"weibull\" => {\n+        val checkedParams = validateParams(distName, params, 2, Array(0.0, 1.0))\n+        new ADWeibull(checkedParams)\n+      }\n+      case _ => throw new IllegalArgumentException(\n+          s\"Anderson-Darling does not currently support $distName distribution\" +\n+          \" must be one of 'norm', 'exp', 'gumbel', 'logistic', or 'weibull'\")\n+    }\n+  }\n+\n+  /**\n+   * Validate the length of parameters passed in by the user, if none are passed, return default\n+   * values\n+   * @param distName name of distribution\n+   * @param params parameters passed by user\n+   * @param reqLen the required length of the parameter array\n+   * @param defParams default alternative for the parameter in case `params` don't\n+   *                 satisfy the length condition"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "If omitted, are these actually estimated from samples (it seems like `initDist` is providing defaults for them)\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T17:44:44Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "sorry no, old comment. That used to be the case. No longer. I double checked comments in the latest, so this issues should be solved. Thanks\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T20:55:07Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "If this is just going to be the type with no description, it can be omitted (the generated scaladoc will already contain the type information)\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T17:45:11Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return [[org.apache.spark.mllib.stat.test.ADTestResult]]"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "nit: `params: Double*` is only guaranteed to be a `Seq` so you may be paying a conversion on the `.toArray` call. Instead, you could just have `initDist`, `validateParams` and the respective distributions take `Seq`s and avoid the conversions. This is my personal preference and very nit though, so feel free to ignore.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T17:54:24Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return [[org.apache.spark.mllib.stat.test.ADTestResult]]\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params.toArray)"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Appreciate the feedback. I have made the change accordingly and will push as soon as I can get the api docs to build. Having issues with that for some reason....\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-10T20:55:01Z",
    "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no ties occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object ADTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * ADTheoreticalDist is a trait that every distribution used in an AD test must extend.\n+   * The rationale for this is that the AD test has distribution-dependent critical values, and by\n+   * requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait ADTheoreticalDist extends Serializable {\n+    val params: Array[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class ADExponential(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n)}\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class ADNormal(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class ADGumbel(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class ADLogistic(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n)}\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class ADWeibull(val params: Array[Double]) extends ADTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n))}\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports standard normal,\n+   *            exponential, gumbel, logistic, weibull\n+   * @param params optional variable-length argument providing parameters for given distribution,\n+   *               otherwise they are estimated from sample but in both cases we adjust critical\n+   *               values assuming they were estimated from sample. Providing them is simply a\n+   *               convenience to avoid recalculation when the values are already available to\n+   *               the user\n+   * @return [[org.apache.spark.mllib.stat.test.ADTestResult]]\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*): ADTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params.toArray)"
  }],
  "prId": 7278
}]