[{
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "orders of import\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:15:15Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "four spaces before function definition. The same for the following line.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:18:02Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "The curly braces are not needed. The same for the following `case` statement.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:27:22Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "mutable.MutableList is better.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:28:28Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "I think you can use `dataFields.get(dataField.getName.getValue).isEmpty` instread of the `!xxx.isDefined`\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:29:53Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove `.value()` in the end, because the type of both sides are not the same. `getOpType` gets the OpType, while `OpType.CONTINUOUS.value()` gets a string.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:32:39Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "Good  catch. Thank You !\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T14:12:18Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove `toMap` in the end, coz the groupBy returns a Map\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:36:02Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }.toMap"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "use `isEmpty`\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:36:24Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }.toMap\n+\n+      values.foreach(category => {\n+        if (!existingValues.get(category.getValue).isDefined) {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "redundant curly braces\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T02:37:28Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }.toMap\n+\n+      values.foreach(category => {\n+        if (!existingValues.get(category.getValue).isDefined) {\n+          dtField.withValues(category)\n+        }\n+      })\n+    }\n+\n+    dtField\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node, fieldName: Option[FieldName], isLeft: Boolean): Predicate = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+\n+      require(fieldName.isDefined, \"fieldName should not be None, it should be defined.\")\n+      val field = fieldName.get\n+\n+      val split = node.split.get\n+      val featureType = split.featureType\n+\n+      featureType match {\n+        case FeatureType.Continuous => {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "There is no need to create a function here, coz it is only a match .. case statement.\n\nYou may use this:\n\n``` scala\ndtModel.algo match {\n  case ... =>\n  case ... =>\n}\n```\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:03:15Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }.toMap\n+\n+      values.foreach(category => {\n+        if (!existingValues.get(category.getValue).isDefined) {\n+          dtField.withValues(category)\n+        }\n+      })\n+    }\n+\n+    dtField\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node, fieldName: Option[FieldName], isLeft: Boolean): Predicate = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+\n+      require(fieldName.isDefined, \"fieldName should not be None, it should be defined.\")\n+      val field = fieldName.get\n+\n+      val split = node.split.get\n+      val featureType = split.featureType\n+\n+      featureType match {\n+        case FeatureType.Continuous => {\n+          val value = split.threshold.toString\n+          if (isLeft) {\n+            new SimplePredicate(field, SimplePredicate.Operator.LESS_OR_EQUAL)\n+              .withValue(value)\n+          }\n+          else {\n+            new SimplePredicate(field, SimplePredicate.Operator.GREATER_THAN)\n+              .withValue(value)\n+          }\n+        }\n+        case FeatureType.Categorical => {\n+          if (split.categories.length > 1) {\n+            if (isLeft) {\n+              val predicates: List[Predicate] =\n+                for (category <- split.categories)\n+                  yield\n+                  new SimplePredicate(field, SimplePredicate.Operator.EQUAL)\n+                    .withValue(category.toString)\n+\n+              val compoundPredicate = new CompoundPredicate()\n+                .withBooleanOperator(CompoundPredicate.BooleanOperator.OR)\n+                .withPredicates(predicates.asJava)\n+\n+              compoundPredicate\n+            } else {\n+              new True()\n+            }\n+          }\n+          else {\n+            val value = split.categories(0).toString\n+\n+            if (isLeft) {\n+              new SimplePredicate(field, SimplePredicate.Operator.EQUAL)\n+                .withValue(value)\n+            }\n+            else {\n+              new True()\n+            }\n+          }\n+        }\n+      }\n+    }\n+    else {\n+      new True()\n+    }\n+\n+  }\n+\n+  /** Create equivalent PMML node for given mlLib node. */\n+  private def createNode(mlLibNode: Node): PMMLNode = {\n+    val node = new PMMLNode()\n+      .withId(mlLibNode.id.toString)\n+      .withScore(mlLibNode.predict.predict.toString)\n+\n+    node\n+  }\n+\n+  /** Get PMML datafield based on the mllib split feature. */\n+  private def getDataField(mllibNode: Node, fieldName: FieldName): Option[DataField] = {\n+    if (!mllibNode.isLeaf && mllibNode.split.isDefined) {\n+      val split = mllibNode.split.get\n+      val dataField = new DataField()\n+        .withName(fieldName)\n+        .withDataType(DataType.fromValue(split.threshold.getClass.getSimpleName.toLowerCase))\n+        .withOpType(OpType.fromValue(split.featureType.toString.toLowerCase))\n+\n+      split.featureType match {\n+        case FeatureType.Continuous => dataField.withOpType(OpType.CONTINUOUS)\n+        case FeatureType.Categorical => {\n+          dataField.withOpType(OpType.CATEGORICAL)\n+          val categories = split.categories\n+            .map(category => new PMMLValue(category.toString)).asJava\n+          dataField.withValues(categories)\n+        }\n+      }\n+\n+      Some(dataField)\n+    }\n+    else {\n+      None\n+    }\n+  }\n+\n+  /** Get PMML mining function type for given mlLib Algo. */\n+  private def getPMMLMiningFunctionType(mlLibAlgo: Algo): MiningFunctionType = {"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "You can merge the two lines of comment.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:05:53Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "It's better to merge the line with the previous one for compactness.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:10:44Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "same here\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:10:51Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove the blank line.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:11:45Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "There is no need to use `var` here, coz the `leftPredicate` and `rightPredicate` are both assigned with value once.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:17:01Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "Actually they are being assigned value once more inside the if block\nif (rootNode.split.isDefined) {\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T14:14:43Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove the empty line.\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:19:02Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "remove the blank line\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:37:43Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "there is no need to define the `node`, new the PMMLNode\n",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2015-10-28T03:47:43Z",
    "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.MutableList\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = getPMMLMiningFunctionType(dtModel.algo)\n+\n+    val treeModel = new org.dmg.pmml.TreeModel()\n+      .withModelName(modelName)\n+      .withFunctionName(miningFunctionType)\n+      .withSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression\n+    // for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification => {\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(FieldName.create(\"class\"))\n+          .withUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .withName(FieldName.create(\"class\"))\n+          .withOpType(OpType.CATEGORICAL)\n+          .withValues(classes.asJava)\n+          .withDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+      }\n+      case Algo.Regression => {\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .withName(targetField)\n+          .withUsageType(FieldUsageType.TARGET)\n+      }\n+    }\n+\n+    val miningSchema = new MiningSchema()\n+      .withMiningFields(miningFields.asJava)\n+\n+    treeModel.withNode(rootNode)\n+      .withMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(\n+              rootDTNode: Node,\n+              algo: Algo): (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = createNode(rootNode)\n+      rootPMMLNode.withPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (!dataFields.get(dataField.getName.getValue).isDefined) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .withName(dataField.getName)\n+            .withUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS.value()) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.withNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.withNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }.toMap\n+\n+      values.foreach(category => {\n+        if (!existingValues.get(category.getValue).isDefined) {\n+          dtField.withValues(category)\n+        }\n+      })\n+    }\n+\n+    dtField\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node, fieldName: Option[FieldName], isLeft: Boolean): Predicate = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+\n+      require(fieldName.isDefined, \"fieldName should not be None, it should be defined.\")\n+      val field = fieldName.get\n+\n+      val split = node.split.get\n+      val featureType = split.featureType\n+\n+      featureType match {\n+        case FeatureType.Continuous => {\n+          val value = split.threshold.toString\n+          if (isLeft) {\n+            new SimplePredicate(field, SimplePredicate.Operator.LESS_OR_EQUAL)\n+              .withValue(value)\n+          }\n+          else {\n+            new SimplePredicate(field, SimplePredicate.Operator.GREATER_THAN)\n+              .withValue(value)\n+          }\n+        }\n+        case FeatureType.Categorical => {\n+          if (split.categories.length > 1) {\n+            if (isLeft) {\n+              val predicates: List[Predicate] =\n+                for (category <- split.categories)\n+                  yield\n+                  new SimplePredicate(field, SimplePredicate.Operator.EQUAL)\n+                    .withValue(category.toString)\n+\n+              val compoundPredicate = new CompoundPredicate()\n+                .withBooleanOperator(CompoundPredicate.BooleanOperator.OR)\n+                .withPredicates(predicates.asJava)\n+\n+              compoundPredicate\n+            } else {\n+              new True()\n+            }\n+          }\n+          else {\n+            val value = split.categories(0).toString\n+\n+            if (isLeft) {\n+              new SimplePredicate(field, SimplePredicate.Operator.EQUAL)\n+                .withValue(value)\n+            }\n+            else {\n+              new True()\n+            }\n+          }\n+        }\n+      }\n+    }\n+    else {\n+      new True()\n+    }\n+\n+  }\n+\n+  /** Create equivalent PMML node for given mlLib node. */\n+  private def createNode(mlLibNode: Node): PMMLNode = {\n+    val node = new PMMLNode()"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "jomach"
    },
    "body": "remove blank Line",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2017-10-13T19:44:26Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+"
  }, {
    "author": {
      "login": "JasmineGeorge"
    },
    "body": "when i remove these lines scala styletest fails. It requires blank lines between different groups",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2017-10-23T22:59:50Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "jomach"
    },
    "body": "remove blank Line",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2017-10-13T19:45:01Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = dtModel.algo match {\n+      case Algo.Classification => MiningFunctionType.CLASSIFICATION\n+      case Algo.Regression => MiningFunctionType.REGRESSION\n+    }\n+\n+    val treeModel = new TreeModel()\n+      .setModelName(modelName)\n+      .setFunctionName(miningFunctionType)\n+      .setSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification =>\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(FieldName.create(\"class\"))\n+          .setUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .setName(FieldName.create(\"class\"))\n+          .setOpType(OpType.CATEGORICAL)\n+          .addValues(classes: _*)\n+          .setDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+\n+      case Algo.Regression =>\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(targetField)\n+          .setUsageType(FieldUsageType.TARGET)\n+\n+    }\n+\n+    val miningSchema = new MiningSchema().addMiningFields(miningFields: _*)\n+\n+    treeModel.setNode(rootNode).setMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(rootDTNode: Node, algo: Algo):\n+    (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = mutable.MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = new PMMLNode()\n+        .setId(rootNode.id.toString)\n+        .setScore(rootNode.predict.predict.toString)\n+        .setPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (dataFields.get(dataField.getName.getValue).isEmpty) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .setName(dataField.getName)\n+            .setUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.addNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.addNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "jomach"
    },
    "body": "remove blank Line",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2017-10-13T19:45:07Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = dtModel.algo match {\n+      case Algo.Classification => MiningFunctionType.CLASSIFICATION\n+      case Algo.Regression => MiningFunctionType.REGRESSION\n+    }\n+\n+    val treeModel = new TreeModel()\n+      .setModelName(modelName)\n+      .setFunctionName(miningFunctionType)\n+      .setSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification =>\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(FieldName.create(\"class\"))\n+          .setUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .setName(FieldName.create(\"class\"))\n+          .setOpType(OpType.CATEGORICAL)\n+          .addValues(classes: _*)\n+          .setDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+\n+      case Algo.Regression =>\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(targetField)\n+          .setUsageType(FieldUsageType.TARGET)\n+\n+    }\n+\n+    val miningSchema = new MiningSchema().addMiningFields(miningFields: _*)\n+\n+    treeModel.setNode(rootNode).setMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(rootDTNode: Node, algo: Algo):\n+    (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = mutable.MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = new PMMLNode()\n+        .setId(rootNode.id.toString)\n+        .setScore(rootNode.predict.predict.toString)\n+        .setPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (dataFields.get(dataField.getName.getValue).isEmpty) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .setName(dataField.getName)\n+            .setUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.addNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.addNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+"
  }],
  "prId": 7842
}, {
  "comments": [{
    "author": {
      "login": "jomach"
    },
    "body": "remove blank Line",
    "commit": "85a4c326c5a573245e40d636c951f0824b7870bc",
    "createdAt": "2017-10-13T19:45:17Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.pmml.export\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConverters._\n+\n+import org.dmg.pmml.{Node => PMMLNode, Value => PMMLValue, _}\n+\n+import org.apache.spark.mllib.tree.configuration.{Algo, FeatureType}\n+import org.apache.spark.mllib.tree.configuration.Algo._\n+import org.apache.spark.mllib.tree.model.{DecisionTreeModel, Node}\n+\n+private[mllib] object PMMLTreeModelUtils {\n+\n+  val FieldNamePrefix = \"field_\"\n+\n+  def toPMMLTree(dtModel: DecisionTreeModel, modelName: String): (TreeModel, List[DataField]) = {\n+\n+    val miningFunctionType = dtModel.algo match {\n+      case Algo.Classification => MiningFunctionType.CLASSIFICATION\n+      case Algo.Regression => MiningFunctionType.REGRESSION\n+    }\n+\n+    val treeModel = new TreeModel()\n+      .setModelName(modelName)\n+      .setFunctionName(miningFunctionType)\n+      .setSplitCharacteristic(TreeModel.SplitCharacteristic.BINARY_SPLIT)\n+\n+    var (rootNode, miningFields, dataFields, classes) = buildStub(dtModel.topNode, dtModel.algo)\n+\n+    // adding predicted classes for classification and target field for regression for completeness\n+    dtModel.algo match {\n+\n+      case Algo.Classification =>\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(FieldName.create(\"class\"))\n+          .setUsageType(FieldUsageType.PREDICTED)\n+\n+        val dataField = new DataField()\n+          .setName(FieldName.create(\"class\"))\n+          .setOpType(OpType.CATEGORICAL)\n+          .addValues(classes: _*)\n+          .setDataType(DataType.DOUBLE)\n+\n+        dataFields = dataFields :+ dataField\n+\n+      case Algo.Regression =>\n+        val targetField = FieldName.create(\"target\")\n+        val dataField = new DataField(targetField, OpType.CONTINUOUS, DataType.DOUBLE)\n+        dataFields = dataFields :+ dataField\n+\n+        miningFields = miningFields :+ new MiningField()\n+          .setName(targetField)\n+          .setUsageType(FieldUsageType.TARGET)\n+\n+    }\n+\n+    val miningSchema = new MiningSchema().addMiningFields(miningFields: _*)\n+\n+    treeModel.setNode(rootNode).setMiningSchema(miningSchema)\n+\n+    (treeModel, dataFields)\n+  }\n+\n+  /** Build a pmml tree stub given the root mllib node. */\n+  private def buildStub(rootDTNode: Node, algo: Algo):\n+    (PMMLNode, List[MiningField], List[DataField], List[PMMLValue]) = {\n+\n+    val miningFields = mutable.MutableList[MiningField]()\n+    val dataFields = mutable.HashMap[String, DataField]()\n+    val classes = mutable.MutableList[Double]()\n+\n+    def buildStubInternal(rootNode: Node, predicate: Predicate): PMMLNode = {\n+\n+      // get rootPMML node for the MLLib node\n+      val rootPMMLNode = new PMMLNode()\n+        .setId(rootNode.id.toString)\n+        .setScore(rootNode.predict.predict.toString)\n+        .setPredicate(predicate)\n+\n+      var leftPredicate: Predicate = new True()\n+      var rightPredicate: Predicate = new True()\n+\n+      if (rootNode.split.isDefined) {\n+        val fieldName = FieldName.create(FieldNamePrefix + rootNode.split.get.feature)\n+        val dataField = getDataField(rootNode, fieldName).get\n+\n+        if (dataFields.get(dataField.getName.getValue).isEmpty) {\n+          dataFields.put(dataField.getName.getValue, dataField)\n+          miningFields += new MiningField()\n+            .setName(dataField.getName)\n+            .setUsageType(FieldUsageType.ACTIVE)\n+\n+        } else if (dataField.getOpType != OpType.CONTINUOUS) {\n+          appendCategories(\n+            dataFields.get(dataField.getName.getValue).get,\n+            dataField.getValues.asScala.toList)\n+        }\n+\n+        leftPredicate = getPredicate(rootNode, Some(dataField.getName), true)\n+        rightPredicate = getPredicate(rootNode, Some(dataField.getName), false)\n+      }\n+      // if left node exist, add the node\n+      if (rootNode.leftNode.isDefined) {\n+        val leftNode = buildStubInternal(rootNode.leftNode.get, leftPredicate)\n+        rootPMMLNode.addNodes(leftNode)\n+      }\n+      // if right node exist, add the node\n+      if (rootNode.rightNode.isDefined) {\n+        val rightNode = buildStubInternal(rootNode.rightNode.get, rightPredicate)\n+        rootPMMLNode.addNodes(rightNode)\n+      }\n+\n+      // add to the list of classes\n+      if (rootNode.isLeaf && (algo == Algo.Classification)) {\n+        classes += rootNode.predict.predict\n+      }\n+\n+      rootPMMLNode\n+    }\n+\n+    val pmmlTreeRootNode = buildStubInternal(rootDTNode, new True())\n+\n+    val pmmlValues = classes.toList.distinct.map(doubleVal => new PMMLValue(doubleVal.toString))\n+\n+    val result = (pmmlTreeRootNode,\n+      sortMiningFields(miningFields.toList),\n+      sortedDataFields(dataFields.values.toList),\n+      pmmlValues)\n+\n+    result\n+\n+  }\n+\n+  private def sortMiningFields(miningFields: List[MiningField]): List[MiningField] = {\n+    miningFields\n+      .sortBy { case mField => mField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def sortedDataFields(dataFields: List[DataField]): List[DataField] = {\n+    dataFields.sortBy { case dField => dField.getName.getValue.replace(FieldNamePrefix, \"\").toInt }\n+  }\n+\n+  private def appendCategories(dtField: DataField, values: List[PMMLValue]): DataField = {\n+    if (dtField.getOpType == OpType.CATEGORICAL) {\n+\n+      val existingValues = dtField.getValues.asScala\n+        .groupBy { case category => category.getValue }\n+\n+      values.foreach(category => {\n+        if (existingValues.get(category.getValue).isEmpty) {\n+          dtField.addValues(category)\n+        }\n+      })\n+    }\n+\n+    dtField\n+  }\n+\n+  /** Get pmml Predicate for a given mlLib tree node. */\n+  private def getPredicate(node: Node, fieldName: Option[FieldName], isLeft: Boolean): Predicate = {\n+    // compound predicate if classification and categories list length > 0\n+\n+    if (node.split.isDefined) {\n+\n+      require(fieldName.isDefined, \"fieldName should not be None, it should be defined.\")\n+      val field = fieldName.get\n+"
  }],
  "prId": 7842
}]