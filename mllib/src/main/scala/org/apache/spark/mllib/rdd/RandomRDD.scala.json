[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Could you double check whether we can have more than `Int.MaxValue` items in a single partition? It may break storage and couple RDD functions like `glob`.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T06:52:23Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "There's no restrictions on the size of each Partition from the trait (in fact it doesn't even need to have a size). The restriction of `size <= Int.MaxValue` happens when the RDD is cached. In the case of `glom`, the size of the entire RDD needs to be `<= Int.MaxValue` since that's the max size of an array.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T00:17:54Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "So let us not put more than `Int.MaxValue` items to a single partition. If the size is beyond this limit, we should throw an error. Different from `collect`, `glom` converts `RDD[T]` to `RDD[Array[T]]`, coalescing all elements within each partition into an array. `glom` is not frequently used but we should support `cache`, which means we shouldn't allow more than `Int.MaxValue` number of items on a single partition.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T05:40:41Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "You can put `override` directly in the constructor.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T06:52:28Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If we couldn't have more than `Int.MaxValue` items per iteration, this is `Iterator.fill(numElem)(rng.nextValue())`.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T06:52:45Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is not evenly distributed, for example, when `size = 1000` and `numSlices = 101`.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T06:52:52Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Switching to the slicing logic from `ParallelCollectionRDD` for more balanced partition sizes.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T00:57:43Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It is safer to make a copy in `compute` than here. In local mode, this may cause problems if a user uses the same generator to create two random RDDs.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T06:52:55Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Or I could just add `.newInstance()' in line 118, which I prefer since it's not necessary for us to have a new rng every time the RDD is computed. But thanks for pointing out this use case.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T00:38:11Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "It feels more secure if people see the following lines in the same group.\n\n```\nval thisGenerator = generator.copy()\nthisGenerator.setSeed(seed)\niter.fill(...)(thisGenerator.nextValue())\n```\n\nIf there are only\n\n```\ngenerator.setSeed(seed)\niter.fill(...)(generator.nextValue())\n```\n\npeople would wonder whether there are concurrency issues.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T05:35:55Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mateiz"
    },
    "body": "Instead of doing this, it would be better to give each partition a seed generated by a Random object based on the RDD's seed. This way the seeds differ in more bits from each other. For example, take a look at PartitionwiseSampledRDD in the current codebase. It uses an RDD-wide seed to create a sequence of seeds, once for each partition, then it takes those as input to new RNGs for each partition.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-22T08:16:16Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)\n+      } else {\n+        new RandomRDDPartition(i, otherPartitionSize, rng.newInstance(), seed)\n+      }\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    partition.rng.setSeed(partition.seed + partition.index)"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "Thanks for the pointer to PartitionwiseSampledRDD. I've actually looked a lot at it for the sampling PRs. There were two considerations for going with this more deterministic seed assignment per partition. One is that this is a lot easier to test to make sure that each partition has a different seed with this deterministic seed assignment, and the other is that we're guaranteed to have a unique seed per partition. Since most RNG implementations hash or otherwise scramble the bits in the input seed before setting it anyway, I think we can get away with the current implementation. \n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T00:32:34Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)\n+      } else {\n+        new RandomRDDPartition(i, otherPartitionSize, rng.newInstance(), seed)\n+      }\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    partition.rng.setSeed(partition.seed + partition.index)"
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "I'm not sure this is a great idea unfortunately, see http://stackoverflow.com/questions/426350/seeding-java-util-random-with-consecutive-numbers. I think it would be safer to use a RNG to generate the seeds. In tests you can just make sure that \"most\" of them are distinct instead, or you can test for the specific sequence expected by our generator.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T07:53:33Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)\n+      } else {\n+        new RandomRDDPartition(i, otherPartitionSize, rng.newInstance(), seed)\n+      }\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    partition.rng.setSeed(partition.seed + partition.index)"
  }, {
    "author": {
      "login": "mateiz"
    },
    "body": "BTW I think this java.util.Random issue is the reason we switched to the current approach in PartitionwiseSampledRDD.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T07:54:13Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)\n+      } else {\n+        new RandomRDDPartition(i, otherPartitionSize, rng.newInstance(), seed)\n+      }\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    partition.rng.setSeed(partition.seed + partition.index)"
  }, {
    "author": {
      "login": "dorx"
    },
    "body": "In that case, we need to change the impl for stratified sampling as well @mengxr \n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-23T18:30:52Z",
    "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+private[mllib] class RandomRDDPartition(val idx: Int,\n+    val size: Long,\n+    val rng: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+\n+  override val index: Int = idx\n+\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  private[mllib] class FixedSizePointIterator(val numElem: Long, val rng: DistributionGenerator)\n+    extends Iterator[Double] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Double = {\n+      currentSize += 1\n+      rng.nextValue()\n+    }\n+  }\n+\n+  private[mllib] class FixedSizeVectorIterator(val numElem: Long,\n+      val vectorSize: Int,\n+      val rng: DistributionGenerator)\n+    extends Iterator[Vector] {\n+\n+    private var currentSize = 0\n+\n+    override def hasNext: Boolean = currentSize < numElem\n+\n+    override def next(): Vector = {\n+      currentSize += 1\n+      new DenseVector((0 until vectorSize).map { _ => rng.nextValue() }.toArray)\n+    }\n+  }\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val firstPartitionSize = size / numSlices + size % numSlices\n+    val otherPartitionSize = size / numSlices\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    while (i < numSlices) {\n+      partitions(i) =  if (i == 0) {\n+        new RandomRDDPartition(i, firstPartitionSize, rng, seed)\n+      } else {\n+        new RandomRDDPartition(i, otherPartitionSize, rng.newInstance(), seed)\n+      }\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    partition.rng.setSeed(partition.seed + partition.index)"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The comment needs update because it is possible to cast a Long to a positive Int:\n\n```\nscala> 100000000000L.toInt\nres0: Int = 1215752192\n```\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-25T07:53:44Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+import scala.util.Random\n+\n+private[mllib] class RandomRDDPartition(override val index: Int,\n+    val size: Int,\n+    val generator: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+  // Safety check in case a Long > Int.MaxValue cast to an Int was passed in as size"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "If `numPartiitons` > `size`, there would be empty partitions. We should allow this case, because it happens when a user uses the default number of partitions, which may be greater than `size`.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-25T07:54:03Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+import scala.util.Random\n+\n+private[mllib] class RandomRDDPartition(override val index: Int,\n+    val size: Int,\n+    val generator: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+  // Safety check in case a Long > Int.MaxValue cast to an Int was passed in as size\n+  require(size > 0, \"Positive partition size required.\")"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`numSlices` -> `numPartitions` to match the naming in previous code?\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-25T07:54:14Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+import scala.util.Random\n+\n+private[mllib] class RandomRDDPartition(override val index: Int,\n+    val size: Int,\n+    val generator: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+  // Safety check in case a Long > Int.MaxValue cast to an Int was passed in as size\n+  require(size > 0, \"Positive partition size required.\")\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`Array.fill(vectorSize)(generator.nextValue())` may be faster because it doesn't create a temp object.\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-25T07:54:48Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+import scala.util.Random\n+\n+private[mllib] class RandomRDDPartition(override val index: Int,\n+    val size: Int,\n+    val generator: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+  // Safety check in case a Long > Int.MaxValue cast to an Int was passed in as size\n+  require(size > 0, \"Positive partition size required.\")\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Double](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(math.ceil(size.toDouble / numSlices) <= Int.MaxValue,\n+    \"Partition size cannot exceed Int.MaxValue\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Double] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getPointIterator(split)\n+  }\n+\n+  override def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] class RandomVectorRDD(@transient private var sc: SparkContext,\n+    size: Long,\n+    vectorSize: Int,\n+    numSlices: Int,\n+    @transient rng: DistributionGenerator,\n+    @transient seed: Long = Utils.random.nextLong) extends RDD[Vector](sc, Nil) {\n+\n+  require(size > 0, \"Positive RDD size required.\")\n+  require(numSlices > 0, \"Positive number of partitions required\")\n+  require(vectorSize > 0, \"Positive vector size required.\")\n+  require(math.ceil(size.toDouble / numSlices) <= Int.MaxValue,\n+    \"Partition size cannot exceed Int.MaxValue\")\n+\n+  override def compute(splitIn: Partition, context: TaskContext): Iterator[Vector] = {\n+    val split = splitIn.asInstanceOf[RandomRDDPartition]\n+    RandomRDD.getVectorIterator(split, vectorSize)\n+  }\n+\n+  override protected def getPartitions: Array[Partition] = {\n+    RandomRDD.getPartitions(size, numSlices, rng, seed)\n+  }\n+}\n+\n+private[mllib] object RandomRDD {\n+\n+  def getPartitions(size: Long,\n+      numSlices: Int,\n+      rng: DistributionGenerator,\n+      seed: Long): Array[Partition] = {\n+\n+    val partitions = new Array[RandomRDDPartition](numSlices)\n+    var i = 0\n+    var start: Long = 0\n+    var end: Long = 0\n+    val random = new Random(seed)\n+    while (i < numSlices) {\n+      end = ((i + 1) * size) / numSlices\n+      partitions(i) = new RandomRDDPartition(i, (end - start).toInt, rng, random.nextLong())\n+      start = end\n+      i += 1\n+    }\n+    partitions.asInstanceOf[Array[Partition]]\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getPointIterator(partition: RandomRDDPartition): Iterator[Double] = {\n+    val generator = partition.generator.copy()\n+    generator.setSeed(partition.seed)\n+    Iterator.fill(partition.size)(generator.nextValue())\n+  }\n+\n+  // The RNG has to be reset every time the iterator is requested to guarantee same data\n+  // every time the content of the RDD is examined.\n+  def getVectorIterator(partition: RandomRDDPartition, vectorSize: Int): Iterator[Vector] = {\n+    val generator = partition.generator.copy()\n+    generator.setSeed(partition.seed)\n+    Iterator.fill(partition.size)(new DenseVector(\n+      (0 until vectorSize).map { _ => generator.nextValue() }.toArray))"
  }],
  "prId": 1520
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Could it be a `val`?\n",
    "commit": "01121ac8af3d7f6cd44160644d387b3747b925f4",
    "createdAt": "2014-07-25T08:07:35Z",
    "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.rdd\n+\n+import org.apache.spark.{Partition, SparkContext, TaskContext}\n+import org.apache.spark.mllib.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.random.DistributionGenerator\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.util.Utils\n+\n+import scala.util.Random\n+\n+private[mllib] class RandomRDDPartition(override val index: Int,\n+    val size: Int,\n+    val generator: DistributionGenerator,\n+    val seed: Long) extends Partition {\n+  // Safety check in case a Long > Int.MaxValue cast to an Int was passed in as size\n+  require(size > 0, \"Positive partition size required.\")\n+}\n+\n+// These two classes are necessary since Range objects in Scala cannot have size > Int.MaxValue\n+private[mllib] class RandomRDD(@transient private var sc: SparkContext,"
  }],
  "prId": 1520
}]