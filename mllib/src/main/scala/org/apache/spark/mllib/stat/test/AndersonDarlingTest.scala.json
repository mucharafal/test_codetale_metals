[{
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "Nit: put comments above, as opposed to after, this class members\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:47:05Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "Nit: one-sample\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:50:28Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class AndersonDarlingLogistic(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n) }\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class AndersonDarlingWeibull(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson-Darling test",
    "line": 170
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "I'd call this getCriticalValues for clarity\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:50:53Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size"
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "thanks for feedback. I've renamed and also renamed rawCVs to rawCriticalValues for consistency\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T17:42:49Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "\"1 sample\" -> \"one-sample\"\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:54:15Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class AndersonDarlingLogistic(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n) }\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class AndersonDarlingWeibull(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson-Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports normal,\n+   *            exponential, gumbel, logistic, weibull as\n+   *            ['norm', 'exp', 'gumbel', 'logistic', 'weibull']\n+   * @param params variable-length argument providing parameters for given distribution. When none\n+   *               are provided, default parameters appropriate to each distribution are chosen. In\n+   *               either case, critical values reflect adjustments that assume the parameters were\n+   *               estimated from the data\n+   * @return\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*)\n+    : AndersonDarlingTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, dist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = dist.getCVs(n)\n+    new AndersonDarlingTestResult(ADStat, criticalVals, NullHypothesis.OneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson-Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part a partition of the data sample to be analyzed\n+   * @param dist a theoretical distribution that extends the AndersonDarlingTheoreticalDist trait,\n+   *             used to calculate CDF values and critical values\n+   * @param n the total size of the data sample\n+   * @return The first element corresponds to the position-independent contribution to the\n+   *         statistic, the second is the value that must be scaled by the number of elements in\n+   *         prior partitions, and the third is the number of elements in this partition\n+   */\n+  private def calcPartAD(part: Iterator[Double], dist: AndersonDarlingTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a theoretical distribution to be used in the 1 sample Anderson-Darling test"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "nit: put `: Seq[Double] = {` on the line above.\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:55:34Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class AndersonDarlingLogistic(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n) }\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class AndersonDarlingWeibull(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson-Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports normal,\n+   *            exponential, gumbel, logistic, weibull as\n+   *            ['norm', 'exp', 'gumbel', 'logistic', 'weibull']\n+   * @param params variable-length argument providing parameters for given distribution. When none\n+   *               are provided, default parameters appropriate to each distribution are chosen. In\n+   *               either case, critical values reflect adjustments that assume the parameters were\n+   *               estimated from the data\n+   * @return\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*)\n+    : AndersonDarlingTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, dist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = dist.getCVs(n)\n+    new AndersonDarlingTestResult(ADStat, criticalVals, NullHypothesis.OneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson-Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior\n+   * partition, and a count of the elements in that partition\n+   * @param part a partition of the data sample to be analyzed\n+   * @param dist a theoretical distribution that extends the AndersonDarlingTheoreticalDist trait,\n+   *             used to calculate CDF values and critical values\n+   * @param n the total size of the data sample\n+   * @return The first element corresponds to the position-independent contribution to the\n+   *         statistic, the second is the value that must be scaled by the number of elements in\n+   *         prior partitions, and the third is the number of elements in this partition\n+   */\n+  private def calcPartAD(part: Iterator[Double], dist: AndersonDarlingTheoreticalDist, n: Double)\n+    : Iterator[(Double, Double, Double)] = {\n+    val initAcc = (0.0, 0.0, 0.0)\n+    val pResult = part.zipWithIndex.foldLeft(initAcc) { case ((prevS, prevC, prevCt), (v, i)) =>\n+      val y = dist.cdf(v)\n+      val a = math.log(y)\n+      val b = math.log(1 - y)\n+      val unAdjusted = a * (2 * i + 1) + b * (2 * n - 2 * i - 1)\n+      val adjConstant = a - b\n+      (prevS + unAdjusted, prevC + adjConstant, prevCt + 1)\n+    }\n+    Array(pResult).iterator\n+  }\n+\n+  /**\n+   * Create a theoretical distribution to be used in the 1 sample Anderson-Darling test\n+   * @param distName name of distribution\n+   * @param params Initialization parameters for distribution, if none provided, default values\n+   *               are chosen.\n+   * @return distribution object used to calculate CDF values\n+   */\n+  private def initDist(distName: String, params: Seq[Double]): AndersonDarlingTheoreticalDist = {\n+    distName match {\n+      case \"norm\" => {\n+        val checkedParams = validateParams(distName, params, 2, Seq(0.0, 1.0))\n+        new AndersonDarlingNormal(checkedParams)\n+      }\n+      case \"exp\" => {\n+        val checkedParams = validateParams(distName, params, 1, Seq(1.0))\n+        new AndersonDarlingExponential(checkedParams)\n+      }\n+      case \"gumbel\" => {\n+        val checkedParams = validateParams(distName, params, 2, Seq(0.0, 1.0))\n+        new AndersonDarlingGumbel(checkedParams)\n+      }\n+      case \"logistic\" => {\n+        val checkedParams = validateParams(distName, params, 2, Seq(0.0, 1.0))\n+        new AndersonDarlingLogistic(checkedParams)\n+      }\n+      case \"weibull\" => {\n+        val checkedParams = validateParams(distName, params, 2, Seq(0.0, 1.0))\n+        new AndersonDarlingWeibull(checkedParams)\n+      }\n+      case _ => throw new IllegalArgumentException(\n+        s\"Anderson-Darling does not currently support $distName distribution\" +\n+          \" must be one of 'norm', 'exp', 'gumbel', 'logistic', or 'weibull'\")\n+    }\n+  }\n+\n+  /**\n+   * Validate the length of parameters passed in by the user, if none are passed, return default\n+   * values\n+   * @param distName name of distribution\n+   * @param params parameters passed by user\n+   * @param reqLen the required length of the parameter sequence\n+   * @param defParams default alternative for the parameter in case `params` is empty\n+   * @return parameters that will be used to initialize the distribution\n+   */\n+  private def validateParams(\n+      distName: String,\n+      params: Seq[Double],\n+      reqLen: Int,\n+      defParams: Seq[Double])\n+    : Seq[Double] = {"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "These can all fit on the same line\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:57:20Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "These can all fit on the same line\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T16:57:43Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,"
  }],
  "prId": 7278
}, {
  "comments": [{
    "author": {
      "login": "sryza"
    },
    "body": "Should this read \"prior partition_s_\"?\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T17:00:37Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class AndersonDarlingLogistic(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n) }\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class AndersonDarlingWeibull(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson-Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports normal,\n+   *            exponential, gumbel, logistic, weibull as\n+   *            ['norm', 'exp', 'gumbel', 'logistic', 'weibull']\n+   * @param params variable-length argument providing parameters for given distribution. When none\n+   *               are provided, default parameters appropriate to each distribution are chosen. In\n+   *               either case, critical values reflect adjustments that assume the parameters were\n+   *               estimated from the data\n+   * @return\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*)\n+    : AndersonDarlingTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, dist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = dist.getCVs(n)\n+    new AndersonDarlingTestResult(ADStat, criticalVals, NullHypothesis.OneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson-Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior",
    "line": 202
  }, {
    "author": {
      "login": "josepablocam"
    },
    "body": "Yes, sorry, that value is adjust by a running aggregate of counts in prior partitions, so it should indeed read _partitions_ not _partition_, corrected now. Thanks\n",
    "commit": "cc352f046608293e1595af44972834e8e2acdc3a",
    "createdAt": "2015-07-23T17:44:27Z",
    "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.mllib.stat.test\n+\n+import scala.annotation.varargs\n+\n+import collection.immutable.ListMap\n+\n+import org.apache.commons.math3.distribution.{ExponentialDistribution, GumbelDistribution,\n+  LogisticDistribution, NormalDistribution, WeibullDistribution}\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * The Anderson-Darling (AD) test, similarly to the Kolmogorov-Smirnov (KS) test, tests whether the\n+ * data follow a given theoretical distribution. It should be used with continuous data and\n+ * assumes that no repeated values occur (the presence of ties can affect the validity of the test).\n+ * The AD test provides an alternative to the KS test. Namely, it is better\n+ * suited to identify departures from the theoretical distribution at the tails.\n+ * It is worth noting that the the AD test's critical values depend on the\n+ * distribution being tested against. The AD statistic is defined as\n+ * {{{\n+ * A^2 = -N - \\frac{1}{N}\\sum_{i = 0}^{N} (2i + 1)(\\ln{\\Phi{(x_i)}} + \\ln{(1 - \\Phi{(x_{N+1-i})})\n+ * }}}\n+ * where {{{\\Phi}}} is the CDF of the given distribution and `N` is the sample size.\n+ * For more information @see[[https://en.wikipedia.org/wiki/Anderson%E2%80%93Darling_test]]\n+ */\n+private[stat] object AndersonDarlingTest extends Logging {\n+\n+  object NullHypothesis extends Enumeration {\n+    type NullHypothesis = Value\n+    val OneSample = Value(\"Sample follows theoretical distribution.\")\n+  }\n+\n+  /**\n+   * AndersonDarlingTheoreticalDist is a trait that every distribution used in an AD test must\n+   * extend. The rationale for this is that the AD test has distribution-dependent critical values,\n+   * and by requiring extension of this trait we guarantee that future additional distributions\n+   * make sure to add the appropriate critical values (CVs) (or at least acknowledge\n+   * that they should be added)\n+   */\n+  sealed trait AndersonDarlingTheoreticalDist extends Serializable {\n+    val params: Seq[Double]  // parameters used to initialized the distribution\n+\n+    def cdf(x: Double): Double // calculate the cdf under the given distribution for value x\n+\n+    def getCVs(n: Double): Map[Double, Double] // return appropriate CVs, adjusted for sample size\n+  }\n+\n+  /**\n+   * Critical values and adjustments for distributions sourced from\n+   * [[http://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-\n+   * test.pdf]]\n+   * [[https://github.com/scipy/scipy/blob/v0.15.1/scipy/stats/morestats.py#L1017]], which in turn\n+   * references:\n+   *\n+   * Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and\n+   * Some Comparisons, Journal of the American Statistical Association,\n+   * Vol. 69, pp. 730-737.\n+   *\n+   * Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit\n+   * Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,\n+   * pp. 357-369.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit for the Extreme Value\n+   * Distribution, Biometrika, Vol. 64, pp. 583-588.\n+   *\n+   * Stephens, M. A. (1977). Goodness of Fit with Special Reference\n+   * to Tests for Exponentiality , Technical Report No. 262,\n+   * Department of Statistics, Stanford University, Stanford, CA.\n+   *\n+   * Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution\n+   * Based on the Empirical Distribution Function, Biometrika, Vol. 66,\n+   * pp. 591-595.\n+   */\n+\n+  // Exponential distribution\n+  class AndersonDarlingExponential(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new ExponentialDistribution(params(0))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.922, 0.10 -> 1.078,\n+      0.05 -> 1.341, 0.025 -> 1.606, 0.01 -> 1.957\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.6 / n) }\n+    }\n+  }\n+\n+  // Normal Distribution\n+  class AndersonDarlingNormal(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new NormalDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.15 -> 0.576, 0.10 -> 0.656,\n+      0.05 -> 0.787, 0.025 -> 0.918, 0.01 -> 1.092\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 4.0 / n - 25.0 / (n * n)) }\n+    }\n+  }\n+\n+  // Gumbel distribution\n+  class AndersonDarlingGumbel(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new GumbelDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  // Logistic distribution\n+  class AndersonDarlingLogistic(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new LogisticDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.426, 0.10 -> 0.563, 0.05 -> 0.660,\n+      0.025 -> 0.769, 0.01 -> 0.906, 0.005 -> 1.010\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.25 / n) }\n+    }\n+  }\n+\n+  // Weibull distribution\n+  class AndersonDarlingWeibull(val params: Seq[Double]) extends AndersonDarlingTheoreticalDist {\n+    private val theoretical = new WeibullDistribution(params(0), params(1))\n+\n+    private val rawCVs = ListMap(\n+      0.25 -> 0.474, 0.10 -> 0.637,\n+      0.05 -> 0.757, 0.025 -> 0.877, 0.01 -> 1.038\n+    )\n+\n+    def cdf(x: Double): Double = theoretical.cumulativeProbability(x)\n+\n+    def getCVs(n: Double): Map[Double, Double] = {\n+      rawCVs.map { case (sig, cv) => sig -> cv / (1 + 0.2 / math.sqrt(n)) }\n+    }\n+  }\n+\n+  /**\n+   * Perform a one sample Anderson-Darling test\n+   * @param data data to test for a given distribution\n+   * @param distName name of theoretical distribution: currently supports normal,\n+   *            exponential, gumbel, logistic, weibull as\n+   *            ['norm', 'exp', 'gumbel', 'logistic', 'weibull']\n+   * @param params variable-length argument providing parameters for given distribution. When none\n+   *               are provided, default parameters appropriate to each distribution are chosen. In\n+   *               either case, critical values reflect adjustments that assume the parameters were\n+   *               estimated from the data\n+   * @return\n+   */\n+  @varargs\n+  def testOneSample(data: RDD[Double], distName: String, params: Double*)\n+    : AndersonDarlingTestResult = {\n+    val n = data.count()\n+    val dist = initDist(distName, params)\n+    val localData = data.sortBy(x => x).mapPartitions(calcPartAD(_, dist, n)).collect()\n+    val s = localData.foldLeft((0.0, 0.0)) { case ((prevStat, prevCt), (rawStat, adj, ct)) =>\n+      val adjVal = 2 * prevCt * adj\n+      val adjustedStat = rawStat + adjVal\n+      val cumCt = prevCt + ct\n+      (prevStat + adjustedStat, cumCt)\n+    }._1\n+    val ADStat = -1 * n - s / n\n+    val criticalVals = dist.getCVs(n)\n+    new AndersonDarlingTestResult(ADStat, criticalVals, NullHypothesis.OneSample.toString)\n+  }\n+\n+\n+  /**\n+   * Calculate a partition's contribution to the Anderson-Darling statistic.\n+   * In each partition we calculate 2 values, an unadjusted value that is contributed to the AD\n+   * statistic directly, a value that must be adjusted by the number of values in the prior",
    "line": 202
  }],
  "prId": 7278
}]