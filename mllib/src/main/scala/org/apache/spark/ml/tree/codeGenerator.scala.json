[{
  "comments": [{
    "author": {
      "login": "frreiss"
    },
    "body": "For small sets, this comparison really should be inlined. \nFor double-valued columns, you can generate a series of equality comparisons against constants OR'd together. If you choose the structure of the comparisons carefully, the JIT compiler should generate SIMD instructions that do four comparisons per clock cycle.\nFor integer-encoded columns with less than 64 categories, you can generate a bitwise AND against a single long constant.\n",
    "commit": "fb63e1f93f9a5f39f8b7e9d800c17d9da9ec1008",
    "createdAt": "2016-03-07T23:34:41Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree\n+\n+import org.codehaus.janino.ClassBodyEvaluator\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+\n+/**\n+ * An object for creating a code generated decision tree model.\n+ * NodeToTree is used to convert a node to a series if code gen\n+ * if/else statements conditions returning the predicition for a\n+ * given vector.\n+ * getScorer wraps this and provides a function we can use to get\n+ * the prediction.\n+ */\n+private[spark] object CodeGenerationDecisionTreeModel extends Logging {\n+  private val prefix = \"mllibCodeGen\"\n+  private val curId = new java.util.concurrent.atomic.AtomicInteger()\n+\n+  /**\n+   * Compile the Java source code into a Java class, using Janino.\n+   * Based on Spark SQL's implementation. This should be moved to a common class\n+   * once we have multiple code generators in ML.\n+   *\n+   * It will track the time used to compile\n+   */\n+  protected def compile(code: String, implements: Array[Class[_]]): Class[_] = {\n+    val startTime = System.nanoTime()\n+    val evaluator = new ClassBodyEvaluator()\n+    val clName = freshName()\n+    evaluator.setParentClassLoader(getClass.getClassLoader)\n+    evaluator.setImplementedInterfaces(implements)\n+    evaluator.setClassName(clName)\n+    evaluator.setDefaultImports(Array(\n+      \"org.apache.spark.mllib.linalg.Vectors\",\n+      \"org.apache.spark.mllib.linalg.Vector\"\n+    ))\n+    evaluator.cook(s\"${clName}.java\", code)\n+    val clazz = evaluator.getClazz()\n+    val endTime = System.nanoTime()\n+    def timeMs: Double = (endTime - startTime).toDouble / 1000000\n+    logDebug(s\"Compiled Java code (${code.size} bytes) in $timeMs ms\")\n+    clazz\n+  }\n+\n+  protected def freshName(): String = {\n+    s\"$prefix${curId.getAndIncrement}\"\n+  }\n+\n+\n+  /**\n+   * Convert the tree starting at the provided root node into a code generated\n+   * series of if/else statements. If the tree is too large to fit in a single\n+   * in-line method breaks it up into multiple methods.\n+   * Returns a string for the current function body and a string of any additional\n+   * functions.\n+   */\n+  def nodeToTree(root: Node, depth: Int): (String, String) = {\n+    // Handle the different types of nodes\n+    root match {\n+      case node: InternalNode => {\n+        // Handle trees that get too large to fit in a single in-line java method\n+        depth match {\n+          case 8 => {\n+            val newFunctionName = freshName()\n+            val newFunction = nodeToFunction(root, newFunctionName)\n+            (s\"return ${newFunctionName}(input);\", newFunction)\n+          }\n+          case _ => {\n+            val nodeSplit = node.split\n+            val (leftSubCode, leftSubFunction) = nodeToTree(node.leftChild, depth + 1)\n+            val (rightSubCode, rightSubFunction) = nodeToTree(node.rightChild, depth + 1)\n+            val subCode = nodeSplit match {\n+              case split: CategoricalSplit => {\n+                val isLeft = split.isLeft\n+                isLeft match {\n+                  case true => s\"\"\"\n+                              if (categories.contains(input.apply(${split.featureIndex}))) {"
  }, {
    "author": {
      "login": "holdenk"
    },
    "body": "Sounds like a good idea, I'll take a look at in-lining this for small sets.\n",
    "commit": "fb63e1f93f9a5f39f8b7e9d800c17d9da9ec1008",
    "createdAt": "2016-03-08T02:30:35Z",
    "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree\n+\n+import org.codehaus.janino.ClassBodyEvaluator\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.mllib.linalg.{Vector, Vectors}\n+\n+/**\n+ * An object for creating a code generated decision tree model.\n+ * NodeToTree is used to convert a node to a series if code gen\n+ * if/else statements conditions returning the predicition for a\n+ * given vector.\n+ * getScorer wraps this and provides a function we can use to get\n+ * the prediction.\n+ */\n+private[spark] object CodeGenerationDecisionTreeModel extends Logging {\n+  private val prefix = \"mllibCodeGen\"\n+  private val curId = new java.util.concurrent.atomic.AtomicInteger()\n+\n+  /**\n+   * Compile the Java source code into a Java class, using Janino.\n+   * Based on Spark SQL's implementation. This should be moved to a common class\n+   * once we have multiple code generators in ML.\n+   *\n+   * It will track the time used to compile\n+   */\n+  protected def compile(code: String, implements: Array[Class[_]]): Class[_] = {\n+    val startTime = System.nanoTime()\n+    val evaluator = new ClassBodyEvaluator()\n+    val clName = freshName()\n+    evaluator.setParentClassLoader(getClass.getClassLoader)\n+    evaluator.setImplementedInterfaces(implements)\n+    evaluator.setClassName(clName)\n+    evaluator.setDefaultImports(Array(\n+      \"org.apache.spark.mllib.linalg.Vectors\",\n+      \"org.apache.spark.mllib.linalg.Vector\"\n+    ))\n+    evaluator.cook(s\"${clName}.java\", code)\n+    val clazz = evaluator.getClazz()\n+    val endTime = System.nanoTime()\n+    def timeMs: Double = (endTime - startTime).toDouble / 1000000\n+    logDebug(s\"Compiled Java code (${code.size} bytes) in $timeMs ms\")\n+    clazz\n+  }\n+\n+  protected def freshName(): String = {\n+    s\"$prefix${curId.getAndIncrement}\"\n+  }\n+\n+\n+  /**\n+   * Convert the tree starting at the provided root node into a code generated\n+   * series of if/else statements. If the tree is too large to fit in a single\n+   * in-line method breaks it up into multiple methods.\n+   * Returns a string for the current function body and a string of any additional\n+   * functions.\n+   */\n+  def nodeToTree(root: Node, depth: Int): (String, String) = {\n+    // Handle the different types of nodes\n+    root match {\n+      case node: InternalNode => {\n+        // Handle trees that get too large to fit in a single in-line java method\n+        depth match {\n+          case 8 => {\n+            val newFunctionName = freshName()\n+            val newFunction = nodeToFunction(root, newFunctionName)\n+            (s\"return ${newFunctionName}(input);\", newFunction)\n+          }\n+          case _ => {\n+            val nodeSplit = node.split\n+            val (leftSubCode, leftSubFunction) = nodeToTree(node.leftChild, depth + 1)\n+            val (rightSubCode, rightSubFunction) = nodeToTree(node.rightChild, depth + 1)\n+            val subCode = nodeSplit match {\n+              case split: CategoricalSplit => {\n+                val isLeft = split.isLeft\n+                isLeft match {\n+                  case true => s\"\"\"\n+                              if (categories.contains(input.apply(${split.featureIndex}))) {"
  }],
  "prId": 9524
}]