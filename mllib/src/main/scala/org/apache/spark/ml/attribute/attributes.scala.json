[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "So, a `BinaryAttribute` is not a subclass of `NominalAttribute` here, for example. That would be lovely in the sense that algorithms could transparently deal with `NominalAttribute` and automatically handle binary. I struggled to declare it in a sensible way though in my PR. Do you think it's possible to get that back?\n",
    "commit": "71d1bd042360376b7f8f75ba6be3471f443ce34e",
    "createdAt": "2015-03-06T11:28:40Z",
    "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.attribute\n+\n+import scala.annotation.varargs\n+\n+import org.apache.spark.sql.types.{DoubleType, Metadata, MetadataBuilder, StructField}\n+\n+/**\n+ * Abstract class for ML attributes.\n+ */\n+sealed abstract class Attribute extends Serializable {\n+\n+  name.foreach { n =>\n+    require(n.nonEmpty, \"Cannot have an empty string for name.\")\n+  }\n+  index.foreach { i =>\n+    require(i >= 0, s\"Index cannot be negative but got $i\")\n+  }\n+\n+  /** Attribute type. */\n+  def attrType: AttributeType\n+\n+  /** Name of the attribute. None if it is not set. */\n+  def name: Option[String]\n+\n+  /** Copy with a new name. */\n+  def withName(name: String): Attribute\n+\n+  /** Copy without the name. */\n+  def withoutName: Attribute\n+\n+  /** Index of the attribute. None if it is not set. */\n+  def index: Option[Int]\n+\n+  /** Copy with a new index. */\n+  def withIndex(index: Int): Attribute\n+\n+  /** Copy without the index. */\n+  def withoutIndex: Attribute\n+\n+  /**\n+   * Tests whether this attribute is numeric, true for [[NumericAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNumeric: Boolean\n+\n+  /**\n+   * Tests whether this attribute is nominal, true for [[NominalAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNominal: Boolean\n+\n+  /**\n+   * Converts this attribute to [[Metadata]].\n+   * @param withType whether to include the type info\n+   */\n+  private[attribute] def toMetadata(withType: Boolean): Metadata\n+\n+  /**\n+   * Converts this attribute to [[Metadata]]. For numeric attributes, the type info is excluded to\n+   * save space, because numeric type is the default attribute type. For nominal and binary\n+   * attributes, the type info is included.\n+   */\n+  private[attribute] def toMetadata(): Metadata = {\n+    if (attrType == AttributeType.Numeric) {\n+      toMetadata(withType = false)\n+    } else {\n+      toMetadata(withType = true)\n+    }\n+  }\n+\n+  /**\n+   * Converts to a [[StructField]] with some existing metadata.\n+   * @param existingMetadata existing metadata to carry over\n+   */\n+  def toStructField(existingMetadata: Metadata): StructField = {\n+    val newMetadata = new MetadataBuilder()\n+      .withMetadata(existingMetadata)\n+      .putMetadata(AttributeKeys.ML_ATTR, withoutName.withoutIndex.toMetadata())\n+      .build()\n+    StructField(name.get, DoubleType, nullable = false, newMetadata)\n+  }\n+\n+  /** Converts to a [[StructField]]. */\n+  def toStructField(): StructField = toStructField(Metadata.empty)\n+\n+  override def toString: String = toMetadata(withType = true).toString\n+}\n+\n+/** Trait for ML attribute factories. */\n+private[attribute] trait AttributeFactory {\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[Metadata]] instance.\n+   */\n+  private[attribute] def fromMetadata(metadata: Metadata): Attribute\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[StructField]] instance.\n+   */\n+  def fromStructField(field: StructField): Attribute = {\n+    require(field.dataType == DoubleType)\n+    fromMetadata(field.metadata.getMetadata(AttributeKeys.ML_ATTR)).withName(field.name)\n+  }\n+}\n+\n+object Attribute extends AttributeFactory {\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): Attribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val attrType = if (metadata.contains(TYPE)) {\n+      metadata.getString(TYPE)\n+    } else {\n+      AttributeType.Numeric.name\n+    }\n+    getFactory(attrType).fromMetadata(metadata)\n+  }\n+\n+  /** Gets the attribute factory given the attribute type name. */\n+  private def getFactory(attrType: String): AttributeFactory = {\n+    if (attrType == AttributeType.Numeric.name) {\n+      NumericAttribute\n+    } else if (attrType == AttributeType.Nominal.name) {\n+      NominalAttribute\n+    } else if (attrType == AttributeType.Binary.name) {\n+      BinaryAttribute\n+    } else {\n+      throw new IllegalArgumentException(s\"Cannot recognize type $attrType.\")\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * A numeric attribute with optional summary statistics.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param min optional min value\n+ * @param max optional max value\n+ * @param std optional standard deviation\n+ * @param sparsity optional sparsity (ratio of zeros)\n+ */\n+class NumericAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val min: Option[Double] = None,\n+    val max: Option[Double] = None,\n+    val std: Option[Double] = None,\n+    val sparsity: Option[Double] = None) extends Attribute {\n+\n+  std.foreach { s =>\n+    require(s >= 0.0, s\"Standard deviation cannot be negative but got $s.\")\n+  }\n+  sparsity.foreach { s =>\n+    require(s >= 0.0 && s <= 1.0, s\"Sparsity must be in [0, 1] but got $s.\")\n+  }\n+\n+  override def attrType: AttributeType = AttributeType.Numeric\n+\n+  override def withName(name: String): NumericAttribute = copy(name = Some(name))\n+  override def withoutName: NumericAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NumericAttribute = copy(index = Some(index))\n+  override def withoutIndex: NumericAttribute = copy(index = None)\n+\n+  /** Copy with a new min value. */\n+  def withMin(min: Double): NumericAttribute = copy(min = Some(min))\n+\n+  /** Copy without the min value. */\n+  def withoutMin: NumericAttribute = copy(min = None)\n+\n+\n+  /** Copy with a new max value. */\n+  def withMax(max: Double): NumericAttribute = copy(max = Some(max))\n+\n+  /** Copy without the max value. */\n+  def withoutMax: NumericAttribute = copy(max = None)\n+\n+  /** Copy with a new standard deviation. */\n+  def withStd(std: Double): NumericAttribute = copy(std = Some(std))\n+\n+  /** Copy without the standard deviation. */\n+  def withoutStd: NumericAttribute = copy(std = None)\n+\n+  /** Copy with a new sparsity. */\n+  def withSparsity(sparsity: Double): NumericAttribute = copy(sparsity = Some(sparsity))\n+\n+  /** Copy without the sparsity. */\n+  def withoutSparsity: NumericAttribute = copy(sparsity = None)\n+\n+  /** Copy without summary statistics. */\n+  def withoutSummary: NumericAttribute = copy(min = None, max = None, std = None, sparsity = None)\n+\n+  override def isNumeric: Boolean = true\n+\n+  override def isNominal: Boolean = false\n+\n+  /** Convert this attribute to metadata. */\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    min.foreach(bldr.putDouble(MIN, _))\n+    max.foreach(bldr.putDouble(MAX, _))\n+    std.foreach(bldr.putDouble(STD, _))\n+    sparsity.foreach(bldr.putDouble(SPARSITY, _))\n+    bldr.build()\n+  }\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      min: Option[Double] = min,\n+      max: Option[Double] = max,\n+      std: Option[Double] = std,\n+      sparsity: Option[Double] = sparsity): NumericAttribute = {\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NumericAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (min == o.min) &&\n+          (max == o.max) &&\n+          (std == o.std) &&\n+          (sparsity == o.sparsity)\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + min.hashCode\n+    sum = 37 * sum + max.hashCode\n+    sum = 37 * sum + std.hashCode\n+    sum = 37 * sum + sparsity.hashCode\n+    sum\n+  }\n+}\n+\n+/**\n+ * Factory methods for numeric attributes.\n+ */\n+object NumericAttribute extends AttributeFactory {\n+\n+  /** The default numeric attribute. */\n+  val defaultAttr: NumericAttribute = new NumericAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NumericAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val min = if (metadata.contains(MIN)) Some(metadata.getDouble(MIN)) else None\n+    val max = if (metadata.contains(MAX)) Some(metadata.getDouble(MAX)) else None\n+    val std = if (metadata.contains(STD)) Some(metadata.getDouble(STD)) else None\n+    val sparsity = if (metadata.contains(SPARSITY)) Some(metadata.getDouble(SPARSITY)) else None\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+}\n+\n+/**\n+ * A nominal attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param isOrdinal whether this attribute is ordinal (optional)\n+ * @param numValues optional number of values. At most one of `numValues` and `values` can be\n+ *                  defined.\n+ * @param values optional values. At most one of `numValues` and `values` can be defined.\n+ */\n+class NominalAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val isOrdinal: Option[Boolean] = None,\n+    val numValues: Option[Int] = None,\n+    val values: Option[Array[String]] = None) extends Attribute {\n+\n+  numValues.foreach { n =>\n+    require(n >= 0, s\"numValues cannot be negative but got $n.\")\n+  }\n+  require(!(numValues.isDefined && values.isDefined),\n+    \"Cannot have both numValues and values defined.\")\n+\n+  override def attrType: AttributeType = AttributeType.Nominal\n+\n+  override def isNumeric: Boolean = false\n+\n+  override def isNominal: Boolean = true\n+\n+  private lazy val valueToIndex: Map[String, Int] = {\n+    values.map(_.zipWithIndex.toMap).getOrElse(Map.empty)\n+  }\n+\n+  /** Index of a specific value. */\n+  def indexOf(value: String): Int = {\n+    valueToIndex(value)\n+  }\n+\n+  /** Tests whether this attribute contains a specific value. */\n+  def hasValue(value: String): Boolean = valueToIndex.contains(value)\n+\n+  /** Gets a value given its index. */\n+  def getValue(index: Int): String = values.get(index)\n+\n+  override def withName(name: String): NominalAttribute = copy(name = Some(name))\n+  override def withoutName: NominalAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NominalAttribute = copy(index = Some(index))\n+  override def withoutIndex: NominalAttribute = copy(index = None)\n+\n+  /** Copy with new values and empty `numValues`. */\n+  def withValues(values: Array[String]): NominalAttribute = {\n+    copy(numValues = None, values = Some(values))\n+  }\n+\n+  /** Copy with new values and empty `numValues`. */\n+  @varargs\n+  def withValues(first: String, others: String*): NominalAttribute = {\n+    copy(numValues = None, values = Some((first +: others).toArray))\n+  }\n+\n+  /** Copy without the values. */\n+  def withoutValues: NominalAttribute = {\n+    copy(values = None)\n+  }\n+\n+  /** Copy with a new `numValues` and empty `values`. */\n+  def withNumValues(numValues: Int): NominalAttribute = {\n+    copy(numValues = Some(numValues), values = None)\n+  }\n+\n+  /** Copy without the `numValues`. */\n+  def withoutNumValues: NominalAttribute = copy(numValues = None)\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      isOrdinal: Option[Boolean] = isOrdinal,\n+      numValues: Option[Int] = numValues,\n+      values: Option[Array[String]] = values): NominalAttribute = {\n+    new NominalAttribute(name, index, isOrdinal, numValues, values)\n+  }\n+\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    isOrdinal.foreach(bldr.putBoolean(ORDINAL, _))\n+    numValues.foreach(bldr.putLong(CARDINALITY, _))\n+    values.foreach(v => bldr.putStringArray(VALUES, v))\n+    bldr.build()\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NominalAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (isOrdinal == o.isOrdinal) &&\n+          (numValues == o.numValues) &&\n+          (values.map(_.toSeq) == o.values.map(_.toSeq))\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + isOrdinal.hashCode\n+    sum = 37 * sum + numValues.hashCode\n+    sum = 37 * sum + values.map(_.toSeq).hashCode\n+    sum\n+  }\n+}\n+\n+/** Factory methods for nominal attributes. */\n+object NominalAttribute extends AttributeFactory {\n+\n+  /** The default nominal attribute. */\n+  final val defaultAttr: NominalAttribute = new NominalAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NominalAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val isOrdinal = if (metadata.contains(ORDINAL)) Some(metadata.getBoolean(ORDINAL)) else None\n+    val cardinality =\n+      if (metadata.contains(CARDINALITY)) Some(metadata.getLong(CARDINALITY).toInt) else None\n+    val values =\n+      if (metadata.contains(VALUES)) Some(metadata.getStringArray(VALUES)) else None\n+    new NominalAttribute(name, index, isOrdinal, cardinality, values)\n+  }\n+}\n+\n+/**\n+ * A binary attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param values optionla values. If set, its size must be 2.\n+ */\n+class BinaryAttribute private[ml] (",
    "line": 427
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I put `isNominal` and `isNumeric` in the `Attribute` field. We can let it extend `NominalAttribute` but then the question is whether we should let it extend `NumericAttribute` too. But it cannot extend both technically.\n",
    "commit": "71d1bd042360376b7f8f75ba6be3471f443ce34e",
    "createdAt": "2015-03-06T16:52:21Z",
    "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.attribute\n+\n+import scala.annotation.varargs\n+\n+import org.apache.spark.sql.types.{DoubleType, Metadata, MetadataBuilder, StructField}\n+\n+/**\n+ * Abstract class for ML attributes.\n+ */\n+sealed abstract class Attribute extends Serializable {\n+\n+  name.foreach { n =>\n+    require(n.nonEmpty, \"Cannot have an empty string for name.\")\n+  }\n+  index.foreach { i =>\n+    require(i >= 0, s\"Index cannot be negative but got $i\")\n+  }\n+\n+  /** Attribute type. */\n+  def attrType: AttributeType\n+\n+  /** Name of the attribute. None if it is not set. */\n+  def name: Option[String]\n+\n+  /** Copy with a new name. */\n+  def withName(name: String): Attribute\n+\n+  /** Copy without the name. */\n+  def withoutName: Attribute\n+\n+  /** Index of the attribute. None if it is not set. */\n+  def index: Option[Int]\n+\n+  /** Copy with a new index. */\n+  def withIndex(index: Int): Attribute\n+\n+  /** Copy without the index. */\n+  def withoutIndex: Attribute\n+\n+  /**\n+   * Tests whether this attribute is numeric, true for [[NumericAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNumeric: Boolean\n+\n+  /**\n+   * Tests whether this attribute is nominal, true for [[NominalAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNominal: Boolean\n+\n+  /**\n+   * Converts this attribute to [[Metadata]].\n+   * @param withType whether to include the type info\n+   */\n+  private[attribute] def toMetadata(withType: Boolean): Metadata\n+\n+  /**\n+   * Converts this attribute to [[Metadata]]. For numeric attributes, the type info is excluded to\n+   * save space, because numeric type is the default attribute type. For nominal and binary\n+   * attributes, the type info is included.\n+   */\n+  private[attribute] def toMetadata(): Metadata = {\n+    if (attrType == AttributeType.Numeric) {\n+      toMetadata(withType = false)\n+    } else {\n+      toMetadata(withType = true)\n+    }\n+  }\n+\n+  /**\n+   * Converts to a [[StructField]] with some existing metadata.\n+   * @param existingMetadata existing metadata to carry over\n+   */\n+  def toStructField(existingMetadata: Metadata): StructField = {\n+    val newMetadata = new MetadataBuilder()\n+      .withMetadata(existingMetadata)\n+      .putMetadata(AttributeKeys.ML_ATTR, withoutName.withoutIndex.toMetadata())\n+      .build()\n+    StructField(name.get, DoubleType, nullable = false, newMetadata)\n+  }\n+\n+  /** Converts to a [[StructField]]. */\n+  def toStructField(): StructField = toStructField(Metadata.empty)\n+\n+  override def toString: String = toMetadata(withType = true).toString\n+}\n+\n+/** Trait for ML attribute factories. */\n+private[attribute] trait AttributeFactory {\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[Metadata]] instance.\n+   */\n+  private[attribute] def fromMetadata(metadata: Metadata): Attribute\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[StructField]] instance.\n+   */\n+  def fromStructField(field: StructField): Attribute = {\n+    require(field.dataType == DoubleType)\n+    fromMetadata(field.metadata.getMetadata(AttributeKeys.ML_ATTR)).withName(field.name)\n+  }\n+}\n+\n+object Attribute extends AttributeFactory {\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): Attribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val attrType = if (metadata.contains(TYPE)) {\n+      metadata.getString(TYPE)\n+    } else {\n+      AttributeType.Numeric.name\n+    }\n+    getFactory(attrType).fromMetadata(metadata)\n+  }\n+\n+  /** Gets the attribute factory given the attribute type name. */\n+  private def getFactory(attrType: String): AttributeFactory = {\n+    if (attrType == AttributeType.Numeric.name) {\n+      NumericAttribute\n+    } else if (attrType == AttributeType.Nominal.name) {\n+      NominalAttribute\n+    } else if (attrType == AttributeType.Binary.name) {\n+      BinaryAttribute\n+    } else {\n+      throw new IllegalArgumentException(s\"Cannot recognize type $attrType.\")\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * A numeric attribute with optional summary statistics.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param min optional min value\n+ * @param max optional max value\n+ * @param std optional standard deviation\n+ * @param sparsity optional sparsity (ratio of zeros)\n+ */\n+class NumericAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val min: Option[Double] = None,\n+    val max: Option[Double] = None,\n+    val std: Option[Double] = None,\n+    val sparsity: Option[Double] = None) extends Attribute {\n+\n+  std.foreach { s =>\n+    require(s >= 0.0, s\"Standard deviation cannot be negative but got $s.\")\n+  }\n+  sparsity.foreach { s =>\n+    require(s >= 0.0 && s <= 1.0, s\"Sparsity must be in [0, 1] but got $s.\")\n+  }\n+\n+  override def attrType: AttributeType = AttributeType.Numeric\n+\n+  override def withName(name: String): NumericAttribute = copy(name = Some(name))\n+  override def withoutName: NumericAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NumericAttribute = copy(index = Some(index))\n+  override def withoutIndex: NumericAttribute = copy(index = None)\n+\n+  /** Copy with a new min value. */\n+  def withMin(min: Double): NumericAttribute = copy(min = Some(min))\n+\n+  /** Copy without the min value. */\n+  def withoutMin: NumericAttribute = copy(min = None)\n+\n+\n+  /** Copy with a new max value. */\n+  def withMax(max: Double): NumericAttribute = copy(max = Some(max))\n+\n+  /** Copy without the max value. */\n+  def withoutMax: NumericAttribute = copy(max = None)\n+\n+  /** Copy with a new standard deviation. */\n+  def withStd(std: Double): NumericAttribute = copy(std = Some(std))\n+\n+  /** Copy without the standard deviation. */\n+  def withoutStd: NumericAttribute = copy(std = None)\n+\n+  /** Copy with a new sparsity. */\n+  def withSparsity(sparsity: Double): NumericAttribute = copy(sparsity = Some(sparsity))\n+\n+  /** Copy without the sparsity. */\n+  def withoutSparsity: NumericAttribute = copy(sparsity = None)\n+\n+  /** Copy without summary statistics. */\n+  def withoutSummary: NumericAttribute = copy(min = None, max = None, std = None, sparsity = None)\n+\n+  override def isNumeric: Boolean = true\n+\n+  override def isNominal: Boolean = false\n+\n+  /** Convert this attribute to metadata. */\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    min.foreach(bldr.putDouble(MIN, _))\n+    max.foreach(bldr.putDouble(MAX, _))\n+    std.foreach(bldr.putDouble(STD, _))\n+    sparsity.foreach(bldr.putDouble(SPARSITY, _))\n+    bldr.build()\n+  }\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      min: Option[Double] = min,\n+      max: Option[Double] = max,\n+      std: Option[Double] = std,\n+      sparsity: Option[Double] = sparsity): NumericAttribute = {\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NumericAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (min == o.min) &&\n+          (max == o.max) &&\n+          (std == o.std) &&\n+          (sparsity == o.sparsity)\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + min.hashCode\n+    sum = 37 * sum + max.hashCode\n+    sum = 37 * sum + std.hashCode\n+    sum = 37 * sum + sparsity.hashCode\n+    sum\n+  }\n+}\n+\n+/**\n+ * Factory methods for numeric attributes.\n+ */\n+object NumericAttribute extends AttributeFactory {\n+\n+  /** The default numeric attribute. */\n+  val defaultAttr: NumericAttribute = new NumericAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NumericAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val min = if (metadata.contains(MIN)) Some(metadata.getDouble(MIN)) else None\n+    val max = if (metadata.contains(MAX)) Some(metadata.getDouble(MAX)) else None\n+    val std = if (metadata.contains(STD)) Some(metadata.getDouble(STD)) else None\n+    val sparsity = if (metadata.contains(SPARSITY)) Some(metadata.getDouble(SPARSITY)) else None\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+}\n+\n+/**\n+ * A nominal attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param isOrdinal whether this attribute is ordinal (optional)\n+ * @param numValues optional number of values. At most one of `numValues` and `values` can be\n+ *                  defined.\n+ * @param values optional values. At most one of `numValues` and `values` can be defined.\n+ */\n+class NominalAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val isOrdinal: Option[Boolean] = None,\n+    val numValues: Option[Int] = None,\n+    val values: Option[Array[String]] = None) extends Attribute {\n+\n+  numValues.foreach { n =>\n+    require(n >= 0, s\"numValues cannot be negative but got $n.\")\n+  }\n+  require(!(numValues.isDefined && values.isDefined),\n+    \"Cannot have both numValues and values defined.\")\n+\n+  override def attrType: AttributeType = AttributeType.Nominal\n+\n+  override def isNumeric: Boolean = false\n+\n+  override def isNominal: Boolean = true\n+\n+  private lazy val valueToIndex: Map[String, Int] = {\n+    values.map(_.zipWithIndex.toMap).getOrElse(Map.empty)\n+  }\n+\n+  /** Index of a specific value. */\n+  def indexOf(value: String): Int = {\n+    valueToIndex(value)\n+  }\n+\n+  /** Tests whether this attribute contains a specific value. */\n+  def hasValue(value: String): Boolean = valueToIndex.contains(value)\n+\n+  /** Gets a value given its index. */\n+  def getValue(index: Int): String = values.get(index)\n+\n+  override def withName(name: String): NominalAttribute = copy(name = Some(name))\n+  override def withoutName: NominalAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NominalAttribute = copy(index = Some(index))\n+  override def withoutIndex: NominalAttribute = copy(index = None)\n+\n+  /** Copy with new values and empty `numValues`. */\n+  def withValues(values: Array[String]): NominalAttribute = {\n+    copy(numValues = None, values = Some(values))\n+  }\n+\n+  /** Copy with new values and empty `numValues`. */\n+  @varargs\n+  def withValues(first: String, others: String*): NominalAttribute = {\n+    copy(numValues = None, values = Some((first +: others).toArray))\n+  }\n+\n+  /** Copy without the values. */\n+  def withoutValues: NominalAttribute = {\n+    copy(values = None)\n+  }\n+\n+  /** Copy with a new `numValues` and empty `values`. */\n+  def withNumValues(numValues: Int): NominalAttribute = {\n+    copy(numValues = Some(numValues), values = None)\n+  }\n+\n+  /** Copy without the `numValues`. */\n+  def withoutNumValues: NominalAttribute = copy(numValues = None)\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      isOrdinal: Option[Boolean] = isOrdinal,\n+      numValues: Option[Int] = numValues,\n+      values: Option[Array[String]] = values): NominalAttribute = {\n+    new NominalAttribute(name, index, isOrdinal, numValues, values)\n+  }\n+\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    isOrdinal.foreach(bldr.putBoolean(ORDINAL, _))\n+    numValues.foreach(bldr.putLong(CARDINALITY, _))\n+    values.foreach(v => bldr.putStringArray(VALUES, v))\n+    bldr.build()\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NominalAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (isOrdinal == o.isOrdinal) &&\n+          (numValues == o.numValues) &&\n+          (values.map(_.toSeq) == o.values.map(_.toSeq))\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + isOrdinal.hashCode\n+    sum = 37 * sum + numValues.hashCode\n+    sum = 37 * sum + values.map(_.toSeq).hashCode\n+    sum\n+  }\n+}\n+\n+/** Factory methods for nominal attributes. */\n+object NominalAttribute extends AttributeFactory {\n+\n+  /** The default nominal attribute. */\n+  final val defaultAttr: NominalAttribute = new NominalAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NominalAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val isOrdinal = if (metadata.contains(ORDINAL)) Some(metadata.getBoolean(ORDINAL)) else None\n+    val cardinality =\n+      if (metadata.contains(CARDINALITY)) Some(metadata.getLong(CARDINALITY).toInt) else None\n+    val values =\n+      if (metadata.contains(VALUES)) Some(metadata.getStringArray(VALUES)) else None\n+    new NominalAttribute(name, index, isOrdinal, cardinality, values)\n+  }\n+}\n+\n+/**\n+ * A binary attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param values optionla values. If set, its size must be 2.\n+ */\n+class BinaryAttribute private[ml] (",
    "line": 427
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Yeah that's what I was struggling with by declaring a number of traits instead in my PR. There was no good solution although you could sort of get it to work with nominal/numeric traits, with concrete classes extending them. I didn't like it.\n",
    "commit": "71d1bd042360376b7f8f75ba6be3471f443ce34e",
    "createdAt": "2015-03-06T16:59:50Z",
    "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.attribute\n+\n+import scala.annotation.varargs\n+\n+import org.apache.spark.sql.types.{DoubleType, Metadata, MetadataBuilder, StructField}\n+\n+/**\n+ * Abstract class for ML attributes.\n+ */\n+sealed abstract class Attribute extends Serializable {\n+\n+  name.foreach { n =>\n+    require(n.nonEmpty, \"Cannot have an empty string for name.\")\n+  }\n+  index.foreach { i =>\n+    require(i >= 0, s\"Index cannot be negative but got $i\")\n+  }\n+\n+  /** Attribute type. */\n+  def attrType: AttributeType\n+\n+  /** Name of the attribute. None if it is not set. */\n+  def name: Option[String]\n+\n+  /** Copy with a new name. */\n+  def withName(name: String): Attribute\n+\n+  /** Copy without the name. */\n+  def withoutName: Attribute\n+\n+  /** Index of the attribute. None if it is not set. */\n+  def index: Option[Int]\n+\n+  /** Copy with a new index. */\n+  def withIndex(index: Int): Attribute\n+\n+  /** Copy without the index. */\n+  def withoutIndex: Attribute\n+\n+  /**\n+   * Tests whether this attribute is numeric, true for [[NumericAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNumeric: Boolean\n+\n+  /**\n+   * Tests whether this attribute is nominal, true for [[NominalAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNominal: Boolean\n+\n+  /**\n+   * Converts this attribute to [[Metadata]].\n+   * @param withType whether to include the type info\n+   */\n+  private[attribute] def toMetadata(withType: Boolean): Metadata\n+\n+  /**\n+   * Converts this attribute to [[Metadata]]. For numeric attributes, the type info is excluded to\n+   * save space, because numeric type is the default attribute type. For nominal and binary\n+   * attributes, the type info is included.\n+   */\n+  private[attribute] def toMetadata(): Metadata = {\n+    if (attrType == AttributeType.Numeric) {\n+      toMetadata(withType = false)\n+    } else {\n+      toMetadata(withType = true)\n+    }\n+  }\n+\n+  /**\n+   * Converts to a [[StructField]] with some existing metadata.\n+   * @param existingMetadata existing metadata to carry over\n+   */\n+  def toStructField(existingMetadata: Metadata): StructField = {\n+    val newMetadata = new MetadataBuilder()\n+      .withMetadata(existingMetadata)\n+      .putMetadata(AttributeKeys.ML_ATTR, withoutName.withoutIndex.toMetadata())\n+      .build()\n+    StructField(name.get, DoubleType, nullable = false, newMetadata)\n+  }\n+\n+  /** Converts to a [[StructField]]. */\n+  def toStructField(): StructField = toStructField(Metadata.empty)\n+\n+  override def toString: String = toMetadata(withType = true).toString\n+}\n+\n+/** Trait for ML attribute factories. */\n+private[attribute] trait AttributeFactory {\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[Metadata]] instance.\n+   */\n+  private[attribute] def fromMetadata(metadata: Metadata): Attribute\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[StructField]] instance.\n+   */\n+  def fromStructField(field: StructField): Attribute = {\n+    require(field.dataType == DoubleType)\n+    fromMetadata(field.metadata.getMetadata(AttributeKeys.ML_ATTR)).withName(field.name)\n+  }\n+}\n+\n+object Attribute extends AttributeFactory {\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): Attribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val attrType = if (metadata.contains(TYPE)) {\n+      metadata.getString(TYPE)\n+    } else {\n+      AttributeType.Numeric.name\n+    }\n+    getFactory(attrType).fromMetadata(metadata)\n+  }\n+\n+  /** Gets the attribute factory given the attribute type name. */\n+  private def getFactory(attrType: String): AttributeFactory = {\n+    if (attrType == AttributeType.Numeric.name) {\n+      NumericAttribute\n+    } else if (attrType == AttributeType.Nominal.name) {\n+      NominalAttribute\n+    } else if (attrType == AttributeType.Binary.name) {\n+      BinaryAttribute\n+    } else {\n+      throw new IllegalArgumentException(s\"Cannot recognize type $attrType.\")\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * A numeric attribute with optional summary statistics.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param min optional min value\n+ * @param max optional max value\n+ * @param std optional standard deviation\n+ * @param sparsity optional sparsity (ratio of zeros)\n+ */\n+class NumericAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val min: Option[Double] = None,\n+    val max: Option[Double] = None,\n+    val std: Option[Double] = None,\n+    val sparsity: Option[Double] = None) extends Attribute {\n+\n+  std.foreach { s =>\n+    require(s >= 0.0, s\"Standard deviation cannot be negative but got $s.\")\n+  }\n+  sparsity.foreach { s =>\n+    require(s >= 0.0 && s <= 1.0, s\"Sparsity must be in [0, 1] but got $s.\")\n+  }\n+\n+  override def attrType: AttributeType = AttributeType.Numeric\n+\n+  override def withName(name: String): NumericAttribute = copy(name = Some(name))\n+  override def withoutName: NumericAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NumericAttribute = copy(index = Some(index))\n+  override def withoutIndex: NumericAttribute = copy(index = None)\n+\n+  /** Copy with a new min value. */\n+  def withMin(min: Double): NumericAttribute = copy(min = Some(min))\n+\n+  /** Copy without the min value. */\n+  def withoutMin: NumericAttribute = copy(min = None)\n+\n+\n+  /** Copy with a new max value. */\n+  def withMax(max: Double): NumericAttribute = copy(max = Some(max))\n+\n+  /** Copy without the max value. */\n+  def withoutMax: NumericAttribute = copy(max = None)\n+\n+  /** Copy with a new standard deviation. */\n+  def withStd(std: Double): NumericAttribute = copy(std = Some(std))\n+\n+  /** Copy without the standard deviation. */\n+  def withoutStd: NumericAttribute = copy(std = None)\n+\n+  /** Copy with a new sparsity. */\n+  def withSparsity(sparsity: Double): NumericAttribute = copy(sparsity = Some(sparsity))\n+\n+  /** Copy without the sparsity. */\n+  def withoutSparsity: NumericAttribute = copy(sparsity = None)\n+\n+  /** Copy without summary statistics. */\n+  def withoutSummary: NumericAttribute = copy(min = None, max = None, std = None, sparsity = None)\n+\n+  override def isNumeric: Boolean = true\n+\n+  override def isNominal: Boolean = false\n+\n+  /** Convert this attribute to metadata. */\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    min.foreach(bldr.putDouble(MIN, _))\n+    max.foreach(bldr.putDouble(MAX, _))\n+    std.foreach(bldr.putDouble(STD, _))\n+    sparsity.foreach(bldr.putDouble(SPARSITY, _))\n+    bldr.build()\n+  }\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      min: Option[Double] = min,\n+      max: Option[Double] = max,\n+      std: Option[Double] = std,\n+      sparsity: Option[Double] = sparsity): NumericAttribute = {\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NumericAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (min == o.min) &&\n+          (max == o.max) &&\n+          (std == o.std) &&\n+          (sparsity == o.sparsity)\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + min.hashCode\n+    sum = 37 * sum + max.hashCode\n+    sum = 37 * sum + std.hashCode\n+    sum = 37 * sum + sparsity.hashCode\n+    sum\n+  }\n+}\n+\n+/**\n+ * Factory methods for numeric attributes.\n+ */\n+object NumericAttribute extends AttributeFactory {\n+\n+  /** The default numeric attribute. */\n+  val defaultAttr: NumericAttribute = new NumericAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NumericAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val min = if (metadata.contains(MIN)) Some(metadata.getDouble(MIN)) else None\n+    val max = if (metadata.contains(MAX)) Some(metadata.getDouble(MAX)) else None\n+    val std = if (metadata.contains(STD)) Some(metadata.getDouble(STD)) else None\n+    val sparsity = if (metadata.contains(SPARSITY)) Some(metadata.getDouble(SPARSITY)) else None\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+}\n+\n+/**\n+ * A nominal attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param isOrdinal whether this attribute is ordinal (optional)\n+ * @param numValues optional number of values. At most one of `numValues` and `values` can be\n+ *                  defined.\n+ * @param values optional values. At most one of `numValues` and `values` can be defined.\n+ */\n+class NominalAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val isOrdinal: Option[Boolean] = None,\n+    val numValues: Option[Int] = None,\n+    val values: Option[Array[String]] = None) extends Attribute {\n+\n+  numValues.foreach { n =>\n+    require(n >= 0, s\"numValues cannot be negative but got $n.\")\n+  }\n+  require(!(numValues.isDefined && values.isDefined),\n+    \"Cannot have both numValues and values defined.\")\n+\n+  override def attrType: AttributeType = AttributeType.Nominal\n+\n+  override def isNumeric: Boolean = false\n+\n+  override def isNominal: Boolean = true\n+\n+  private lazy val valueToIndex: Map[String, Int] = {\n+    values.map(_.zipWithIndex.toMap).getOrElse(Map.empty)\n+  }\n+\n+  /** Index of a specific value. */\n+  def indexOf(value: String): Int = {\n+    valueToIndex(value)\n+  }\n+\n+  /** Tests whether this attribute contains a specific value. */\n+  def hasValue(value: String): Boolean = valueToIndex.contains(value)\n+\n+  /** Gets a value given its index. */\n+  def getValue(index: Int): String = values.get(index)\n+\n+  override def withName(name: String): NominalAttribute = copy(name = Some(name))\n+  override def withoutName: NominalAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NominalAttribute = copy(index = Some(index))\n+  override def withoutIndex: NominalAttribute = copy(index = None)\n+\n+  /** Copy with new values and empty `numValues`. */\n+  def withValues(values: Array[String]): NominalAttribute = {\n+    copy(numValues = None, values = Some(values))\n+  }\n+\n+  /** Copy with new values and empty `numValues`. */\n+  @varargs\n+  def withValues(first: String, others: String*): NominalAttribute = {\n+    copy(numValues = None, values = Some((first +: others).toArray))\n+  }\n+\n+  /** Copy without the values. */\n+  def withoutValues: NominalAttribute = {\n+    copy(values = None)\n+  }\n+\n+  /** Copy with a new `numValues` and empty `values`. */\n+  def withNumValues(numValues: Int): NominalAttribute = {\n+    copy(numValues = Some(numValues), values = None)\n+  }\n+\n+  /** Copy without the `numValues`. */\n+  def withoutNumValues: NominalAttribute = copy(numValues = None)\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      isOrdinal: Option[Boolean] = isOrdinal,\n+      numValues: Option[Int] = numValues,\n+      values: Option[Array[String]] = values): NominalAttribute = {\n+    new NominalAttribute(name, index, isOrdinal, numValues, values)\n+  }\n+\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    isOrdinal.foreach(bldr.putBoolean(ORDINAL, _))\n+    numValues.foreach(bldr.putLong(CARDINALITY, _))\n+    values.foreach(v => bldr.putStringArray(VALUES, v))\n+    bldr.build()\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NominalAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (isOrdinal == o.isOrdinal) &&\n+          (numValues == o.numValues) &&\n+          (values.map(_.toSeq) == o.values.map(_.toSeq))\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + isOrdinal.hashCode\n+    sum = 37 * sum + numValues.hashCode\n+    sum = 37 * sum + values.map(_.toSeq).hashCode\n+    sum\n+  }\n+}\n+\n+/** Factory methods for nominal attributes. */\n+object NominalAttribute extends AttributeFactory {\n+\n+  /** The default nominal attribute. */\n+  final val defaultAttr: NominalAttribute = new NominalAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NominalAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val isOrdinal = if (metadata.contains(ORDINAL)) Some(metadata.getBoolean(ORDINAL)) else None\n+    val cardinality =\n+      if (metadata.contains(CARDINALITY)) Some(metadata.getLong(CARDINALITY).toInt) else None\n+    val values =\n+      if (metadata.contains(VALUES)) Some(metadata.getStringArray(VALUES)) else None\n+    new NominalAttribute(name, index, isOrdinal, cardinality, values)\n+  }\n+}\n+\n+/**\n+ * A binary attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param values optionla values. If set, its size must be 2.\n+ */\n+class BinaryAttribute private[ml] (",
    "line": 427
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "We can define traits like `NumericLike`, `HasSummary`, `NominalLike`. Then `NumericAttribute` extends `NumericLike` with `HasSummary`, `NominalAttribute` extends `NominalLike`, and `BinaryAttribute` extends `NumericLike` and `NominalLike`.\n\nI don't know whether this is really useful in implementing feature transformers. I think it might be better if we merge this, then try a few feature transformers like `LabelIndexer` and `OneHotEncoder` and see whether the APIs are sufficient. Does it sound good to you?\n",
    "commit": "71d1bd042360376b7f8f75ba6be3471f443ce34e",
    "createdAt": "2015-03-06T22:53:08Z",
    "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.attribute\n+\n+import scala.annotation.varargs\n+\n+import org.apache.spark.sql.types.{DoubleType, Metadata, MetadataBuilder, StructField}\n+\n+/**\n+ * Abstract class for ML attributes.\n+ */\n+sealed abstract class Attribute extends Serializable {\n+\n+  name.foreach { n =>\n+    require(n.nonEmpty, \"Cannot have an empty string for name.\")\n+  }\n+  index.foreach { i =>\n+    require(i >= 0, s\"Index cannot be negative but got $i\")\n+  }\n+\n+  /** Attribute type. */\n+  def attrType: AttributeType\n+\n+  /** Name of the attribute. None if it is not set. */\n+  def name: Option[String]\n+\n+  /** Copy with a new name. */\n+  def withName(name: String): Attribute\n+\n+  /** Copy without the name. */\n+  def withoutName: Attribute\n+\n+  /** Index of the attribute. None if it is not set. */\n+  def index: Option[Int]\n+\n+  /** Copy with a new index. */\n+  def withIndex(index: Int): Attribute\n+\n+  /** Copy without the index. */\n+  def withoutIndex: Attribute\n+\n+  /**\n+   * Tests whether this attribute is numeric, true for [[NumericAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNumeric: Boolean\n+\n+  /**\n+   * Tests whether this attribute is nominal, true for [[NominalAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNominal: Boolean\n+\n+  /**\n+   * Converts this attribute to [[Metadata]].\n+   * @param withType whether to include the type info\n+   */\n+  private[attribute] def toMetadata(withType: Boolean): Metadata\n+\n+  /**\n+   * Converts this attribute to [[Metadata]]. For numeric attributes, the type info is excluded to\n+   * save space, because numeric type is the default attribute type. For nominal and binary\n+   * attributes, the type info is included.\n+   */\n+  private[attribute] def toMetadata(): Metadata = {\n+    if (attrType == AttributeType.Numeric) {\n+      toMetadata(withType = false)\n+    } else {\n+      toMetadata(withType = true)\n+    }\n+  }\n+\n+  /**\n+   * Converts to a [[StructField]] with some existing metadata.\n+   * @param existingMetadata existing metadata to carry over\n+   */\n+  def toStructField(existingMetadata: Metadata): StructField = {\n+    val newMetadata = new MetadataBuilder()\n+      .withMetadata(existingMetadata)\n+      .putMetadata(AttributeKeys.ML_ATTR, withoutName.withoutIndex.toMetadata())\n+      .build()\n+    StructField(name.get, DoubleType, nullable = false, newMetadata)\n+  }\n+\n+  /** Converts to a [[StructField]]. */\n+  def toStructField(): StructField = toStructField(Metadata.empty)\n+\n+  override def toString: String = toMetadata(withType = true).toString\n+}\n+\n+/** Trait for ML attribute factories. */\n+private[attribute] trait AttributeFactory {\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[Metadata]] instance.\n+   */\n+  private[attribute] def fromMetadata(metadata: Metadata): Attribute\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[StructField]] instance.\n+   */\n+  def fromStructField(field: StructField): Attribute = {\n+    require(field.dataType == DoubleType)\n+    fromMetadata(field.metadata.getMetadata(AttributeKeys.ML_ATTR)).withName(field.name)\n+  }\n+}\n+\n+object Attribute extends AttributeFactory {\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): Attribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val attrType = if (metadata.contains(TYPE)) {\n+      metadata.getString(TYPE)\n+    } else {\n+      AttributeType.Numeric.name\n+    }\n+    getFactory(attrType).fromMetadata(metadata)\n+  }\n+\n+  /** Gets the attribute factory given the attribute type name. */\n+  private def getFactory(attrType: String): AttributeFactory = {\n+    if (attrType == AttributeType.Numeric.name) {\n+      NumericAttribute\n+    } else if (attrType == AttributeType.Nominal.name) {\n+      NominalAttribute\n+    } else if (attrType == AttributeType.Binary.name) {\n+      BinaryAttribute\n+    } else {\n+      throw new IllegalArgumentException(s\"Cannot recognize type $attrType.\")\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * A numeric attribute with optional summary statistics.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param min optional min value\n+ * @param max optional max value\n+ * @param std optional standard deviation\n+ * @param sparsity optional sparsity (ratio of zeros)\n+ */\n+class NumericAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val min: Option[Double] = None,\n+    val max: Option[Double] = None,\n+    val std: Option[Double] = None,\n+    val sparsity: Option[Double] = None) extends Attribute {\n+\n+  std.foreach { s =>\n+    require(s >= 0.0, s\"Standard deviation cannot be negative but got $s.\")\n+  }\n+  sparsity.foreach { s =>\n+    require(s >= 0.0 && s <= 1.0, s\"Sparsity must be in [0, 1] but got $s.\")\n+  }\n+\n+  override def attrType: AttributeType = AttributeType.Numeric\n+\n+  override def withName(name: String): NumericAttribute = copy(name = Some(name))\n+  override def withoutName: NumericAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NumericAttribute = copy(index = Some(index))\n+  override def withoutIndex: NumericAttribute = copy(index = None)\n+\n+  /** Copy with a new min value. */\n+  def withMin(min: Double): NumericAttribute = copy(min = Some(min))\n+\n+  /** Copy without the min value. */\n+  def withoutMin: NumericAttribute = copy(min = None)\n+\n+\n+  /** Copy with a new max value. */\n+  def withMax(max: Double): NumericAttribute = copy(max = Some(max))\n+\n+  /** Copy without the max value. */\n+  def withoutMax: NumericAttribute = copy(max = None)\n+\n+  /** Copy with a new standard deviation. */\n+  def withStd(std: Double): NumericAttribute = copy(std = Some(std))\n+\n+  /** Copy without the standard deviation. */\n+  def withoutStd: NumericAttribute = copy(std = None)\n+\n+  /** Copy with a new sparsity. */\n+  def withSparsity(sparsity: Double): NumericAttribute = copy(sparsity = Some(sparsity))\n+\n+  /** Copy without the sparsity. */\n+  def withoutSparsity: NumericAttribute = copy(sparsity = None)\n+\n+  /** Copy without summary statistics. */\n+  def withoutSummary: NumericAttribute = copy(min = None, max = None, std = None, sparsity = None)\n+\n+  override def isNumeric: Boolean = true\n+\n+  override def isNominal: Boolean = false\n+\n+  /** Convert this attribute to metadata. */\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    min.foreach(bldr.putDouble(MIN, _))\n+    max.foreach(bldr.putDouble(MAX, _))\n+    std.foreach(bldr.putDouble(STD, _))\n+    sparsity.foreach(bldr.putDouble(SPARSITY, _))\n+    bldr.build()\n+  }\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      min: Option[Double] = min,\n+      max: Option[Double] = max,\n+      std: Option[Double] = std,\n+      sparsity: Option[Double] = sparsity): NumericAttribute = {\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NumericAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (min == o.min) &&\n+          (max == o.max) &&\n+          (std == o.std) &&\n+          (sparsity == o.sparsity)\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + min.hashCode\n+    sum = 37 * sum + max.hashCode\n+    sum = 37 * sum + std.hashCode\n+    sum = 37 * sum + sparsity.hashCode\n+    sum\n+  }\n+}\n+\n+/**\n+ * Factory methods for numeric attributes.\n+ */\n+object NumericAttribute extends AttributeFactory {\n+\n+  /** The default numeric attribute. */\n+  val defaultAttr: NumericAttribute = new NumericAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NumericAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val min = if (metadata.contains(MIN)) Some(metadata.getDouble(MIN)) else None\n+    val max = if (metadata.contains(MAX)) Some(metadata.getDouble(MAX)) else None\n+    val std = if (metadata.contains(STD)) Some(metadata.getDouble(STD)) else None\n+    val sparsity = if (metadata.contains(SPARSITY)) Some(metadata.getDouble(SPARSITY)) else None\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+}\n+\n+/**\n+ * A nominal attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param isOrdinal whether this attribute is ordinal (optional)\n+ * @param numValues optional number of values. At most one of `numValues` and `values` can be\n+ *                  defined.\n+ * @param values optional values. At most one of `numValues` and `values` can be defined.\n+ */\n+class NominalAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val isOrdinal: Option[Boolean] = None,\n+    val numValues: Option[Int] = None,\n+    val values: Option[Array[String]] = None) extends Attribute {\n+\n+  numValues.foreach { n =>\n+    require(n >= 0, s\"numValues cannot be negative but got $n.\")\n+  }\n+  require(!(numValues.isDefined && values.isDefined),\n+    \"Cannot have both numValues and values defined.\")\n+\n+  override def attrType: AttributeType = AttributeType.Nominal\n+\n+  override def isNumeric: Boolean = false\n+\n+  override def isNominal: Boolean = true\n+\n+  private lazy val valueToIndex: Map[String, Int] = {\n+    values.map(_.zipWithIndex.toMap).getOrElse(Map.empty)\n+  }\n+\n+  /** Index of a specific value. */\n+  def indexOf(value: String): Int = {\n+    valueToIndex(value)\n+  }\n+\n+  /** Tests whether this attribute contains a specific value. */\n+  def hasValue(value: String): Boolean = valueToIndex.contains(value)\n+\n+  /** Gets a value given its index. */\n+  def getValue(index: Int): String = values.get(index)\n+\n+  override def withName(name: String): NominalAttribute = copy(name = Some(name))\n+  override def withoutName: NominalAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NominalAttribute = copy(index = Some(index))\n+  override def withoutIndex: NominalAttribute = copy(index = None)\n+\n+  /** Copy with new values and empty `numValues`. */\n+  def withValues(values: Array[String]): NominalAttribute = {\n+    copy(numValues = None, values = Some(values))\n+  }\n+\n+  /** Copy with new values and empty `numValues`. */\n+  @varargs\n+  def withValues(first: String, others: String*): NominalAttribute = {\n+    copy(numValues = None, values = Some((first +: others).toArray))\n+  }\n+\n+  /** Copy without the values. */\n+  def withoutValues: NominalAttribute = {\n+    copy(values = None)\n+  }\n+\n+  /** Copy with a new `numValues` and empty `values`. */\n+  def withNumValues(numValues: Int): NominalAttribute = {\n+    copy(numValues = Some(numValues), values = None)\n+  }\n+\n+  /** Copy without the `numValues`. */\n+  def withoutNumValues: NominalAttribute = copy(numValues = None)\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      isOrdinal: Option[Boolean] = isOrdinal,\n+      numValues: Option[Int] = numValues,\n+      values: Option[Array[String]] = values): NominalAttribute = {\n+    new NominalAttribute(name, index, isOrdinal, numValues, values)\n+  }\n+\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    isOrdinal.foreach(bldr.putBoolean(ORDINAL, _))\n+    numValues.foreach(bldr.putLong(CARDINALITY, _))\n+    values.foreach(v => bldr.putStringArray(VALUES, v))\n+    bldr.build()\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NominalAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (isOrdinal == o.isOrdinal) &&\n+          (numValues == o.numValues) &&\n+          (values.map(_.toSeq) == o.values.map(_.toSeq))\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + isOrdinal.hashCode\n+    sum = 37 * sum + numValues.hashCode\n+    sum = 37 * sum + values.map(_.toSeq).hashCode\n+    sum\n+  }\n+}\n+\n+/** Factory methods for nominal attributes. */\n+object NominalAttribute extends AttributeFactory {\n+\n+  /** The default nominal attribute. */\n+  final val defaultAttr: NominalAttribute = new NominalAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NominalAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val isOrdinal = if (metadata.contains(ORDINAL)) Some(metadata.getBoolean(ORDINAL)) else None\n+    val cardinality =\n+      if (metadata.contains(CARDINALITY)) Some(metadata.getLong(CARDINALITY).toInt) else None\n+    val values =\n+      if (metadata.contains(VALUES)) Some(metadata.getStringArray(VALUES)) else None\n+    new NominalAttribute(name, index, isOrdinal, cardinality, values)\n+  }\n+}\n+\n+/**\n+ * A binary attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param values optionla values. If set, its size must be 2.\n+ */\n+class BinaryAttribute private[ml] (",
    "line": 427
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Yeah it sounds nice in theory but it got complicated to express. Go ahead and see how it works.\n",
    "commit": "71d1bd042360376b7f8f75ba6be3471f443ce34e",
    "createdAt": "2015-03-06T22:56:01Z",
    "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.attribute\n+\n+import scala.annotation.varargs\n+\n+import org.apache.spark.sql.types.{DoubleType, Metadata, MetadataBuilder, StructField}\n+\n+/**\n+ * Abstract class for ML attributes.\n+ */\n+sealed abstract class Attribute extends Serializable {\n+\n+  name.foreach { n =>\n+    require(n.nonEmpty, \"Cannot have an empty string for name.\")\n+  }\n+  index.foreach { i =>\n+    require(i >= 0, s\"Index cannot be negative but got $i\")\n+  }\n+\n+  /** Attribute type. */\n+  def attrType: AttributeType\n+\n+  /** Name of the attribute. None if it is not set. */\n+  def name: Option[String]\n+\n+  /** Copy with a new name. */\n+  def withName(name: String): Attribute\n+\n+  /** Copy without the name. */\n+  def withoutName: Attribute\n+\n+  /** Index of the attribute. None if it is not set. */\n+  def index: Option[Int]\n+\n+  /** Copy with a new index. */\n+  def withIndex(index: Int): Attribute\n+\n+  /** Copy without the index. */\n+  def withoutIndex: Attribute\n+\n+  /**\n+   * Tests whether this attribute is numeric, true for [[NumericAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNumeric: Boolean\n+\n+  /**\n+   * Tests whether this attribute is nominal, true for [[NominalAttribute]] and [[BinaryAttribute]].\n+   */\n+  def isNominal: Boolean\n+\n+  /**\n+   * Converts this attribute to [[Metadata]].\n+   * @param withType whether to include the type info\n+   */\n+  private[attribute] def toMetadata(withType: Boolean): Metadata\n+\n+  /**\n+   * Converts this attribute to [[Metadata]]. For numeric attributes, the type info is excluded to\n+   * save space, because numeric type is the default attribute type. For nominal and binary\n+   * attributes, the type info is included.\n+   */\n+  private[attribute] def toMetadata(): Metadata = {\n+    if (attrType == AttributeType.Numeric) {\n+      toMetadata(withType = false)\n+    } else {\n+      toMetadata(withType = true)\n+    }\n+  }\n+\n+  /**\n+   * Converts to a [[StructField]] with some existing metadata.\n+   * @param existingMetadata existing metadata to carry over\n+   */\n+  def toStructField(existingMetadata: Metadata): StructField = {\n+    val newMetadata = new MetadataBuilder()\n+      .withMetadata(existingMetadata)\n+      .putMetadata(AttributeKeys.ML_ATTR, withoutName.withoutIndex.toMetadata())\n+      .build()\n+    StructField(name.get, DoubleType, nullable = false, newMetadata)\n+  }\n+\n+  /** Converts to a [[StructField]]. */\n+  def toStructField(): StructField = toStructField(Metadata.empty)\n+\n+  override def toString: String = toMetadata(withType = true).toString\n+}\n+\n+/** Trait for ML attribute factories. */\n+private[attribute] trait AttributeFactory {\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[Metadata]] instance.\n+   */\n+  private[attribute] def fromMetadata(metadata: Metadata): Attribute\n+\n+  /**\n+   * Creates an [[Attribute]] from a [[StructField]] instance.\n+   */\n+  def fromStructField(field: StructField): Attribute = {\n+    require(field.dataType == DoubleType)\n+    fromMetadata(field.metadata.getMetadata(AttributeKeys.ML_ATTR)).withName(field.name)\n+  }\n+}\n+\n+object Attribute extends AttributeFactory {\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): Attribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val attrType = if (metadata.contains(TYPE)) {\n+      metadata.getString(TYPE)\n+    } else {\n+      AttributeType.Numeric.name\n+    }\n+    getFactory(attrType).fromMetadata(metadata)\n+  }\n+\n+  /** Gets the attribute factory given the attribute type name. */\n+  private def getFactory(attrType: String): AttributeFactory = {\n+    if (attrType == AttributeType.Numeric.name) {\n+      NumericAttribute\n+    } else if (attrType == AttributeType.Nominal.name) {\n+      NominalAttribute\n+    } else if (attrType == AttributeType.Binary.name) {\n+      BinaryAttribute\n+    } else {\n+      throw new IllegalArgumentException(s\"Cannot recognize type $attrType.\")\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * A numeric attribute with optional summary statistics.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param min optional min value\n+ * @param max optional max value\n+ * @param std optional standard deviation\n+ * @param sparsity optional sparsity (ratio of zeros)\n+ */\n+class NumericAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val min: Option[Double] = None,\n+    val max: Option[Double] = None,\n+    val std: Option[Double] = None,\n+    val sparsity: Option[Double] = None) extends Attribute {\n+\n+  std.foreach { s =>\n+    require(s >= 0.0, s\"Standard deviation cannot be negative but got $s.\")\n+  }\n+  sparsity.foreach { s =>\n+    require(s >= 0.0 && s <= 1.0, s\"Sparsity must be in [0, 1] but got $s.\")\n+  }\n+\n+  override def attrType: AttributeType = AttributeType.Numeric\n+\n+  override def withName(name: String): NumericAttribute = copy(name = Some(name))\n+  override def withoutName: NumericAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NumericAttribute = copy(index = Some(index))\n+  override def withoutIndex: NumericAttribute = copy(index = None)\n+\n+  /** Copy with a new min value. */\n+  def withMin(min: Double): NumericAttribute = copy(min = Some(min))\n+\n+  /** Copy without the min value. */\n+  def withoutMin: NumericAttribute = copy(min = None)\n+\n+\n+  /** Copy with a new max value. */\n+  def withMax(max: Double): NumericAttribute = copy(max = Some(max))\n+\n+  /** Copy without the max value. */\n+  def withoutMax: NumericAttribute = copy(max = None)\n+\n+  /** Copy with a new standard deviation. */\n+  def withStd(std: Double): NumericAttribute = copy(std = Some(std))\n+\n+  /** Copy without the standard deviation. */\n+  def withoutStd: NumericAttribute = copy(std = None)\n+\n+  /** Copy with a new sparsity. */\n+  def withSparsity(sparsity: Double): NumericAttribute = copy(sparsity = Some(sparsity))\n+\n+  /** Copy without the sparsity. */\n+  def withoutSparsity: NumericAttribute = copy(sparsity = None)\n+\n+  /** Copy without summary statistics. */\n+  def withoutSummary: NumericAttribute = copy(min = None, max = None, std = None, sparsity = None)\n+\n+  override def isNumeric: Boolean = true\n+\n+  override def isNominal: Boolean = false\n+\n+  /** Convert this attribute to metadata. */\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    min.foreach(bldr.putDouble(MIN, _))\n+    max.foreach(bldr.putDouble(MAX, _))\n+    std.foreach(bldr.putDouble(STD, _))\n+    sparsity.foreach(bldr.putDouble(SPARSITY, _))\n+    bldr.build()\n+  }\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      min: Option[Double] = min,\n+      max: Option[Double] = max,\n+      std: Option[Double] = std,\n+      sparsity: Option[Double] = sparsity): NumericAttribute = {\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NumericAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (min == o.min) &&\n+          (max == o.max) &&\n+          (std == o.std) &&\n+          (sparsity == o.sparsity)\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + min.hashCode\n+    sum = 37 * sum + max.hashCode\n+    sum = 37 * sum + std.hashCode\n+    sum = 37 * sum + sparsity.hashCode\n+    sum\n+  }\n+}\n+\n+/**\n+ * Factory methods for numeric attributes.\n+ */\n+object NumericAttribute extends AttributeFactory {\n+\n+  /** The default numeric attribute. */\n+  val defaultAttr: NumericAttribute = new NumericAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NumericAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val min = if (metadata.contains(MIN)) Some(metadata.getDouble(MIN)) else None\n+    val max = if (metadata.contains(MAX)) Some(metadata.getDouble(MAX)) else None\n+    val std = if (metadata.contains(STD)) Some(metadata.getDouble(STD)) else None\n+    val sparsity = if (metadata.contains(SPARSITY)) Some(metadata.getDouble(SPARSITY)) else None\n+    new NumericAttribute(name, index, min, max, std, sparsity)\n+  }\n+}\n+\n+/**\n+ * A nominal attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param isOrdinal whether this attribute is ordinal (optional)\n+ * @param numValues optional number of values. At most one of `numValues` and `values` can be\n+ *                  defined.\n+ * @param values optional values. At most one of `numValues` and `values` can be defined.\n+ */\n+class NominalAttribute private[ml] (\n+    override val name: Option[String] = None,\n+    override val index: Option[Int] = None,\n+    val isOrdinal: Option[Boolean] = None,\n+    val numValues: Option[Int] = None,\n+    val values: Option[Array[String]] = None) extends Attribute {\n+\n+  numValues.foreach { n =>\n+    require(n >= 0, s\"numValues cannot be negative but got $n.\")\n+  }\n+  require(!(numValues.isDefined && values.isDefined),\n+    \"Cannot have both numValues and values defined.\")\n+\n+  override def attrType: AttributeType = AttributeType.Nominal\n+\n+  override def isNumeric: Boolean = false\n+\n+  override def isNominal: Boolean = true\n+\n+  private lazy val valueToIndex: Map[String, Int] = {\n+    values.map(_.zipWithIndex.toMap).getOrElse(Map.empty)\n+  }\n+\n+  /** Index of a specific value. */\n+  def indexOf(value: String): Int = {\n+    valueToIndex(value)\n+  }\n+\n+  /** Tests whether this attribute contains a specific value. */\n+  def hasValue(value: String): Boolean = valueToIndex.contains(value)\n+\n+  /** Gets a value given its index. */\n+  def getValue(index: Int): String = values.get(index)\n+\n+  override def withName(name: String): NominalAttribute = copy(name = Some(name))\n+  override def withoutName: NominalAttribute = copy(name = None)\n+\n+  override def withIndex(index: Int): NominalAttribute = copy(index = Some(index))\n+  override def withoutIndex: NominalAttribute = copy(index = None)\n+\n+  /** Copy with new values and empty `numValues`. */\n+  def withValues(values: Array[String]): NominalAttribute = {\n+    copy(numValues = None, values = Some(values))\n+  }\n+\n+  /** Copy with new values and empty `numValues`. */\n+  @varargs\n+  def withValues(first: String, others: String*): NominalAttribute = {\n+    copy(numValues = None, values = Some((first +: others).toArray))\n+  }\n+\n+  /** Copy without the values. */\n+  def withoutValues: NominalAttribute = {\n+    copy(values = None)\n+  }\n+\n+  /** Copy with a new `numValues` and empty `values`. */\n+  def withNumValues(numValues: Int): NominalAttribute = {\n+    copy(numValues = Some(numValues), values = None)\n+  }\n+\n+  /** Copy without the `numValues`. */\n+  def withoutNumValues: NominalAttribute = copy(numValues = None)\n+\n+  /** Creates a copy of this attribute with optional changes. */\n+  private def copy(\n+      name: Option[String] = name,\n+      index: Option[Int] = index,\n+      isOrdinal: Option[Boolean] = isOrdinal,\n+      numValues: Option[Int] = numValues,\n+      values: Option[Array[String]] = values): NominalAttribute = {\n+    new NominalAttribute(name, index, isOrdinal, numValues, values)\n+  }\n+\n+  private[attribute] override def toMetadata(withType: Boolean): Metadata = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val bldr = new MetadataBuilder()\n+    if (withType) bldr.putString(TYPE, attrType.name)\n+    name.foreach(bldr.putString(NAME, _))\n+    index.foreach(bldr.putLong(INDEX, _))\n+    isOrdinal.foreach(bldr.putBoolean(ORDINAL, _))\n+    numValues.foreach(bldr.putLong(CARDINALITY, _))\n+    values.foreach(v => bldr.putStringArray(VALUES, v))\n+    bldr.build()\n+  }\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: NominalAttribute =>\n+        (name == o.name) &&\n+          (index == o.index) &&\n+          (isOrdinal == o.isOrdinal) &&\n+          (numValues == o.numValues) &&\n+          (values.map(_.toSeq) == o.values.map(_.toSeq))\n+      case _ =>\n+        false\n+    }\n+  }\n+\n+  override def hashCode: Int = {\n+    var sum = 17\n+    sum = 37 * sum + name.hashCode\n+    sum = 37 * sum + index.hashCode\n+    sum = 37 * sum + isOrdinal.hashCode\n+    sum = 37 * sum + numValues.hashCode\n+    sum = 37 * sum + values.map(_.toSeq).hashCode\n+    sum\n+  }\n+}\n+\n+/** Factory methods for nominal attributes. */\n+object NominalAttribute extends AttributeFactory {\n+\n+  /** The default nominal attribute. */\n+  final val defaultAttr: NominalAttribute = new NominalAttribute\n+\n+  private[attribute] override def fromMetadata(metadata: Metadata): NominalAttribute = {\n+    import org.apache.spark.ml.attribute.AttributeKeys._\n+    val name = if (metadata.contains(NAME)) Some(metadata.getString(NAME)) else None\n+    val index = if (metadata.contains(INDEX)) Some(metadata.getLong(INDEX).toInt) else None\n+    val isOrdinal = if (metadata.contains(ORDINAL)) Some(metadata.getBoolean(ORDINAL)) else None\n+    val cardinality =\n+      if (metadata.contains(CARDINALITY)) Some(metadata.getLong(CARDINALITY).toInt) else None\n+    val values =\n+      if (metadata.contains(VALUES)) Some(metadata.getStringArray(VALUES)) else None\n+    new NominalAttribute(name, index, isOrdinal, cardinality, values)\n+  }\n+}\n+\n+/**\n+ * A binary attribute.\n+ * @param name optional name\n+ * @param index optional index\n+ * @param values optionla values. If set, its size must be 2.\n+ */\n+class BinaryAttribute private[ml] (",
    "line": 427
  }],
  "prId": 4925
}]