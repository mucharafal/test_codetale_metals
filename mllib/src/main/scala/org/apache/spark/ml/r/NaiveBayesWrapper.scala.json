[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`(\"labels\" -> instance.labels.toSeq) ~` should work.\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-21T23:45:47Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~"
  }],
  "prId": 12573
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "ditto\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-21T23:45:48Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~\n+        (\"features\" -> parse(compact(render(instance.features.toSeq))))"
  }],
  "prId": 12573
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`(rMetadata \\ \"labels\").extract[Array[String]]` should work.\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-21T23:45:50Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~\n+        (\"features\" -> parse(compact(render(instance.features.toSeq))))\n+      val rMetadataJson: String = compact(render(rMetadata))\n+      sc.parallelize(Seq(rMetadataJson), 1).saveAsTextFile(rMetadataPath)\n+\n+      instance.pipeline.save(pipelinePath)\n+    }\n+  }\n+\n+  class NaiveBayesWrapperReader extends MLReader[NaiveBayesWrapper] {\n+\n+    override def load(path: String): NaiveBayesWrapper = {\n+      implicit val format = DefaultFormats\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadataStr = sc.textFile(rMetadataPath, 1).first()\n+      val rMetadata = parse(rMetadataStr)\n+      val labels = parse(compact(render(rMetadata \\ \"labels\"))).extract[Seq[String]].toArray"
  }],
  "prId": 12573
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "ditto\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-21T23:45:52Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~\n+        (\"features\" -> parse(compact(render(instance.features.toSeq))))\n+      val rMetadataJson: String = compact(render(rMetadata))\n+      sc.parallelize(Seq(rMetadataJson), 1).saveAsTextFile(rMetadataPath)\n+\n+      instance.pipeline.save(pipelinePath)\n+    }\n+  }\n+\n+  class NaiveBayesWrapperReader extends MLReader[NaiveBayesWrapper] {\n+\n+    override def load(path: String): NaiveBayesWrapper = {\n+      implicit val format = DefaultFormats\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadataStr = sc.textFile(rMetadataPath, 1).first()\n+      val rMetadata = parse(rMetadataStr)\n+      val labels = parse(compact(render(rMetadata \\ \"labels\"))).extract[Seq[String]].toArray\n+      val features = parse(compact(render(rMetadata \\ \"features\"))).extract[Seq[String]].toArray"
  }],
  "prId": 12573
}, {
  "comments": [{
    "author": {
      "login": "felixcheung"
    },
    "body": "should this support saving the model in a more compact format than text?\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-22T00:19:49Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~\n+        (\"features\" -> parse(compact(render(instance.features.toSeq))))\n+      val rMetadataJson: String = compact(render(rMetadata))\n+      sc.parallelize(Seq(rMetadataJson), 1).saveAsTextFile(rMetadataPath)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "We use the same format as in ML pipelines. The output will be a folder instead of a single file. Maybe users can zip that folder if they want to send the model to someone else. Designing a new format is certainly beyond the scope of this PR.\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-22T00:30:48Z",
    "diffHunk": "@@ -74,4 +83,41 @@ private[r] object NaiveBayesWrapper {\n       .fit(data)\n     new NaiveBayesWrapper(pipeline, labels, features)\n   }\n+\n+  override def read: MLReader[NaiveBayesWrapper] = new NaiveBayesWrapperReader\n+\n+  override def load(path: String): NaiveBayesWrapper = super.load(path)\n+\n+  class NaiveBayesWrapperWriter(instance: NaiveBayesWrapper) extends MLWriter {\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      val rMetadataPath = new Path(path, \"rMetadata\").toString\n+      val pipelinePath = new Path(path, \"pipeline\").toString\n+\n+      val rMetadata = (\"class\" -> instance.getClass.getName) ~\n+        (\"labels\" -> parse(compact(render(instance.labels.toSeq)))) ~\n+        (\"features\" -> parse(compact(render(instance.features.toSeq))))\n+      val rMetadataJson: String = compact(render(rMetadata))\n+      sc.parallelize(Seq(rMetadataJson), 1).saveAsTextFile(rMetadataPath)"
  }],
  "prId": 12573
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "You can `.extract[Array[String]]` directly.\n",
    "commit": "ac42a0a96460ed460574c86afc715e3c144cb137",
    "createdAt": "2016-04-22T15:26:35Z",
    "diffHunk": "@@ -113,8 +113,8 @@ private[r] object NaiveBayesWrapper extends MLReadable[NaiveBayesWrapper] {\n \n       val rMetadataStr = sc.textFile(rMetadataPath, 1).first()\n       val rMetadata = parse(rMetadataStr)\n-      val labels = parse(compact(render(rMetadata \\ \"labels\"))).extract[Seq[String]].toArray\n-      val features = parse(compact(render(rMetadata \\ \"features\"))).extract[Seq[String]].toArray\n+      val labels = (rMetadata \\ \"labels\").extract[Seq[String]].toArray"
  }],
  "prId": 12573
}]