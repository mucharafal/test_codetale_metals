[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Open-ended question: if `labels` changes from run to run (e.g. more labels are added) then the numbering may change. The label for 0 may be different from run to run. Is that going to be a surprise later? If the indexing is only transient and is never persisted anywhere, it doesn't matter, but, might it be? I'm afraid of reloading a model referring to label 0, 1, 2 that have entirely different meaning.\n\nMaybe there are reasons this is not an issue, or the assumption is that the caller only appends values to the end of the `labels` array, ever.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-02-24T10:24:48Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{IntegerType, StringType, StructField, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    // TODO: Store ML attributes in metadata.\n+    val outputFields = inputFields :+ StructField(map(outputCol), IntegerType, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an integer column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * The most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: Allow unseen labels in transform.\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray\n+    val model = new LabelIndexerModel(this, map, labels)\n+    Params.inheritValues(map, this, model)\n+    model\n+  }\n+\n+  override def transformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    validateAndTransformSchema(schema, paramMap)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Model fitted by [[LabelIndexer]].\n+ */\n+@AlphaComponent\n+class LabelIndexerModel private[ml] (\n+    override val parent: LabelIndexer,\n+    override val fittingParamMap: ParamMap,\n+    labels: Array[String]) extends Model[LabelIndexerModel] with LabelIndexerBase {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "The `labels` in a fitted model should be viewed as immutable. If there are new labels, we can train a new `LabelIndexerModel`. We are gonna put label names into the metadata, so we still tracks which index maps to which label.\n\nWe can add an option to `LabelIndexer` that allows users to specify part of the mapping. If we implement this option, then we can keep the original ordering unchanged on new datasets.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-02-24T19:52:56Z",
    "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{IntegerType, StringType, StructField, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    // TODO: Store ML attributes in metadata.\n+    val outputFields = inputFields :+ StructField(map(outputCol), IntegerType, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an integer column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * The most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: Allow unseen labels in transform.\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray\n+    val model = new LabelIndexerModel(this, map, labels)\n+    Params.inheritValues(map, this, model)\n+    model\n+  }\n+\n+  override def transformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    validateAndTransformSchema(schema, paramMap)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Model fitted by [[LabelIndexer]].\n+ */\n+@AlphaComponent\n+class LabelIndexerModel private[ml] (\n+    override val parent: LabelIndexer,\n+    override val fittingParamMap: ParamMap,\n+    labels: Array[String]) extends Model[LabelIndexerModel] with LabelIndexerBase {"
  }],
  "prId": 4735
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Instead of ordering by count, which requires all that counting, can labels just be ordered alphabetically? maybe I miss why it's important to sort them this way, but I'd think it's arbitrary. A deterministic function of the labels themselves might be less surprising or something later, though I can't name a specific problem it would solve, now.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-25T17:38:32Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Since we need to distinct labels anyway, there is little overhead with count and sort. Couple benefits:\n1. better sparsity as there will be more zeros\n2. easy inspection as common labels are at the beginning.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-25T21:21:57Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Hm because the most common label is encoded as 0.0? it feels like a funny optimization since it's not \"really\" a 0, and these values are handled as individual values or dense vectors mostly (right?). Is counting the whole data set by label really that cheap? it still means looking at every datum even if there are few labels. I don't strongly object or anything, this just hadn't occurred to me.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-25T21:34:36Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "In vector assembler, where we merge multiple columns into a vector column, the encoded indices are stored inside a sparse vector. For multiclass labels, this doesn't help much. But for binary labels, this saves at least half of the storage.\n\n`countByValue` costs about the same as `distinct`:\nhttps://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/rdd/RDD.scala#L1041\nhttps://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/rdd/RDD.scala#L313\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-27T07:23:57Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray"
  }],
  "prId": 4735
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Yep so here is where the labels go into the metadata, in order. That's good.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-25T17:39:12Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray\n+    val model = new LabelIndexerModel(this, map, labels)\n+    Params.inheritValues(map, this, model)\n+    model\n+  }\n+\n+  override def transformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    validateAndTransformSchema(schema, paramMap)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Model fitted by [[LabelIndexer]].\n+ */\n+@AlphaComponent\n+class LabelIndexerModel private[ml] (\n+    override val parent: LabelIndexer,\n+    override val fittingParamMap: ParamMap,\n+    labels: Array[String]) extends Model[LabelIndexerModel] with LabelIndexerBase {\n+\n+  private val labelToIndex: OpenHashMap[String, Double] = {\n+    val n = labels.length\n+    val map = new OpenHashMap[String, Double](n)\n+    var i = 0\n+    while (i < n) {\n+      map.update(labels(i), i)\n+      i += 1\n+    }\n+    map\n+  }\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  override def transform(dataset: DataFrame, paramMap: ParamMap): DataFrame = {\n+    val map = this.paramMap ++ paramMap\n+    val indexer = udf { label: String =>\n+      if (labelToIndex.contains(label)) {\n+        labelToIndex(label)\n+      } else {\n+        throw new SparkException(s\"Unseen label: $label.\")\n+      }\n+    }\n+    val outputColName = map(outputCol)\n+    val metadata = NominalAttribute.defaultAttr\n+      .withName(outputColName).withValues(labels).toStructField().metadata"
  }],
  "prId": 4735
}, {
  "comments": [{
    "author": {
      "login": "petro-rudenko"
    },
    "body": "If it suppose to be general indexer, not just for label column, maybe it makes sense to call it ColumnIndexer and use setInputCol instead.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-31T14:59:07Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I agree with this since we have used \"label\" to mean label for prediction thus far.  (But @mengxr disagreed based on precedence from sklearn; you can see the comments above.)\n\nI also added questions in the JIRA about whether this class should support multiple input and output columns and support more native types than String.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-31T18:28:44Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "petro-rudenko"
    },
    "body": "Yes, but in jira's example it uses setInputCol rather then setFeatureCol:\n\n``` scala\nval i = new LabelIndexer()\n  .setInputCol(\"country\")\n  .setOutputCol(\"countryIndex\")\n```\n\nwhich makes more sense as for me.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-03-31T18:48:05Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I agree\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-01T00:06:30Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I will rename `labelCol` to `inputCol`. Feel free to suggest better class names. I'm okay with not calling it `LabelIndexer`. How about `StringToNominal`?\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-02T00:30:42Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "Any thoughts about generalizing it beyond String?\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-02T02:24:37Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "For model persistence, we need to save labels to disk. String would be ideal and may be sufficient.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-07T22:32:56Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "Since the data are already in a DataFrame, we know we can save it to disk.  But keeping it simple with String is fine for now.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-09T05:07:33Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I rename the class to `StringIndexer` and changed `labelCol` to `inputCol`.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-10T06:33:37Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)"
  }],
  "prId": 4735
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "This will be shorter if you use the utility methods checkInputColumn and addOutputColumn.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-03T22:22:27Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType"
  }],
  "prId": 4735
}, {
  "comments": [{
    "author": {
      "login": "petro-rudenko"
    },
    "body": "Maybe make an option to specify default value for unknown label rather then throwing exception.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-08T11:50:16Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray\n+    val model = new LabelIndexerModel(this, map, labels)\n+    Params.inheritValues(map, this, model)\n+    model\n+  }\n+\n+  override def transformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    validateAndTransformSchema(schema, paramMap)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Model fitted by [[LabelIndexer]].\n+ */\n+@AlphaComponent\n+class LabelIndexerModel private[ml] (\n+    override val parent: LabelIndexer,\n+    override val fittingParamMap: ParamMap,\n+    labels: Array[String]) extends Model[LabelIndexerModel] with LabelIndexerBase {\n+\n+  private val labelToIndex: OpenHashMap[String, Double] = {\n+    val n = labels.length\n+    val map = new OpenHashMap[String, Double](n)\n+    var i = 0\n+    while (i < n) {\n+      map.update(labels(i), i)\n+      i += 1\n+    }\n+    map\n+  }\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  override def transform(dataset: DataFrame, paramMap: ParamMap): DataFrame = {\n+    val map = this.paramMap ++ paramMap\n+    val indexer = udf { label: String =>\n+      if (labelToIndex.contains(label)) {\n+        labelToIndex(label)\n+      } else {\n+        throw new SparkException(s\"Unseen label: $label.\")"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "I left a TODO for this. The issues are\n1. if we assign unseen label a unique index, it creases the number of values by 1 and a binary feature is no longer binary.\n2. if we map unseen label to an exiting index, it may silently change the behavior and users may not be aware of it.\n3. another option is to map the unseen label to `Double.NaN`, which is treated as missing value and can be filled in later.\n\nSo I think we can discuss this in a follow-up PR.\n",
    "commit": "d82575fd9a29149ecd5979baa70091d567c3c5bd",
    "createdAt": "2015-04-10T06:38:39Z",
    "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.attribute.NominalAttribute\n+import org.apache.spark.ml.param._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.{StringType, StructType}\n+import org.apache.spark.util.collection.OpenHashMap\n+\n+/**\n+ * Base trait for [[LabelIndexer]] and [[LabelIndexerModel]].\n+ */\n+private[feature] trait LabelIndexerBase extends Params with HasLabelCol with HasOutputCol {\n+\n+  /** Validates and transforms the input schema. */\n+  protected def validateAndTransformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    val map = this.paramMap ++ paramMap\n+    val labelType = schema(map(labelCol)).dataType\n+    require(labelType == StringType, s\"The label column must be string-typed but got $labelType.\")\n+    val inputFields = schema.fields\n+    val outputColName = map(outputCol)\n+    require(inputFields.forall(_.name != outputColName),\n+      s\"Output column $outputColName already exists.\")\n+    val attr = NominalAttribute.defaultAttr.withName(map(outputCol))\n+    val outputFields = inputFields :+ attr.toStructField()\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * A label indexer that maps a string column of labels to an ML column of label indices.\n+ * The indices are in [0, numLabels), ordered by label frequencies.\n+ * So the most frequent label gets index 0.\n+ */\n+@AlphaComponent\n+class LabelIndexer extends Estimator[LabelIndexerModel] with LabelIndexerBase {\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // TODO: handle unseen labels\n+\n+  override def fit(dataset: DataFrame, paramMap: ParamMap): LabelIndexerModel = {\n+    val map = this.paramMap ++ paramMap\n+    val counts = dataset.select(map(labelCol)).map(_.getString(0)).countByValue()\n+    val labels = counts.toSeq.sortBy(-_._2).map(_._1).toArray\n+    val model = new LabelIndexerModel(this, map, labels)\n+    Params.inheritValues(map, this, model)\n+    model\n+  }\n+\n+  override def transformSchema(schema: StructType, paramMap: ParamMap): StructType = {\n+    validateAndTransformSchema(schema, paramMap)\n+  }\n+}\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Model fitted by [[LabelIndexer]].\n+ */\n+@AlphaComponent\n+class LabelIndexerModel private[ml] (\n+    override val parent: LabelIndexer,\n+    override val fittingParamMap: ParamMap,\n+    labels: Array[String]) extends Model[LabelIndexerModel] with LabelIndexerBase {\n+\n+  private val labelToIndex: OpenHashMap[String, Double] = {\n+    val n = labels.length\n+    val map = new OpenHashMap[String, Double](n)\n+    var i = 0\n+    while (i < n) {\n+      map.update(labels(i), i)\n+      i += 1\n+    }\n+    map\n+  }\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  override def transform(dataset: DataFrame, paramMap: ParamMap): DataFrame = {\n+    val map = this.paramMap ++ paramMap\n+    val indexer = udf { label: String =>\n+      if (labelToIndex.contains(label)) {\n+        labelToIndex(label)\n+      } else {\n+        throw new SparkException(s\"Unseen label: $label.\")"
  }],
  "prId": 4735
}]