[{
  "comments": [{
    "author": {
      "login": "Lewuathe"
    },
    "body": "Spark already has a implementation of LBFGS. `org.apache.spark.mllib.optimization.LBFGS`. \nCan you apply this class into your implementation? The interface is a little bit different but `Gradient` can calculate if label and feature are included in given data. `ANNGradient` may be good resource to learn this method.\n",
    "commit": "39a1be34fb9ddc900053a4cec5e4847c848bdd8c",
    "createdAt": "2015-11-20T00:58:45Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.ml.nlp\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[ml] class Lbfgs {"
  }],
  "prId": 9794
}, {
  "comments": [{
    "author": {
      "login": "Lewuathe"
    },
    "body": "You can use `org.apache.spark.mllib.linalg.Vector` type and Spark provides a class that provides BLAS functionality. (`org.apache.spark.mllib.linalg.BLAS`) with this Vector type. It might be bette to avoid re-implement it for `ArrayBuffer`.\n",
    "commit": "39a1be34fb9ddc900053a4cec5e4847c848bdd8c",
    "createdAt": "2015-11-20T01:02:41Z",
    "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.ml.nlp\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+private[ml] class Lbfgs {\n+\n+  private var w: ArrayBuffer[Double] = new ArrayBuffer[Double]()\n+  private var v: ArrayBuffer[Double] = new ArrayBuffer[Double]()\n+  private var xi: ArrayBuffer[Double] = new ArrayBuffer[Double]()\n+  private var diag: ArrayBuffer[Double] = new ArrayBuffer[Double]()\n+  private var iflag: Int = 0\n+  private var point: Int = 0\n+  private var ispt: Int = 0\n+  private var iypt: Int = 0\n+  private var iycn: Int = 0\n+  private var iter: Int = 0\n+  private var info: Int = 0\n+  private var stp1: Double = 0\n+  private var npt: Int = 0\n+  private var iscn: Int = 0\n+  private var nfev: Int = 0\n+  private var stp: Double = 1.0\n+  private var continue: Boolean = true\n+  private val eps: Double = 1e-7\n+  private var dginit: Double = 0.0\n+  private var infoc: Int = 0\n+  private var brackt: Boolean = false\n+  private var stage1: Boolean = false\n+  private var finit: Double = 0.0\n+  private var dgtest: Double = 0.0\n+  private val ftol: Double = 1e-4\n+  private val p5: Double = 0.5\n+  private val p66: Double = 0.66\n+  private val xtrapf: Double = 4.0\n+  private val maxfev: Int = 20\n+  private var width: Double = 0.0\n+  private var width1: Double = 0.0\n+  private var stx: Double = 0.0\n+  private var fx: Double = 0.0\n+  private var dgx: Double = 0.0\n+  private var sty: Double = 0.0\n+  private var fy: Double = 0.0\n+  private var dgy: Double = 0.0\n+  private var contadj: Boolean = true\n+  private var stmin: Double = 0.0\n+  private var stmax: Double = 0.0\n+\n+\n+  def lbfgs(size: Int, x: ArrayBuffer[Double], f: Double,\n+            g: ArrayBuffer[Double], C: Float): Unit = {\n+    val msize: Int = 5\n+    var bound: Int = 0\n+    var ys: Double = 0.0\n+    var yy: Double = 0.0\n+    var cp: Int = 0\n+    var j: Int = 0\n+    val p5: Double = 0.5\n+    val p66: Double = 0.66\n+    val xtrapf: Double = 4.0\n+    val maxfev: Int = 20\n+    var i: Int = 0\n+    var persist: Boolean = true\n+\n+    if (w.isEmpty) {\n+      iflag = 0\n+      for (i <- 0 until size) {\n+        diag.append(1.0)\n+      }\n+      ispt = size + (msize << 1)\n+      iypt = ispt + size * msize\n+      for (i <- 0 until size * (2 * msize + 1) + 2 * msize) {\n+        w.append(0.0)\n+      }\n+    }\n+    if (iflag == 0) {\n+      point = 0\n+      while (j < size) {\n+        w.update(ispt + j, -g(j) * diag(j))\n+        j += 1\n+      }\n+      stp1 = 1.0 / math.sqrt(ddot(size, g, 0, g, 0))\n+    }\n+    while (true) {\n+      if (iflag == 0) {\n+        iter += 1\n+        info = 0\n+        if (iter == 1) {\n+          nfev = 0\n+          stp = 1.0\n+          stp = stp1\n+          for (i <- 1 until size) {\n+            w(i) = g(i)\n+          }\n+        } else {\n+          if (iter > size) {\n+            bound = size\n+          }\n+          ys = ddot(size, w, iypt + npt, w, ispt + npt)\n+          yy = ddot(size, w, iypt + npt, w, iypt + npt)\n+          i = 0\n+          while (i < size) {\n+            diag(i) = ys / yy\n+            i += 1\n+          }\n+        }\n+      }\n+      else if (iflag != 1 && iter != 1) {\n+        cp = point\n+        if (point == 0) {\n+          cp = msize\n+        }\n+        w(size + cp) = 1.0 / ys\n+\n+        for (i <- 0 until size) {\n+          w(i) = -g(i)\n+        }\n+\n+        bound = math.min(iter - 1, msize)\n+        cp = point\n+        i = 0\n+        while (i < bound) {\n+          cp -= 1\n+          if (cp == -1) cp = msize\n+          val sq: Double = ddot(size, w, ispt + cp * size, w, 0)\n+          val inmc: Int = size + msize + cp\n+          iycn = iypt + cp * size\n+          w(inmc) = w(size + cp) * sq\n+          val d: Double = -w(inmc)\n+          daxpy(size, d, w, iycn, w, 0)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < size) {\n+          w(i) = diag(i) * w(i)\n+          i += 1\n+        }\n+        i = 0\n+        while (i < bound) {\n+          val yr: Double = ddot(size, w, iypt + cp * size + 1, w, 1)\n+          var beta: Double = w(size + cp + 1) * yr\n+          val inmc: Int = size + msize + cp\n+          beta = w(inmc) - beta\n+          iscn = ispt + cp * size\n+          daxpy(size, beta, w, iscn, w, 0)\n+          cp += 1\n+          if (cp == msize) cp = 0\n+          i += 1\n+        }\n+        i = 0\n+        while (i < size) {\n+          w(ispt + point * size + i) = w(i)\n+          i += 1\n+        }\n+      }\n+      // mcsrch line search\n+      if (info != -1) {\n+        infoc = 1\n+        if (size <= 0 || stp <= 0.0) {\n+          return\n+        }\n+        dginit = ddot(size, g, 0, w, ispt)\n+        if (dginit >= 0.0) return\n+        brackt = false\n+        stage1 = true\n+        nfev = 0\n+        finit = f\n+        dgtest = ftol * dginit\n+        width = 1e20 - 1e-20\n+        width1 = width / p5\n+        j = 0\n+        while (j < size) {\n+          diag(j) = x(j)\n+          j += 1\n+        }\n+        stx = 0.0\n+        fx = finit\n+        dgx = dginit\n+        sty = 0.0\n+        fy = finit\n+        dgy = dginit\n+      }\n+      while (persist) {\n+        if (info != -1) {\n+          stmin = stx\n+          stmax = stp + xtrapf * (stp - stx)\n+          stp = math.max(stp, 1e-20)\n+          stp = math.min(stp, 1e20)\n+          j = 0\n+          while (j < size) {\n+            x(j) = diag(j) + stp * w(j + ispt)\n+            j += 1\n+          }\n+          info = -1\n+          persist = false\n+        } else {\n+          info = 0\n+          nfev += 1\n+          val dg: Double = ddot(size, g, 0, w, ispt)\n+          val ftest1: Double = finit + stp * dgtest\n+\n+          if (stp == 1e20 && f <= ftest1 && dg <= dgtest) {\n+            info = 5\n+          }\n+          if (stp == 1e-20 && (f > ftest1 || dg >= dgtest)) {\n+            info = 4\n+          }\n+          if (nfev >= maxfev) {\n+            info = 3\n+          }\n+          if (f <= ftest1 && math.abs(dg) <= 0.9 * (-dginit)) {\n+            info = 1\n+          }\n+          if (info != 0) {\n+            persist = false\n+          }\n+        }\n+      }\n+      // mcsrch\n+      if (info == -1) {\n+        iflag = 1\n+        return\n+      }\n+      if (info != 1) {\n+        iflag = -1\n+        return\n+      }\n+      npt = point * size\n+      i = 0\n+      while (i < size) {\n+        w(ispt + npt + i) = stp * w(ispt + npt + i)\n+        w(iypt + npt + i) = g(i) - w(i)\n+        i += 1\n+      }\n+      point += 1\n+      if (point == msize) point = 0\n+      val gnorm: Double = math.sqrt(ddot(size, v, 0, v, 0))\n+      val xnorm: Double = math.max(1.0, math.sqrt(ddot(size, x, 0, x, 0)))\n+      if (gnorm / xnorm <= eps) {\n+        iflag = 0\n+      }\n+    }\n+  }\n+\n+  def ddot(size: Int, v1: ArrayBuffer[Double], v1start: Int,\n+           v2: ArrayBuffer[Double], v2start: Int): Double = {"
  }],
  "prId": 9794
}]