[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Make this sealed\r\nAlso mark Experimental",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-27T16:29:05Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {",
    "line": 42
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Mark Experimental",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-27T16:29:06Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {",
    "line": 73
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Add Since annotations for all of these public methods",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-27T16:29:24Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")",
    "line": 102
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "`lazy val` should be enough.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-30T04:27:13Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted",
    "line": 143
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "RDD's Summarizer doesn't have BLAS optimization actually. So this may not be the reason for the performance gap.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-30T07:27:23Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>"
  }, {
    "author": {
      "login": "thunterdb"
    },
    "body": "Oh yes it does not. Note that the benchmark below is works with vectors of size 1, so as to analyze the overhead of dataframes vs RDDs. I will put a more realistic benchmark later.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-30T23:45:02Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>"
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "This should hurt performance.\r\n\r\nWhen deserializing a vector, we copy (indices and) values array from the unsafe row.\r\n\r\n\r\n",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-03-30T07:35:20Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>\n+        if (value != 0.0) {\n+          if (buffer.max != null && buffer.max(index) < value) {\n+            buffer.max(index) = value\n+          }\n+          if (buffer.min != null && buffer.min(index) > value) {\n+            buffer.min(index) = value\n+          }\n+\n+          if (buffer.mean != null) {\n+            assert(buffer.weightSum != null)\n+            val prevMean = buffer.mean(index)\n+            val diff = value - prevMean\n+            buffer.mean(index) += w * diff / (buffer.weightSum(index) + w)\n+            if (buffer.m2n != null) {\n+              buffer.m2n(index) += w * (value - buffer.mean(index)) * diff\n+            }\n+          }\n+          if (buffer.m2 != null) {\n+            buffer.m2(index) += w * value * value\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1(index) += w * math.abs(value)\n+          }\n+          if (buffer.weightSum != null) {\n+            buffer.weightSum(index) += w\n+          }\n+          if (buffer.nnz != null) {\n+            buffer.nnz(index) += 1\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+\n+    }\n+\n+\n+    /**\n+     * Merges other into buffer.\n+     */\n+    private def mergeInitializedBuffers(buffer: Buffer, other: Buffer): Unit = {\n+      // Each buffer needs to be properly initialized.\n+      require(buffer.n > 0 && other.n > 0, (buffer.n, other.n))\n+      require(buffer.n == other.n, (buffer.n, other.n))\n+      // Mandatory scalar values\n+      buffer.totalWeightSquareSum += other.totalWeightSquareSum\n+      buffer.totalWeightSum += other.totalWeightSum\n+      buffer.totalCount += other.totalCount\n+      // Keep the original weight sums.\n+      val weightSum1 = if (buffer.weightSum == null) null else { buffer.weightSum.clone() }\n+      val weightSum2 = if (other.weightSum == null) null else { other.weightSum.clone() }\n+\n+      // This sum is going to be used as a denominator. In order to guarantee that the\n+      // division is well-defined, we add an epsilon to the zero coefficients.\n+      // This is not going to change the value of the resul since the numerator will also be zero.\n+      val weightSum: BV[Double] = if (weightSum1 == null) null else {\n+        require(weightSum2 != null, s\"buffer=$buffer other=$other\")\n+        val x = b(weightSum1) :+ b(weightSum2)\n+        la.max(x, Double.MinPositiveValue)\n+      }\n+\n+\n+      // Since the operations are dense, we can directly use BLAS calls here.\n+      val deltaMean: BV[Double] = if (buffer.mean != null) {\n+        require(other.mean != null)\n+        b(other.mean) :- b(buffer.mean)\n+      } else { null }\n+\n+      if (buffer.mean != null) {\n+        require(other.mean != null)\n+        require(weightSum != null)\n+        b(buffer.mean) :+= deltaMean :* (b(weightSum2) :/ weightSum)\n+      }\n+\n+      if (buffer.m2n != null) {\n+        require(other.m2n != null)\n+        val w = (b(weightSum1) :* b(weightSum2)) :/ weightSum\n+        val z = (deltaMean :* deltaMean) :* w\n+        b(buffer.m2n) :+= b(other.m2n) :+ z\n+      }\n+\n+      if (buffer.m2 != null) {\n+        require(other.m2 != null)\n+        b(buffer.m2) :+= b(other.m2)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        require(other.l1 != null)\n+        b(buffer.l1) :+= b(other.l1)\n+      }\n+\n+      if (buffer.max != null) {\n+        require(other.max != null)\n+        b(buffer.max) := la.max(b(buffer.max), b(other.max))\n+      }\n+\n+      if (buffer.min != null) {\n+        require(other.min != null)\n+        b(buffer.min) := la.min(b(buffer.min), b(other.min))\n+      }\n+\n+      if (buffer.nnz != null) {\n+        require(other.nnz != null)\n+        bl(buffer.nnz) :+= bl(other.nnz)\n+      }\n+\n+      if (buffer.weightSum != null) {\n+        require(other.weightSum != null)\n+        b(buffer.weightSum) :+= b(other.weightSum)\n+      }\n+    }\n+  }\n+\n+  private case class MetricsAggregate(\n+      requested: Seq[Metrics],\n+      startBuffer: Buffer,\n+      child: Expression,\n+      mutableAggBufferOffset: Int,\n+      inputAggBufferOffset: Int)\n+    extends TypedImperativeAggregate[Buffer] {\n+\n+    // These objects are not thread-safe, allocate them in the aggregator.\n+    private[this] lazy val row = new UnsafeRow(Buffer.numFields)\n+    private[this] lazy val projection = UnsafeProjection.create(Buffer.bufferSchema)\n+\n+\n+    override def eval(buff: Buffer): InternalRow = {\n+      val metrics = requested.map({\n+        case Mean => UnsafeArrayData.fromPrimitiveArray(Buffer.mean(buff))\n+        case Variance => UnsafeArrayData.fromPrimitiveArray(Buffer.variance(buff))\n+        case Count => Buffer.totalCount(buff)\n+        case NumNonZeros => UnsafeArrayData.fromPrimitiveArray(Buffer.nnz(buff))\n+        case Max => UnsafeArrayData.fromPrimitiveArray(Buffer.max(buff))\n+        case Min => UnsafeArrayData.fromPrimitiveArray(Buffer.min(buff))\n+        case NormL2 => UnsafeArrayData.fromPrimitiveArray(Buffer.l2(buff))\n+        case NormL1 => UnsafeArrayData.fromPrimitiveArray(Buffer.l1(buff))\n+      })\n+      InternalRow.apply(metrics: _*)\n+    }\n+\n+    override def children: Seq[Expression] = child :: Nil\n+\n+    override def update(buff: Buffer, row: InternalRow): Buffer = {\n+      // Unsafe rows do not play well with UDTs, it seems.\n+      // Directly call the deserializer.\n+      val v = udt.deserialize(row.getStruct(0, udt.sqlType.size))",
    "line": 756
  }, {
    "author": {
      "login": "WeichenXu123"
    },
    "body": "I think\r\n```\r\nval v = udt.deserialize(row.getStruct(0, udt.sqlType.size))\r\n```\r\nhas some problems.\r\nWe cannot directly use `getter` method on `row` parameter passed in, because the ordinal of the column we want to get depends on the underlying catalyst layer, instead, we should use:\r\n```\r\nval datum = child.eval(row) \r\nval featureVector  = udt.deserialize(datum)\r\n```\r\nto get column value.\r\n",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-07-20T05:36:53Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>\n+        if (value != 0.0) {\n+          if (buffer.max != null && buffer.max(index) < value) {\n+            buffer.max(index) = value\n+          }\n+          if (buffer.min != null && buffer.min(index) > value) {\n+            buffer.min(index) = value\n+          }\n+\n+          if (buffer.mean != null) {\n+            assert(buffer.weightSum != null)\n+            val prevMean = buffer.mean(index)\n+            val diff = value - prevMean\n+            buffer.mean(index) += w * diff / (buffer.weightSum(index) + w)\n+            if (buffer.m2n != null) {\n+              buffer.m2n(index) += w * (value - buffer.mean(index)) * diff\n+            }\n+          }\n+          if (buffer.m2 != null) {\n+            buffer.m2(index) += w * value * value\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1(index) += w * math.abs(value)\n+          }\n+          if (buffer.weightSum != null) {\n+            buffer.weightSum(index) += w\n+          }\n+          if (buffer.nnz != null) {\n+            buffer.nnz(index) += 1\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+\n+    }\n+\n+\n+    /**\n+     * Merges other into buffer.\n+     */\n+    private def mergeInitializedBuffers(buffer: Buffer, other: Buffer): Unit = {\n+      // Each buffer needs to be properly initialized.\n+      require(buffer.n > 0 && other.n > 0, (buffer.n, other.n))\n+      require(buffer.n == other.n, (buffer.n, other.n))\n+      // Mandatory scalar values\n+      buffer.totalWeightSquareSum += other.totalWeightSquareSum\n+      buffer.totalWeightSum += other.totalWeightSum\n+      buffer.totalCount += other.totalCount\n+      // Keep the original weight sums.\n+      val weightSum1 = if (buffer.weightSum == null) null else { buffer.weightSum.clone() }\n+      val weightSum2 = if (other.weightSum == null) null else { other.weightSum.clone() }\n+\n+      // This sum is going to be used as a denominator. In order to guarantee that the\n+      // division is well-defined, we add an epsilon to the zero coefficients.\n+      // This is not going to change the value of the resul since the numerator will also be zero.\n+      val weightSum: BV[Double] = if (weightSum1 == null) null else {\n+        require(weightSum2 != null, s\"buffer=$buffer other=$other\")\n+        val x = b(weightSum1) :+ b(weightSum2)\n+        la.max(x, Double.MinPositiveValue)\n+      }\n+\n+\n+      // Since the operations are dense, we can directly use BLAS calls here.\n+      val deltaMean: BV[Double] = if (buffer.mean != null) {\n+        require(other.mean != null)\n+        b(other.mean) :- b(buffer.mean)\n+      } else { null }\n+\n+      if (buffer.mean != null) {\n+        require(other.mean != null)\n+        require(weightSum != null)\n+        b(buffer.mean) :+= deltaMean :* (b(weightSum2) :/ weightSum)\n+      }\n+\n+      if (buffer.m2n != null) {\n+        require(other.m2n != null)\n+        val w = (b(weightSum1) :* b(weightSum2)) :/ weightSum\n+        val z = (deltaMean :* deltaMean) :* w\n+        b(buffer.m2n) :+= b(other.m2n) :+ z\n+      }\n+\n+      if (buffer.m2 != null) {\n+        require(other.m2 != null)\n+        b(buffer.m2) :+= b(other.m2)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        require(other.l1 != null)\n+        b(buffer.l1) :+= b(other.l1)\n+      }\n+\n+      if (buffer.max != null) {\n+        require(other.max != null)\n+        b(buffer.max) := la.max(b(buffer.max), b(other.max))\n+      }\n+\n+      if (buffer.min != null) {\n+        require(other.min != null)\n+        b(buffer.min) := la.min(b(buffer.min), b(other.min))\n+      }\n+\n+      if (buffer.nnz != null) {\n+        require(other.nnz != null)\n+        bl(buffer.nnz) :+= bl(other.nnz)\n+      }\n+\n+      if (buffer.weightSum != null) {\n+        require(other.weightSum != null)\n+        b(buffer.weightSum) :+= b(other.weightSum)\n+      }\n+    }\n+  }\n+\n+  private case class MetricsAggregate(\n+      requested: Seq[Metrics],\n+      startBuffer: Buffer,\n+      child: Expression,\n+      mutableAggBufferOffset: Int,\n+      inputAggBufferOffset: Int)\n+    extends TypedImperativeAggregate[Buffer] {\n+\n+    // These objects are not thread-safe, allocate them in the aggregator.\n+    private[this] lazy val row = new UnsafeRow(Buffer.numFields)\n+    private[this] lazy val projection = UnsafeProjection.create(Buffer.bufferSchema)\n+\n+\n+    override def eval(buff: Buffer): InternalRow = {\n+      val metrics = requested.map({\n+        case Mean => UnsafeArrayData.fromPrimitiveArray(Buffer.mean(buff))\n+        case Variance => UnsafeArrayData.fromPrimitiveArray(Buffer.variance(buff))\n+        case Count => Buffer.totalCount(buff)\n+        case NumNonZeros => UnsafeArrayData.fromPrimitiveArray(Buffer.nnz(buff))\n+        case Max => UnsafeArrayData.fromPrimitiveArray(Buffer.max(buff))\n+        case Min => UnsafeArrayData.fromPrimitiveArray(Buffer.min(buff))\n+        case NormL2 => UnsafeArrayData.fromPrimitiveArray(Buffer.l2(buff))\n+        case NormL1 => UnsafeArrayData.fromPrimitiveArray(Buffer.l1(buff))\n+      })\n+      InternalRow.apply(metrics: _*)\n+    }\n+\n+    override def children: Seq[Expression] = child :: Nil\n+\n+    override def update(buff: Buffer, row: InternalRow): Buffer = {\n+      // Unsafe rows do not play well with UDTs, it seems.\n+      // Directly call the deserializer.\n+      val v = udt.deserialize(row.getStruct(0, udt.sqlType.size))",
    "line": 756
  }, {
    "author": {
      "login": "WeichenXu123"
    },
    "body": "If we want to use `weight` column when summarizing, I think we can define the UDAF as:\r\n`summary(featureCol, weightCol)`\r\nand in the constructor of `MetricsAggregate` pass the weight column in.\r\nExample code as following:\r\n\r\n```\r\ncase class MetricsAggregate(\r\n      requested: Seq[Metrics],\r\n      featureExpr: Expression, // feature column expr\r\n      weightExpr: Expression, // weight column expr\r\n      mutableAggBufferOffset: Int,\r\n      inputAggBufferOffset: Int) extends TypedImperativeAggregate[Buffer] {\r\n\r\n    override def children: Seq[Expression] = featureExpr :: weightExpr :: Nil\r\n\r\n    override def update(buff: Buffer, row: InternalRow): Buffer = {\r\n      val featureVector = udt.deserialize(featureExpr.eval(row))\r\n      val weight = weightExpr.eval(row)\r\n      Buffer.updateInPlace(buff, featureVector, weight)\r\n      buff\r\n    }\r\n    ....\r\n}\r\n\r\ndef summary(featureCol: Column, weightCol: Column): Column = {\r\n    val agg = MetricsAggregate(\r\n      requestedMetrics,\r\n      featureCol.expr,\r\n      weightCol.expr,\r\n      mutableAggBufferOffset = 0,\r\n      inputAggBufferOffset = 0)\r\n    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\r\n}\r\n\r\n// handle the case user do not specify weight column\r\ndef summary(featureCol: Column): Column = {\r\n    summary(featureCol, lit(1.0))\r\n}\r\n\r\n```\r\ncc @cloud-fan @liancheng @yanboliang ",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-07-20T05:38:19Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>\n+        if (value != 0.0) {\n+          if (buffer.max != null && buffer.max(index) < value) {\n+            buffer.max(index) = value\n+          }\n+          if (buffer.min != null && buffer.min(index) > value) {\n+            buffer.min(index) = value\n+          }\n+\n+          if (buffer.mean != null) {\n+            assert(buffer.weightSum != null)\n+            val prevMean = buffer.mean(index)\n+            val diff = value - prevMean\n+            buffer.mean(index) += w * diff / (buffer.weightSum(index) + w)\n+            if (buffer.m2n != null) {\n+              buffer.m2n(index) += w * (value - buffer.mean(index)) * diff\n+            }\n+          }\n+          if (buffer.m2 != null) {\n+            buffer.m2(index) += w * value * value\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1(index) += w * math.abs(value)\n+          }\n+          if (buffer.weightSum != null) {\n+            buffer.weightSum(index) += w\n+          }\n+          if (buffer.nnz != null) {\n+            buffer.nnz(index) += 1\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+\n+    }\n+\n+\n+    /**\n+     * Merges other into buffer.\n+     */\n+    private def mergeInitializedBuffers(buffer: Buffer, other: Buffer): Unit = {\n+      // Each buffer needs to be properly initialized.\n+      require(buffer.n > 0 && other.n > 0, (buffer.n, other.n))\n+      require(buffer.n == other.n, (buffer.n, other.n))\n+      // Mandatory scalar values\n+      buffer.totalWeightSquareSum += other.totalWeightSquareSum\n+      buffer.totalWeightSum += other.totalWeightSum\n+      buffer.totalCount += other.totalCount\n+      // Keep the original weight sums.\n+      val weightSum1 = if (buffer.weightSum == null) null else { buffer.weightSum.clone() }\n+      val weightSum2 = if (other.weightSum == null) null else { other.weightSum.clone() }\n+\n+      // This sum is going to be used as a denominator. In order to guarantee that the\n+      // division is well-defined, we add an epsilon to the zero coefficients.\n+      // This is not going to change the value of the resul since the numerator will also be zero.\n+      val weightSum: BV[Double] = if (weightSum1 == null) null else {\n+        require(weightSum2 != null, s\"buffer=$buffer other=$other\")\n+        val x = b(weightSum1) :+ b(weightSum2)\n+        la.max(x, Double.MinPositiveValue)\n+      }\n+\n+\n+      // Since the operations are dense, we can directly use BLAS calls here.\n+      val deltaMean: BV[Double] = if (buffer.mean != null) {\n+        require(other.mean != null)\n+        b(other.mean) :- b(buffer.mean)\n+      } else { null }\n+\n+      if (buffer.mean != null) {\n+        require(other.mean != null)\n+        require(weightSum != null)\n+        b(buffer.mean) :+= deltaMean :* (b(weightSum2) :/ weightSum)\n+      }\n+\n+      if (buffer.m2n != null) {\n+        require(other.m2n != null)\n+        val w = (b(weightSum1) :* b(weightSum2)) :/ weightSum\n+        val z = (deltaMean :* deltaMean) :* w\n+        b(buffer.m2n) :+= b(other.m2n) :+ z\n+      }\n+\n+      if (buffer.m2 != null) {\n+        require(other.m2 != null)\n+        b(buffer.m2) :+= b(other.m2)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        require(other.l1 != null)\n+        b(buffer.l1) :+= b(other.l1)\n+      }\n+\n+      if (buffer.max != null) {\n+        require(other.max != null)\n+        b(buffer.max) := la.max(b(buffer.max), b(other.max))\n+      }\n+\n+      if (buffer.min != null) {\n+        require(other.min != null)\n+        b(buffer.min) := la.min(b(buffer.min), b(other.min))\n+      }\n+\n+      if (buffer.nnz != null) {\n+        require(other.nnz != null)\n+        bl(buffer.nnz) :+= bl(other.nnz)\n+      }\n+\n+      if (buffer.weightSum != null) {\n+        require(other.weightSum != null)\n+        b(buffer.weightSum) :+= b(other.weightSum)\n+      }\n+    }\n+  }\n+\n+  private case class MetricsAggregate(\n+      requested: Seq[Metrics],\n+      startBuffer: Buffer,\n+      child: Expression,\n+      mutableAggBufferOffset: Int,\n+      inputAggBufferOffset: Int)\n+    extends TypedImperativeAggregate[Buffer] {\n+\n+    // These objects are not thread-safe, allocate them in the aggregator.\n+    private[this] lazy val row = new UnsafeRow(Buffer.numFields)\n+    private[this] lazy val projection = UnsafeProjection.create(Buffer.bufferSchema)\n+\n+\n+    override def eval(buff: Buffer): InternalRow = {\n+      val metrics = requested.map({\n+        case Mean => UnsafeArrayData.fromPrimitiveArray(Buffer.mean(buff))\n+        case Variance => UnsafeArrayData.fromPrimitiveArray(Buffer.variance(buff))\n+        case Count => Buffer.totalCount(buff)\n+        case NumNonZeros => UnsafeArrayData.fromPrimitiveArray(Buffer.nnz(buff))\n+        case Max => UnsafeArrayData.fromPrimitiveArray(Buffer.max(buff))\n+        case Min => UnsafeArrayData.fromPrimitiveArray(Buffer.min(buff))\n+        case NormL2 => UnsafeArrayData.fromPrimitiveArray(Buffer.l2(buff))\n+        case NormL1 => UnsafeArrayData.fromPrimitiveArray(Buffer.l1(buff))\n+      })\n+      InternalRow.apply(metrics: _*)\n+    }\n+\n+    override def children: Seq[Expression] = child :: Nil\n+\n+    override def update(buff: Buffer, row: InternalRow): Buffer = {\n+      // Unsafe rows do not play well with UDTs, it seems.\n+      // Directly call the deserializer.\n+      val v = udt.deserialize(row.getStruct(0, udt.sqlType.size))",
    "line": 756
  }, {
    "author": {
      "login": "yanboliang"
    },
    "body": "+1 @WeichenXu123.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-08-01T04:03:33Z",
    "diffHunk": "@@ -0,0 +1,746 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+      // All the fields that we compute on demand:\n+      // TODO: the most common case is dense vectors. In that case we should\n+      // directly use BLAS instructions instead of iterating through a scala iterator.\n+      v.foreachActive { (index, value) =>\n+        if (value != 0.0) {\n+          if (buffer.max != null && buffer.max(index) < value) {\n+            buffer.max(index) = value\n+          }\n+          if (buffer.min != null && buffer.min(index) > value) {\n+            buffer.min(index) = value\n+          }\n+\n+          if (buffer.mean != null) {\n+            assert(buffer.weightSum != null)\n+            val prevMean = buffer.mean(index)\n+            val diff = value - prevMean\n+            buffer.mean(index) += w * diff / (buffer.weightSum(index) + w)\n+            if (buffer.m2n != null) {\n+              buffer.m2n(index) += w * (value - buffer.mean(index)) * diff\n+            }\n+          }\n+          if (buffer.m2 != null) {\n+            buffer.m2(index) += w * value * value\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1(index) += w * math.abs(value)\n+          }\n+          if (buffer.weightSum != null) {\n+            buffer.weightSum(index) += w\n+          }\n+          if (buffer.nnz != null) {\n+            buffer.nnz(index) += 1\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+\n+    }\n+\n+\n+    /**\n+     * Merges other into buffer.\n+     */\n+    private def mergeInitializedBuffers(buffer: Buffer, other: Buffer): Unit = {\n+      // Each buffer needs to be properly initialized.\n+      require(buffer.n > 0 && other.n > 0, (buffer.n, other.n))\n+      require(buffer.n == other.n, (buffer.n, other.n))\n+      // Mandatory scalar values\n+      buffer.totalWeightSquareSum += other.totalWeightSquareSum\n+      buffer.totalWeightSum += other.totalWeightSum\n+      buffer.totalCount += other.totalCount\n+      // Keep the original weight sums.\n+      val weightSum1 = if (buffer.weightSum == null) null else { buffer.weightSum.clone() }\n+      val weightSum2 = if (other.weightSum == null) null else { other.weightSum.clone() }\n+\n+      // This sum is going to be used as a denominator. In order to guarantee that the\n+      // division is well-defined, we add an epsilon to the zero coefficients.\n+      // This is not going to change the value of the resul since the numerator will also be zero.\n+      val weightSum: BV[Double] = if (weightSum1 == null) null else {\n+        require(weightSum2 != null, s\"buffer=$buffer other=$other\")\n+        val x = b(weightSum1) :+ b(weightSum2)\n+        la.max(x, Double.MinPositiveValue)\n+      }\n+\n+\n+      // Since the operations are dense, we can directly use BLAS calls here.\n+      val deltaMean: BV[Double] = if (buffer.mean != null) {\n+        require(other.mean != null)\n+        b(other.mean) :- b(buffer.mean)\n+      } else { null }\n+\n+      if (buffer.mean != null) {\n+        require(other.mean != null)\n+        require(weightSum != null)\n+        b(buffer.mean) :+= deltaMean :* (b(weightSum2) :/ weightSum)\n+      }\n+\n+      if (buffer.m2n != null) {\n+        require(other.m2n != null)\n+        val w = (b(weightSum1) :* b(weightSum2)) :/ weightSum\n+        val z = (deltaMean :* deltaMean) :* w\n+        b(buffer.m2n) :+= b(other.m2n) :+ z\n+      }\n+\n+      if (buffer.m2 != null) {\n+        require(other.m2 != null)\n+        b(buffer.m2) :+= b(other.m2)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        require(other.l1 != null)\n+        b(buffer.l1) :+= b(other.l1)\n+      }\n+\n+      if (buffer.max != null) {\n+        require(other.max != null)\n+        b(buffer.max) := la.max(b(buffer.max), b(other.max))\n+      }\n+\n+      if (buffer.min != null) {\n+        require(other.min != null)\n+        b(buffer.min) := la.min(b(buffer.min), b(other.min))\n+      }\n+\n+      if (buffer.nnz != null) {\n+        require(other.nnz != null)\n+        bl(buffer.nnz) :+= bl(other.nnz)\n+      }\n+\n+      if (buffer.weightSum != null) {\n+        require(other.weightSum != null)\n+        b(buffer.weightSum) :+= b(other.weightSum)\n+      }\n+    }\n+  }\n+\n+  private case class MetricsAggregate(\n+      requested: Seq[Metrics],\n+      startBuffer: Buffer,\n+      child: Expression,\n+      mutableAggBufferOffset: Int,\n+      inputAggBufferOffset: Int)\n+    extends TypedImperativeAggregate[Buffer] {\n+\n+    // These objects are not thread-safe, allocate them in the aggregator.\n+    private[this] lazy val row = new UnsafeRow(Buffer.numFields)\n+    private[this] lazy val projection = UnsafeProjection.create(Buffer.bufferSchema)\n+\n+\n+    override def eval(buff: Buffer): InternalRow = {\n+      val metrics = requested.map({\n+        case Mean => UnsafeArrayData.fromPrimitiveArray(Buffer.mean(buff))\n+        case Variance => UnsafeArrayData.fromPrimitiveArray(Buffer.variance(buff))\n+        case Count => Buffer.totalCount(buff)\n+        case NumNonZeros => UnsafeArrayData.fromPrimitiveArray(Buffer.nnz(buff))\n+        case Max => UnsafeArrayData.fromPrimitiveArray(Buffer.max(buff))\n+        case Min => UnsafeArrayData.fromPrimitiveArray(Buffer.min(buff))\n+        case NormL2 => UnsafeArrayData.fromPrimitiveArray(Buffer.l2(buff))\n+        case NormL1 => UnsafeArrayData.fromPrimitiveArray(Buffer.l1(buff))\n+      })\n+      InternalRow.apply(metrics: _*)\n+    }\n+\n+    override def children: Seq[Expression] = child :: Nil\n+\n+    override def update(buff: Buffer, row: InternalRow): Buffer = {\n+      // Unsafe rows do not play well with UDTs, it seems.\n+      // Directly call the deserializer.\n+      val v = udt.deserialize(row.getStruct(0, udt.sqlType.size))",
    "line": 756
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "we should not pass around the `startBuffer`, but create an initial one in `createAggregationBuffer`",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-05-08T17:34:30Z",
    "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+\n+      v match {\n+        case dv: DenseVector => updateInPlaceDense(buffer, dv, w)\n+        case sv: SparseVector => updateInPlaceSparse(buffer, sv, w)\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+    }\n+\n+    private def updateInPlaceDense(buffer: Buffer, v: DenseVector, w: Double): Unit = {\n+      val epsi = Double.MinPositiveValue\n+      lazy val value = v.asBreeze\n+      // The mask is zero for all the zero values, and one otherwise.\n+      lazy val mask = numerics.ceil(la.min(numerics.abs(value), epsi))\n+      lazy val maskWeight = w * mask\n+\n+      if (buffer.max != null) {\n+        val x = b(buffer.max)\n+        x := la.max(x, value)\n+      }\n+\n+      if (buffer.min != null) {\n+        val x = b(buffer.min)\n+        x := la.min(x, value)\n+      }\n+\n+      if (buffer.mean != null) {\n+        assert(buffer.weightSum != null)\n+        val prevMean = b(buffer.mean).copy\n+        val diff = value :- prevMean\n+        // Adding an epsilon to ensure that the denominator is always positive.\n+        // This epsilon is not going to have impact since numerator(i) == 0 => denominator(i) == 0.\n+        val denom = la.max(b(buffer.weightSum) :+ maskWeight, epsi)\n+        b(buffer.mean) :+= (maskWeight :* diff) :/ denom\n+        if (buffer.m2n != null) {\n+          b(buffer.m2n) :+= maskWeight :* ((value :- b(buffer.mean)) :* diff)\n+        }\n+      }\n+\n+      if (buffer.m2 != null) {\n+        b(buffer.m2) :+= maskWeight :* (value :* value)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        b(buffer.l1) :+= maskWeight :* numerics.abs(value)\n+      }\n+\n+\n+      if (buffer.weightSum != null) {\n+        b(buffer.weightSum) :+= maskWeight\n+      }\n+\n+      if (buffer.nnz != null) {\n+        bl(buffer.nnz) :+= la.convert(maskWeight, Long)\n+      }\n+    }\n+\n+\n+    private def updateInPlaceSparse(buffer: Buffer, v: SparseVector, w: Double): Unit = {\n+      v.foreachActive { (index, value) =>\n+        if (value != 0.0) {\n+          if (buffer.max != null && buffer.max(index) < value) {\n+            buffer.max(index) = value\n+          }\n+          if (buffer.min != null && buffer.min(index) > value) {\n+            buffer.min(index) = value\n+          }\n+\n+          if (buffer.mean != null) {\n+            assert(buffer.weightSum != null)\n+            val prevMean = buffer.mean(index)\n+            val diff = value - prevMean\n+            buffer.mean(index) += w * diff / (buffer.weightSum(index) + w)\n+            if (buffer.m2n != null) {\n+              buffer.m2n(index) += w * (value - buffer.mean(index)) * diff\n+            }\n+          }\n+          if (buffer.m2 != null) {\n+            buffer.m2(index) += w * value * value\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1(index) += w * math.abs(value)\n+          }\n+          if (buffer.weightSum != null) {\n+            buffer.weightSum(index) += w\n+          }\n+          if (buffer.nnz != null) {\n+            buffer.nnz(index) += 1\n+          }\n+        }\n+      }\n+\n+    }\n+\n+    /**\n+     * Merges other into buffer.\n+     */\n+    private def mergeInitializedBuffers(buffer: Buffer, other: Buffer): Unit = {\n+      // Each buffer needs to be properly initialized.\n+      require(buffer.n > 0 && other.n > 0, (buffer.n, other.n))\n+      require(buffer.n == other.n, (buffer.n, other.n))\n+      // Mandatory scalar values\n+      buffer.totalWeightSquareSum += other.totalWeightSquareSum\n+      buffer.totalWeightSum += other.totalWeightSum\n+      buffer.totalCount += other.totalCount\n+      // Keep the original weight sums.\n+      val weightSum1 = if (buffer.weightSum == null) null else { buffer.weightSum.clone() }\n+      val weightSum2 = if (other.weightSum == null) null else { other.weightSum.clone() }\n+\n+      // This sum is going to be used as a denominator. In order to guarantee that the\n+      // division is well-defined, we add an epsilon to the zero coefficients.\n+      // This is not going to change the value of the resul since the numerator will also be zero.\n+      val weightSum: BV[Double] = if (weightSum1 == null) null else {\n+        require(weightSum2 != null, s\"buffer=$buffer other=$other\")\n+        val x = b(weightSum1) :+ b(weightSum2)\n+        la.max(x, Double.MinPositiveValue)\n+      }\n+\n+\n+      // Since the operations are dense, we can directly use BLAS calls here.\n+      val deltaMean: BV[Double] = if (buffer.mean != null) {\n+        require(other.mean != null)\n+        b(other.mean) :- b(buffer.mean)\n+      } else { null }\n+\n+      if (buffer.mean != null) {\n+        require(other.mean != null)\n+        require(weightSum != null)\n+        b(buffer.mean) :+= deltaMean :* (b(weightSum2) :/ weightSum)\n+      }\n+\n+      if (buffer.m2n != null) {\n+        require(other.m2n != null)\n+        val w = (b(weightSum1) :* b(weightSum2)) :/ weightSum\n+        val z = (deltaMean :* deltaMean) :* w\n+        b(buffer.m2n) :+= b(other.m2n) :+ z\n+      }\n+\n+      if (buffer.m2 != null) {\n+        require(other.m2 != null)\n+        b(buffer.m2) :+= b(other.m2)\n+      }\n+\n+      if (buffer.l1 != null) {\n+        require(other.l1 != null)\n+        b(buffer.l1) :+= b(other.l1)\n+      }\n+\n+      if (buffer.max != null) {\n+        require(other.max != null)\n+        b(buffer.max) := la.max(b(buffer.max), b(other.max))\n+      }\n+\n+      if (buffer.min != null) {\n+        require(other.min != null)\n+        b(buffer.min) := la.min(b(buffer.min), b(other.min))\n+      }\n+\n+      if (buffer.nnz != null) {\n+        require(other.nnz != null)\n+        bl(buffer.nnz) :+= bl(other.nnz)\n+      }\n+\n+      if (buffer.weightSum != null) {\n+        require(other.weightSum != null)\n+        b(buffer.weightSum) :+= b(other.weightSum)\n+      }\n+    }\n+  }\n+\n+  private case class MetricsAggregate(\n+      requested: Seq[Metrics],\n+      startBuffer: Buffer,",
    "line": 726
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "Does the purpose of the code using breeze here to use BLAS to improve performance ?\r\nBUT in breeze implementation ops between vectors do not use BLAS, instead in breeze it use `cForRange`.\r\ncc @yanboliang ",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-07-20T05:44:52Z",
    "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+\n+      v match {\n+        case dv: DenseVector => updateInPlaceDense(buffer, dv, w)\n+        case sv: SparseVector => updateInPlaceSparse(buffer, sv, w)\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+    }\n+\n+    private def updateInPlaceDense(buffer: Buffer, v: DenseVector, w: Double): Unit = {\n+      val epsi = Double.MinPositiveValue",
    "line": 564
  }, {
    "author": {
      "login": "yanboliang"
    },
    "body": "I think the intention here is to make sequential operation conveniently and efficiently. AFAIK, ```cForRange``` is also very efficient. Thanks.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-08-01T04:27:52Z",
    "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap\n+    val fields = metrics.map(dct.apply).map { case (n, dt) =>\n+        StructField(n, dt, nullable = false)\n+    }\n+    StructType(fields)\n+  }\n+\n+  private val arrayDType = ArrayType(DoubleType, containsNull = false)\n+  private val arrayLType = ArrayType(LongType, containsNull = false)\n+\n+  /**\n+   * All the metrics that can be currently computed by Spark for vectors.\n+   *\n+   * This list associates the user name, the internal (typed) name, and the list of computation\n+   * metrics that need to de computed internally to get the final result.\n+   */\n+  private val allMetrics: Seq[(String, Metrics, DataType, Seq[ComputeMetrics])] = Seq(\n+    (\"mean\", Mean, arrayDType, Seq(ComputeMean, ComputeWeightSum)),\n+    (\"variance\", Variance, arrayDType, Seq(ComputeWeightSum, ComputeMean, ComputeM2n)),\n+    (\"count\", Count, LongType, Seq()),\n+    (\"numNonZeros\", NumNonZeros, arrayLType, Seq(ComputeNNZ)),\n+    (\"max\", Max, arrayDType, Seq(ComputeMax)),\n+    (\"min\", Min, arrayDType, Seq(ComputeMin)),\n+    (\"normL2\", NormL2, arrayDType, Seq(ComputeM2)),\n+    (\"normL1\", NormL1, arrayDType, Seq(ComputeL1))\n+  )\n+\n+  /**\n+   * The metrics that are currently implemented.\n+   */\n+  sealed trait Metrics\n+  case object Mean extends Metrics\n+  case object Variance extends Metrics\n+  case object Count extends Metrics\n+  case object NumNonZeros extends Metrics\n+  case object Max extends Metrics\n+  case object Min extends Metrics\n+  case object NormL2 extends Metrics\n+  case object NormL1 extends Metrics\n+\n+  /**\n+   * The running metrics that are going to be computed.\n+   *\n+   * There is a bipartite graph between the metrics and the computed metrics.\n+   */\n+  sealed trait ComputeMetrics\n+  case object ComputeMean extends ComputeMetrics\n+  case object ComputeM2n extends ComputeMetrics\n+  case object ComputeM2 extends ComputeMetrics\n+  case object ComputeL1 extends ComputeMetrics\n+  case object ComputeWeightSum extends ComputeMetrics\n+  case object ComputeNNZ extends ComputeMetrics\n+  case object ComputeMax extends ComputeMetrics\n+  case object ComputeMin extends ComputeMetrics\n+\n+  /**\n+   * The buffer that contains all the summary statistics. If the value is null, it is considered\n+   * to be not required.\n+   *\n+   * If it is required but the size of the vectors (n) is not yet know, it is initialized to\n+   * an empty array.\n+   */\n+  case class Buffer private (\n+    var n: Int = -1,                          // 0\n+    var mean: Array[Double] = null,           // 1\n+    var m2n: Array[Double] = null,            // 2\n+    var m2: Array[Double] = null,             // 3\n+    var l1: Array[Double] = null,             // 4\n+    var totalCount: Long = 0,                 // 5\n+    var totalWeightSum: Double = 0.0,         // 6\n+    var totalWeightSquareSum: Double = 0.0,   // 7\n+    var weightSum: Array[Double] = null,      // 8\n+    var nnz: Array[Long] = null,              // 9\n+    var max: Array[Double] = null,            // 10\n+    var min: Array[Double] = null             // 11\n+  ) {\n+      override def toString: String = {\n+        def v(x: Array[Double]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+        def vl(x: Array[Long]) = if (x==null) \"null\" else x.toSeq.mkString(\"[\", \" \", \"]\")\n+\n+        s\"Buffer(n=$n mean=${v(mean)} m2n=${v(m2n)} m2=${v(m2)} l1=${v(l1)}\" +\n+          s\" totalCount=$totalCount totalWeightSum=$totalWeightSum\" +\n+          s\" totalWeightSquareSum=$totalWeightSquareSum weightSum=${v(weightSum)} nnz=${vl(nnz)}\" +\n+          s\" max=${v(max)} min=${v(min)})\"\n+      }\n+    }\n+\n+  object Buffer extends Logging {\n+    // Recursive function, but the number of cases is really small.\n+    def fromMetrics(requested: Seq[ComputeMetrics]): Buffer = {\n+      if (requested.isEmpty) {\n+        new Buffer()\n+      } else {\n+        val b = fromMetrics(requested.tail)\n+        requested.head match {\n+          case ComputeMean => b.copy(mean = Array.empty)\n+          case ComputeM2n => b.copy(m2n = Array.empty)\n+          case ComputeM2 => b.copy(m2 = Array.empty)\n+          case ComputeL1 => b.copy(l1 = Array.empty)\n+          case ComputeWeightSum => b.copy(weightSum = Array.empty)\n+          case ComputeNNZ => b.copy(nnz = Array.empty)\n+          case ComputeMax => b.copy(max = Array.empty)\n+          case ComputeMin => b.copy(min = Array.empty)\n+          case _ => b // These cases are already being computed\n+        }\n+      }\n+    }\n+\n+    /**\n+     * (testing only). Makes a buffer with all the metrics enabled.\n+     */\n+    def allMetrics(): Buffer = {\n+      fromMetrics(Seq(ComputeMean, ComputeM2n, ComputeM2, ComputeL1,\n+        ComputeWeightSum, ComputeNNZ, ComputeMax,\n+        ComputeMin))\n+    }\n+\n+    val bufferSchema: StructType = {\n+      val fields = Seq(\n+        \"n\" -> IntegerType,\n+        \"mean\" -> arrayDType,\n+        \"m2n\" -> arrayDType,\n+        \"m2\" -> arrayDType,\n+        \"l1\" -> arrayDType,\n+        \"totalCount\" -> LongType,\n+        \"totalWeightSum\" -> DoubleType,\n+        \"totalWeightSquareSum\" -> DoubleType,\n+        \"weightSum\" -> arrayDType,\n+        \"nnz\" -> arrayLType,\n+        \"max\" -> arrayDType,\n+        \"min\" -> arrayDType\n+      )\n+      StructType(fields.map { case (name, t) => StructField(name, t, nullable = true)})\n+    }\n+\n+    val numFields = bufferSchema.fields.length\n+\n+    def updateInPlace(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      val startN = buffer.n\n+      if (startN == -1) {\n+        // The buffer was not initialized, we initialize it with the incoming row.\n+        fillBufferWithRow(buffer, v, w)\n+        return\n+      } else {\n+        require(startN == v.size,\n+          s\"Trying to insert a vector of size $v into a buffer that \" +\n+            s\"has been sized with $startN\")\n+      }\n+      val n = buffer.n\n+      assert(n > 0, n)\n+      // Always update the following fields.\n+      buffer.totalWeightSum += w\n+      buffer.totalCount += 1\n+      buffer.totalWeightSquareSum += w * w\n+\n+      v match {\n+        case dv: DenseVector => updateInPlaceDense(buffer, dv, w)\n+        case sv: SparseVector => updateInPlaceSparse(buffer, sv, w)\n+      }\n+    }\n+\n+    /**\n+     * Updates 'buffer' with the content of 'other', and returns 'buffer'.\n+     */\n+    @throws[SparkException](\"When the buffers are not compatible\")\n+    def mergeBuffers(buffer: Buffer, other: Buffer): Buffer = {\n+      if (buffer.n == -1) {\n+        // buffer is not initialized.\n+        if (other.n == -1) {\n+          // Both are not initialized.\n+          buffer\n+        } else {\n+          // other is initialized\n+          other\n+        }\n+      } else {\n+        // Buffer is initialized.\n+        if (other.n == -1) {\n+          buffer\n+        } else {\n+          mergeInitializedBuffers(buffer, other)\n+          buffer\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Reads a buffer from a serialized form, using the row object as an assistant.\n+     */\n+    def read(bytes: Array[Byte], backingRow: UnsafeRow): Buffer = {\n+      backingRow.pointTo(bytes.clone(), bytes.length)\n+      val row = backingRow.getStruct(0, numFields)\n+      new Buffer(\n+        n = row.getInt(0),\n+        mean = nullableArrayD(row, 1),\n+        m2n = nullableArrayD(row, 2),\n+        m2 = nullableArrayD(row, 3),\n+        l1 = nullableArrayD(row, 4),\n+        totalCount = row.getLong(5),\n+        totalWeightSum = row.getDouble(6),\n+        totalWeightSquareSum = row.getDouble(7),\n+        weightSum = nullableArrayD(row, 8),\n+        nnz = nullableArrayL(row, 9),\n+        max = nullableArrayD(row, 10),\n+        min = nullableArrayD(row, 11)\n+      )\n+    }\n+\n+\n+    def write(buffer: Buffer, project: UnsafeProjection): Array[Byte] = {\n+      val ir = InternalRow.apply(\n+        buffer.n,\n+        gadD(buffer.mean),\n+        gadD(buffer.m2n),\n+        gadD(buffer.m2),\n+        gadD(buffer.l1),\n+        buffer.totalCount,\n+        buffer.totalWeightSum,\n+        buffer.totalWeightSquareSum,\n+        gadD(buffer.weightSum),\n+        gadL(buffer.nnz),\n+        gadD(buffer.max),\n+        gadD(buffer.min)\n+      )\n+      project.apply(ir).getBytes\n+    }\n+\n+    def mean(buffer: Buffer): Array[Double] = {\n+      require(buffer.totalWeightSum > 0)\n+      require(buffer.mean != null)\n+      require(buffer.weightSum != null)\n+      val res = b(buffer.mean) :* b(buffer.weightSum) :/ buffer.totalWeightSum\n+      res.toArray\n+    }\n+\n+    def variance(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(n >= 0, n)\n+      require(totalWeightSum > 0, totalWeightSum)\n+      require(totalWeightSquareSum > 0, totalWeightSquareSum)\n+      require(buffer.mean != null)\n+      require(m2n != null)\n+      require(weightSum != null)\n+\n+      val denom = totalWeightSum - (totalWeightSquareSum / totalWeightSum)\n+      if (denom > 0.0) {\n+        val normWs = b(weightSum) :/ totalWeightSum\n+        val x = b(buffer.mean) :* b(buffer.mean) :* b(weightSum) :* (- normWs :+ 1.0)\n+        val res = (b(m2n) :+ x) :/ denom\n+        res.toArray\n+      } else {\n+        Array.ofDim(n) // Return 0.0 instead.\n+      }\n+    }\n+\n+    def totalCount(buffer: Buffer): Long = buffer.totalCount\n+\n+    def nnz(buffer: Buffer): Array[Long] = {\n+      require(buffer.nnz != null)\n+      buffer.nnz\n+    }\n+\n+    def max(buffer: Buffer): Array[Double] = {\n+      require(buffer.max != null)\n+      buffer.max\n+    }\n+\n+    def min(buffer: Buffer): Array[Double] = {\n+      require(buffer.min != null)\n+      buffer.min\n+    }\n+\n+    def l2(buffer: Buffer): Array[Double] = {\n+      import buffer._\n+      require(totalWeightSum > 0.0)\n+      require(m2 != null)\n+      numerics.sqrt(b(m2)).toArray\n+    }\n+\n+    def l1(buffer: Buffer): Array[Double] = {\n+      require(buffer.l1 != null)\n+      buffer.l1\n+    }\n+\n+\n+    private def gadD(arr: Array[Double]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    private def gadL(arr: Array[Long]): UnsafeArrayData = {\n+      if (arr == null) {\n+        null\n+      } else {\n+        UnsafeArrayData.fromPrimitiveArray(arr)\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayD(row: UnsafeRow, ordinal: Int): Array[Double] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toDoubleArray\n+      }\n+    }\n+\n+    // Returns the array at a given index, or null if the array is null.\n+    private def nullableArrayL(row: UnsafeRow, ordinal: Int): Array[Long] = {\n+      if (row.isNullAt(ordinal)) {\n+        null\n+      } else {\n+        row.getArray(ordinal).toLongArray\n+      }\n+    }\n+\n+    private def b(x: Array[Double]): BV[Double] = Vectors.dense(x).asBreeze\n+\n+    private def bl(x: Array[Long]): BV[Long] = BV.apply(x)\n+\n+    /**\n+     * Sets the content of a buffer based on a single row (initialization).\n+     *\n+     * The buffer must be uninitialized first.\n+     */\n+    private def fillBufferWithRow(buffer: Buffer, v: Vector, w: Double): Unit = {\n+      require(buffer.n == -1, (buffer.n, buffer))\n+      val n = v.size\n+      buffer.n = n\n+      buffer.totalCount = 1L\n+      buffer.totalWeightSum = w\n+      buffer.totalWeightSquareSum = w * w\n+\n+      val arr = v.toArray\n+      assert(arr.length == n, (arr.toSeq, n))\n+      if (buffer.mean != null) {\n+        buffer.mean = arr.clone()\n+      }\n+      if (buffer.m2n != null) {\n+        buffer.m2n = Array.ofDim(n)\n+      }\n+      if (buffer.max != null) {\n+        buffer.max = arr.clone()\n+      }\n+      if (buffer.min != null) {\n+        buffer.min = arr.clone()\n+      }\n+\n+      // The rest of these operations have efficient bulk versions.\n+      v match {\n+        case dv: DenseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            b(buffer.m2) := w * (b(arr) :* b(arr))\n+          }\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            b(buffer.l1) := numerics.abs(b(arr))\n+          }\n+\n+        case sv: SparseVector =>\n+          if (buffer.m2 != null) {\n+            buffer.m2 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.m2(index) = w * value * value\n+            }\n+          }\n+\n+          if (buffer.l1 != null) {\n+            buffer.l1 = Array.ofDim(n)\n+            v.foreachActive { (index, value) =>\n+              buffer.l1(index) = w * math.abs(value)\n+            }\n+          }\n+      }\n+\n+      // In the case of the weightSum and NNZ, we also have to account for the value of\n+      // the elements.\n+      // TODO It would be nice to vectorize these operations too.\n+      if (buffer.weightSum != null) {\n+        buffer.weightSum = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.weightSum(index) = w\n+          }\n+        }\n+      }\n+\n+      if (buffer.nnz != null) {\n+        buffer.nnz = Array.ofDim(n)\n+        v.foreachActive { (index, value) =>\n+          if (value != 0.0) {\n+            buffer.nnz(index) = 1L\n+          }\n+        }\n+      }\n+    }\n+\n+    private def updateInPlaceDense(buffer: Buffer, v: DenseVector, w: Double): Unit = {\n+      val epsi = Double.MinPositiveValue",
    "line": 564
  }],
  "prId": 17419
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "`m -> (n, dt)` This expr has some syntax problem.\r\nThe scala complier will turn `->` into `.->` method and will treat `n, dt` as two parameters.\r\nAnd this cause compiling error (after rebase this PR with master)\r\nwe can use:\r\n`m -> (n -> dt)` or `(m, (n, dt))` or `m -> ((n, dt))` \r\ninstead.",
    "commit": "a569dac8998d63adbc9adba1f2eb2f42967533e7",
    "createdAt": "2017-07-24T22:42:12Z",
    "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.stat\n+\n+import breeze.{linalg => la}\n+import breeze.linalg.{Vector => BV}\n+import breeze.numerics\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg.{DenseVector, SparseVector, Vector, Vectors, VectorUDT}\n+import org.apache.spark.sql.Column\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Expression, UnsafeArrayData, UnsafeProjection, UnsafeRow}\n+import org.apache.spark.sql.catalyst.expressions.aggregate.{AggregateExpression, Complete, TypedImperativeAggregate}\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * A builder object that provides summary statistics about a given column.\n+ *\n+ * Users should not directly create such builders, but instead use one of the methods in\n+ * [[Summarizer]].\n+ */\n+@Since(\"2.2.0\")\n+abstract class SummaryBuilder {\n+  /**\n+   * Returns an aggregate object that contains the summary of the column with the requested metrics.\n+   * @param column a column that contains Vector object.\n+   * @return an aggregate column that contains the statistics. The exact content of this\n+   *         structure is determined during the creation of the builder.\n+   */\n+  @Since(\"2.2.0\")\n+  def summary(column: Column): Column\n+}\n+\n+/**\n+ * Tools for vectorized statistics on MLlib Vectors.\n+ *\n+ * The methods in this package provide various statistics for Vectors contained inside DataFrames.\n+ *\n+ * This class lets users pick the statistics they would like to extract for a given column. Here is\n+ * an example in Scala:\n+ * {{{\n+ *   val dataframe = ... // Some dataframe containing a feature column\n+ *   val allStats = dataframe.select(Summarizer.metrics(\"min\", \"max\").summary($\"features\"))\n+ *   val Row(min_, max_) = allStats.first()\n+ * }}}\n+ *\n+ * If one wants to get a single metric, shortcuts are also available:\n+ * {{{\n+ *   val meanDF = dataframe.select(Summarizer.mean($\"features\"))\n+ *   val Row(mean_) = meanDF.first()\n+ * }}}\n+ */\n+@Since(\"2.2.0\")\n+object Summarizer extends Logging {\n+\n+  import SummaryBuilderImpl._\n+\n+  /**\n+   * Given a list of metrics, provides a builder that it turns computes metrics from a column.\n+   *\n+   * See the documentation of [[Summarizer]] for an example.\n+   *\n+   * The following metrics are accepted (case sensitive):\n+   *  - mean: a vector that contains the coefficient-wise mean.\n+   *  - variance: a vector tha contains the coefficient-wise variance.\n+   *  - count: the count of all vectors seen.\n+   *  - numNonzeros: a vector with the number of non-zeros for each coefficients\n+   *  - max: the maximum for each coefficient.\n+   *  - min: the minimum for each coefficient.\n+   *  - normL2: the Euclidian norm for each coefficient.\n+   *  - normL1: the L1 norm of each coefficient (sum of the absolute values).\n+   * @param firstMetric the metric being provided\n+   * @param metrics additional metrics that can be provided.\n+   * @return a builder.\n+   * @throws IllegalArgumentException if one of the metric names is not understood.\n+   */\n+  @Since(\"2.2.0\")\n+  def metrics(firstMetric: String, metrics: String*): SummaryBuilder = {\n+    val (typedMetrics, computeMetrics) = getRelevantMetrics(Seq(firstMetric) ++ metrics)\n+    new SummaryBuilderImpl(typedMetrics, computeMetrics)\n+  }\n+\n+  def mean(col: Column): Column = getSingleMetric(col, \"mean\")\n+\n+  def variance(col: Column): Column = getSingleMetric(col, \"variance\")\n+\n+  def count(col: Column): Column = getSingleMetric(col, \"count\")\n+\n+  def numNonZeros(col: Column): Column = getSingleMetric(col, \"numNonZeros\")\n+\n+  def max(col: Column): Column = getSingleMetric(col, \"max\")\n+\n+  def min(col: Column): Column = getSingleMetric(col, \"min\")\n+\n+  def normL1(col: Column): Column = getSingleMetric(col, \"normL1\")\n+\n+  def normL2(col: Column): Column = getSingleMetric(col, \"normL2\")\n+\n+  private def getSingleMetric(col: Column, metric: String): Column = {\n+    val c1 = metrics(metric).summary(col)\n+    c1.getField(metric).as(s\"$metric($col)\")\n+  }\n+}\n+\n+private[ml] class SummaryBuilderImpl(\n+    requestedMetrics: Seq[SummaryBuilderImpl.Metrics],\n+    requestedCompMetrics: Seq[SummaryBuilderImpl.ComputeMetrics]) extends SummaryBuilder {\n+\n+  override def summary(column: Column): Column = {\n+    val start = SummaryBuilderImpl.Buffer.fromMetrics(requestedCompMetrics)\n+    val agg = SummaryBuilderImpl.MetricsAggregate(\n+      requestedMetrics,\n+      start,\n+      column.expr,\n+      mutableAggBufferOffset = 0,\n+      inputAggBufferOffset = 0)\n+    new Column(AggregateExpression(agg, mode = Complete, isDistinct = false))\n+  }\n+}\n+\n+private[ml]\n+object SummaryBuilderImpl extends Logging {\n+\n+  def implementedMetrics: Seq[String] = allMetrics.map(_._1).sorted\n+\n+  @throws[IllegalArgumentException](\"When the list is empty or not a subset of known metrics\")\n+  def getRelevantMetrics(requested: Seq[String]): (Seq[Metrics], Seq[ComputeMetrics]) = {\n+    val all = requested.map { req =>\n+      val (_, metric, _, deps) = allMetrics.find(tup => tup._1 == req).getOrElse {\n+        throw new IllegalArgumentException(s\"Metric $req cannot be found.\" +\n+          s\" Valid metrics are $implementedMetrics\")\n+      }\n+      metric -> deps\n+    }\n+    // Do not sort, otherwise the user has to look the schema to see the order that it\n+    // is going to be given in.\n+    val metrics = all.map(_._1)\n+    val computeMetrics = all.flatMap(_._2).distinct.sortBy(_.toString)\n+    metrics -> computeMetrics\n+  }\n+\n+  def structureForMetrics(metrics: Seq[Metrics]): StructType = {\n+    val dct = allMetrics.map { case (n, m, dt, _) => m -> (n, dt) }.toMap",
    "line": 162
  }],
  "prId": 17419
}]