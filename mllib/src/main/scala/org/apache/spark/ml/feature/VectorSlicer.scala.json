[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Document the behavior when there are overlaps between features by index and by name, though it is in the param doc.\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:27Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given)."
  }],
  "prId": 7972
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: would `indices` be sufficient?\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:28Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given).\n+ */\n+@Experimental\n+final class VectorSlicer(override val uid: String)\n+  extends Transformer with HasInputCol with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"vectorSlicer\"))\n+\n+  /**\n+   * An array of indices to select features from a vector column.\n+   * There can be no overlap with [[selectedNames]].\n+   * @group param\n+   */\n+  val selectedIndices = new IntArrayParam(this, \"selectedIndices\","
  }],
  "prId": 7972
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`getOrDefault` -> `$`\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:29Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given).\n+ */\n+@Experimental\n+final class VectorSlicer(override val uid: String)\n+  extends Transformer with HasInputCol with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"vectorSlicer\"))\n+\n+  /**\n+   * An array of indices to select features from a vector column.\n+   * There can be no overlap with [[selectedNames]].\n+   * @group param\n+   */\n+  val selectedIndices = new IntArrayParam(this, \"selectedIndices\",\n+    \"An array of indices to select features from a vector column.\" +\n+      \" There can be no overlap with selectedNames.\", VectorSlicer.validIndices)\n+\n+  setDefault(selectedIndices -> Array.empty[Int])\n+\n+  /** @group getParam */\n+  def getSelectedIndices: Array[Int] = getOrDefault(selectedIndices)"
  }],
  "prId": 7972
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Maybe we don't need two `selectColumns`. One with case matching inside should be sufficient.\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:31Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given).\n+ */\n+@Experimental\n+final class VectorSlicer(override val uid: String)\n+  extends Transformer with HasInputCol with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"vectorSlicer\"))\n+\n+  /**\n+   * An array of indices to select features from a vector column.\n+   * There can be no overlap with [[selectedNames]].\n+   * @group param\n+   */\n+  val selectedIndices = new IntArrayParam(this, \"selectedIndices\",\n+    \"An array of indices to select features from a vector column.\" +\n+      \" There can be no overlap with selectedNames.\", VectorSlicer.validIndices)\n+\n+  setDefault(selectedIndices -> Array.empty[Int])\n+\n+  /** @group getParam */\n+  def getSelectedIndices: Array[Int] = getOrDefault(selectedIndices)\n+\n+  /** @group setParam */\n+  def setSelectedIndices(value: Array[Int]): this.type = set(selectedIndices, value)\n+\n+  /**\n+   * An array of feature names to select features from a vector column.\n+   * These names must be specified by ML [[org.apache.spark.ml.attribute.Attribute]]s.\n+   * There can be no overlap with [[selectedIndices]].\n+   * @group param\n+   */\n+  val selectedNames = new StringArrayParam(this, \"selectedNames\",\n+    \"An array of feature names to select features from a vector column.\" +\n+      \" There can be no overlap with selectedIndices.\", VectorSlicer.validNames)\n+\n+  setDefault(selectedNames -> Array.empty[String])\n+\n+  /** @group getParam */\n+  def getSelectedNames: Array[String] = getOrDefault(selectedNames)\n+\n+  /** @group setParam */\n+  def setSelectedNames(value: Array[String]): this.type = set(selectedNames, value)\n+\n+  /** @group setParam */\n+  def setInputCol(value: String): this.type = set(inputCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  /**\n+   * Slice a dense vector with an array of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: DenseVector): Vector = {\n+    Vectors.dense(indices.map(features.apply))\n+  }\n+\n+  /**\n+   * Slice a sparse vector with a set of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: SparseVector): Vector = {"
  }],
  "prId": 7972
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "remove `if (` and `) true else false`\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:38Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given).\n+ */\n+@Experimental\n+final class VectorSlicer(override val uid: String)\n+  extends Transformer with HasInputCol with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"vectorSlicer\"))\n+\n+  /**\n+   * An array of indices to select features from a vector column.\n+   * There can be no overlap with [[selectedNames]].\n+   * @group param\n+   */\n+  val selectedIndices = new IntArrayParam(this, \"selectedIndices\",\n+    \"An array of indices to select features from a vector column.\" +\n+      \" There can be no overlap with selectedNames.\", VectorSlicer.validIndices)\n+\n+  setDefault(selectedIndices -> Array.empty[Int])\n+\n+  /** @group getParam */\n+  def getSelectedIndices: Array[Int] = getOrDefault(selectedIndices)\n+\n+  /** @group setParam */\n+  def setSelectedIndices(value: Array[Int]): this.type = set(selectedIndices, value)\n+\n+  /**\n+   * An array of feature names to select features from a vector column.\n+   * These names must be specified by ML [[org.apache.spark.ml.attribute.Attribute]]s.\n+   * There can be no overlap with [[selectedIndices]].\n+   * @group param\n+   */\n+  val selectedNames = new StringArrayParam(this, \"selectedNames\",\n+    \"An array of feature names to select features from a vector column.\" +\n+      \" There can be no overlap with selectedIndices.\", VectorSlicer.validNames)\n+\n+  setDefault(selectedNames -> Array.empty[String])\n+\n+  /** @group getParam */\n+  def getSelectedNames: Array[String] = getOrDefault(selectedNames)\n+\n+  /** @group setParam */\n+  def setSelectedNames(value: Array[String]): this.type = set(selectedNames, value)\n+\n+  /** @group setParam */\n+  def setInputCol(value: String): this.type = set(inputCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  /**\n+   * Slice a dense vector with an array of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: DenseVector): Vector = {\n+    Vectors.dense(indices.map(features.apply))\n+  }\n+\n+  /**\n+   * Slice a sparse vector with a set of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: SparseVector): Vector = {\n+    features.slice(indices)\n+  }\n+\n+  override def validateParams(): Unit = {\n+    require($(selectedIndices).length > 0 || $(selectedNames).length > 0,\n+      s\"VectorSlicer requires that at least one feature be selected.\")\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    // Validity checks\n+    transformSchema(dataset.schema)\n+    val inputAttr = AttributeGroup.fromStructField(dataset.schema($(inputCol)))\n+    inputAttr.numAttributes.foreach { numFeatures =>\n+      val maxIndex = $(selectedIndices).max\n+      require(maxIndex < numFeatures,\n+        s\"Selected feature index $maxIndex invalid for only $numFeatures input features.\")\n+    }\n+\n+    // Prepare output attributes\n+    val indices = getSelectedFeatureIndices(dataset.schema)\n+    val selectedAttrs: Option[Array[Attribute]] = inputAttr.attributes.map { attrs =>\n+      indices.map(index => attrs(index))\n+    }\n+    val outputAttr = selectedAttrs match {\n+      case Some(attrs) => new AttributeGroup($(outputCol), attrs)\n+      case None => new AttributeGroup($(outputCol), indices.length)\n+    }\n+\n+    // Select features\n+    val indicesSet = indices.toSet\n+    val slicer = udf { vec: Vector =>\n+      vec match {\n+        case features: DenseVector => selectColumns(indices, features)\n+        case features: SparseVector => selectColumns(indices, features)\n+      }\n+    }\n+    dataset.withColumn($(outputCol),\n+      slicer(dataset($(inputCol))).as($(outputCol), outputAttr.toMetadata()))\n+  }\n+\n+  /** Get the feature indices in order: selectedIndices, selectedNames */\n+  private def getSelectedFeatureIndices(schema: StructType): Array[Int] = {\n+    val nameFeatures = SchemaUtils.getFeatureIndicesFromNames(schema($(inputCol)), $(selectedNames))\n+    val indFeatures = $(selectedIndices)\n+    val numDistinctFeatures = (nameFeatures ++ indFeatures).distinct.length\n+    lazy val errMsg = \"VectorSlicer requires selectedIndices and selectedNames to be disjoint\" +\n+      s\" sets of features, but they overlap.\" +\n+      s\" selectedIndices: ${indFeatures.mkString(\"[\", \",\", \"]\")}.\" +\n+      s\" selectedNames: \" +\n+      nameFeatures.zip($(selectedNames)).map { case (i, n) => s\"$i:$n\" }.mkString(\"[\", \",\", \"]\")\n+    require(nameFeatures.length + indFeatures.length == numDistinctFeatures, errMsg)\n+    indFeatures ++ nameFeatures\n+  }\n+\n+  override def transformSchema(schema: StructType): StructType = {\n+    SchemaUtils.checkColumnType(schema, $(inputCol), new VectorUDT)\n+\n+    if (schema.fieldNames.contains($(outputCol))) {\n+      throw new IllegalArgumentException(s\"Output column ${$(outputCol)} already exists.\")\n+    }\n+    val numFeaturesSelected = $(selectedIndices).length + $(selectedNames).length\n+    val outputAttr = new AttributeGroup($(outputCol), numFeaturesSelected)\n+    val outputFields = schema.fields :+ outputAttr.toStructField()\n+    StructType(outputFields)\n+  }\n+\n+  override def copy(extra: ParamMap): VectorSlicer = defaultCopy(extra)\n+}\n+\n+private[feature] object VectorSlicer {\n+\n+  /** Return true if given feature indices are valid */\n+  def validIndices(indices: Array[Int]): Boolean = {\n+    if (indices.isEmpty) {\n+      true\n+    } else {\n+      if (indices.length == indices.distinct.length && indices.forall(_ >= 0)) true else false"
  }],
  "prId": 7972
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`_.length > 0` -> `_.nonEmpty`\n",
    "commit": "b16e86e0f940b60152d57c16369945182449c6f6",
    "createdAt": "2015-08-05T22:35:42Z",
    "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.Transformer\n+import org.apache.spark.ml.attribute.{Attribute, AttributeGroup}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.ml.param.{IntArrayParam, ParamMap, StringArrayParam}\n+import org.apache.spark.ml.util.{Identifiable, SchemaUtils}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * :: Experimental ::\n+ * This class takes a feature vector and outputs a new feature vector with a subarray of the\n+ * original features.\n+ * The subset of features can be specified with either indices ([[setSelectedIndices()]])\n+ * or names ([[setSelectedNames()]]).  At least one feature must be selected.\n+ * The output vector will order features with the selected indices first (in the order given),\n+ * followed by the selected names (in the order given).\n+ */\n+@Experimental\n+final class VectorSlicer(override val uid: String)\n+  extends Transformer with HasInputCol with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"vectorSlicer\"))\n+\n+  /**\n+   * An array of indices to select features from a vector column.\n+   * There can be no overlap with [[selectedNames]].\n+   * @group param\n+   */\n+  val selectedIndices = new IntArrayParam(this, \"selectedIndices\",\n+    \"An array of indices to select features from a vector column.\" +\n+      \" There can be no overlap with selectedNames.\", VectorSlicer.validIndices)\n+\n+  setDefault(selectedIndices -> Array.empty[Int])\n+\n+  /** @group getParam */\n+  def getSelectedIndices: Array[Int] = getOrDefault(selectedIndices)\n+\n+  /** @group setParam */\n+  def setSelectedIndices(value: Array[Int]): this.type = set(selectedIndices, value)\n+\n+  /**\n+   * An array of feature names to select features from a vector column.\n+   * These names must be specified by ML [[org.apache.spark.ml.attribute.Attribute]]s.\n+   * There can be no overlap with [[selectedIndices]].\n+   * @group param\n+   */\n+  val selectedNames = new StringArrayParam(this, \"selectedNames\",\n+    \"An array of feature names to select features from a vector column.\" +\n+      \" There can be no overlap with selectedIndices.\", VectorSlicer.validNames)\n+\n+  setDefault(selectedNames -> Array.empty[String])\n+\n+  /** @group getParam */\n+  def getSelectedNames: Array[String] = getOrDefault(selectedNames)\n+\n+  /** @group setParam */\n+  def setSelectedNames(value: Array[String]): this.type = set(selectedNames, value)\n+\n+  /** @group setParam */\n+  def setInputCol(value: String): this.type = set(inputCol, value)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  /**\n+   * Slice a dense vector with an array of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: DenseVector): Vector = {\n+    Vectors.dense(indices.map(features.apply))\n+  }\n+\n+  /**\n+   * Slice a sparse vector with a set of indices.\n+   */\n+  private[feature] def selectColumns(indices: Array[Int], features: SparseVector): Vector = {\n+    features.slice(indices)\n+  }\n+\n+  override def validateParams(): Unit = {\n+    require($(selectedIndices).length > 0 || $(selectedNames).length > 0,\n+      s\"VectorSlicer requires that at least one feature be selected.\")\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    // Validity checks\n+    transformSchema(dataset.schema)\n+    val inputAttr = AttributeGroup.fromStructField(dataset.schema($(inputCol)))\n+    inputAttr.numAttributes.foreach { numFeatures =>\n+      val maxIndex = $(selectedIndices).max\n+      require(maxIndex < numFeatures,\n+        s\"Selected feature index $maxIndex invalid for only $numFeatures input features.\")\n+    }\n+\n+    // Prepare output attributes\n+    val indices = getSelectedFeatureIndices(dataset.schema)\n+    val selectedAttrs: Option[Array[Attribute]] = inputAttr.attributes.map { attrs =>\n+      indices.map(index => attrs(index))\n+    }\n+    val outputAttr = selectedAttrs match {\n+      case Some(attrs) => new AttributeGroup($(outputCol), attrs)\n+      case None => new AttributeGroup($(outputCol), indices.length)\n+    }\n+\n+    // Select features\n+    val indicesSet = indices.toSet\n+    val slicer = udf { vec: Vector =>\n+      vec match {\n+        case features: DenseVector => selectColumns(indices, features)\n+        case features: SparseVector => selectColumns(indices, features)\n+      }\n+    }\n+    dataset.withColumn($(outputCol),\n+      slicer(dataset($(inputCol))).as($(outputCol), outputAttr.toMetadata()))\n+  }\n+\n+  /** Get the feature indices in order: selectedIndices, selectedNames */\n+  private def getSelectedFeatureIndices(schema: StructType): Array[Int] = {\n+    val nameFeatures = SchemaUtils.getFeatureIndicesFromNames(schema($(inputCol)), $(selectedNames))\n+    val indFeatures = $(selectedIndices)\n+    val numDistinctFeatures = (nameFeatures ++ indFeatures).distinct.length\n+    lazy val errMsg = \"VectorSlicer requires selectedIndices and selectedNames to be disjoint\" +\n+      s\" sets of features, but they overlap.\" +\n+      s\" selectedIndices: ${indFeatures.mkString(\"[\", \",\", \"]\")}.\" +\n+      s\" selectedNames: \" +\n+      nameFeatures.zip($(selectedNames)).map { case (i, n) => s\"$i:$n\" }.mkString(\"[\", \",\", \"]\")\n+    require(nameFeatures.length + indFeatures.length == numDistinctFeatures, errMsg)\n+    indFeatures ++ nameFeatures\n+  }\n+\n+  override def transformSchema(schema: StructType): StructType = {\n+    SchemaUtils.checkColumnType(schema, $(inputCol), new VectorUDT)\n+\n+    if (schema.fieldNames.contains($(outputCol))) {\n+      throw new IllegalArgumentException(s\"Output column ${$(outputCol)} already exists.\")\n+    }\n+    val numFeaturesSelected = $(selectedIndices).length + $(selectedNames).length\n+    val outputAttr = new AttributeGroup($(outputCol), numFeaturesSelected)\n+    val outputFields = schema.fields :+ outputAttr.toStructField()\n+    StructType(outputFields)\n+  }\n+\n+  override def copy(extra: ParamMap): VectorSlicer = defaultCopy(extra)\n+}\n+\n+private[feature] object VectorSlicer {\n+\n+  /** Return true if given feature indices are valid */\n+  def validIndices(indices: Array[Int]): Boolean = {\n+    if (indices.isEmpty) {\n+      true\n+    } else {\n+      if (indices.length == indices.distinct.length && indices.forall(_ >= 0)) true else false\n+    }\n+  }\n+\n+  /** Return true if given feature names are valid */\n+  def validNames(names: Array[String]): Boolean = {\n+    names.forall(_.length > 0) && names.length == names.distinct.length"
  }],
  "prId": 7972
}]