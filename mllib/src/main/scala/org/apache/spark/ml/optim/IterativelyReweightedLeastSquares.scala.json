[{
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "Pre-computing `eta` here seems unnecessary since it is re-assigned within the while loop before it is used.\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-08T00:15:43Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.mllib.linalg.BLAS._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Fits a generalized linear model (GLM) for a given family using\n+ * iteratively reweighted least squares (IRLS).\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val family: Family,\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val standardizeFeatures: Boolean,\n+    val standardizeLabel: Boolean,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    val y = instances.map(_.label).persist(StorageLevel.MEMORY_AND_DISK)\n+    val yMean = y.reduce(_ + _) / y.count()\n+    var mu = y.map { yi => family.startingMu(yi, yMean) }\n+    var eta = mu.map { mu => family.link.link(mu) }"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "sethah"
    },
    "body": "Is there a reason to prefer `y.reduce(_ + _) / y.count()` over `y.mean()` ? \n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-12T00:27:30Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.mllib.linalg.BLAS._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Fits a generalized linear model (GLM) for a given family using\n+ * iteratively reweighted least squares (IRLS).\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val family: Family,\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val standardizeFeatures: Boolean,\n+    val standardizeLabel: Boolean,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    val y = instances.map(_.label).persist(StorageLevel.MEMORY_AND_DISK)\n+    val yMean = y.reduce(_ + _) / y.count()"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "yanboliang"
    },
    "body": "R glm has argument named `offset`, but `offsetsAndWeights` is `private`. I hope it won't confuse users, or should we rename to other better one?\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-21T11:47:17Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and some other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "It is fine for internal use.\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:38Z",
    "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and some other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`= null`\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:40Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`zip` is not efficient. Generate `newInstances` directly:\n\n``` scala\nval newInstances = instances.map { instance =>\n  val (newOffset, newWeight) = reweightFunc(instance, oldModel)\n  Instance(newOffset, newWeight, instance.features)\n}\n```\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:42Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "use named arguments for booleans\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:44Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is inefficient because it allocates several temporary vectors. We can compute `(intercept - oldIntercept)^2 + ||coefficients - oldCoefficients||_2^2` and then take the square root, without allocating new vectors.\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:45Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)\n+\n+      val oldParameters = Array.concat(Array(oldModel.intercept), oldModel.coefficients.toArray)\n+      val parameters = Array.concat(Array(model.intercept), model.coefficients.toArray)\n+      val deltaArray = oldParameters.zip(parameters).map { case (x: Double, y: Double) =>\n+        math.abs(x - y)\n+      }"
  }, {
    "author": {
      "login": "yanboliang"
    },
    "body": "I think Chebyshev distance is more suitable than Euclidean distance if we compare between difference model vectors rather than data. I get efficient way to compute Chebyshev distance inspired by your comments, thanks!\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T14:45:59Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)\n+\n+      val oldParameters = Array.concat(Array(oldModel.intercept), oldModel.coefficients.toArray)\n+      val parameters = Array.concat(Array(model.intercept), model.coefficients.toArray)\n+      val deltaArray = oldParameters.zip(parameters).map { case (x: Double, y: Double) =>\n+        math.abs(x - y)\n+      }"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "Either norm is fine for now. They are more or less equivalent. We can have a separate discussion about it. For this PR, let's just make the computation more efficient.\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-27T21:13:13Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)\n+\n+      val oldParameters = Array.concat(Array(oldModel.intercept), oldModel.coefficients.toArray)\n+      val parameters = Array.concat(Array(model.intercept), model.coefficients.toArray)\n+      val deltaArray = oldParameters.zip(parameters).map { case (x: Double, y: Double) =>\n+        math.abs(x - y)\n+      }"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is the infinity norm. Any reference?\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:12:47Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)\n+\n+      val oldParameters = Array.concat(Array(oldModel.intercept), oldModel.coefficients.toArray)\n+      val parameters = Array.concat(Array(model.intercept), model.coefficients.toArray)\n+      val deltaArray = oldParameters.zip(parameters).map { case (x: Double, y: Double) =>\n+        math.abs(x - y)\n+      }\n+      if (!deltaArray.exists(_ > tol)) {"
  }, {
    "author": {
      "login": "yanboliang"
    },
    "body": "I found R [`l1linreg`](https://github.com/cran/pracma/blob/master/R/l1linreg.R) use infinity norm (Chebyshev distance between the model vectors) as the convergence criterion. But R GLM use `deviance residuals` as the convergence criterion which is family related, that means we need pass another argument to `IterativelyReweightedLeastSquares`. So R GLM and robust regression use different convergence criterion that is hard to ideal unify.\nIt's more efficient that check convergence by model vectors rather than deviance which need computing on the whole datasets. But different convergence criterion will lead to slightly different models, so the output model may be not the same as R exactly. If we have to always ensure consistent result with R, I think we can add new argument which is a function to check convergence.\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T14:12:42Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.\n+ *\n+ * @param initialModel the initial guess model.\n+ * @param reweightFunc the reweight function which is used to update offsets and weights\n+ *                     at each iteration.\n+ * @param fitIntercept whether to fit intercept.\n+ * @param regParam L2 regularization parameter used by WLS.\n+ * @param maxIter maximum number of iterations.\n+ * @param tol the convergence tolerance.\n+ */\n+private[ml] class IterativelyReweightedLeastSquares(\n+    val initialModel: WeightedLeastSquaresModel,\n+    val reweightFunc: (Instance, WeightedLeastSquaresModel) => (Double, Double),\n+    val fitIntercept: Boolean,\n+    val regParam: Double,\n+    val maxIter: Int,\n+    val tol: Double) extends Logging with Serializable {\n+\n+  def fit(instances: RDD[Instance]): IterativelyReweightedLeastSquaresModel = {\n+\n+    var converged = false\n+    var iter = 0\n+\n+    var offsetsAndWeights: RDD[(Double, Double)] = null\n+    var model: WeightedLeastSquaresModel = initialModel\n+    var oldModel: WeightedLeastSquaresModel = initialModel\n+\n+    while (iter < maxIter && !converged) {\n+\n+      oldModel = model\n+\n+      // Update offsets and weights using reweightFunc\n+      offsetsAndWeights = instances.map { instance => reweightFunc(instance, oldModel) }\n+\n+      // Estimate new model\n+      val newInstances = instances.zip(offsetsAndWeights).map {\n+        case (instance, (offset, weight)) => Instance(offset, weight, instance.features)\n+      }\n+      model = new WeightedLeastSquares(fitIntercept, regParam, false, false).fit(newInstances)\n+\n+      val oldParameters = Array.concat(Array(oldModel.intercept), oldModel.coefficients.toArray)\n+      val parameters = Array.concat(Array(model.intercept), model.coefficients.toArray)\n+      val deltaArray = oldParameters.zip(parameters).map { case (x: Double, y: Double) =>\n+        math.abs(x - y)\n+      }\n+      if (!deltaArray.exists(_ > tol)) {"
  }],
  "prId": 10639
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It would be good to provide a reference about IRLS. The IRLS page on Wikipedia is specialized for Lp regression. I would recommend Green's paper as a reference: http://www.jstor.org/stable/2345503\n",
    "commit": "cb2057e2eeadbb52c467667ad15e23f1723685cd",
    "createdAt": "2016-01-26T07:17:43Z",
    "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.optim\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+\n+/**\n+ * Model fitted by [[IterativelyReweightedLeastSquares]].\n+ * @param coefficients model coefficients\n+ * @param intercept model intercept\n+ */\n+private[ml] class IterativelyReweightedLeastSquaresModel(\n+    val coefficients: DenseVector,\n+    val intercept: Double) extends Serializable\n+\n+/**\n+ * Implements the method of iteratively reweighted least squares (IRLS) which is used to solve\n+ * certain optimization problems by an iterative method. In each step of the iterations, it\n+ * involves solving a weighted lease squares (WLS) problem by [[WeightedLeastSquares]].\n+ * It can be used to find maximum likelihood estimates of a generalized linear model (GLM),\n+ * find M-estimator in robust regression and other optimization problems.",
    "line": 39
  }],
  "prId": 10639
}]