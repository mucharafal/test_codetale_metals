[{
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Instead of reimplementing all of this, can we extend `CrossValidatorParams`\n",
    "commit": "3d8244d4e4bdb6f0af4ce8cb2f6cf579168d4173",
    "createdAt": "2015-08-31T22:59:06Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tuning\n+\n+import com.github.fommil.netlib.F2jBLAS\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml._\n+import org.apache.spark.ml.evaluation.Evaluator\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.mllib.util.MLUtils\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * Params for [[SlidingWindowCrossValidator]] and [[SlidingWindowCrossValidatorModel]].\n+ */\n+private[ml] trait SlidingWindowCrossValidatorParams extends Params {",
    "line": 35
  }],
  "prId": 6757
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "4 indent break in parameter list\n",
    "commit": "3d8244d4e4bdb6f0af4ce8cb2f6cf579168d4173",
    "createdAt": "2015-08-31T22:59:36Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tuning\n+\n+import com.github.fommil.netlib.F2jBLAS\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml._\n+import org.apache.spark.ml.evaluation.Evaluator\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.mllib.util.MLUtils\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * Params for [[SlidingWindowCrossValidator]] and [[SlidingWindowCrossValidatorModel]].\n+ */\n+private[ml] trait SlidingWindowCrossValidatorParams extends Params {\n+\n+  /**\n+   * param for the estimator to be cross-validated\n+   * @group param\n+   */\n+  val estimator: Param[Estimator[_]] = new Param(this, \"estimator\", \"estimator for selection\")\n+\n+  /** @group getParam */\n+  def getEstimator: Estimator[_] = $(estimator)\n+\n+  /**\n+   * param for estimator param maps\n+   * @group param\n+   */\n+  val estimatorParamMaps: Param[Array[ParamMap]] =\n+    new Param(this, \"estimatorParamMaps\", \"param maps for the estimator\")\n+\n+  /** @group getParam */\n+  def getEstimatorParamMaps: Array[ParamMap] = $(estimatorParamMaps)\n+\n+  /**\n+   * param for the evaluator used to select hyper-parameters that maximize the cross-validated\n+   * metric\n+   * @group param\n+   */\n+  val evaluator: Param[Evaluator] = new Param(this, \"evaluator\",\n+    \"evaluator used to select hyper-parameters that maximize the cross-validated metric\")\n+\n+  /** @group getParam */\n+  def getEvaluator: Evaluator = $(evaluator)\n+\n+  /**\n+   * Param for number of folds for cross validation.  Must be >= 2.\n+   * Default: 3\n+   * @group param\n+   */\n+  val numFolds: IntParam = new IntParam(this, \"numFolds\",\n+    \"number of folds for cross validation (>= 2)\", ParamValidators.gtEq(2))\n+\n+  /** @group getParam */\n+  def getNumFolds: Int = $(numFolds)\n+\n+  setDefault(numFolds -> 3)\n+\n+  /**\n+   * Param for the cutoff index (exclusive) for the first training data. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val firstCutoffIndex: LongParam = new LongParam(this, \"firstCutoffIndex\",\n+    \"cutoff index (exclusive) for the first training data\", ParamValidators.gt(0))\n+\n+  setDefault(firstCutoffIndex -> 1L)\n+\n+  /** @group getParam */\n+  def getFirstCutoffIndex: Long = $(firstCutoffIndex)\n+\n+  /**\n+   * Param for the size of the validation data window. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val windowSize: LongParam = new LongParam(this, \"windowSize\",\n+    \"size of the validation data window\", ParamValidators.gt(0))\n+\n+  setDefault(windowSize -> 1L)\n+\n+  /** @group getParam */\n+  def getWindowSize: Long = $(windowSize)\n+\n+  /**\n+   * Param for index column name.\n+   * Default: \"index\"\n+   * @group param\n+   */\n+  val indexCol: Param[String] = new Param[String](this, \"indexCol\", \"index column name\")\n+\n+  setDefault(indexCol, \"index\")\n+\n+  /** @group getParam */\n+  def getIndexCol: String = $(indexCol)\n+}\n+\n+private [tuning] object SlidingWindowCrossValidator {\n+  def split(dataset: DataFrame, firstCutoffIndex: Long, windowSize: Long, numFolds: Int,\n+    indexCol: String): Array[(DataFrame, DataFrame)] = {",
    "line": 121
  }],
  "prId": 6757
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "Please invoke constructor with parenthesis (I know CrossValidator doesn't but it probably should to adhere to the [Scala style guide](http://docs.scala-lang.org/style/method-invocation.html))\n",
    "commit": "3d8244d4e4bdb6f0af4ce8cb2f6cf579168d4173",
    "createdAt": "2015-08-31T23:00:52Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tuning\n+\n+import com.github.fommil.netlib.F2jBLAS\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml._\n+import org.apache.spark.ml.evaluation.Evaluator\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.mllib.util.MLUtils\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * Params for [[SlidingWindowCrossValidator]] and [[SlidingWindowCrossValidatorModel]].\n+ */\n+private[ml] trait SlidingWindowCrossValidatorParams extends Params {\n+\n+  /**\n+   * param for the estimator to be cross-validated\n+   * @group param\n+   */\n+  val estimator: Param[Estimator[_]] = new Param(this, \"estimator\", \"estimator for selection\")\n+\n+  /** @group getParam */\n+  def getEstimator: Estimator[_] = $(estimator)\n+\n+  /**\n+   * param for estimator param maps\n+   * @group param\n+   */\n+  val estimatorParamMaps: Param[Array[ParamMap]] =\n+    new Param(this, \"estimatorParamMaps\", \"param maps for the estimator\")\n+\n+  /** @group getParam */\n+  def getEstimatorParamMaps: Array[ParamMap] = $(estimatorParamMaps)\n+\n+  /**\n+   * param for the evaluator used to select hyper-parameters that maximize the cross-validated\n+   * metric\n+   * @group param\n+   */\n+  val evaluator: Param[Evaluator] = new Param(this, \"evaluator\",\n+    \"evaluator used to select hyper-parameters that maximize the cross-validated metric\")\n+\n+  /** @group getParam */\n+  def getEvaluator: Evaluator = $(evaluator)\n+\n+  /**\n+   * Param for number of folds for cross validation.  Must be >= 2.\n+   * Default: 3\n+   * @group param\n+   */\n+  val numFolds: IntParam = new IntParam(this, \"numFolds\",\n+    \"number of folds for cross validation (>= 2)\", ParamValidators.gtEq(2))\n+\n+  /** @group getParam */\n+  def getNumFolds: Int = $(numFolds)\n+\n+  setDefault(numFolds -> 3)\n+\n+  /**\n+   * Param for the cutoff index (exclusive) for the first training data. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val firstCutoffIndex: LongParam = new LongParam(this, \"firstCutoffIndex\",\n+    \"cutoff index (exclusive) for the first training data\", ParamValidators.gt(0))\n+\n+  setDefault(firstCutoffIndex -> 1L)\n+\n+  /** @group getParam */\n+  def getFirstCutoffIndex: Long = $(firstCutoffIndex)\n+\n+  /**\n+   * Param for the size of the validation data window. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val windowSize: LongParam = new LongParam(this, \"windowSize\",\n+    \"size of the validation data window\", ParamValidators.gt(0))\n+\n+  setDefault(windowSize -> 1L)\n+\n+  /** @group getParam */\n+  def getWindowSize: Long = $(windowSize)\n+\n+  /**\n+   * Param for index column name.\n+   * Default: \"index\"\n+   * @group param\n+   */\n+  val indexCol: Param[String] = new Param[String](this, \"indexCol\", \"index column name\")\n+\n+  setDefault(indexCol, \"index\")\n+\n+  /** @group getParam */\n+  def getIndexCol: String = $(indexCol)\n+}\n+\n+private [tuning] object SlidingWindowCrossValidator {\n+  def split(dataset: DataFrame, firstCutoffIndex: Long, windowSize: Long, numFolds: Int,\n+    indexCol: String): Array[(DataFrame, DataFrame)] = {\n+    (0 until numFolds).map { idx =>\n+      val trainingUntil = firstCutoffIndex + idx * windowSize\n+      val validationUntil = firstCutoffIndex + (idx + 1) * windowSize\n+      val trainingSet = dataset.filter(dataset(indexCol) < trainingUntil)\n+      val validationSet = dataset.filter(\n+        dataset(indexCol) >= trainingUntil && dataset(indexCol) < validationUntil)\n+      (trainingSet, validationSet)\n+    }\n+    .toArray\n+  }\n+}\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Sliding window cross validation.\n+ *\n+ * [[SlidingWindowCrossValidator]] provides a cross-validation method by splitting the data set by\n+ * a cutoff index. The cutoff index is used to separate training and validation data set. Rows\n+ * smaller than the cutoff index go to the training set and rows larger than it go to the validation\n+ * set. This splitting method is useful for time-sensitive problem like fraud detection and stock\n+ * price prediction.\n+ *\n+ * 3 parameters govern the splitting: numFolds is the number of splits, firstCutoffIndex denotes the\n+ * the cutoff index of the first training data, and windowSize defines the index range of a\n+ * validation set. In particular, training data is constructed with index range in [-inf, firstCutoffIndex\n+ * + i * windowSize) and validation data is constructed with index range in [firstCutoffIndex +\n+ * i * windowSize, firstCutoffIndex + (i + 1) * windowSize).\n+ */\n+@Experimental\n+class SlidingWindowCrossValidator(override val uid: String)\n+  extends Estimator[SlidingWindowCrossValidatorModel]\n+  with SlidingWindowCrossValidatorParams with Logging {\n+\n+  def this() = this(Identifiable.randomUID(\"swcv\"))\n+\n+  private val f2jBLAS = new F2jBLAS",
    "line": 158
  }],
  "prId": 6757
}, {
  "comments": [{
    "author": {
      "login": "feynmanliang"
    },
    "body": "There is a lot of duplication between this and `CrossValidator`; perhaps we can think about subclassing here (i.e. defining a splitting method which defaults to `MLUtils.kFold` in `CrossValidator` and is overridden by `SlidingWindowCrossValidator.split` here)\n",
    "commit": "3d8244d4e4bdb6f0af4ce8cb2f6cf579168d4173",
    "createdAt": "2015-08-31T23:03:13Z",
    "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tuning\n+\n+import com.github.fommil.netlib.F2jBLAS\n+\n+import org.apache.spark.Logging\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml._\n+import org.apache.spark.ml.evaluation.Evaluator\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.mllib.util.MLUtils\n+import org.apache.spark.sql.DataFrame\n+import org.apache.spark.sql.types.StructType\n+\n+/**\n+ * Params for [[SlidingWindowCrossValidator]] and [[SlidingWindowCrossValidatorModel]].\n+ */\n+private[ml] trait SlidingWindowCrossValidatorParams extends Params {\n+\n+  /**\n+   * param for the estimator to be cross-validated\n+   * @group param\n+   */\n+  val estimator: Param[Estimator[_]] = new Param(this, \"estimator\", \"estimator for selection\")\n+\n+  /** @group getParam */\n+  def getEstimator: Estimator[_] = $(estimator)\n+\n+  /**\n+   * param for estimator param maps\n+   * @group param\n+   */\n+  val estimatorParamMaps: Param[Array[ParamMap]] =\n+    new Param(this, \"estimatorParamMaps\", \"param maps for the estimator\")\n+\n+  /** @group getParam */\n+  def getEstimatorParamMaps: Array[ParamMap] = $(estimatorParamMaps)\n+\n+  /**\n+   * param for the evaluator used to select hyper-parameters that maximize the cross-validated\n+   * metric\n+   * @group param\n+   */\n+  val evaluator: Param[Evaluator] = new Param(this, \"evaluator\",\n+    \"evaluator used to select hyper-parameters that maximize the cross-validated metric\")\n+\n+  /** @group getParam */\n+  def getEvaluator: Evaluator = $(evaluator)\n+\n+  /**\n+   * Param for number of folds for cross validation.  Must be >= 2.\n+   * Default: 3\n+   * @group param\n+   */\n+  val numFolds: IntParam = new IntParam(this, \"numFolds\",\n+    \"number of folds for cross validation (>= 2)\", ParamValidators.gtEq(2))\n+\n+  /** @group getParam */\n+  def getNumFolds: Int = $(numFolds)\n+\n+  setDefault(numFolds -> 3)\n+\n+  /**\n+   * Param for the cutoff index (exclusive) for the first training data. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val firstCutoffIndex: LongParam = new LongParam(this, \"firstCutoffIndex\",\n+    \"cutoff index (exclusive) for the first training data\", ParamValidators.gt(0))\n+\n+  setDefault(firstCutoffIndex -> 1L)\n+\n+  /** @group getParam */\n+  def getFirstCutoffIndex: Long = $(firstCutoffIndex)\n+\n+  /**\n+   * Param for the size of the validation data window. Must be > 0.\n+   * Default: 1\n+   * @group param\n+   */\n+  val windowSize: LongParam = new LongParam(this, \"windowSize\",\n+    \"size of the validation data window\", ParamValidators.gt(0))\n+\n+  setDefault(windowSize -> 1L)\n+\n+  /** @group getParam */\n+  def getWindowSize: Long = $(windowSize)\n+\n+  /**\n+   * Param for index column name.\n+   * Default: \"index\"\n+   * @group param\n+   */\n+  val indexCol: Param[String] = new Param[String](this, \"indexCol\", \"index column name\")\n+\n+  setDefault(indexCol, \"index\")\n+\n+  /** @group getParam */\n+  def getIndexCol: String = $(indexCol)\n+}\n+\n+private [tuning] object SlidingWindowCrossValidator {\n+  def split(dataset: DataFrame, firstCutoffIndex: Long, windowSize: Long, numFolds: Int,\n+    indexCol: String): Array[(DataFrame, DataFrame)] = {\n+    (0 until numFolds).map { idx =>\n+      val trainingUntil = firstCutoffIndex + idx * windowSize\n+      val validationUntil = firstCutoffIndex + (idx + 1) * windowSize\n+      val trainingSet = dataset.filter(dataset(indexCol) < trainingUntil)\n+      val validationSet = dataset.filter(\n+        dataset(indexCol) >= trainingUntil && dataset(indexCol) < validationUntil)\n+      (trainingSet, validationSet)\n+    }\n+    .toArray\n+  }\n+}\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Sliding window cross validation.\n+ *\n+ * [[SlidingWindowCrossValidator]] provides a cross-validation method by splitting the data set by\n+ * a cutoff index. The cutoff index is used to separate training and validation data set. Rows\n+ * smaller than the cutoff index go to the training set and rows larger than it go to the validation\n+ * set. This splitting method is useful for time-sensitive problem like fraud detection and stock\n+ * price prediction.\n+ *\n+ * 3 parameters govern the splitting: numFolds is the number of splits, firstCutoffIndex denotes the\n+ * the cutoff index of the first training data, and windowSize defines the index range of a\n+ * validation set. In particular, training data is constructed with index range in [-inf, firstCutoffIndex\n+ * + i * windowSize) and validation data is constructed with index range in [firstCutoffIndex +\n+ * i * windowSize, firstCutoffIndex + (i + 1) * windowSize).\n+ */\n+@Experimental\n+class SlidingWindowCrossValidator(override val uid: String)\n+  extends Estimator[SlidingWindowCrossValidatorModel]\n+  with SlidingWindowCrossValidatorParams with Logging {\n+\n+  def this() = this(Identifiable.randomUID(\"swcv\"))\n+\n+  private val f2jBLAS = new F2jBLAS\n+\n+  /** @group setParam */\n+  def setEstimator(value: Estimator[_]): this.type = set(estimator, value)\n+\n+  /** @group setParam */\n+  def setEstimatorParamMaps(value: Array[ParamMap]): this.type = set(estimatorParamMaps, value)\n+\n+  /** @group setParam */\n+  def setEvaluator(value: Evaluator): this.type = set(evaluator, value)\n+\n+  /** @group setParam */\n+  def setNumFolds(value: Int): this.type = set(numFolds, value)\n+\n+  /** @group setParam */\n+  def setFirstCutoffIndex(value: Long): this.type = set(firstCutoffIndex, value)\n+\n+  /** @group setParam */\n+  def setWindowSize(value: Long): this.type = set(windowSize, value)\n+\n+  /** @group setParam */\n+  def setIndexCol(value: String): this.type = set(indexCol, value)\n+\n+  override def fit(dataset: DataFrame): SlidingWindowCrossValidatorModel = {",
    "line": 181
  }],
  "prId": 6757
}]