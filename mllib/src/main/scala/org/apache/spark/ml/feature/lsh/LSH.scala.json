[{
  "comments": [{
    "author": {
      "login": "karlhigley"
    },
    "body": "By default, this is computing the Manhattan distance between hash values, which probably works as a proxy for the distance between hash buckets when using LSH based on p-stable distributions and any other approach that produces vectors of integers/doubles as hash signatures (e.g. MinHash).\n\nHowever, the default won't work for approaches that produce vectors of booleans as hash signatures (e.g. sign random projection for cosine distance). It could be overridden to compute Hamming distance in that case, though.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-25T21:29:00Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Yes, I am planning to override it for BitSampling (LSH for Hamming distance)\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T05:58:30Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "If it's algorithm-specific, I'd recommend making it abstract here so it's more future bug-proof.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T19:43:13Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:40:52Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "karlhigley"
    },
    "body": "This looks like a variant of multi-probe LSH, which seems extensible to the other distance measures and hashing schemes that are likely candidates for future work. It might be nice to have an option to select between probing a single bucket and probing multiple buckets though -- in some cases, the user may be happy to accept less than exactly k neighbors (i.e. a non-zero miss rate) in exchange for faster lookups.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-25T21:40:35Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    // Compute threshold to get exact k elements.\n+    val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+    val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+    val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+    // Filter the dataset where the hash value is less than the threshold.\n+    val modelSubset = modelDataset.filter(hashDistCol <= hashThreshold)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "This is a really good advice. Added an option for Single/Multiple probing.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T05:57:23Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    // Compute threshold to get exact k elements.\n+    val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+    val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+    val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+    // Filter the dataset where the hash value is less than the threshold.\n+    val modelSubset = modelDataset.filter(hashDistCol <= hashThreshold)"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "karlhigley"
    },
    "body": "Does this transform the original dataset for each key lookup? If so, it seems inefficient for repeated lookups. I can imagine a few possibilities to help with that:\n- Allowing lookups of multiple keys simultaneously (to amortize the cost of building the hash tables), and/or\n- Providing a way to pre-compute the hash tables (i.e. `modelDataset`) and execute multiple lookups against them, and/or\n- Storing the hash tables on the model and making it possible to cache them in memory\n\nThe ability to load and save models with their `modelDataset`s would also help, but that's probably out of scope for this initial PR. Structuring the model so that hash tables can be pre-computed/cached would set up that future work nicely, though.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-25T22:00:22Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Based on my discussion with @jkbradley, storing the hash tables on the model is not an option. To make the interface cleaner, I went with option (2) in the new commit. Basically, transforms() will skip the computation if outputCol is already there. So users can do the following to avoid inefficiency in repeated lookups.\n`val model = new MinHash()...fit(df)`\n`val transformedDf = model.transform(df).cache()`\n`model.approxNearestNeighbor(transformedDf, key1, k=3)`\n`model.approxNearestNeighbor(transformedDf, key2, k=5)`\n\nMeanwhile, putting the raw Df works as well, but with low performance for multiple queries,\n`val model = new MinHash()...fit(df)`\n`model.approxNearestNeighbor(df, key, k=3)`\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T06:20:54Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)"
  }, {
    "author": {
      "login": "MLnick"
    },
    "body": "Can you elaborate on this discussion? I don't see it referenced anywhere on the PR, JIRA or design doc.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T10:05:40Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "@MLnick I believe the discussion is in the resolved comments in the design doc.\n\nThe main issue is that, currently, no MLlib models store the entire dataset.  Some do store transient references, but those do not need to be saved when models are saved.  If a model method like approxNearestNeighbor assumed that the dataset were part of the model, then model.save would need to save the entire dataset.\n\nI'm in favor of supporting pre-computation too.  I'd recommend that approxNearestNeighbor implement the logic to check whether outputCol already exists; this should not belong in transform (to be consistent with the rest of MLlib).\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T19:46:14Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Moved the checking logic to approxNearestNeighbor and approxSimilarityJoin\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:40:48Z",
    "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    transformSchema(dataset.schema, logging = true)\n+    val transformUDF = udf(hashFunction, new VectorUDT)\n+    dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Make this one line, i.e. `setDefault(outputDim -> 1, outputCol -> \"lsh_output\")`\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T12:14:57Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:40:43Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Strictly speaking this is actually the number of hash buckets/functions. Yes, it is a \"dimensionality reduction\" and the output vectors have this dimension, but perhaps we can add a bit more documentation here expanding on the role of the buckets?\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T12:50:51Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\","
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "This is the dimension of LSH OR-amplification. Added in Scaladoc\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:40:40Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\","
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "This method should be protected. Also, while not strictly required, it's common to call this type of shared method `validateAndTransformSchema` (it's not defined as an internal API, it's just what has ended up being used commonly in various models & transformers).\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T12:54:50Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:41:00Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "You can use `SchemaUtils.appendColumn(schema, $(outputCol), new VectorUDT)` for this purpose\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T12:55:35Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:41:02Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Please follow Spark code style for method arg indentation (https://cwiki.apache.org/confluence/display/SPARK/Spark+Code+Style+Guide#SparkCodeStyleGuide-Indentation)\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T12:56:45Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:41:04Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Ditto here for indentation style\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T13:09:51Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    val modelSubset = if (singleProbing) {\n+      modelDataset.filter(hashDistCol === 0.0)\n+    } else {\n+      // Compute threshold to get exact k elements.\n+      val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+      val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+      val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+      // Filter the dataset where the hash value is less than the threshold.\n+      modelDataset.filter(hashDistCol <= hashThreshold)\n+    }\n+\n+    // Get the top k nearest neighbor by their distance to the key\n+    val keyDistUDF = udf((x: KeyType) => keyDistance(x, key), DataTypes.DoubleType)\n+    val modelSubsetWithDistCol = modelSubset.withColumn(distCol, keyDistUDF(col($(inputCol))))\n+    modelSubsetWithDistCol.sort(distCol).limit(k)\n+  }\n+\n+  /**\n+   * Preprocess step for approximate similarity join. Transform and explode the outputCol to\n+   * explodeCols.\n+   * @param dataset The dataset to transform and explode.\n+   * @param explodeCols The alias for the exploded columns, must be a seq of two strings.\n+   * @return A dataset containing idCol, inputCol and explodeCols\n+   */\n+  private[this] def processDataset(dataset: Dataset[_], explodeCols: Seq[String]): Dataset[_] = {\n+    if (explodeCols.size != 2) {\n+      throw new Exception(\"explodeCols must be two strings.\")\n+    }\n+    val vectorToMap: UserDefinedFunction = udf((x: Vector) => x.asBreeze.iterator.toMap,\n+      MapType(DataTypes.IntegerType, DataTypes.DoubleType))\n+    transform(dataset)\n+      .select(col(\"*\"), explode(vectorToMap(col($(outputCol)))).as(explodeCols))\n+  }\n+\n+  /**\n+   * Recreate a column using the same column name but different attribute id. Used in approximate\n+   * similarity join.\n+   * @param dataset The dataset where a column need to recreate\n+   * @param colName The name of the column to recreate\n+   * @param tmpColName A temporary column name which does not conflict with existing columns\n+   * @return\n+   */\n+  private[this] def recreateCol(dataset: Dataset[_], colName: String,\n+                                tmpColName: String): Dataset[_] = {\n+    dataset\n+      .withColumnRenamed(colName, tmpColName)\n+      .withColumn(colName, col(tmpColName))\n+      .drop(tmpColName)\n+  }\n+\n+  /**\n+   * Join two dataset to approximately find all pairs of records whose distance are smaller\n+   * than the threshold.\n+   * @param datasetA One of the datasets to join\n+   * @param datasetB Another dataset to join\n+   * @param threshold The threshold for the distance of record pairs\n+   * @param distCol The column to store the distance between pairs\n+   * @return A joined dataset containing pairs of records. A distCol is added to show the distance\n+   *         between each pair of records.\n+   */\n+  def approxSimilarityJoin(datasetA: Dataset[_], datasetB: Dataset[_], threshold: Double,\n+                           distCol: String = \"distance\"): Dataset[_] = {"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "Btw, it'd also be good to avoid default parameter values in methods since they are not Java-friendly.  You can write a version of the method which does not take `distCol` as an arg in order to implement the default.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T20:02:11Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    val modelSubset = if (singleProbing) {\n+      modelDataset.filter(hashDistCol === 0.0)\n+    } else {\n+      // Compute threshold to get exact k elements.\n+      val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+      val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+      val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+      // Filter the dataset where the hash value is less than the threshold.\n+      modelDataset.filter(hashDistCol <= hashThreshold)\n+    }\n+\n+    // Get the top k nearest neighbor by their distance to the key\n+    val keyDistUDF = udf((x: KeyType) => keyDistance(x, key), DataTypes.DoubleType)\n+    val modelSubsetWithDistCol = modelSubset.withColumn(distCol, keyDistUDF(col($(inputCol))))\n+    modelSubsetWithDistCol.sort(distCol).limit(k)\n+  }\n+\n+  /**\n+   * Preprocess step for approximate similarity join. Transform and explode the outputCol to\n+   * explodeCols.\n+   * @param dataset The dataset to transform and explode.\n+   * @param explodeCols The alias for the exploded columns, must be a seq of two strings.\n+   * @return A dataset containing idCol, inputCol and explodeCols\n+   */\n+  private[this] def processDataset(dataset: Dataset[_], explodeCols: Seq[String]): Dataset[_] = {\n+    if (explodeCols.size != 2) {\n+      throw new Exception(\"explodeCols must be two strings.\")\n+    }\n+    val vectorToMap: UserDefinedFunction = udf((x: Vector) => x.asBreeze.iterator.toMap,\n+      MapType(DataTypes.IntegerType, DataTypes.DoubleType))\n+    transform(dataset)\n+      .select(col(\"*\"), explode(vectorToMap(col($(outputCol)))).as(explodeCols))\n+  }\n+\n+  /**\n+   * Recreate a column using the same column name but different attribute id. Used in approximate\n+   * similarity join.\n+   * @param dataset The dataset where a column need to recreate\n+   * @param colName The name of the column to recreate\n+   * @param tmpColName A temporary column name which does not conflict with existing columns\n+   * @return\n+   */\n+  private[this] def recreateCol(dataset: Dataset[_], colName: String,\n+                                tmpColName: String): Dataset[_] = {\n+    dataset\n+      .withColumnRenamed(colName, tmpColName)\n+      .withColumn(colName, col(tmpColName))\n+      .drop(tmpColName)\n+  }\n+\n+  /**\n+   * Join two dataset to approximately find all pairs of records whose distance are smaller\n+   * than the threshold.\n+   * @param datasetA One of the datasets to join\n+   * @param datasetB Another dataset to join\n+   * @param threshold The threshold for the distance of record pairs\n+   * @param distCol The column to store the distance between pairs\n+   * @return A joined dataset containing pairs of records. A distCol is added to show the distance\n+   *         between each pair of records.\n+   */\n+  def approxSimilarityJoin(datasetA: Dataset[_], datasetB: Dataset[_], threshold: Double,\n+                           distCol: String = \"distance\"): Dataset[_] = {"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:41:13Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    val modelSubset = if (singleProbing) {\n+      modelDataset.filter(hashDistCol === 0.0)\n+    } else {\n+      // Compute threshold to get exact k elements.\n+      val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+      val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+      val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+      // Filter the dataset where the hash value is less than the threshold.\n+      modelDataset.filter(hashDistCol <= hashThreshold)\n+    }\n+\n+    // Get the top k nearest neighbor by their distance to the key\n+    val keyDistUDF = udf((x: KeyType) => keyDistance(x, key), DataTypes.DoubleType)\n+    val modelSubsetWithDistCol = modelSubset.withColumn(distCol, keyDistUDF(col($(inputCol))))\n+    modelSubsetWithDistCol.sort(distCol).limit(k)\n+  }\n+\n+  /**\n+   * Preprocess step for approximate similarity join. Transform and explode the outputCol to\n+   * explodeCols.\n+   * @param dataset The dataset to transform and explode.\n+   * @param explodeCols The alias for the exploded columns, must be a seq of two strings.\n+   * @return A dataset containing idCol, inputCol and explodeCols\n+   */\n+  private[this] def processDataset(dataset: Dataset[_], explodeCols: Seq[String]): Dataset[_] = {\n+    if (explodeCols.size != 2) {\n+      throw new Exception(\"explodeCols must be two strings.\")\n+    }\n+    val vectorToMap: UserDefinedFunction = udf((x: Vector) => x.asBreeze.iterator.toMap,\n+      MapType(DataTypes.IntegerType, DataTypes.DoubleType))\n+    transform(dataset)\n+      .select(col(\"*\"), explode(vectorToMap(col($(outputCol)))).as(explodeCols))\n+  }\n+\n+  /**\n+   * Recreate a column using the same column name but different attribute id. Used in approximate\n+   * similarity join.\n+   * @param dataset The dataset where a column need to recreate\n+   * @param colName The name of the column to recreate\n+   * @param tmpColName A temporary column name which does not conflict with existing columns\n+   * @return\n+   */\n+  private[this] def recreateCol(dataset: Dataset[_], colName: String,\n+                                tmpColName: String): Dataset[_] = {\n+    dataset\n+      .withColumnRenamed(colName, tmpColName)\n+      .withColumn(colName, col(tmpColName))\n+      .drop(tmpColName)\n+  }\n+\n+  /**\n+   * Join two dataset to approximately find all pairs of records whose distance are smaller\n+   * than the threshold.\n+   * @param datasetA One of the datasets to join\n+   * @param datasetB Another dataset to join\n+   * @param threshold The threshold for the distance of record pairs\n+   * @param distCol The column to store the distance between pairs\n+   * @return A joined dataset containing pairs of records. A distCol is added to show the distance\n+   *         between each pair of records.\n+   */\n+  def approxSimilarityJoin(datasetA: Dataset[_], datasetB: Dataset[_], threshold: Double,\n+                           distCol: String = \"distance\"): Dataset[_] = {"
  }],
  "prId": 15148
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "These methods that return `this.type` need to be overridden in the concrete subclasses for Java compat in the method chaining style (sadly)... see `RandomForestClassifier` for an example.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-26T13:11:13Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    val modelSubset = if (singleProbing) {\n+      modelDataset.filter(hashDistCol === 0.0)\n+    } else {\n+      // Compute threshold to get exact k elements.\n+      val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+      val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+      val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+      // Filter the dataset where the hash value is less than the threshold.\n+      modelDataset.filter(hashDistCol <= hashThreshold)\n+    }\n+\n+    // Get the top k nearest neighbor by their distance to the key\n+    val keyDistUDF = udf((x: KeyType) => keyDistance(x, key), DataTypes.DoubleType)\n+    val modelSubsetWithDistCol = modelSubset.withColumn(distCol, keyDistUDF(col($(inputCol))))\n+    modelSubsetWithDistCol.sort(distCol).limit(k)\n+  }\n+\n+  /**\n+   * Preprocess step for approximate similarity join. Transform and explode the outputCol to\n+   * explodeCols.\n+   * @param dataset The dataset to transform and explode.\n+   * @param explodeCols The alias for the exploded columns, must be a seq of two strings.\n+   * @return A dataset containing idCol, inputCol and explodeCols\n+   */\n+  private[this] def processDataset(dataset: Dataset[_], explodeCols: Seq[String]): Dataset[_] = {\n+    if (explodeCols.size != 2) {\n+      throw new Exception(\"explodeCols must be two strings.\")\n+    }\n+    val vectorToMap: UserDefinedFunction = udf((x: Vector) => x.asBreeze.iterator.toMap,\n+      MapType(DataTypes.IntegerType, DataTypes.DoubleType))\n+    transform(dataset)\n+      .select(col(\"*\"), explode(vectorToMap(col($(outputCol)))).as(explodeCols))\n+  }\n+\n+  /**\n+   * Recreate a column using the same column name but different attribute id. Used in approximate\n+   * similarity join.\n+   * @param dataset The dataset where a column need to recreate\n+   * @param colName The name of the column to recreate\n+   * @param tmpColName A temporary column name which does not conflict with existing columns\n+   * @return\n+   */\n+  private[this] def recreateCol(dataset: Dataset[_], colName: String,\n+                                tmpColName: String): Dataset[_] = {\n+    dataset\n+      .withColumnRenamed(colName, tmpColName)\n+      .withColumn(colName, col(tmpColName))\n+      .drop(tmpColName)\n+  }\n+\n+  /**\n+   * Join two dataset to approximately find all pairs of records whose distance are smaller\n+   * than the threshold.\n+   * @param datasetA One of the datasets to join\n+   * @param datasetB Another dataset to join\n+   * @param threshold The threshold for the distance of record pairs\n+   * @param distCol The column to store the distance between pairs\n+   * @return A joined dataset containing pairs of records. A distCol is added to show the distance\n+   *         between each pair of records.\n+   */\n+  def approxSimilarityJoin(datasetA: Dataset[_], datasetB: Dataset[_], threshold: Double,\n+                           distCol: String = \"distance\"): Dataset[_] = {\n+\n+    val explodeCols = Seq(\"lsh#entry\", \"lsh#hashValue\")\n+    val explodedA = processDataset(datasetA, explodeCols)\n+\n+    // If this is a self join, we need to recreate the inputCol of datasetB to avoid ambiguity.\n+    // TODO: Remove recreateCol logic once SPARK-17154 is resolved.\n+    val explodedB = if (datasetA != datasetB) {\n+      processDataset(datasetB, explodeCols)\n+    } else {\n+      val recreatedB = recreateCol(datasetB, $(inputCol), s\"${$(inputCol)}#${Random.nextString(5)}\")\n+      processDataset(recreatedB, explodeCols)\n+    }\n+\n+    // Do a hash join on where the exploded hash values are equal.\n+    val joinedDataset = explodedA.join(explodedB, explodeCols)\n+      .drop(explodeCols: _*)\n+\n+    // Add a new column to store the distance of the two records.\n+    val distUDF = udf((x: KeyType, y: KeyType) => keyDistance(x, y), DataTypes.DoubleType)\n+    val joinedDatasetWithDist = joinedDataset.select(col(\"*\"),\n+      distUDF(explodedA($(inputCol)), explodedB($(inputCol))).as(distCol)\n+    )\n+\n+    // Filter the joined datasets where the distance are smaller than the threshold.\n+    joinedDatasetWithDist.filter(col(distCol) < threshold).distinct()\n+  }\n+}\n+\n+/**\n+ * Locality Sensitive Hashing for different metrics space. Support basic transformation with a new\n+ * hash column, approximate nearest neighbor search with a dataset and a key, and approximate\n+ * similarity join of two datasets.\n+ *\n+ * Currently the following LSH family is implemented:\n+ *  - Euclidean Distance: Random Projection\n+ *\n+ * References:\n+ * (1) Gionis, Aristides, Piotr Indyk, and Rajeev Motwani. \"Similarity search in high dimensions\n+ * via hashing.\" VLDB 7 Sep. 1999: 518-529.\n+ * (2) Wang, Jingdong et al. \"Hashing for similarity search: A survey.\" arXiv preprint\n+ * arXiv:1408.2927 (2014).\n+ * @tparam KeyType The input key type of LSH\n+ * @tparam T The class type of lsh\n+ */\n+abstract class LSH[KeyType, T <: LSHModel[KeyType, T]] extends Estimator[T] with LSHParams {\n+  /** @group setParam */\n+  def setInputCol(value: String): this.type = set(inputCol, value)"
  }, {
    "author": {
      "login": "Yunni"
    },
    "body": "Done.\n",
    "commit": "35708458a0ee156c097ca604efeafaa37d3c8a6d",
    "createdAt": "2016-09-28T19:41:16Z",
    "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature.lsh\n+\n+import scala.util.Random\n+\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.linalg.{Vector, VectorUDT}\n+import org.apache.spark.ml.param.{IntParam, ParamMap, ParamValidators}\n+import org.apache.spark.ml.param.shared.{HasInputCol, HasOutputCol}\n+import org.apache.spark.sql._\n+import org.apache.spark.sql.expressions.UserDefinedFunction\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * Params for [[LSH]].\n+ */\n+private[ml] trait LSHParams extends HasInputCol with HasOutputCol {\n+  /**\n+   * Param for output dimension.\n+   *\n+   * @group param\n+   */\n+  final val outputDim: IntParam = new IntParam(this, \"outputDim\", \"output dimension\",\n+    ParamValidators.gt(0))\n+\n+  /** @group getParam */\n+  final def getOutputDim: Int = $(outputDim)\n+\n+  setDefault(outputDim -> 1)\n+\n+  setDefault(outputCol -> \"lsh_output\")\n+\n+  /**\n+   * Transform the Schema for LSH\n+   * @param schema The schema of the input dataset without outputCol\n+   * @return A derived schema with outputCol added\n+   */\n+  final def transformLSHSchema(schema: StructType): StructType = {\n+    val outputFields = schema.fields :+\n+      StructField($(outputCol), new VectorUDT, nullable = false)\n+    StructType(outputFields)\n+  }\n+}\n+\n+/**\n+ * Model produced by [[LSH]].\n+ */\n+abstract class LSHModel[KeyType, T <: LSHModel[KeyType, T]] private[ml]\n+  extends Model[T] with LSHParams {\n+  override def copy(extra: ParamMap): T = defaultCopy(extra)\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * The hash function of LSH, mapping a predefined KeyType to a Vector\n+   * @return The mapping of LSH function.\n+   */\n+  protected[this] val hashFunction: KeyType => Vector\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different keys using the distance metric corresponding\n+   * to the hashFunction\n+   * @param x One of the point in the metric space\n+   * @param y Another the point in the metric space\n+   * @return The distance between x and y in double\n+   */\n+  protected[ml] def keyDistance(x: KeyType, y: KeyType): Double\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Calculate the distance between two different hash Vectors. By default, the distance is the\n+   * minimum distance of two hash values in any dimension.\n+   *\n+   * @param x One of the hash vector\n+   * @param y Another hash vector\n+   * @return The distance between hash vectors x and y in double\n+   */\n+  protected[ml] def hashDistance(x: Vector, y: Vector): Double = {\n+    // Since it's generated by hashing, it will be a pair of dense vectors.\n+    x.toDense.values.zip(y.toDense.values).map(x => math.abs(x._1 - x._2)).min\n+  }\n+\n+  /**\n+   * Transforms the input dataset.\n+   */\n+  override def transform(dataset: Dataset[_]): DataFrame = {\n+    if (!dataset.columns.contains($(outputCol))) {\n+      transformSchema(dataset.schema, logging = true)\n+      val transformUDF = udf(hashFunction, new VectorUDT)\n+      dataset.withColumn($(outputCol), transformUDF(dataset($(inputCol))))\n+    } else {\n+      dataset.toDF()\n+    }\n+  }\n+\n+  /**\n+   * :: DeveloperApi ::\n+   *\n+   * Check transform validity and derive the output schema from the input schema.\n+   *\n+   * Typical implementation should first conduct verification on schema change and parameter\n+   * validity, including complex parameter interaction checks.\n+   */\n+  override def transformSchema(schema: StructType): StructType = {\n+    transformLSHSchema(schema)\n+  }\n+\n+  /**\n+   * Given a large dataset and an item, approximately find at most k items which have the closest\n+   * distance to the item.\n+   *\n+   * This method has implemented two way of fetching k nearest neighbors:\n+   *    Single Probing: Fast, return at most k elements (Probing only one buckets)\n+   *    Multiple Probing: Slow, return exact k elements (Probing multiple buckets close to the key)\n+   *\n+   * @param dataset the dataset to look for the key\n+   * @param key The key to hash for the item\n+   * @param k The maximum number of items closest to the key\n+   * @param singleProbing True for using Single Probing; false for multiple probing\n+   * @param distCol The column to store the distance between pairs\n+   * @return A dataset containing at most k items closest to the key. A distCol is added to show\n+   *         the distance between each record and the key.\n+   */\n+  def approxNearestNeighbors(dataset: Dataset[_], key: KeyType, k: Int = 1,\n+                             singleProbing: Boolean = true,\n+                             distCol: String = \"distance\"): Dataset[_] = {\n+    assert(k > 0, \"The number of nearest neighbors cannot be less than 1\")\n+    // Get Hash Value of the key v\n+    val keyHash = hashFunction(key)\n+    val modelDataset = transform(dataset)\n+\n+    // In the origin dataset, find the hash value u that is closest to v\n+    val hashDistUDF = udf((x: Vector) => hashDistance(x, keyHash), DataTypes.DoubleType)\n+    val hashDistCol = hashDistUDF(col($(outputCol)))\n+\n+    val modelSubset = if (singleProbing) {\n+      modelDataset.filter(hashDistCol === 0.0)\n+    } else {\n+      // Compute threshold to get exact k elements.\n+      val modelDatasetSortedByHash = modelDataset.sort(hashDistCol).limit(k)\n+      val thresholdDataset = modelDatasetSortedByHash.select(max(hashDistCol))\n+      val hashThreshold = thresholdDataset.collect()(0)(0).asInstanceOf[Double]\n+\n+      // Filter the dataset where the hash value is less than the threshold.\n+      modelDataset.filter(hashDistCol <= hashThreshold)\n+    }\n+\n+    // Get the top k nearest neighbor by their distance to the key\n+    val keyDistUDF = udf((x: KeyType) => keyDistance(x, key), DataTypes.DoubleType)\n+    val modelSubsetWithDistCol = modelSubset.withColumn(distCol, keyDistUDF(col($(inputCol))))\n+    modelSubsetWithDistCol.sort(distCol).limit(k)\n+  }\n+\n+  /**\n+   * Preprocess step for approximate similarity join. Transform and explode the outputCol to\n+   * explodeCols.\n+   * @param dataset The dataset to transform and explode.\n+   * @param explodeCols The alias for the exploded columns, must be a seq of two strings.\n+   * @return A dataset containing idCol, inputCol and explodeCols\n+   */\n+  private[this] def processDataset(dataset: Dataset[_], explodeCols: Seq[String]): Dataset[_] = {\n+    if (explodeCols.size != 2) {\n+      throw new Exception(\"explodeCols must be two strings.\")\n+    }\n+    val vectorToMap: UserDefinedFunction = udf((x: Vector) => x.asBreeze.iterator.toMap,\n+      MapType(DataTypes.IntegerType, DataTypes.DoubleType))\n+    transform(dataset)\n+      .select(col(\"*\"), explode(vectorToMap(col($(outputCol)))).as(explodeCols))\n+  }\n+\n+  /**\n+   * Recreate a column using the same column name but different attribute id. Used in approximate\n+   * similarity join.\n+   * @param dataset The dataset where a column need to recreate\n+   * @param colName The name of the column to recreate\n+   * @param tmpColName A temporary column name which does not conflict with existing columns\n+   * @return\n+   */\n+  private[this] def recreateCol(dataset: Dataset[_], colName: String,\n+                                tmpColName: String): Dataset[_] = {\n+    dataset\n+      .withColumnRenamed(colName, tmpColName)\n+      .withColumn(colName, col(tmpColName))\n+      .drop(tmpColName)\n+  }\n+\n+  /**\n+   * Join two dataset to approximately find all pairs of records whose distance are smaller\n+   * than the threshold.\n+   * @param datasetA One of the datasets to join\n+   * @param datasetB Another dataset to join\n+   * @param threshold The threshold for the distance of record pairs\n+   * @param distCol The column to store the distance between pairs\n+   * @return A joined dataset containing pairs of records. A distCol is added to show the distance\n+   *         between each pair of records.\n+   */\n+  def approxSimilarityJoin(datasetA: Dataset[_], datasetB: Dataset[_], threshold: Double,\n+                           distCol: String = \"distance\"): Dataset[_] = {\n+\n+    val explodeCols = Seq(\"lsh#entry\", \"lsh#hashValue\")\n+    val explodedA = processDataset(datasetA, explodeCols)\n+\n+    // If this is a self join, we need to recreate the inputCol of datasetB to avoid ambiguity.\n+    // TODO: Remove recreateCol logic once SPARK-17154 is resolved.\n+    val explodedB = if (datasetA != datasetB) {\n+      processDataset(datasetB, explodeCols)\n+    } else {\n+      val recreatedB = recreateCol(datasetB, $(inputCol), s\"${$(inputCol)}#${Random.nextString(5)}\")\n+      processDataset(recreatedB, explodeCols)\n+    }\n+\n+    // Do a hash join on where the exploded hash values are equal.\n+    val joinedDataset = explodedA.join(explodedB, explodeCols)\n+      .drop(explodeCols: _*)\n+\n+    // Add a new column to store the distance of the two records.\n+    val distUDF = udf((x: KeyType, y: KeyType) => keyDistance(x, y), DataTypes.DoubleType)\n+    val joinedDatasetWithDist = joinedDataset.select(col(\"*\"),\n+      distUDF(explodedA($(inputCol)), explodedB($(inputCol))).as(distCol)\n+    )\n+\n+    // Filter the joined datasets where the distance are smaller than the threshold.\n+    joinedDatasetWithDist.filter(col(distCol) < threshold).distinct()\n+  }\n+}\n+\n+/**\n+ * Locality Sensitive Hashing for different metrics space. Support basic transformation with a new\n+ * hash column, approximate nearest neighbor search with a dataset and a key, and approximate\n+ * similarity join of two datasets.\n+ *\n+ * Currently the following LSH family is implemented:\n+ *  - Euclidean Distance: Random Projection\n+ *\n+ * References:\n+ * (1) Gionis, Aristides, Piotr Indyk, and Rajeev Motwani. \"Similarity search in high dimensions\n+ * via hashing.\" VLDB 7 Sep. 1999: 518-529.\n+ * (2) Wang, Jingdong et al. \"Hashing for similarity search: A survey.\" arXiv preprint\n+ * arXiv:1408.2927 (2014).\n+ * @tparam KeyType The input key type of LSH\n+ * @tparam T The class type of lsh\n+ */\n+abstract class LSH[KeyType, T <: LSHModel[KeyType, T]] extends Estimator[T] with LSHParams {\n+  /** @group setParam */\n+  def setInputCol(value: String): this.type = set(inputCol, value)"
  }],
  "prId": 15148
}]