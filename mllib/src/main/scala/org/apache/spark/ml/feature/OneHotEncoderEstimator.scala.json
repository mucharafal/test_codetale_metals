[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I have a question. Since we don't allow negative value when fitting, should we allow it in transforming even handleInvalid is KEEP_INVALID?",
    "commit": "c547d0fa7c4e1bb61312219df4d273af4a5a9db9",
    "createdAt": "2018-01-01T15:09:19Z",
    "diffHunk": "@@ -205,60 +210,58 @@ class OneHotEncoderModel private[ml] (\n \n   import OneHotEncoderModel._\n \n-  // Returns the category size for a given index with `dropLast` and `handleInvalid`\n+  // Returns the category size for each index with `dropLast` and `handleInvalid`\n   // taken into account.\n-  private def configedCategorySize(orgCategorySize: Int, idx: Int): Int = {\n+  private def getConfigedCategorySizes: Array[Int] = {\n     val dropLast = getDropLast\n     val keepInvalid = getHandleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n \n     if (!dropLast && keepInvalid) {\n       // When `handleInvalid` is \"keep\", an extra category is added as last category\n       // for invalid data.\n-      orgCategorySize + 1\n+      categorySizes.map(_ + 1)\n     } else if (dropLast && !keepInvalid) {\n       // When `dropLast` is true, the last category is removed.\n-      orgCategorySize - 1\n+      categorySizes.map(_ - 1)\n     } else {\n       // When `dropLast` is true and `handleInvalid` is \"keep\", the extra category for invalid\n       // data is removed. Thus, it is the same as the plain number of categories.\n-      orgCategorySize\n+      categorySizes\n     }\n   }\n \n   private def encoder: UserDefinedFunction = {\n-    val oneValue = Array(1.0)\n-    val emptyValues = Array.empty[Double]\n-    val emptyIndices = Array.empty[Int]\n-    val dropLast = getDropLast\n-    val handleInvalid = getHandleInvalid\n-    val keepInvalid = handleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n+    val keepInvalid = getHandleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n+    val configedSizes = getConfigedCategorySizes\n+    val localCategorySizes = categorySizes\n \n     // The udf performed on input data. The first parameter is the input value. The second\n-    // parameter is the index of input.\n-    udf { (label: Double, idx: Int) =>\n-      val plainNumCategories = categorySizes(idx)\n-      val size = configedCategorySize(plainNumCategories, idx)\n-\n-      if (label < 0) {\n-        throw new SparkException(s\"Negative value: $label. Input can't be negative.\")\n-      } else if (label == size && dropLast && !keepInvalid) {\n-        // When `dropLast` is true and `handleInvalid` is not \"keep\",\n-        // the last category is removed.\n-        Vectors.sparse(size, emptyIndices, emptyValues)\n-      } else if (label >= plainNumCategories && keepInvalid) {\n-        // When `handleInvalid` is \"keep\", encodes invalid data to last category (and removed\n-        // if `dropLast` is true)\n-        if (dropLast) {\n-          Vectors.sparse(size, emptyIndices, emptyValues)\n+    // parameter is the index in inputCols of the column being encoded.\n+    udf { (label: Double, colIdx: Int) =>\n+      val origCategorySize = localCategorySizes(colIdx)\n+      // idx: index in vector of the single 1-valued element\n+      val idx = if (label >= 0 && label < origCategorySize) {\n+        label\n+      } else {\n+        if (keepInvalid) {\n+          origCategorySize\n         } else {\n-          Vectors.sparse(size, Array(size - 1), oneValue)\n+          if (label < 0) {\n+            throw new SparkException(s\"Negative value: $label. Input can't be negative. \" +",
    "line": 126
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "Good point that it's unclear.  I do think it'd be good to be robust during transform().  As far as fitting, I could see going either way (forcing data validation vs. being robust to small issues).  I'd like to keep this strict during fitting (throwing errors) and robust during transform(), but let me know what you think.\r\n\r\nI'll clarify this in the documentation.",
    "commit": "c547d0fa7c4e1bb61312219df4d273af4a5a9db9",
    "createdAt": "2018-01-05T06:18:51Z",
    "diffHunk": "@@ -205,60 +210,58 @@ class OneHotEncoderModel private[ml] (\n \n   import OneHotEncoderModel._\n \n-  // Returns the category size for a given index with `dropLast` and `handleInvalid`\n+  // Returns the category size for each index with `dropLast` and `handleInvalid`\n   // taken into account.\n-  private def configedCategorySize(orgCategorySize: Int, idx: Int): Int = {\n+  private def getConfigedCategorySizes: Array[Int] = {\n     val dropLast = getDropLast\n     val keepInvalid = getHandleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n \n     if (!dropLast && keepInvalid) {\n       // When `handleInvalid` is \"keep\", an extra category is added as last category\n       // for invalid data.\n-      orgCategorySize + 1\n+      categorySizes.map(_ + 1)\n     } else if (dropLast && !keepInvalid) {\n       // When `dropLast` is true, the last category is removed.\n-      orgCategorySize - 1\n+      categorySizes.map(_ - 1)\n     } else {\n       // When `dropLast` is true and `handleInvalid` is \"keep\", the extra category for invalid\n       // data is removed. Thus, it is the same as the plain number of categories.\n-      orgCategorySize\n+      categorySizes\n     }\n   }\n \n   private def encoder: UserDefinedFunction = {\n-    val oneValue = Array(1.0)\n-    val emptyValues = Array.empty[Double]\n-    val emptyIndices = Array.empty[Int]\n-    val dropLast = getDropLast\n-    val handleInvalid = getHandleInvalid\n-    val keepInvalid = handleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n+    val keepInvalid = getHandleInvalid == OneHotEncoderEstimator.KEEP_INVALID\n+    val configedSizes = getConfigedCategorySizes\n+    val localCategorySizes = categorySizes\n \n     // The udf performed on input data. The first parameter is the input value. The second\n-    // parameter is the index of input.\n-    udf { (label: Double, idx: Int) =>\n-      val plainNumCategories = categorySizes(idx)\n-      val size = configedCategorySize(plainNumCategories, idx)\n-\n-      if (label < 0) {\n-        throw new SparkException(s\"Negative value: $label. Input can't be negative.\")\n-      } else if (label == size && dropLast && !keepInvalid) {\n-        // When `dropLast` is true and `handleInvalid` is not \"keep\",\n-        // the last category is removed.\n-        Vectors.sparse(size, emptyIndices, emptyValues)\n-      } else if (label >= plainNumCategories && keepInvalid) {\n-        // When `handleInvalid` is \"keep\", encodes invalid data to last category (and removed\n-        // if `dropLast` is true)\n-        if (dropLast) {\n-          Vectors.sparse(size, emptyIndices, emptyValues)\n+    // parameter is the index in inputCols of the column being encoded.\n+    udf { (label: Double, colIdx: Int) =>\n+      val origCategorySize = localCategorySizes(colIdx)\n+      // idx: index in vector of the single 1-valued element\n+      val idx = if (label >= 0 && label < origCategorySize) {\n+        label\n+      } else {\n+        if (keepInvalid) {\n+          origCategorySize\n         } else {\n-          Vectors.sparse(size, Array(size - 1), oneValue)\n+          if (label < 0) {\n+            throw new SparkException(s\"Negative value: $label. Input can't be negative. \" +",
    "line": 126
  }],
  "prId": 20132
}]