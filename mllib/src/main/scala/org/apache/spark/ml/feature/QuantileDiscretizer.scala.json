[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "It looks a bit weird to have `HasInputCols` and `HasOutputCols` directly in `QuantileDiscretizer` and leave other params in `QuantileDiscretizerBase`.\r\n\r\nBut extending `HasInputCols` and `HasOutputCols` in `QuantileDiscretizerBase` causes binary compatibility issue. I think we don't want to break the compatibility in the effort of adding multi-col support.",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-12T06:35:30Z",
    "diffHunk": "@@ -104,7 +126,8 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  */\n @Since(\"1.6.0\")\n final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val uid: String)\n-  extends Estimator[Bucketizer] with QuantileDiscretizerBase with DefaultParamsWritable {\n+  extends Estimator[Bucketizer] with QuantileDiscretizerBase with DefaultParamsWritable\n+    with HasInputCols with HasOutputCols {",
    "line": 67
  }, {
    "author": {
      "login": "huaxingao"
    },
    "body": "I guess I will leave this as is even though it's a bit weird. ",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-13T05:21:39Z",
    "diffHunk": "@@ -104,7 +126,8 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  */\n @Since(\"1.6.0\")\n final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val uid: String)\n-  extends Estimator[Bucketizer] with QuantileDiscretizerBase with DefaultParamsWritable {\n+  extends Estimator[Bucketizer] with QuantileDiscretizerBase with DefaultParamsWritable\n+    with HasInputCols with HasOutputCols {",
    "line": 67
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "style issue:\r\n\r\n```scala\r\n  ...\r\n} else {\r\n  ...\r\n```",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-12T06:41:27Z",
    "diffHunk": "@@ -129,34 +152,95 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>\n+      SchemaUtils.checkNumericType(schema, inputColName)\n+      require(existingFields.forall(_.name != outputColName),\n+        s\"Output column ${outputColName} already exists.\")\n+      val attr = NominalAttribute.defaultAttr.withName(outputColName)\n+      outputFields :+= attr.toStructField()\n+    }\n     StructType(outputFields)\n   }\n \n   @Since(\"2.0.0\")\n   override def fit(dataset: Dataset[_]): Bucketizer = {\n     transformSchema(dataset.schema, logging = true)\n-    val splits = dataset.stat.approxQuantile($(inputCol),\n-      (0.0 to 1.0 by 1.0/$(numBuckets)).toArray, $(relativeError))\n+    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))\n+    if (isQuantileDiscretizeMultipleColumns) {\n+      var bucketArray = Array.empty[Int]\n+      if (isSet(numBucketsArray)) {\n+        bucketArray = $(numBucketsArray)\n+      }\n+      else {\n+        bucketArray = Array($(numBuckets))\n+      }\n+      val probabilityArray = bucketArray.toSeq.flatMap { numOfBucket =>\n+        (0.0 to 1.0 by 1.0 / numOfBucket)\n+      }\n+      val splitsArray = dataset.stat.approxQuantile($(inputCols),\n+        probabilityArray.sorted.toArray.distinct, $(relativeError))\n+      val distinctSplitsArray = splitsArray.toSeq.map { splits =>\n+        getDistinctSplits(splits)\n+      }\n+      bucketizer.setSplitsArray(distinctSplitsArray.toArray)\n+      copyValues(bucketizer.setParent(this))\n+    }\n+    else {"
  }, {
    "author": {
      "login": "huaxingao"
    },
    "body": "Will fix this. And fix the same problem in another place. ",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-13T05:22:42Z",
    "diffHunk": "@@ -129,34 +152,95 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>\n+      SchemaUtils.checkNumericType(schema, inputColName)\n+      require(existingFields.forall(_.name != outputColName),\n+        s\"Output column ${outputColName} already exists.\")\n+      val attr = NominalAttribute.defaultAttr.withName(outputColName)\n+      outputFields :+= attr.toStructField()\n+    }\n     StructType(outputFields)\n   }\n \n   @Since(\"2.0.0\")\n   override def fit(dataset: Dataset[_]): Bucketizer = {\n     transformSchema(dataset.schema, logging = true)\n-    val splits = dataset.stat.approxQuantile($(inputCol),\n-      (0.0 to 1.0 by 1.0/$(numBuckets)).toArray, $(relativeError))\n+    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))\n+    if (isQuantileDiscretizeMultipleColumns) {\n+      var bucketArray = Array.empty[Int]\n+      if (isSet(numBucketsArray)) {\n+        bucketArray = $(numBucketsArray)\n+      }\n+      else {\n+        bucketArray = Array($(numBuckets))\n+      }\n+      val probabilityArray = bucketArray.toSeq.flatMap { numOfBucket =>\n+        (0.0 to 1.0 by 1.0 / numOfBucket)\n+      }\n+      val splitsArray = dataset.stat.approxQuantile($(inputCols),\n+        probabilityArray.sorted.toArray.distinct, $(relativeError))\n+      val distinctSplitsArray = splitsArray.toSeq.map { splits =>\n+        getDistinctSplits(splits)\n+      }\n+      bucketizer.setSplitsArray(distinctSplitsArray.toArray)\n+      copyValues(bucketizer.setParent(this))\n+    }\n+    else {"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "'only map' -> 'will only map'",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:26:13Z",
    "diffHunk": "@@ -129,34 +152,119 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "`QuantileDiscretize` -> `QuantileDiscretizer`",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:26:38Z",
    "diffHunk": "@@ -129,34 +152,119 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Need a validator function here to ensure all bucket values >= 2",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:33:00Z",
    "diffHunk": "@@ -50,10 +50,26 @@ private[feature] trait QuantileDiscretizerBase extends Params\n   /** @group getParam */\n   def getNumBuckets: Int = getOrDefault(numBuckets)\n \n+  /**\n+   * Array of number of buckets (quantiles, or categories) into which data points are grouped.\n+   *\n+   * See also [[handleInvalid]], which can optionally create an additional bucket for NaN values.\n+   *\n+   * @group param\n+   */\n+  val numBucketsArray = new IntArrayParam(this, \"numBucketsArray\", \"Array of number of buckets \" +\n+    \"(quantiles, or categories) into which data points are grouped. This is for multiple \" +\n+    \"columns input. If numBucketsArray is not set but numBuckets is set, it means user wants \" +\n+    \"to use the same numBuckets across all columns.\")"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "\"If transforming multiple columns and numBucketsArray is not set, but numBuckets is set, then numBuckets will be applied across all columns.\"",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:33:53Z",
    "diffHunk": "@@ -50,10 +50,26 @@ private[feature] trait QuantileDiscretizerBase extends Params\n   /** @group getParam */\n   def getNumBuckets: Int = getOrDefault(numBuckets)\n \n+  /**\n+   * Array of number of buckets (quantiles, or categories) into which data points are grouped.\n+   *\n+   * See also [[handleInvalid]], which can optionally create an additional bucket for NaN values.\n+   *\n+   * @group param\n+   */\n+  val numBucketsArray = new IntArrayParam(this, \"numBucketsArray\", \"Array of number of buckets \" +\n+    \"(quantiles, or categories) into which data points are grouped. This is for multiple \" +\n+    \"columns input. If numBucketsArray is not set but numBuckets is set, it means user wants \" +"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Let's match the Bucketizer comment. So something like:\r\n\r\n```\r\n...\r\nSince 2.3.0, `QuantileDiscretizer ` can map multiple columns at once by setting the `inputCols` parameter. \r\nNote that when both the `inputCol` and `inputCols` parameters are set, a log warning will be printed and\r\nonly `inputCol` will take effect, while `inputCols` will be ignored. To specify the number of buckets \r\nfor each column , the `numBucketsArray ` parameter can be set, or if the number of buckets should be the\r\nsame across columns, `numBuckets` can be set as a convenience.\r\n```",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:37:19Z",
    "diffHunk": "@@ -86,6 +104,10 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  * categorical features. The number of bins can be set using the `numBuckets` parameter. It is\n  * possible that the number of buckets used will be smaller than this value, for example, if there\n  * are too few distinct values of the input to create enough distinct quantiles.\n+ * Since 2.3.0,"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Can add a comment about \"each value must be greater than or equal to 2\"",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:39:20Z",
    "diffHunk": "@@ -50,10 +50,26 @@ private[feature] trait QuantileDiscretizerBase extends Params\n   /** @group getParam */\n   def getNumBuckets: Int = getOrDefault(numBuckets)\n \n+  /**\n+   * Array of number of buckets (quantiles, or categories) into which data points are grouped.",
    "line": 14
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "```scala\r\nval bucketSeq = if (isSet(numBucketsArray)) {\r\n  $(numBucketsArray).toSeq\r\n} else {\r\n  Seq($(numBuckets))\r\n}",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T12:45:53Z",
    "diffHunk": "@@ -129,34 +152,119 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>\n+      SchemaUtils.checkNumericType(schema, inputColName)\n+      require(existingFields.forall(_.name != outputColName),\n+        s\"Output column ${outputColName} already exists.\")\n+      val attr = NominalAttribute.defaultAttr.withName(outputColName)\n+      outputFields :+= attr.toStructField()\n+    }\n     StructType(outputFields)\n   }\n \n   @Since(\"2.0.0\")\n   override def fit(dataset: Dataset[_]): Bucketizer = {\n     transformSchema(dataset.schema, logging = true)\n-    val splits = dataset.stat.approxQuantile($(inputCol),\n-      (0.0 to 1.0 by 1.0/$(numBuckets)).toArray, $(relativeError))\n+    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))\n+    if (isQuantileDiscretizeMultipleColumns) {\n+      var bucketArray = Array.empty[Int]"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "This section overall seems like it can be cleaned up - it should be possible to have one code path for a Seq of numBuckets and at the end if transforming only one column the splits array should be the first element.\r\n\r\nYou could check the case of a single `numBuckets` value and `Array.fill` that value (if `numBucketsArray` is not set).",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-11-29T13:27:15Z",
    "diffHunk": "@@ -129,34 +152,119 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretize` only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>\n+      SchemaUtils.checkNumericType(schema, inputColName)\n+      require(existingFields.forall(_.name != outputColName),\n+        s\"Output column ${outputColName} already exists.\")\n+      val attr = NominalAttribute.defaultAttr.withName(outputColName)\n+      outputFields :+= attr.toStructField()\n+    }\n     StructType(outputFields)\n   }\n \n   @Since(\"2.0.0\")\n   override def fit(dataset: Dataset[_]): Bucketizer = {\n     transformSchema(dataset.schema, logging = true)\n-    val splits = dataset.stat.approxQuantile($(inputCol),\n-      (0.0 to 1.0 by 1.0/$(numBuckets)).toArray, $(relativeError))\n+    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))\n+    if (isQuantileDiscretizeMultipleColumns) {"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "\"bucketsfor\" -> \"buckets for\"\r\n\r\nand remove the leading space from \" number of buckets ...\" on next line",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-04T07:17:14Z",
    "diffHunk": "@@ -105,9 +107,11 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  * possible that the number of buckets used will be smaller than this value, for example, if there\n  * are too few distinct values of the input to create enough distinct quantiles.\n  * Since 2.3.0,\n- * `QuantileDiscretizer` can also map multiple columns at once. Whether it goes to map a column or\n- * multiple columns, it depends on which parameter of `inputCol` and `inputCols` is set. When both\n- * are set, a log warning will be printed and by default it chooses `inputCol`.\n+ * `QuantileDiscretizer ` can map multiple columns at once by setting the `inputCols` parameter.\n+ * Note that when both the `inputCol` and `inputCols` parameters are set, a log warning will be\n+ * printed and only `inputCol` will take effect, while `inputCols` will be ignored. To specify\n+ * the number of bucketsfor each column , the `numBucketsArray ` parameter can be set, or if the"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "`map` can be `foreach` because there's no return value",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-08T10:20:50Z",
    "diffHunk": "@@ -129,34 +156,106 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretizer` will only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Looking at this now, the `Array.fill` approach probably adds needless complexity.\r\n\r\nBut the multi-buckets case can perhaps still be cleaned up. How about something like this:\r\n\r\n```scala\r\n  override def fit(dataset: Dataset[_]): Bucketizer = {\r\n    transformSchema(dataset.schema, logging = true)\r\n    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))\r\n    if (isQuantileDiscretizeMultipleColumns) {\r\n      val splitsArray = if (isSet(numBucketsArray)) {\r\n        val probArrayPerCol = $(numBucketsArray).map { numOfBuckets =>\r\n          (0.0 to 1.0 by 1.0 / numOfBuckets).toArray\r\n        }\r\n\r\n        val probabilityArray = probArrayPerCol.flatten.sorted.distinct\r\n        val splitsArrayRaw = dataset.stat.approxQuantile($(inputCols),\r\n          probabilityArray, $(relativeError))\r\n\r\n        splitsArrayRaw.zip(probArrayPerCol).map { case (splits, probs) =>\r\n          val probSet = probs.toSet\r\n          val idxSet = probabilityArray.zipWithIndex.collect {\r\n            case (p, idx) if probSet(p) =>\r\n              idx\r\n          }.toSet\r\n          splits.zipWithIndex.collect {\r\n            case (s, idx) if idxSet(idx) =>\r\n              s\r\n          }\r\n        }\r\n      } else {\r\n        dataset.stat.approxQuantile($(inputCols),\r\n          (0.0 to 1.0 by 1.0 / $(numBuckets)).toArray, $(relativeError))\r\n      }\r\n      bucketizer.setSplitsArray(splitsArray.map(getDistinctSplits))\r\n    } else {\r\n      val splits = dataset.stat.approxQuantile($(inputCol),\r\n        (0.0 to 1.0 by 1.0 / $(numBuckets)).toArray, $(relativeError))\r\n      bucketizer.setSplits(getDistinctSplits(splits))\r\n    }\r\n    copyValues(bucketizer.setParent(this))\r\n  }\r\n```\r\n\r\nThen we don't need `getSplitsForEachColumn` method (or part of the above could be factored out into a private method if it makes sense).",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-08T11:39:33Z",
    "diffHunk": "@@ -129,34 +156,106 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n+        \"`QuantileDiscretizer` will only map one column specified by `inputCol`\")\n+      false\n+    } else if (isSet(inputCols)) {\n+      true\n+    } else {\n+      false\n+    }\n+  }\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    if (!isQuantileDiscretizeMultipleColumns) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,\n+        \"inputCols number do not match outputCols\")\n+      ($(inputCols), $(outputCols))\n+    }\n+  }\n+\n   @Since(\"1.6.0\")\n   override def transformSchema(schema: StructType): StructType = {\n-    SchemaUtils.checkNumericType(schema, $(inputCol))\n-    val inputFields = schema.fields\n-    require(inputFields.forall(_.name != $(outputCol)),\n-      s\"Output column ${$(outputCol)} already exists.\")\n-    val attr = NominalAttribute.defaultAttr.withName($(outputCol))\n-    val outputFields = inputFields :+ attr.toStructField()\n+    val (inputColNames, outputColNames) = getInOutCols\n+    val existingFields = schema.fields\n+    var outputFields = existingFields\n+    inputColNames.zip(outputColNames).map { case (inputColName, outputColName) =>\n+      SchemaUtils.checkNumericType(schema, inputColName)\n+      require(existingFields.forall(_.name != outputColName),\n+        s\"Output column ${outputColName} already exists.\")\n+      val attr = NominalAttribute.defaultAttr.withName(outputColName)\n+      outputFields :+= attr.toStructField()\n+    }\n     StructType(outputFields)\n   }\n \n   @Since(\"2.0.0\")\n   override def fit(dataset: Dataset[_]): Bucketizer = {\n     transformSchema(dataset.schema, logging = true)\n-    val splits = dataset.stat.approxQuantile($(inputCol),\n-      (0.0 to 1.0 by 1.0/$(numBuckets)).toArray, $(relativeError))\n+    val bucketizer = new Bucketizer(uid).setHandleInvalid($(handleInvalid))",
    "line": 129
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "According to the discussion result at JIRA SPARK-8418, we should throw exception when both inputCol and inputCols are specified ?",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-11T08:50:53Z",
    "diffHunk": "@@ -129,34 +156,102 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +"
  }, {
    "author": {
      "login": "huaxingao"
    },
    "body": "@WeichenXu123 I will change to throw Exception. Thanks. ",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-11T18:38:00Z",
    "diffHunk": "@@ -129,34 +156,102 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n+    if (isSet(inputCols) && isSet(inputCol)) {\n+      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "I think a better message is something like \"QuantileDiscretizer only supports setting either ...\"",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-12T10:20:10Z",
    "diffHunk": "@@ -168,20 +168,13 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.3.0\")\n   def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n \n-  private[feature] def isQuantileDiscretizeMultipleColumns(): Boolean = {\n-    if (isSet(inputCols) && isSet(inputCol)) {\n-      logWarning(\"Both `inputCol` and `inputCols` are set, we ignore `inputCols` and this \" +\n-        \"`QuantileDiscretizer` will only map one column specified by `inputCol`\")\n-      false\n-    } else if (isSet(inputCols)) {\n-      true\n-    } else {\n-      false\n-    }\n-  }\n-\n   private[feature] def getInOutCols: (Array[String], Array[String]) = {\n-    if (!isQuantileDiscretizeMultipleColumns) {\n+    require((isSet(inputCol) && isSet(outputCol) && !isSet(inputCols) && !isSet(outputCols)) ||\n+      (!isSet(inputCol) && !isSet(outputCol) && isSet(inputCols) && isSet(outputCols)),\n+      \"Only allow to set either inputCol/outputCol, or inputCols/outputCols\""
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "Think we can simplify to \"If both `inputCol` and `inputCols` are set, ...\" (since we already said in the previous sentence that only one of the parameters can be set)",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-12T12:52:12Z",
    "diffHunk": "@@ -107,11 +107,11 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  * possible that the number of buckets used will be smaller than this value, for example, if there\n  * are too few distinct values of the input to create enough distinct quantiles.\n  * Since 2.3.0,\n- * `QuantileDiscretizer ` can map multiple columns at once by setting the `inputCols` parameter.\n- * Note that when both the `inputCol` and `inputCols` parameters are set, a log warning will be\n- * printed and only `inputCol` will take effect, while `inputCols` will be ignored. To specify\n- * the number of bucketsfor each column , the `numBucketsArray ` parameter can be set, or if the\n- *  number of buckets should be the same across columns, `numBuckets` can be set as a convenience.\n+ * `QuantileDiscretizer` can map multiple columns at once by setting the `inputCols` parameter.\n+ * Note that only one of `inputCol` and `inputCols` parameters can be set. If both of the\n+ * `inputCol` and `inputCols` parameters are set, an Exception will be thrown. To specify the"
  }, {
    "author": {
      "login": "huaxingao"
    },
    "body": "@MLnick Thank you very much for your comments. I will change these. ",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-12T17:42:24Z",
    "diffHunk": "@@ -107,11 +107,11 @@ private[feature] trait QuantileDiscretizerBase extends Params\n  * possible that the number of buckets used will be smaller than this value, for example, if there\n  * are too few distinct values of the input to create enough distinct quantiles.\n  * Since 2.3.0,\n- * `QuantileDiscretizer ` can map multiple columns at once by setting the `inputCols` parameter.\n- * Note that when both the `inputCol` and `inputCols` parameters are set, a log warning will be\n- * printed and only `inputCol` will take effect, while `inputCols` will be ignored. To specify\n- * the number of bucketsfor each column , the `numBucketsArray ` parameter can be set, or if the\n- *  number of buckets should be the same across columns, `numBuckets` can be set as a convenience.\n+ * `QuantileDiscretizer` can map multiple columns at once by setting the `inputCols` parameter.\n+ * Note that only one of `inputCol` and `inputCols` parameters can be set. If both of the\n+ * `inputCol` and `inputCols` parameters are set, an Exception will be thrown. To specify the"
  }],
  "prId": 19715
}, {
  "comments": [{
    "author": {
      "login": "MLnick"
    },
    "body": "We should add a small test case for mismatched sizes of `inputCols` / `outputCols`.",
    "commit": "486b68d1de9e9dc480133d8680baebc98f6e572c",
    "createdAt": "2017-12-15T09:44:27Z",
    "diffHunk": "@@ -129,34 +155,96 @@ final class QuantileDiscretizer @Since(\"1.6.0\") (@Since(\"1.6.0\") override val ui\n   @Since(\"2.1.0\")\n   def setHandleInvalid(value: String): this.type = set(handleInvalid, value)\n \n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setNumBucketsArray(value: Array[Int]): this.type = set(numBucketsArray, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setInputCols(value: Array[String]): this.type = set(inputCols, value)\n+\n+  /** @group setParam */\n+  @Since(\"2.3.0\")\n+  def setOutputCols(value: Array[String]): this.type = set(outputCols, value)\n+\n+  private[feature] def getInOutCols: (Array[String], Array[String]) = {\n+    require((isSet(inputCol) && isSet(outputCol) && !isSet(inputCols) && !isSet(outputCols)) ||\n+      (!isSet(inputCol) && !isSet(outputCol) && isSet(inputCols) && isSet(outputCols)),\n+      \"QuantileDiscretizer only supports setting either inputCol/outputCol or\" +\n+        \"inputCols/outputCols.\"\n+    )\n+\n+    if (isSet(inputCol)) {\n+      (Array($(inputCol)), Array($(outputCol)))\n+    } else {\n+      require($(inputCols).length == $(outputCols).length,",
    "line": 97
  }],
  "prId": 19715
}]