[{
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "I guess we miss a doc for return?",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T10:13:00Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "added \"Returns the previous hdfs path filter\"",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T15:56:16Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Usually we don't break new line like this in Spark codes. We possibly do it like:\r\n\r\n```scala\r\ndef setPathFilter(\r\n    value: Option[Class[_]],\r\n    sampleRatio: Option[Double] = None,\r\n    spark: SparkSession): Option[Class[_]] = {\r\n```\r\n",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T10:15:23Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,\n+                    spark: SparkSession)\n+  : Option[Class[_]] = {"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T15:53:14Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,\n+                    spark: SparkSession)\n+  : Option[Class[_]] = {"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Looks like `None` is redundant.",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T10:17:55Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,\n+                    spark: SparkSession)\n+  : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    if (sampleRatio.isDefined) {\n+      hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio.get)\n+    } else {\n+      hadoopConf.unset(SamplePathFilter.ratioParam)\n+      None"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T15:57:35Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,\n+                    spark: SparkSession)\n+  : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    if (sampleRatio.isDefined) {\n+      hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio.get)\n+    } else {\n+      hadoopConf.unset(SamplePathFilter.ratioParam)\n+      None"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Shall we have both set and unset methods instead of one method to do both set/unset?",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T10:18:39Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done, added an unset method",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T16:16:18Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Option[Double] = None,"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Usual comment style is:\r\n\r\n```scala\r\n/**\r\n *  Set/unset  hdfs PathFilter\r\n *\r\n *  @param value\r\n *  ...\r\n */\r\n```",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T10:20:30Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-10T16:20:17Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /** Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/** Filter that allows loading a fraction of HDFS files. */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /** Set/unset  hdfs PathFilter"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Please add `If value is a None, it unsets the flag.`.",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-11T03:31:41Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T04:11:03Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "viirya"
    },
    "body": "Shall we set a seed based on like current time instead of a constant?",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-11T03:35:28Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Why seed at all?",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-11T06:52:32Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "removed seed - it might be good to expose this as a parameter in the future so that readImages loads the same images (and not just the same ratio) on every invocation",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T04:17:07Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: look for typos like hdfs -> HDFS",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-11T06:52:08Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous hdfs path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets hdfs PathFilter"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T04:22:23Z",
    "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = {\n+    val rd = new Random()\n+    rd.setSeed(0)\n+    rd\n+  }\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets hdfs PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous hdfs path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets hdfs PathFilter"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "Maybe, \r\n\r\n```scala\r\n@param value Filter class that is passed to HDFS\r\n@param sampleRatio Fraction of the files that the filter picks\r\n@param spark Existing Spark session\r\n@return Returns the previous HDFS path filter\r\n```",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T13:58:59Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-16T14:03:56Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "I think we could make this inlined.",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T14:01:41Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-16T14:03:11Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit:\r\n\r\n```scala\r\ndef setPathFilter(\r\n    value: Option[Class[_]],\r\n    sampleRatio: Double,\r\n    spark: SparkSession): Option[Class[_]] = {\r\n  ...\r\n```",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T14:03:57Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-16T14:04:27Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit:\r\n\r\n```scala\r\n@param value Filter class to restore to HDFS\r\n@param spark Existing Spark session\r\n```",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T14:04:57Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets HDFS PathFilter\n+   *\n+   * @param value       Filter class to restore to HDFS\n+   * @param spark       Existing Spark session"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-16T14:04:49Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets HDFS PathFilter\n+   *\n+   * @param value       Filter class to restore to HDFS\n+   * @param spark       Existing Spark session"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit: `) :` -> `):`.",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-12T14:05:41Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets HDFS PathFilter\n+   *\n+   * @param value       Filter class to restore to HDFS\n+   * @param spark       Existing Spark session\n+   */\n+  def unsetPathFilter(value: Option[Class[_]], spark: SparkSession) : Unit = {"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-16T14:05:23Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) ||\n+      random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value       Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark       Existing Spark session\n+   * @return            Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]], sampleRatio: Double,\n+                    spark: SparkSession) : Option[Class[_]] = {\n+    val flagName = FileInputFormat.PATHFILTER_CLASS\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.getClass(flagName, null))\n+    hadoopConf.setDouble(SamplePathFilter.ratioParam, sampleRatio)\n+\n+    value match {\n+      case Some(v) => hadoopConf.setClass(flagName, v, classOf[PathFilter])\n+      case None => hadoopConf.unset(flagName)\n+    }\n+    old\n+  }\n+\n+  /**\n+   * Unsets HDFS PathFilter\n+   *\n+   * @param value       Filter class to restore to HDFS\n+   * @param spark       Existing Spark session\n+   */\n+  def unsetPathFilter(value: Option[Class[_]], spark: SparkSession) : Unit = {"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "HyukjinKwon"
    },
    "body": "nit:\r\n\r\n```scala\r\ndef setPathFilter(\r\n    value: Option[Class[_]],\r\n    sampleRatio: Double,\r\n    spark: SparkSession): Option[Class[_]] = {\r\n```",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-18T08:10:09Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) || random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark Existing Spark session\n+   * @return Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]],\n+                    sampleRatio: Double,\n+                    spark: SparkSession): Option[Class[_]] = {"
  }, {
    "author": {
      "login": "imatiach-msft"
    },
    "body": "done",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-18T17:46:50Z",
    "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) || random.nextDouble() < sampleRatio\n+  }\n+}\n+\n+private object SamplePathFilter {\n+  val ratioParam = \"sampleRatio\"\n+\n+  def isFile(path: Path): Boolean = FilenameUtils.getExtension(path.toString) != \"\"\n+\n+  /**\n+   * Sets HDFS PathFilter\n+   *\n+   * @param value Filter class that is passed to HDFS\n+   * @param sampleRatio Fraction of the files that the filter picks\n+   * @param spark Existing Spark session\n+   * @return Returns the previous HDFS path filter\n+   */\n+  def setPathFilter(value: Option[Class[_]],\n+                    sampleRatio: Double,\n+                    spark: SparkSession): Option[Class[_]] = {"
  }],
  "prId": 19439
}, {
  "comments": [{
    "author": {
      "login": "thunterdb"
    },
    "body": "I would prefer that we do not use a seed and that the result is deterministic, based for example on some hash of the file name, to make it more robust to future code changes. That being said, there is no fundamental issues with the current implementation and other developers may have differing opinions, so the current implementation is fine as far as I am concerned.",
    "commit": "a76496be9ebc8b4aba1cd1cd4e3132411649597e",
    "createdAt": "2017-10-30T10:14:16Z",
    "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.image\n+\n+import scala.language.existentials\n+import scala.util.Random\n+\n+import org.apache.commons.io.FilenameUtils\n+import org.apache.hadoop.conf.{Configuration, Configured}\n+import org.apache.hadoop.fs.{Path, PathFilter}\n+import org.apache.hadoop.mapreduce.lib.input.FileInputFormat\n+\n+import org.apache.spark.sql.SparkSession\n+\n+private object RecursiveFlag {\n+\n+  /**\n+   * Sets a value of spark recursive flag.\n+   * If value is a None, it unsets the flag.\n+   *\n+   * @param value value to set\n+   * @param spark existing spark session\n+   * @return previous value of this flag\n+   */\n+  def setRecursiveFlag(value: Option[String], spark: SparkSession): Option[String] = {\n+    val flagName = FileInputFormat.INPUT_DIR_RECURSIVE\n+    val hadoopConf = spark.sparkContext.hadoopConfiguration\n+    val old = Option(hadoopConf.get(flagName))\n+\n+    value match {\n+      case Some(v) => hadoopConf.set(flagName, v)\n+      case None => hadoopConf.unset(flagName)\n+    }\n+\n+    old\n+  }\n+}\n+\n+/**\n+ * Filter that allows loading a fraction of HDFS files.\n+ */\n+private class SamplePathFilter extends Configured with PathFilter {\n+  val random = new Random()\n+\n+  // Ratio of files to be read from disk\n+  var sampleRatio: Double = 1\n+\n+  override def setConf(conf: Configuration): Unit = {\n+    if (conf != null) {\n+      sampleRatio = conf.getDouble(SamplePathFilter.ratioParam, 1)\n+    }\n+  }\n+\n+  override def accept(path: Path): Boolean = {\n+    // Note: checking fileSystem.isDirectory is very slow here, so we use basic rules instead\n+    !SamplePathFilter.isFile(path) || random.nextDouble() < sampleRatio",
    "line": 72
  }],
  "prId": 19439
}]