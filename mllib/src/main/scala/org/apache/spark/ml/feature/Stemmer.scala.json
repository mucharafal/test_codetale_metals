[{
  "comments": [{
    "author": {
      "login": "BenFradet"
    },
    "body": "The different `orElse` need to be uniformized.\nSame thing goes for `step4`.\n",
    "commit": "ff03152daa3d710dbb54b244488f9eb4b4a80378",
    "createdAt": "2015-12-14T13:31:18Z",
    "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.ParamMap\n+import org.apache.spark.ml.util.{DefaultParamsReadable, DefaultParamsWritable, Identifiable}\n+import org.apache.spark.sql.types.{ArrayType, DataType, StringType}\n+\n+/**\n+ * :: Experimental ::\n+ * Stemmer removes the commoner morphological and inflexional endings from words in English\n+ */\n+@Experimental\n+@Since(\"1.7.0\")\n+class Stemmer (override val uid: String)\n+  extends UnaryTransformer[Seq[String], Seq[String], Stemmer] with DefaultParamsWritable {\n+  def this() = this(Identifiable.randomUID(\"stemmer\"))\n+\n+  override protected def createTransformFunc: Seq[String] => Seq[String] = {\n+    terms => terms.map(t => PorterStemmer(t))\n+  }\n+\n+  override protected def validateInputType(inputType: DataType): Unit = {\n+    require(inputType.sameType(ArrayType(StringType)),\n+      s\"Input type must be ArrayType(StringType) but got $inputType.\")\n+  }\n+\n+  override protected def outputDataType: DataType = new ArrayType(StringType, true)\n+\n+  override def copy(extra: ParamMap): Stemmer = defaultCopy(extra)\n+}\n+\n+@Since(\"1.7.0\")\n+object Stemmer extends DefaultParamsReadable[Stemmer] {\n+\n+  @Since(\"1.7.0\")\n+  override def load(path: String): Stemmer = super.load(path)\n+}\n+\n+/**\n+ * :: Experimental ::\n+ * Classical Porter stemmer, which is implemented referring to scalanlp/chalk\n+ * [[https://github.com/scalanlp/chalk/blob/master/src/main/scala/chalk/text/analyze]].\n+ * The details of PorterStemmer can be found at\n+ * [[http://snowball.tartarus.org/algorithms/porter/stemmer.html]].\n+ */\n+private[feature] object PorterStemmer {\n+\n+  def apply(w: String): String = {\n+    if (w.length < 3) w.toLowerCase\n+    else {\n+      val ret = w.toLowerCase.replaceAll(\"([aeiou])y\", \"$1Y\").replaceAll(\"^y\", \"Y\")\n+      step5(step4(step3(step2(step1(ret))))).toLowerCase\n+    }\n+  }\n+\n+  private def step1(w: String): String = step1c(step1b(step1a(w)))\n+\n+  private def step1a(w: String): String = {\n+    if (w.endsWith(\"sses\") || w.endsWith(\"ies\")) {\n+      w.substring(0, w.length - 2)\n+    }\n+    else if (w.endsWith(\"s\") && w.charAt(w.length - 2) != 's') {\n+      w.substring(0, w.length - 1)\n+    }\n+    else w\n+  }\n+\n+  private def step1b(w: String): String = {\n+    def extra(w: String) = {\n+      if (w.endsWith(\"at\") || w.endsWith(\"bl\") || w.endsWith(\"iz\")) w + 'e'\n+      else if (doublec(w) && !\"lsz\".contains(w.last)) w.substring(0, w.length - 1)\n+      else if (m(w) == 1 && cvc(w)) w + \"e\"\n+      else w\n+    }\n+\n+    if (w.endsWith(\"eed\")) {\n+      if (m(w.substring(0, w.length - 3)) > 0) w.substring(0, w.length - 1) else w\n+    } else if (w.endsWith(\"ed\")) {\n+      if (w.indexWhere(isVowel) < (w.length - 2)) extra(w.substring(0, w.length - 2))\n+      else w\n+    } else if (w.endsWith(\"ing\")) {\n+      if (w.indexWhere(isVowel) < (w.length - 3)) extra(w.substring(0, w.length - 3))\n+      else w\n+    } else w\n+  }\n+\n+  private def step1c(w: String): String = {\n+    if ((w.last == 'y' || w.last == 'Y') && w.indexWhere(isVowel) < w.length - 1) {\n+      w.substring(0, w.length - 1) + 'i'\n+    } else w\n+  }\n+\n+  private def step2(w: String): String = {\n+    if (w.length < 3) w\n+    else {\n+      val opt = w(w.length - 2) match {\n+        case 'a' => replaceSuffix(w, \"ational\", \"ate\").orElse(replaceSuffix(w, \"tional\", \"tion\"))\n+        case 'c' =>\n+          replaceSuffix(w, \"enci\", \"ence\").orElse(replaceSuffix(w, \"anci\", \"ance\"))\n+        case 'e' => replaceSuffix(w, \"izer\", \"ize\")\n+        case 'g' => replaceSuffix(w, \"logi\", \"log\")\n+        case 'l' => replaceSuffix(w, \"bli\", \"ble\")\n+          .orElse(replaceSuffix(w, \"alli\", \"al\"))\n+          .orElse ( replaceSuffix(w, \"entli\", \"ent\"))"
  }],
  "prId": 10272
}]