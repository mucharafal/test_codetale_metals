[{
  "comments": [{
    "author": {
      "login": "WeichenXu123"
    },
    "body": "Although `numLeftRows` == `numBitsNotSet`, it is better to keep them the same in doc.",
    "commit": "d86dd18e47451c2e4463c68db441f92a898ac765",
    "createdAt": "2017-10-16T08:45:25Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.util.collection.BitSet\n+\n+/**\n+ * Stores values for a single training data column (a single continuous or categorical feature).\n+ *\n+ * Values are currently stored in a dense representation only.\n+ * TODO: Support sparse storage (to optimize deeper levels of the tree), and maybe compressed\n+ *       storage (to optimize upper levels of the tree).\n+ *\n+ * TODO: Sort feature values to support more complicated splitting logic (e.g. considering every\n+ *       possible continuous split instead of discretizing continuous features).\n+ *\n+ * NOTE: We could add sorting of feature values in this PR; the only changed required would be to\n+ * sort feature values at construction-time. Sorting might improve locality during stats\n+ * aggregation (we'd frequently update the same O(statsSize) array for a (feature, bin),\n+ * instead of frequently updating for the same feature).\n+ *\n+ * @param featureArity  For categorical features, this gives the number of categories.\n+ *                      For continuous features, this should be set to 0.\n+ * @param rowIndices Optional: rowIndices(i) is the row index of the ith feature value (values(i))\n+ *                   If unspecified, feature values are assumed to be ordered by row (i.e. values(i)\n+ *                   is a feature value from the ith row).\n+ */\n+private[impl] class FeatureVector(\n+    val featureIndex: Int,\n+    val featureArity: Int,\n+    val values: Array[Int],\n+    private val rowIndices: Option[Array[Int]])\n+  extends Serializable {\n+  // Associates feature values with training point rows. indices(i) = training point index\n+  // (row index) of ith feature value\n+  val indices = rowIndices.getOrElse(values.indices.toArray)\n+\n+  def isCategorical: Boolean = featureArity > 0\n+\n+  /** For debugging */\n+  override def toString: String = {\n+    \"  FeatureVector(\" +\n+      s\"    featureIndex: $featureIndex,\\n\" +\n+      s\"    featureType: ${if (featureArity == 0) \"Continuous\" else \"Categorical\"},\\n\" +\n+      s\"    featureArity: $featureArity,\\n\" +\n+      s\"    values: ${values.mkString(\", \")},\\n\" +\n+      s\"    indices: ${indices.mkString(\", \")},\\n\" +\n+      \"  )\"\n+  }\n+\n+  def deepCopy(): FeatureVector =\n+    new FeatureVector(featureIndex, featureArity, values.clone(), Some(indices.clone()))\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: FeatureVector =>\n+        featureIndex == o.featureIndex && featureArity == o.featureArity &&\n+          values.sameElements(o.values) && indices.sameElements(o.indices)\n+      case _ => false\n+    }\n+  }\n+\n+  /**\n+   * Reorders the subset of feature values at indices [from, to) in the passed-in column\n+   * according to the split information encoded in instanceBitVector (feature values for rows\n+   * that split left appear before feature values for rows that split right).\n+   *\n+   * @param numLeftRows Number of rows on the left side of the split\n+   * @param tempVals Destination buffer for reordered feature values\n+   * @param tempIndices Destination buffer for row indices corresponding to reordered feature values\n+   * @param instanceBitVector instanceBitVector(i) = true if the row for the ith feature\n+   *                          value splits right, false otherwise\n+   */\n+  private[ml] def updateForSplit(\n+      from: Int,\n+      to: Int,\n+      numLeftRows: Int,\n+      tempVals: Array[Int],\n+      tempIndices: Array[Int],\n+      instanceBitVector: BitSet): Unit = {\n+\n+    // BEGIN SORTING\n+    // We sort the [from, to) slice of col based on instance bit.\n+    // All instances going \"left\" in the split (which are false)\n+    // should be ordered before the instances going \"right\". The instanceBitVector\n+    // gives us the split bit value for each instance based on the instance's index.\n+    // We copy our feature values into @tempVals and @tempIndices either:\n+    // 1) in the [from, numLeftRows) range if the bit is false, or\n+    // 2) in the [numBitsNotSet, to) range if the bit is true."
  }, {
    "author": {
      "login": "smurching"
    },
    "body": "Will change this, thanks for the catch!",
    "commit": "d86dd18e47451c2e4463c68db441f92a898ac765",
    "createdAt": "2017-10-25T00:46:46Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.util.collection.BitSet\n+\n+/**\n+ * Stores values for a single training data column (a single continuous or categorical feature).\n+ *\n+ * Values are currently stored in a dense representation only.\n+ * TODO: Support sparse storage (to optimize deeper levels of the tree), and maybe compressed\n+ *       storage (to optimize upper levels of the tree).\n+ *\n+ * TODO: Sort feature values to support more complicated splitting logic (e.g. considering every\n+ *       possible continuous split instead of discretizing continuous features).\n+ *\n+ * NOTE: We could add sorting of feature values in this PR; the only changed required would be to\n+ * sort feature values at construction-time. Sorting might improve locality during stats\n+ * aggregation (we'd frequently update the same O(statsSize) array for a (feature, bin),\n+ * instead of frequently updating for the same feature).\n+ *\n+ * @param featureArity  For categorical features, this gives the number of categories.\n+ *                      For continuous features, this should be set to 0.\n+ * @param rowIndices Optional: rowIndices(i) is the row index of the ith feature value (values(i))\n+ *                   If unspecified, feature values are assumed to be ordered by row (i.e. values(i)\n+ *                   is a feature value from the ith row).\n+ */\n+private[impl] class FeatureVector(\n+    val featureIndex: Int,\n+    val featureArity: Int,\n+    val values: Array[Int],\n+    private val rowIndices: Option[Array[Int]])\n+  extends Serializable {\n+  // Associates feature values with training point rows. indices(i) = training point index\n+  // (row index) of ith feature value\n+  val indices = rowIndices.getOrElse(values.indices.toArray)\n+\n+  def isCategorical: Boolean = featureArity > 0\n+\n+  /** For debugging */\n+  override def toString: String = {\n+    \"  FeatureVector(\" +\n+      s\"    featureIndex: $featureIndex,\\n\" +\n+      s\"    featureType: ${if (featureArity == 0) \"Continuous\" else \"Categorical\"},\\n\" +\n+      s\"    featureArity: $featureArity,\\n\" +\n+      s\"    values: ${values.mkString(\", \")},\\n\" +\n+      s\"    indices: ${indices.mkString(\", \")},\\n\" +\n+      \"  )\"\n+  }\n+\n+  def deepCopy(): FeatureVector =\n+    new FeatureVector(featureIndex, featureArity, values.clone(), Some(indices.clone()))\n+\n+  override def equals(other: Any): Boolean = {\n+    other match {\n+      case o: FeatureVector =>\n+        featureIndex == o.featureIndex && featureArity == o.featureArity &&\n+          values.sameElements(o.values) && indices.sameElements(o.indices)\n+      case _ => false\n+    }\n+  }\n+\n+  /**\n+   * Reorders the subset of feature values at indices [from, to) in the passed-in column\n+   * according to the split information encoded in instanceBitVector (feature values for rows\n+   * that split left appear before feature values for rows that split right).\n+   *\n+   * @param numLeftRows Number of rows on the left side of the split\n+   * @param tempVals Destination buffer for reordered feature values\n+   * @param tempIndices Destination buffer for row indices corresponding to reordered feature values\n+   * @param instanceBitVector instanceBitVector(i) = true if the row for the ith feature\n+   *                          value splits right, false otherwise\n+   */\n+  private[ml] def updateForSplit(\n+      from: Int,\n+      to: Int,\n+      numLeftRows: Int,\n+      tempVals: Array[Int],\n+      tempIndices: Array[Int],\n+      instanceBitVector: BitSet): Unit = {\n+\n+    // BEGIN SORTING\n+    // We sort the [from, to) slice of col based on instance bit.\n+    // All instances going \"left\" in the split (which are false)\n+    // should be ordered before the instances going \"right\". The instanceBitVector\n+    // gives us the split bit value for each instance based on the instance's index.\n+    // We copy our feature values into @tempVals and @tempIndices either:\n+    // 1) in the [from, numLeftRows) range if the bit is false, or\n+    // 2) in the [numBitsNotSet, to) range if the bit is true."
  }],
  "prId": 19433
}]