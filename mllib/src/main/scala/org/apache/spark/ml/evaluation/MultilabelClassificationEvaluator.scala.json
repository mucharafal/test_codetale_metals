[{
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "You don't really need the `@Since` annotations here because it's assumed that they're all \"since\" the class was created by default.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-03T12:50:40Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for regression, which expects two input columns: predictions and labels.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (@Since(\"3.0.0\") override val uid: String)"
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Might be simpler to just have this case, followed by `case _ => true`",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-03T12:51:19Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for regression, which expects two input columns: predictions and labels.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (@Since(\"3.0.0\") override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1\"` (default), `\"weightedPrecision\"`,\n+   * `\"weightedRecall\"`, `\"accuracy\"`)\n+   * @group param\n+   */\n+  @Since(\"3.0.0\")\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(Array(\"subsetAccuracy\", \"accuracy\",\n+      \"hammingLoss\", \"precision\", \"recall\", \"f1Measure\", \"precisionByLabel\",\n+      \"recallByLabel\", \"f1MeasureByLabel\", \"microPrecision\", \"microRecall\",\n+      \"microF1Measure\"))\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      \"(subsetAccuracy|accuracy|hammingLoss|precision|recall|f1Measure|\" +\n+      \"precisionByLabel|recallByLabel|f1MeasureByLabel|microPrecision|microRecall|\" +\n+      \"microF1Measure)\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  @Since(\"3.0.0\")\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  @Since(\"3.0.0\")\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel/recallByLabel/\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  @Since(\"3.0.0\")\n+  def getLabel: Double = $(label)\n+\n+  @Since(\"3.0.0\")\n+  def setLabel(value: Double): this.type = set(label, value)\n+\n+  setDefault(label -> 0.0)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setPredictionCol(value: String): this.type = set(predictionCol, value)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+\n+  @Since(\"3.0.0\")\n+  override def evaluate(dataset: Dataset[_]): Double = {\n+    val schema = dataset.schema\n+    SchemaUtils.checkColumnType(schema, $(predictionCol), ArrayType(DoubleType, false))\n+    SchemaUtils.checkColumnType(schema, $(labelCol), ArrayType(DoubleType, false))\n+\n+    val predictionAndLabels =\n+      dataset.select(col($(predictionCol)), col($(labelCol)))\n+        .rdd.map { row =>\n+        (row.getSeq[Double](0).toArray, row.getSeq[Double](1).toArray)\n+      }\n+    val metrics = new MultilabelMetrics(predictionAndLabels)\n+    val metric = $(metricName) match {\n+      case \"subsetAccuracy\" => metrics.subsetAccuracy\n+      case \"accuracy\" => metrics.accuracy\n+      case \"hammingLoss\" => metrics.hammingLoss\n+      case \"precision\" => metrics.precision\n+      case \"recall\" => metrics.recall\n+      case \"f1Measure\" => metrics.f1Measure\n+      case \"precisionByLabel\" => metrics.precision($(label))\n+      case \"recallByLabel\" => metrics.recall($(label))\n+      case \"f1MeasureByLabel\" => metrics.f1Measure($(label))\n+      case \"microPrecision\" => metrics.microPrecision\n+      case \"microRecall\" => metrics.microRecall\n+      case \"microF1Measure\" => metrics.microF1Measure\n+    }\n+    metric\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def isLargerBetter: Boolean = {\n+    $(metricName) match {\n+      case \"subsetAccuracy\" => true\n+      case \"accuracy\" => true\n+      case \"hammingLoss\" => false",
    "line": 117
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "You could probably declare this array as a private val in the object, and then reuse it to create the string below too: `metrics.mkString(\"(\", \"|\", \")\")`",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-03T12:54:45Z",
    "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for regression, which expects two input columns: predictions and labels.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (@Since(\"3.0.0\") override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1\"` (default), `\"weightedPrecision\"`,\n+   * `\"weightedRecall\"`, `\"accuracy\"`)\n+   * @group param\n+   */\n+  @Since(\"3.0.0\")\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(Array(\"subsetAccuracy\", \"accuracy\",\n+      \"hammingLoss\", \"precision\", \"recall\", \"f1Measure\", \"precisionByLabel\","
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "In the Python side, the default datatype of array columns create by `spark.createDataFrame` or `.toDF` is ArrayType(_, true), to pass the python tests, we need to allow `ArrayType(DoubleType, true)` here.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-04T11:19:50Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  @Since(\"3.0.0\")\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  @Since(\"3.0.0\")\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  @Since(\"3.0.0\")\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  @Since(\"3.0.0\")\n+  def getLabel: Double = $(label)\n+\n+  @Since(\"3.0.0\")\n+  def setLabel(value: Double): this.type = set(label, value)\n+\n+  setDefault(label -> 0.0)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setPredictionCol(value: String): this.type = set(predictionCol, value)\n+\n+  /** @group setParam */\n+  @Since(\"3.0.0\")\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+\n+  @Since(\"3.0.0\")\n+  override def evaluate(dataset: Dataset[_]): Double = {\n+    val schema = dataset.schema\n+    SchemaUtils.checkColumnTypes(schema, $(predictionCol),\n+      Seq(ArrayType(DoubleType, false), ArrayType(DoubleType, true)))",
    "line": 89
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think my comment got lost: you only need \"Since\" on the new classes, and not all of their members, here and in Python.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-05T14:58:27Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  @Since(\"3.0.0\")"
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "In the python side, I found other evaluator(BinaryClassificationEvaluator/RegressionEvaluator) add \"Since\" before each method, so I do not change it.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-06T02:12:09Z",
    "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator @Since(\"3.0.0\") (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  @Since(\"3.0.0\")"
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nit: `metric` is redundant here",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-06T14:27:52Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)\n+\n+  setDefault(label -> 0.0)\n+\n+  /** @group setParam */\n+  def setPredictionCol(value: String): this.type = set(predictionCol, value)\n+\n+  /** @group setParam */\n+  def setLabelCol(value: String): this.type = set(labelCol, value)\n+\n+\n+  override def evaluate(dataset: Dataset[_]): Double = {\n+    val schema = dataset.schema\n+    SchemaUtils.checkColumnTypes(schema, $(predictionCol),\n+      Seq(ArrayType(DoubleType, false), ArrayType(DoubleType, true)))\n+    SchemaUtils.checkColumnTypes(schema, $(labelCol),\n+      Seq(ArrayType(DoubleType, false), ArrayType(DoubleType, true)))\n+\n+    val predictionAndLabels =\n+      dataset.select(col($(predictionCol)), col($(labelCol)))\n+        .rdd.map { row =>\n+        (row.getSeq[Double](0).toArray, row.getSeq[Double](1).toArray)\n+      }\n+    val metrics = new MultilabelMetrics(predictionAndLabels)\n+    val metric = $(metricName) match {"
  }],
  "prId": 24777
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Hm, I think using `label` here is confusing, as this also has `labelCol` from `HasLabelCol` to specify the (multi-)label column. I wonder if we can just pick a clearly different name, like `metricClass` or `oneVsAllLabelCol`, that kind of thing?",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-06T14:30:30Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I perfer `metricClass` to `oneVsAllLabelCol`.\r\nOr what about this?\r\n```\r\ndef setClass(value: Double): this.type = set(clazz, value)\r\n```",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-10T02:28:11Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "@srowen Just found that in  [LogisticRegressionSummary](https://github.com/apache/spark/blob/master/mllib/src/main/scala/org/apache/spark/ml/classification/LogisticRegression.scala#L1404) per-class metrics are named `xxByLabel`, should we keep in line with it? ",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-10T08:47:06Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Yeah, 'class' would be inconsistent with 'label'. I think we need to differentiate \"the column that is the label\" from \"the label that is used to compute a per-label metric\". Just \"label\" seems confusing. \"metricLabel\"? anything a little more descriptive.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-10T14:03:28Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "@srowen  If we use a name other than `label`, I personally perfer `metricClass` to `metricLabel` or others.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-11T02:16:24Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Sounds good to me, just anything to distinguish its purpose. I suppose we say `labelCol` specifies the _class_ that the instance is labeled with, and `metricClass` chooses the _class_ to use when evaluating the 1 vs all metric.",
    "commit": "89d2c3598248d1e445933c024e3f977e4d5a5b2a",
    "createdAt": "2019-06-11T11:55:04Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.evaluation\n+\n+import org.apache.spark.annotation.{Experimental, Since}\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.mllib.evaluation.MultilabelMetrics\n+import org.apache.spark.sql.Dataset\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+\n+/**\n+ * :: Experimental ::\n+ * Evaluator for multi-label classification, which expects two input\n+ * columns: prediction and label.\n+ */\n+@Since(\"3.0.0\")\n+@Experimental\n+class MultilabelClassificationEvaluator (override val uid: String)\n+  extends Evaluator with HasPredictionCol with HasLabelCol\n+    with DefaultParamsWritable {\n+\n+  import MultilabelClassificationEvaluator.supportedMetricNames\n+\n+  def this() = this(Identifiable.randomUID(\"mlcEval\"))\n+\n+  /**\n+   * param for metric name in evaluation (supports `\"f1Measure\"` (default), `\"subsetAccuracy\"`,\n+   * `\"accuracy\"`, `\"hammingLoss\"`, `\"precision\"`, `\"recall\"`, `\"precisionByLabel\"`,\n+   * `\"recallByLabel\"`, `\"f1MeasureByLabel\"`, `\"microPrecision\"`, `\"microRecall\"`,\n+   * `\"microF1Measure\"`)\n+   * @group param\n+   */\n+  final val metricName: Param[String] = {\n+    val allowedParams = ParamValidators.inArray(supportedMetricNames)\n+    new Param(this, \"metricName\", \"metric name in evaluation \" +\n+      s\"${supportedMetricNames.mkString(\"(\", \"|\", \")\")}\", allowedParams)\n+  }\n+\n+  /** @group getParam */\n+  def getMetricName: String = $(metricName)\n+\n+  /** @group setParam */\n+  def setMetricName(value: String): this.type = set(metricName, value)\n+\n+  setDefault(metricName -> \"f1Measure\")\n+\n+  final val label: DoubleParam = new DoubleParam(this, \"label\",\n+    \"The label whose metric will be computed in precisionByLabel|recallByLabel|\" +\n+      \"f1MeasureByLabel. Must be >= 0. The default value is 0.\",\n+    ParamValidators.gtEq(0.0))\n+\n+  /** @group getParam */\n+  def getLabel: Double = $(label)\n+\n+  /** @group setParam */\n+  def setLabel(value: Double): this.type = set(label, value)"
  }],
  "prId": 24777
}]