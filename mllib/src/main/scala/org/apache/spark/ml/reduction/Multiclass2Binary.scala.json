[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`classifier.fit(trainingDataset, classifer.labelCol -> labelColName)`\n",
    "commit": "5f4b495e41324ca423aaea1b4cce3c782e13147c",
    "createdAt": "2015-05-05T19:18:00Z",
    "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.reduction\n+\n+import scala.language.existentials\n+\n+import org.apache.spark.annotation.{AlphaComponent, DeveloperApi}\n+import org.apache.spark.ml.{Estimator, Model}\n+import org.apache.spark.ml.classification.{ClassificationModel, Classifier, ClassifierParams}\n+import org.apache.spark.ml.param.{IntParam, Param, ParamMap}\n+import org.apache.spark.ml.util.SchemaUtils\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for [[Multiclass2Binary]].\n+ */\n+private[ml] trait Multiclass2BinaryParams extends ClassifierParams {\n+\n+  type ClassifierType = Classifier[F, E, M] forSome {\n+    type F ;\n+    type M <: ClassificationModel[F,M];\n+    type E <:  Classifier[F, E,M]\n+  }\n+\n+  /**\n+   * param for prediction column name\n+   * @group param\n+   */\n+  val idCol: Param[String] =\n+    new Param(this, \"idCol\", \"id column name\")\n+\n+  setDefault(idCol, \"id\")\n+\n+  /**\n+   * param for base classifier index column name\n+   * @group param\n+   */\n+  val indexCol: Param[String] =\n+    new Param(this, \"indexCol\", \"classifier index column name\")\n+\n+  setDefault(indexCol, \"index\")\n+\n+  /**\n+   * param for the base classifier that we reduce multiclass classification into.\n+   * @group param\n+   */\n+  val baseClassifier: Param[ClassifierType]  =\n+    new Param(this, \"baseClassifier\", \"base binary classifier/regressor \")\n+\n+  /** @group getParam */\n+  def getBaseClassifier: ClassifierType = getOrDefault(baseClassifier)\n+\n+  /**\n+   * param for number of classes.\n+   * @group param\n+   */\n+  val k: IntParam = new IntParam(this, \"k\", \"number of classes\")\n+\n+  /** @group getParam */\n+  def getK(): Int = getOrDefault(k)\n+\n+}\n+\n+/**\n+ *\n+ * @param parent\n+ * @param baseClassificationModels the binary classification models for reduction.\n+ */\n+@AlphaComponent\n+private[ml] class Multiclass2BinaryModel(\n+    override val parent: Multiclass2Binary,\n+    val baseClassificationModels: Seq[Model[_]])\n+  extends Model[Multiclass2BinaryModel] with Multiclass2BinaryParams {\n+\n+  /**\n+   * Transforms the dataset with provided parameter map as additional parameters.\n+   * @param dataset input dataset\n+   * @return transformed dataset\n+   */\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    // Check schema\n+    val parentSchema = dataset.schema\n+    transformSchema(parentSchema, logging = true)\n+    val sqlCtx = dataset.sqlContext\n+\n+    // score each model on every data point and pick the model with highest score\n+    // TODO: Add randomization when there are ties.\n+    val predictions = baseClassificationModels.zipWithIndex.par.map { case (model, index) =>\n+      val output = model.transform(dataset)\n+      output.select($(rawPredictionCol)).map { case Row(p: Vector) => List((index, p(1))) }\n+    }.reduce[RDD[List[(Int, Double)]]] { case (x, y) =>\n+      x.zip(y).map { case ((a, b)) =>\n+        a ++ b\n+      }\n+    }.\n+      map(_.maxBy(_._2))\n+\n+    // ensure that we pass through columns that are part of the original dataset.\n+    val results = dataset.select(col(\"*\")).rdd.zip(predictions).map { case ((row, (label, _))) =>\n+      Row.fromSeq(row.toSeq ++ List(label.toDouble))\n+    }\n+\n+    // the output schema should retain all input fields and add prediction column.\n+    val outputSchema = SchemaUtils.appendColumn(parentSchema, $(predictionCol), DoubleType)\n+    sqlCtx.createDataFrame(results, outputSchema)\n+  }\n+\n+  @DeveloperApi\n+  protected def featuresDataType: DataType = new VectorUDT\n+\n+  override def transformSchema(schema: StructType): StructType = {\n+    validateAndTransformSchema(schema, fitting = false, featuresDataType)\n+  }\n+\n+}\n+\n+/**\n+ * :: Experimental ::\n+ *\n+ * Reduction of Multiclass Classification to Binary Classification.\n+ * Performs reduction using one against all strategy.\n+ * For a multiclass classification with k classes, train k models (one per class).\n+ * Each example is scored against all k models and the model with highest score\n+ * is picked to label the example.\n+ *\n+ */\n+class Multiclass2Binary extends Estimator[Multiclass2BinaryModel]\n+  with Multiclass2BinaryParams {\n+\n+  @DeveloperApi\n+  protected def featuresDataType: DataType = new VectorUDT\n+\n+  /** @group setParam */\n+  def setBaseClassifier(value: ClassifierType): this.type = set(baseClassifier, value)\n+\n+  /** @group setParam */\n+  def setNumClasses(value: Int): this.type = set(k, value)\n+\n+  override def fit(dataset: DataFrame): Multiclass2BinaryModel = {\n+\n+    val numClasses = $(k)\n+    val multiclassLabeled = dataset.select($(labelCol), $(featuresCol))\n+\n+    // persist if underlying dataset is not persistent\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    if (handlePersistence) {\n+      multiclassLabeled.persist(StorageLevel.MEMORY_AND_DISK)\n+    }\n+\n+    // create k columns, one for each binary classifier.\n+    val models = Range(0, numClasses).par.map { index =>\n+      val labelColName = \"mc2b$\" + index\n+      val label: Double => Double = (label: Double) => {\n+        if (label.toInt == index) 1.0 else 0.0\n+      }\n+      val labelUDF = callUDF(label, DoubleType, col($(labelCol)))\n+      val trainingDataset = multiclassLabeled.withColumn(labelColName, labelUDF)\n+      val classifier = newClassifier(extractParamMap(), labelColName)\n+      classifier.fit(trainingDataset)"
  }],
  "prId": 5830
}]