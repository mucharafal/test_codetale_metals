[{
  "comments": [{
    "author": {
      "login": "mpetruska"
    },
    "body": "Please help me fill this in.",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-04T13:31:40Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")"
  }],
  "prId": 19659
}, {
  "comments": [{
    "author": {
      "login": "mpetruska"
    },
    "body": "Note to self: please don't forget to fill this in.",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-04T13:32:08Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")\n+  def multiSliding[A](x: Seq[A], min: Int, max: Int): Seq[Seq[A]] = {\n+    type B = Seq[A]\n+\n+    def addWindowsFromBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.drop(min - 1).foldLeft((acc, buffer.take(min - 1))) {\n+        case ((a, b), current) =>\n+          val newB = b.enqueue(current)\n+          (newB :: a, newB)\n+      }._1\n+    }\n+\n+    @tailrec\n+    def addWindowsFromFinalBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.dequeueOption match {\n+        case Some((_, tail)) => addWindowsFromFinalBuffer(addWindowsFromBuffer(acc, tail), tail)\n+        case None => acc\n+      }\n+    }\n+\n+    def calculateMultiSliding(): List[B] = {\n+      val (accumulated, finalBuffer) = x.foldLeft((List.empty[B], Queue.empty[A])) {\n+\n+        case ((acc, buffer), current) if buffer.length < min - 1 =>\n+          (acc, buffer.enqueue(current))\n+\n+        case ((acc, buffer), current) if buffer.length == min - 1 =>\n+          val newBuffer = buffer.enqueue(current)\n+          (newBuffer :: acc, newBuffer)\n+\n+        case ((acc, buffer), current) if buffer.length >= min && buffer.length < max =>\n+          val newBuffer = buffer.enqueue(current)\n+          (newBuffer :: acc, newBuffer)\n+\n+        case ((acc, buffer), current) if buffer.length == max =>\n+          val (_, newBuffer) = buffer.enqueue(current).dequeue\n+          (addWindowsFromBuffer(acc, newBuffer), newBuffer)\n+\n+        case ((acc, buffer), _) if buffer.length > max =>\n+          (acc, buffer)\n+\n+      }\n+\n+      addWindowsFromFinalBuffer(accumulated, finalBuffer).reverse\n+    }\n+\n+    (1 <= min) && (min <= max) match {\n+      case true => calculateMultiSliding()\n+      case false => Seq.empty\n+    }\n+  }\n+\n+  @Since(\"From which version?\")"
  }],
  "prId": 19659
}, {
  "comments": [{
    "author": {
      "login": "mpetruska"
    },
    "body": "Note to self: please don't forget to fill this in.",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-04T13:32:15Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")\n+  def multiSliding[A](x: Seq[A], min: Int, max: Int): Seq[Seq[A]] = {\n+    type B = Seq[A]\n+\n+    def addWindowsFromBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.drop(min - 1).foldLeft((acc, buffer.take(min - 1))) {\n+        case ((a, b), current) =>\n+          val newB = b.enqueue(current)\n+          (newB :: a, newB)\n+      }._1\n+    }\n+\n+    @tailrec\n+    def addWindowsFromFinalBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.dequeueOption match {\n+        case Some((_, tail)) => addWindowsFromFinalBuffer(addWindowsFromBuffer(acc, tail), tail)\n+        case None => acc\n+      }\n+    }\n+\n+    def calculateMultiSliding(): List[B] = {\n+      val (accumulated, finalBuffer) = x.foldLeft((List.empty[B], Queue.empty[A])) {\n+\n+        case ((acc, buffer), current) if buffer.length < min - 1 =>\n+          (acc, buffer.enqueue(current))\n+\n+        case ((acc, buffer), current) if buffer.length == min - 1 =>\n+          val newBuffer = buffer.enqueue(current)\n+          (newBuffer :: acc, newBuffer)\n+\n+        case ((acc, buffer), current) if buffer.length >= min && buffer.length < max =>\n+          val newBuffer = buffer.enqueue(current)\n+          (newBuffer :: acc, newBuffer)\n+\n+        case ((acc, buffer), current) if buffer.length == max =>\n+          val (_, newBuffer) = buffer.enqueue(current).dequeue\n+          (addWindowsFromBuffer(acc, newBuffer), newBuffer)\n+\n+        case ((acc, buffer), _) if buffer.length > max =>\n+          (acc, buffer)\n+\n+      }\n+\n+      addWindowsFromFinalBuffer(accumulated, finalBuffer).reverse\n+    }\n+\n+    (1 <= min) && (min <= max) match {\n+      case true => calculateMultiSliding()\n+      case false => Seq.empty\n+    }\n+  }\n+\n+  @Since(\"From which version?\")\n+  implicit class SeqOps[A](val x: Seq[A]) extends AnyVal {\n+\n+    /**\n+     * Calculates sliding windows over multiple length parameters\n+     * simultaneously.\n+     * @see `org.apache.spark.ml.extensions.seq.multiSliding`\n+     */\n+    @Since(\"From which version?\")"
  }],
  "prId": 19659
}, {
  "comments": [{
    "author": {
      "login": "holdenk"
    },
    "body": "We probably don't want these APIs to be public unless there is a good reason to have them be. Maybe make them private?",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-07T19:31:29Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")"
  }, {
    "author": {
      "login": "holdenk"
    },
    "body": "Also is there a reason not to put this functionality inside of ngram its self for now?",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-07T19:36:41Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")"
  }, {
    "author": {
      "login": "mpetruska"
    },
    "body": "Right, agreed, will move the implementation into `NGram`.",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-08T08:27:35Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")"
  }],
  "prId": 19659
}, {
  "comments": [{
    "author": {
      "login": "holdenk"
    },
    "body": "Does this perform as well as the current code does?",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-07T19:37:56Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")\n+  def multiSliding[A](x: Seq[A], min: Int, max: Int): Seq[Seq[A]] = {\n+    type B = Seq[A]\n+\n+    def addWindowsFromBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.drop(min - 1).foldLeft((acc, buffer.take(min - 1))) {\n+        case ((a, b), current) =>\n+          val newB = b.enqueue(current)\n+          (newB :: a, newB)\n+      }._1\n+    }\n+\n+    @tailrec\n+    def addWindowsFromFinalBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.dequeueOption match {\n+        case Some((_, tail)) => addWindowsFromFinalBuffer(addWindowsFromBuffer(acc, tail), tail)\n+        case None => acc\n+      }\n+    }\n+\n+    def calculateMultiSliding(): List[B] = {"
  }, {
    "author": {
      "login": "mpetruska"
    },
    "body": "Nope, unfortunately it's not the case:\r\n\r\n```Scala\r\nscala> def slidingOriginal(x: Seq[String], n: Int): Seq[String] = {\r\n     |     x.iterator.sliding(n).withPartial(false).map(_.mkString(\" \")).toSeq\r\n     |   }\r\nslidingOriginal: (x: Seq[String], n: Int)Seq[String]\r\n\r\nscala> def slidingNew(x: Seq[String], n: Int): Seq[String] = {\r\n     |     multiSliding(x, n, n).map(_.mkString(\" \"))\r\n     |   }\r\nslidingNew: (x: Seq[String], n: Int)Seq[String]\r\n\r\nscala> time(slidingOriginal((1 to 10000).map(_.toString), 5))\r\nres9: scala.concurrent.duration.FiniteDuration = 2427473 nanoseconds\r\n\r\nscala> time(slidingOriginal((1 to 10000).map(_.toString), 5)).toMillis\r\nres10: Long = 3\r\n\r\nscala> time(slidingNew((1 to 10000).map(_.toString), 5)).toMillis\r\nres11: Long = 15\r\n\r\nscala> time(slidingOriginal((1 to 100000).map(_.toString), 5)).toMillis\r\nres12: Long = 11\r\n\r\nscala> time(slidingNew((1 to 100000).map(_.toString), 5)).toMillis\r\nres13: Long = 479\r\n\r\nscala> time(slidingOriginal((1 to 10000).map(_.toString), 50)).toMillis\r\nres14: Long = 1\r\n\r\nscala> time(slidingNew((1 to 10000).map(_.toString), 50)).toMillis\r\nres15: Long = 136\r\n```\r\n\r\nAdding code to fall back to the original implementation if `n == maxN`...",
    "commit": "43534b2d5daa8cfdbd9aefcad00956851de040b3",
    "createdAt": "2017-11-08T15:10:34Z",
    "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.extensions\n+\n+import scala.annotation.tailrec\n+import scala.collection.immutable.Queue\n+\n+import org.apache.spark.annotation.Since\n+\n+package object seq {\n+\n+  /**\n+   * Calculates sliding windows over multiple length parameters simultaneously.\n+   * @param x    the input sequence over which sliding windows will be collected\n+   * @param min  the inclusive minimal length of the window to be collected\n+   * @param max  the inclusive maximal length of the window to be collected\n+   * @return     the collected windows\n+   *\n+   * @example {{{\n+   * multiSliding(1 to 5, min = 2, max = 4) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5),\n+   *   Seq(3, 4), Seq(3, 4, 5),\n+   *   Seq(4, 5)\n+   * )\n+   *\n+   * multiSliding(1 to 10, min = 2, max = 5) == Seq(\n+   *   Seq(1, 2), Seq(1, 2, 3), Seq(1, 2, 3, 4), Seq(1, 2, 3, 4, 5),\n+   *   Seq(2, 3), Seq(2, 3, 4), Seq(2, 3, 4, 5), Seq(2, 3, 4, 5, 6),\n+   *   Seq(3, 4), Seq(3, 4, 5), Seq(3, 4, 5, 6), Seq(3, 4, 5, 6, 7),\n+   *   Seq(4, 5), Seq(4, 5, 6), Seq(4, 5, 6, 7), Seq(4, 5, 6, 7, 8),\n+   *   Seq(5, 6), Seq(5, 6, 7), Seq(5, 6, 7, 8), Seq(5, 6, 7, 8, 9),\n+   *   Seq(6, 7), Seq(6, 7, 8), Seq(6, 7, 8, 9), Seq(6, 7, 8, 9, 10),\n+   *   Seq(7, 8), Seq(7, 8, 9), Seq(7, 8, 9, 10),\n+   *   Seq(8, 9), Seq(8, 9, 10),\n+   *   Seq(9, 10)\n+   * )\n+   * }}}\n+   */\n+  @Since(\"From which version?\")\n+  def multiSliding[A](x: Seq[A], min: Int, max: Int): Seq[Seq[A]] = {\n+    type B = Seq[A]\n+\n+    def addWindowsFromBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.drop(min - 1).foldLeft((acc, buffer.take(min - 1))) {\n+        case ((a, b), current) =>\n+          val newB = b.enqueue(current)\n+          (newB :: a, newB)\n+      }._1\n+    }\n+\n+    @tailrec\n+    def addWindowsFromFinalBuffer(acc: List[B], buffer: Queue[A]): List[B] = {\n+      buffer.dequeueOption match {\n+        case Some((_, tail)) => addWindowsFromFinalBuffer(addWindowsFromBuffer(acc, tail), tail)\n+        case None => acc\n+      }\n+    }\n+\n+    def calculateMultiSliding(): List[B] = {"
  }],
  "prId": 19659
}]