[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Try to be more specific about what this transformer does. `into a larger one` is not sufficient to describe the transformer.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-07T22:05:10Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one."
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Default should be 2. Otherwise, the default becomes a noop.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-07T22:05:12Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))"
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "I don't think this is necessary. We can have all coefficients be 1.0.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-07T22:05:14Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {"
  }, {
    "author": {
      "login": "yinxusen"
    },
    "body": "Here the binomialCoefficient is used to compute the following two values: num of monomials and num expanded length.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-10T05:01:11Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {"
  }, {
    "author": {
      "login": "mengxr"
    },
    "body": "`def choose(n: Int, k: Int): Int`\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-22T05:42:35Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {"
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This generates too many temporary vectors, which are not necessary.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-07T22:05:15Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {\n+    (N - k + 1 to N).product / (1 to k).product\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding at a specific polynomial\n+   * degree `degree`.\n+   */\n+  private def numMonomials(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree - 1, degree)\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding from polynomial degree 1 to\n+   * polynomial degree `degree`.\n+   */\n+  private def numExpandedDims(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree, numVariables) - 1\n+  }\n+\n+  /**\n+   * Multiply two polynomials, the first is the original vector, i.e. the expanded vector with\n+   * degree 1, while the second is the expanded vector with degree `currDegree - 1`. A new expanded\n+   * vector with degree `currDegree` will be generated after the function call.\n+   *\n+   * @param lhs original vector with degree 1\n+   * @param rhs expanded vector with degree `currDegree - 1`\n+   * @param nDim the dimension of original vector\n+   * @param currDegree the polynomial degree that need to be achieved\n+   */\n+  private def expandVector(lhs: Vector, rhs: Vector, nDim: Int, currDegree: Int): Vector = {"
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "The implementation is too expensive. We already know the output size and it should be easy to fill in the values one by one.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-07T22:05:19Z",
    "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Polynomially expand a vector into a larger one.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than or equal to 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(1))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {\n+    (N - k + 1 to N).product / (1 to k).product\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding at a specific polynomial\n+   * degree `degree`.\n+   */\n+  private def numMonomials(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree - 1, degree)\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding from polynomial degree 1 to\n+   * polynomial degree `degree`.\n+   */\n+  private def numExpandedDims(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree, numVariables) - 1\n+  }\n+\n+  /**\n+   * Multiply two polynomials, the first is the original vector, i.e. the expanded vector with\n+   * degree 1, while the second is the expanded vector with degree `currDegree - 1`. A new expanded\n+   * vector with degree `currDegree` will be generated after the function call.\n+   *\n+   * @param lhs original vector with degree 1\n+   * @param rhs expanded vector with degree `currDegree - 1`\n+   * @param nDim the dimension of original vector\n+   * @param currDegree the polynomial degree that need to be achieved\n+   */\n+  private def expandVector(lhs: Vector, rhs: Vector, nDim: Int, currDegree: Int): Vector = {\n+    (lhs, rhs) match {\n+      case (l: DenseVector, r: DenseVector) =>\n+        val rLen = rhs.size\n+        val allExpansions = l.toArray.zipWithIndex.flatMap { case (lVal, lIdx) =>\n+          val numToKeep = numMonomials(currDegree - 1, nDim - lIdx)\n+          r.toArray.slice(rLen - numToKeep, rLen).map(rVal => lVal * rVal)\n+        }\n+        Vectors.dense(allExpansions)\n+\n+      case (SparseVector(lLen, lIdx, lVal), SparseVector(rLen, rIdx, rVal)) =>\n+        val len = numMonomials(currDegree, nDim)\n+        var numToKeepCum = 0\n+        val allExpansions = lVal.zip(lIdx).flatMap { case (lv, li) =>\n+          val numToKeep = numMonomials(currDegree - 1, nDim - li)\n+          val currExpansions = rVal.zip(rIdx).map { case (rv, ri) =>\n+            val realIdx = ri - (rLen - numToKeep)\n+            (if (realIdx >= 0) lv * rv else 0.0, numToKeepCum + realIdx)\n+          }\n+          numToKeepCum += numToKeep\n+          currExpansions\n+        }.filter(_._1 != 0.0)\n+        Vectors.sparse(len, allExpansions.map(_._2), allExpansions.map(_._1))\n+\n+      case _ => throw new Exception(\"vector types are not match.\")\n+    }\n+  }\n+\n+  /**\n+   * Transform a vector of variables into a larger vector which stores the polynomial expansion from\n+   * degree 1 to degree `degree`.\n+   */\n+  private def transform(degree: Int)(feature: Vector): Vector = {\n+    val nDim = feature.size\n+    feature match {\n+      case f: DenseVector =>\n+        (2 to degree).foldLeft(Array(feature.copy)) { (vectors, currDegree) =>"
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "yinxusen"
    },
    "body": "@mengxr I notice that it is not a feasible solution. We have to compute the real indices of the sparse vector. I'll fix it ASAP.\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-11T06:12:35Z",
    "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.annotation.tailrec\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Perform feature expansion in a polynomial space. As said in wikipedia of Polynomial Expansion,\n+ * which is available at [[http://en.wikipedia.org/wiki/Polynomial_expansion]], \"In mathematics, an\n+ * expansion of a product of sums expresses it as a sum of products by using the fact that\n+ * multiplication distributes over addition\". Take a 2-variable feature vector as an example:\n+ * `(x, y)`, if we want to expand it with degree 2, then we get `(x, y, x * x, x * y, y * y)`.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(2))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {\n+    (N - k + 1 to N).product / (1 to k).product\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding at a specific polynomial\n+   * degree `degree`.\n+   */\n+  private def numMonomials(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree - 1, degree)\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding from polynomial degree 1 to\n+   * polynomial degree `degree`.\n+   */\n+  private def numExpandedDims(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree, numVariables) - 1\n+  }\n+\n+  /**\n+   * Given a pre-built array of Double, fill it with expanded monomials until a given polynomial\n+   * degree.\n+   * @param values the array of Double, which represents a dense vector.\n+   * @param prevStart the start offset of elements that filled in the last function call.\n+   * @param prevLen the length of elements that filled in the last function.\n+   * @param currDegree the current degree that we want to expand.\n+   * @param finalDegree the final expected degree that we want to expand.\n+   * @param nVariables number of variables in the original feature vector.\n+   */\n+  @tailrec\n+  private def fillDenseVector(values: Array[Double], prevStart: Int, prevLen: Int, currDegree: Int,\n+        finalDegree: Int, nVariables: Int): Unit = {\n+\n+    if (currDegree > finalDegree) {\n+      return\n+    }\n+\n+    val currExpandedVecFrom = prevStart + prevLen\n+    val currExpandedVecLen = numMonomials(currDegree, nVariables)\n+\n+    var leftIndex = 0\n+    var currIndex = currExpandedVecFrom\n+\n+    while (leftIndex < nVariables) {\n+      val numToKeep = numMonomials(currDegree - 1, nVariables - leftIndex)\n+      val prevVecStartIndex = prevStart + prevLen - numToKeep\n+\n+      var rightIndex = 0\n+      while (rightIndex < numToKeep) {\n+        values(currIndex) =\n+          values(leftIndex) * values(prevVecStartIndex + rightIndex)\n+        currIndex += 1\n+        rightIndex += 1\n+      }\n+\n+      leftIndex += 1\n+    }\n+\n+    fillDenseVector(values, currExpandedVecFrom, currExpandedVecLen, currDegree + 1, finalDegree,\n+      nVariables)\n+  }\n+\n+  /**\n+   * For polynomial expanding a `SparseVector`, we treat it as a dense vector and call\n+   * `fillDenseVector` to fill in the `values` of `SparseVector`. For its `indices` part, we encode\n+   * the indices from `nVariables` one by one, because we do not care of the real indices.\n+   */\n+  private def fillPseudoSparseVectorIndices(indices: Array[Int], startFrom: Int, startWith: Int) = {"
  }],
  "prId": 5245
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`choose(n + 1, k) - 1`?\n",
    "commit": "dc461a6c0253b584ac1e6b0f320e2198e1667751",
    "createdAt": "2015-04-22T05:47:14Z",
    "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.annotation.tailrec\n+import scala.collection.mutable.ArrayBuffer\n+\n+import org.apache.spark.annotation.AlphaComponent\n+import org.apache.spark.ml.UnaryTransformer\n+import org.apache.spark.ml.param.{IntParam, ParamMap}\n+import org.apache.spark.mllib.linalg._\n+import org.apache.spark.sql.types.DataType\n+\n+/**\n+ * :: AlphaComponent ::\n+ * Perform feature expansion in a polynomial space. As said in wikipedia of Polynomial Expansion,\n+ * which is available at [[http://en.wikipedia.org/wiki/Polynomial_expansion]], \"In mathematics, an\n+ * expansion of a product of sums expresses it as a sum of products by using the fact that\n+ * multiplication distributes over addition\". Take a 2-variable feature vector as an example:\n+ * `(x, y)`, if we want to expand it with degree 2, then we get `(x, y, x * x, x * y, y * y)`.\n+ */\n+@AlphaComponent\n+class PolynomialMapper extends UnaryTransformer[Vector, Vector, PolynomialMapper] {\n+\n+  /**\n+   * The polynomial degree to expand, which should be larger than 1.\n+   * @group param\n+   */\n+  val degree = new IntParam(this, \"degree\", \"the polynomial degree to expand\", Some(2))\n+\n+  /** @group getParam */\n+  def getDegree: Int = get(degree)\n+\n+  /** @group setParam */\n+  def setDegree(value: Int): this.type = set(degree, value)\n+\n+  override protected def createTransformFunc(paramMap: ParamMap): Vector => Vector = {\n+    PolynomialMapper.transform(getDegree)\n+  }\n+\n+  override protected def outputDataType: DataType = new VectorUDT()\n+}\n+\n+object PolynomialMapper {\n+  /**\n+   * The number that combines k items from N items without repeat, i.e. the binomial coefficient.\n+   */\n+  private def binomialCoefficient(N: Int, k: Int): Int = {\n+    (N - k + 1 to N).product / (1 to k).product\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding at a specific polynomial\n+   * degree `degree`.\n+   */\n+  private def numMonomials(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree - 1, degree)\n+  }\n+\n+  /**\n+   * The number of monomials of a `numVariables` vector after expanding from polynomial degree 1 to\n+   * polynomial degree `degree`.\n+   */\n+  private def numExpandedDims(degree: Int, numVariables: Int): Int = {\n+    binomialCoefficient(numVariables + degree, numVariables) - 1"
  }],
  "prId": 5245
}]