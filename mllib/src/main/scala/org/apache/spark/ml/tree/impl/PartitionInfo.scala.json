[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "not needed; use actual nodes\n",
    "commit": "6e3be3a76c27ba1e173207b3eff8b30d8bbce1aa",
    "createdAt": "2016-08-30T18:34:17Z",
    "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.util.collection.BitSet\n+\n+/**\n+ * Intermediate data stored during learning.\n+ * TODO(smurching): Rename; maybe TrainingInfo?\n+ *\n+ * Node indexing for nodeOffsets, activeNodes:\n+ * Nodes are indexed left-to-right along the periphery of the tree, with 0-based indices.\n+ * The periphery is the set of leaf nodes (active and inactive).\n+ *\n+ * @param columns  Array of columns.\n+ *                 Each column is sorted first by nodes (left-to-right along the tree periphery);\n+ *                 all columns share this first level of sorting.\n+ *                 Within each node's group, each column is sorted based on feature value;\n+ *                 this second level of sorting differs across columns.\n+ * @param nodeOffsets  Offsets into the columns indicating the first level of sorting (by node).\n+ *                     The rows corresponding to node i are in the range\n+ *                     [nodeOffsets(i), nodeOffsets(i+1)).\n+ * @param activeNodes  Nodes which are active (still being split).\n+ *                     Inactive nodes are known to be leaves in the final tree.\n+ */\n+private[impl] case class PartitionInfo(\n+    columns: Array[FeatureVector],\n+    nodeOffsets: Array[Int],\n+    activeNodes: BitSet,"
  }],
  "prId": 14872
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "Don't store this.  Just compute it when first choosing a split for a node, and reuse those stats as the fullImpurityAggs for all features for that node.\n",
    "commit": "6e3be3a76c27ba1e173207b3eff8b30d8bbce1aa",
    "createdAt": "2016-08-30T18:34:21Z",
    "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.util.collection.BitSet\n+\n+/**\n+ * Intermediate data stored during learning.\n+ * TODO(smurching): Rename; maybe TrainingInfo?\n+ *\n+ * Node indexing for nodeOffsets, activeNodes:\n+ * Nodes are indexed left-to-right along the periphery of the tree, with 0-based indices.\n+ * The periphery is the set of leaf nodes (active and inactive).\n+ *\n+ * @param columns  Array of columns.\n+ *                 Each column is sorted first by nodes (left-to-right along the tree periphery);\n+ *                 all columns share this first level of sorting.\n+ *                 Within each node's group, each column is sorted based on feature value;\n+ *                 this second level of sorting differs across columns.\n+ * @param nodeOffsets  Offsets into the columns indicating the first level of sorting (by node).\n+ *                     The rows corresponding to node i are in the range\n+ *                     [nodeOffsets(i), nodeOffsets(i+1)).\n+ * @param activeNodes  Nodes which are active (still being split).\n+ *                     Inactive nodes are known to be leaves in the final tree.\n+ */\n+private[impl] case class PartitionInfo(\n+    columns: Array[FeatureVector],\n+    nodeOffsets: Array[Int],\n+    activeNodes: BitSet,\n+    fullImpurityAggs: Array[ImpurityAggregatorSingle]) extends Serializable {"
  }],
  "prId": 14872
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "activeNodes will be replaced by an Array of nodes.  Some will be leafs (no split), and some will not.  Could still use instanceBitVector to avoid recomputing split decisions for each row.\n",
    "commit": "6e3be3a76c27ba1e173207b3eff8b30d8bbce1aa",
    "createdAt": "2016-08-30T18:35:39Z",
    "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.tree.impl\n+\n+import org.apache.spark.util.collection.BitSet\n+\n+/**\n+ * Intermediate data stored during learning.\n+ * TODO(smurching): Rename; maybe TrainingInfo?\n+ *\n+ * Node indexing for nodeOffsets, activeNodes:\n+ * Nodes are indexed left-to-right along the periphery of the tree, with 0-based indices.\n+ * The periphery is the set of leaf nodes (active and inactive).\n+ *\n+ * @param columns  Array of columns.\n+ *                 Each column is sorted first by nodes (left-to-right along the tree periphery);\n+ *                 all columns share this first level of sorting.\n+ *                 Within each node's group, each column is sorted based on feature value;\n+ *                 this second level of sorting differs across columns.\n+ * @param nodeOffsets  Offsets into the columns indicating the first level of sorting (by node).\n+ *                     The rows corresponding to node i are in the range\n+ *                     [nodeOffsets(i), nodeOffsets(i+1)).\n+ * @param activeNodes  Nodes which are active (still being split).\n+ *                     Inactive nodes are known to be leaves in the final tree.\n+ */\n+private[impl] case class PartitionInfo(\n+    columns: Array[FeatureVector],\n+    nodeOffsets: Array[Int],\n+    activeNodes: BitSet,\n+    fullImpurityAggs: Array[ImpurityAggregatorSingle]) extends Serializable {\n+\n+  // pre-allocated temporary buffers that we use to sort\n+  // instances in left and right children during update\n+  val tempVals: Array[Int] = new Array[Int](columns(0).values.length)\n+  val tempIndices: Array[Int] = new Array[Int](columns(0).values.length)\n+\n+  /** For debugging */\n+  override def toString: String = {\n+    \"PartitionInfo(\" +\n+      \"  columns: {\\n\" +\n+      columns.mkString(\",\\n\") +\n+      \"  },\\n\" +\n+      s\"  nodeOffsets: ${nodeOffsets.mkString(\", \")},\\n\" +\n+      s\"  activeNodes: ${activeNodes.iterator.mkString(\", \")},\\n\" +\n+      \")\\n\"\n+  }\n+\n+  /**\n+   * Update columns and nodeOffsets for the next level of the tree.\n+   *\n+   * Update columns:\n+   *   For each column,\n+   *     For each (previously) active node,\n+   *       Sort corresponding range of instances based on bit vector.\n+   * Update nodeOffsets, activeNodes:\n+   *   Split offsets for nodes which split (which can be identified using the bit vector).\n+   *\n+   * @param instanceBitVector  Bit vector encoding splits for the next level of the tree.\n+   *                    These must follow a 2-level ordering, where the first level is by node\n+   *                    and the second level is by row index.\n+   *                    bitVector(i) = false iff instance i goes to the left child.\n+   *                    For instances at inactive (leaf) nodes, the value can be arbitrary.\n+   * @return Updated partition info\n+   */\n+  def update(\n+      instanceBitVector: BitSet,\n+      newNumNodeOffsets: Int,\n+      labels: Array[Byte],\n+      metadata: DecisionTreeMetadata): PartitionInfo = {\n+    // Create a 2-level representation of the new nodeOffsets (to be flattened).\n+    // These 2 levels correspond to original nodes and their children (if split).\n+    val newNodeOffsets = nodeOffsets.map(Array(_))\n+    val newFullImpurityAggs = fullImpurityAggs.map(Array(_))\n+\n+    val newColumns = columns.zipWithIndex.map { case (col, index) =>\n+      index match {\n+        case 0 => first(col, instanceBitVector, metadata,\n+          labels, newNodeOffsets, newFullImpurityAggs)\n+        case _ => rest(col, instanceBitVector, newNodeOffsets)\n+      }\n+      col\n+    }\n+\n+    // Identify the new activeNodes based on the 2-level representation of the new nodeOffsets.\n+    val newActiveNodes = new BitSet(newNumNodeOffsets - 1)\n+    var newNodeOffsetsIdx = 0\n+    var i = 0\n+    while (i < newNodeOffsets.length) {\n+      val offsets = newNodeOffsets(i)\n+      if (offsets.length == 2) {\n+        newActiveNodes.set(newNodeOffsetsIdx)\n+        newActiveNodes.set(newNodeOffsetsIdx + 1)\n+        newNodeOffsetsIdx += 2\n+      } else {\n+        newNodeOffsetsIdx += 1\n+      }\n+      i += 1\n+    }\n+    PartitionInfo(newColumns, newNodeOffsets.flatten, newActiveNodes, newFullImpurityAggs.flatten)\n+  }\n+\n+\n+  /**\n+   * Sort the very first column in the [[PartitionInfo.columns]]. While\n+   * we sort the column, we also update [[PartitionInfo.nodeOffsets]]\n+   * (by modifying @param newNodeOffsets) and [[PartitionInfo.fullImpurityAggs]]\n+   * (by modifying @param newFullImpurityAggs).\n+   *\n+   * @param col The very first column in [[PartitionInfo.columns]]\n+   * @param metadata Used to create new [[ImpurityAggregatorSingle]] for a new child\n+   *                 node in the tree\n+   * @param labels   Labels are read as we sort column to populate stats for each\n+   *                 new ImpurityAggregatorSingle\n+   */\n+  private def first(\n+      col: FeatureVector,\n+      instanceBitVector: BitSet,\n+      metadata: DecisionTreeMetadata,\n+      labels: Array[Byte],\n+      newNodeOffsets: Array[Array[Int]],\n+      newFullImpurityAggs: Array[Array[ImpurityAggregatorSingle]]) = {\n+    activeNodes.iterator.foreach { nodeIdx =>"
  }],
  "prId": 14872
}]