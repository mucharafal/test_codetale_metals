[{
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "extra space!\n",
    "commit": "40b43476dafcd42a562027740f4efe7089d0efd4",
    "createdAt": "2015-07-15T18:08:48Z",
    "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.util\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.{Accumulator, SparkContext}\n+\n+/**\n+ * Abstract class for stopwatches.\n+ */\n+private[spark] abstract class Stopwatch extends Serializable {\n+\n+  @transient private var running: Boolean = false\n+  private var startTime: Long = _\n+\n+  /**\n+   * Name of the stopwatch.\n+   */\n+  val name: String\n+\n+  /**\n+   * Starts the stopwatch.\n+   * Throws an exception if the stopwatch is already running.\n+   */\n+  def start(): Unit = {\n+    assume(!running, \"start() called but the stopwatch is already running.\")\n+    running = true\n+    startTime = now\n+  }\n+\n+  /**\n+   * Stops the stopwatch and returns the duration of the last session in milliseconds.\n+   * Throws an exception if the stopwatch is not running.\n+   */\n+  def stop(): Long = {\n+    assume(running, \"stop() called but the stopwatch is not running.\")\n+    val duration = now  - startTime"
  }],
  "prId": 7415
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "private\n",
    "commit": "40b43476dafcd42a562027740f4efe7089d0efd4",
    "createdAt": "2015-07-15T18:08:51Z",
    "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.util\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.{Accumulator, SparkContext}\n+\n+/**\n+ * Abstract class for stopwatches.\n+ */\n+private[spark] abstract class Stopwatch extends Serializable {\n+\n+  @transient private var running: Boolean = false\n+  private var startTime: Long = _\n+\n+  /**\n+   * Name of the stopwatch.\n+   */\n+  val name: String\n+\n+  /**\n+   * Starts the stopwatch.\n+   * Throws an exception if the stopwatch is already running.\n+   */\n+  def start(): Unit = {\n+    assume(!running, \"start() called but the stopwatch is already running.\")\n+    running = true\n+    startTime = now\n+  }\n+\n+  /**\n+   * Stops the stopwatch and returns the duration of the last session in milliseconds.\n+   * Throws an exception if the stopwatch is not running.\n+   */\n+  def stop(): Long = {\n+    assume(running, \"stop() called but the stopwatch is not running.\")\n+    val duration = now  - startTime\n+    add(duration)\n+    running = false\n+    duration\n+  }\n+\n+  /**\n+   * Checks whether the stopwatch is running.\n+   */\n+  def isRunning: Boolean = running\n+\n+  /**\n+   * Returns total elapsed time in milliseconds, not counting the current session if the stopwatch\n+   * is running.\n+   */\n+  def elapsed(): Long\n+\n+  /**\n+   * Gets the current time in milliseconds.\n+   */\n+  protected def now: Long = System.currentTimeMillis()\n+\n+  /**\n+   * Adds input duration to total elapsed time.\n+   */\n+  protected def add(duration: Long): Unit\n+}\n+\n+/**\n+ * A local [[Stopwatch]].\n+ */\n+private[spark] class LocalStopwatch(override val name: String) extends Stopwatch {\n+\n+  private var elapsedTime: Long = 0L\n+\n+  override def elapsed(): Long = elapsedTime\n+\n+  override protected def add(duration: Long): Unit = {\n+    elapsedTime += duration\n+  }\n+}\n+\n+/**\n+ * A distributed [[Stopwatch]] using Spark accumulator.\n+ * @param sc SparkContext\n+ */\n+private[spark] class DistributedStopwatch(\n+    sc: SparkContext,\n+    override val name: String) extends Stopwatch {\n+\n+  val elapsedTime: Accumulator[Long] = sc.accumulator(0L, s\"DistributedStopwatch($name)\")"
  }],
  "prId": 7415
}, {
  "comments": [{
    "author": {
      "login": "jkbradley"
    },
    "body": "I don't think this should print a title.  If I used it to time an algorithm, I'd prefer it read:\n\n```\nDecisionTreeClassifier(\n  init -> 17ms,\n  ...\n)\n```\n",
    "commit": "40b43476dafcd42a562027740f4efe7089d0efd4",
    "createdAt": "2015-07-15T18:08:53Z",
    "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.util\n+\n+import scala.collection.mutable\n+\n+import org.apache.spark.{Accumulator, SparkContext}\n+\n+/**\n+ * Abstract class for stopwatches.\n+ */\n+private[spark] abstract class Stopwatch extends Serializable {\n+\n+  @transient private var running: Boolean = false\n+  private var startTime: Long = _\n+\n+  /**\n+   * Name of the stopwatch.\n+   */\n+  val name: String\n+\n+  /**\n+   * Starts the stopwatch.\n+   * Throws an exception if the stopwatch is already running.\n+   */\n+  def start(): Unit = {\n+    assume(!running, \"start() called but the stopwatch is already running.\")\n+    running = true\n+    startTime = now\n+  }\n+\n+  /**\n+   * Stops the stopwatch and returns the duration of the last session in milliseconds.\n+   * Throws an exception if the stopwatch is not running.\n+   */\n+  def stop(): Long = {\n+    assume(running, \"stop() called but the stopwatch is not running.\")\n+    val duration = now  - startTime\n+    add(duration)\n+    running = false\n+    duration\n+  }\n+\n+  /**\n+   * Checks whether the stopwatch is running.\n+   */\n+  def isRunning: Boolean = running\n+\n+  /**\n+   * Returns total elapsed time in milliseconds, not counting the current session if the stopwatch\n+   * is running.\n+   */\n+  def elapsed(): Long\n+\n+  /**\n+   * Gets the current time in milliseconds.\n+   */\n+  protected def now: Long = System.currentTimeMillis()\n+\n+  /**\n+   * Adds input duration to total elapsed time.\n+   */\n+  protected def add(duration: Long): Unit\n+}\n+\n+/**\n+ * A local [[Stopwatch]].\n+ */\n+private[spark] class LocalStopwatch(override val name: String) extends Stopwatch {\n+\n+  private var elapsedTime: Long = 0L\n+\n+  override def elapsed(): Long = elapsedTime\n+\n+  override protected def add(duration: Long): Unit = {\n+    elapsedTime += duration\n+  }\n+}\n+\n+/**\n+ * A distributed [[Stopwatch]] using Spark accumulator.\n+ * @param sc SparkContext\n+ */\n+private[spark] class DistributedStopwatch(\n+    sc: SparkContext,\n+    override val name: String) extends Stopwatch {\n+\n+  val elapsedTime: Accumulator[Long] = sc.accumulator(0L, s\"DistributedStopwatch($name)\")\n+\n+  override def elapsed(): Long = elapsedTime.value\n+\n+  override protected def add(duration: Long): Unit = {\n+    elapsedTime += duration\n+  }\n+}\n+\n+/**\n+ * A multiple stopwatch that contains local and distributed stopwatches.\n+ * @param sc SparkContext\n+ */\n+private[spark] class MultiStopwatch(@transient private val sc: SparkContext) extends Serializable {\n+\n+  private val stopwatches: mutable.Map[String, Stopwatch] = mutable.Map.empty\n+\n+  /**\n+   * Adds a local stopwatch.\n+   * @param name stopwatch name\n+   */\n+  def addLocal(name: String): this.type = {\n+    require(!stopwatches.contains(name), s\"Stopwatch with name $name already exists.\")\n+    stopwatches(name) = new LocalStopwatch(name)\n+    this\n+  }\n+\n+  /**\n+   * Adds a distributed stopwatch.\n+   * @param name stopwatch name\n+   */\n+  def addDistributed(name: String): this.type = {\n+    require(!stopwatches.contains(name), s\"Stopwatch with name $name already exists.\")\n+    stopwatches(name) = new DistributedStopwatch(sc, name)\n+    this\n+  }\n+\n+  /**\n+   * Gets a stopwatch.\n+   * @param name stopwatch name\n+   */\n+  def apply(name: String): Stopwatch = stopwatches(name)\n+\n+  override def toString: String = {\n+    \"MultiStopwatch\" +"
  }],
  "prId": 7415
}]