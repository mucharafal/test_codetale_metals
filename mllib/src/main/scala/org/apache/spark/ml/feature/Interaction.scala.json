[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "remove `R-style` because this is a common feature transformation\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:02Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`true` -> `false`?\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:04Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "add API doc\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:18Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is used to calculate the output index of iteration features. Maybe we can change `cardinality` to `numFeatures`. Then the output is `numValues` for a nominal feature, 1 for a binary feature, and 1 for a numeric feature.\n\nBtw, (not in this PR) it might be useful to store only the nonzeros because most features would be numeric features. If there are millions of features, this cardinality array becomes very large.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:24Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "- missing API doc\n- `schema` -> `fields` (`schema` should be a `StructType`)\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:26Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`attrIterator` is not an `Iterator`. rename it to `encodedAttrs`?\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:28Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "- missing doc\n- it might be helpful to list the combinations in the API doc\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:34Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding("
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "chop down args\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:35Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "should override `validateParams`\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:47Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "It may be simpler to store the cumulative sum of `cardinalities` instead.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:50Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**  \n+ * An iterator over VectorUDT or Double that one-hot encodes nominal fields in the output.\n+ *\n+ * @param cardinalities An array defining the cardinality of each vector sub-field, or a single"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: This is not really an `Iterator`.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:17:57Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**  \n+ * An iterator over VectorUDT or Double that one-hot encodes nominal fields in the output.\n+ *\n+ * @param cardinalities An array defining the cardinality of each vector sub-field, or a single\n+ *                      value if the field is numeric. Fields with zero cardinality will not be\n+ *                      one-hot encoded (output verbatim).\n+ */\n+// TODO(ekl) support drop-last option like OneHotEncoder does?\n+private[ml] class EncodingIterator(cardinalities: Array[Int]) {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "missing doc\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:18:02Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**  \n+ * An iterator over VectorUDT or Double that one-hot encodes nominal fields in the output.\n+ *\n+ * @param cardinalities An array defining the cardinality of each vector sub-field, or a single\n+ *                      value if the field is numeric. Fields with zero cardinality will not be\n+ *                      one-hot encoded (output verbatim).\n+ */\n+// TODO(ekl) support drop-last option like OneHotEncoder does?\n+private[ml] class EncodingIterator(cardinalities: Array[Int]) {\n+  /** The size of the output vector. */\n+  val size = cardinalities.map(i => if (i > 0) i else 1).sum\n+\n+  /**\n+   * @param value The row to iterate over, either a Double or Vector."
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`foreachActive` -> `foreachNonzero`\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:18:04Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**  \n+ * An iterator over VectorUDT or Double that one-hot encodes nominal fields in the output.\n+ *\n+ * @param cardinalities An array defining the cardinality of each vector sub-field, or a single\n+ *                      value if the field is numeric. Fields with zero cardinality will not be\n+ *                      one-hot encoded (output verbatim).\n+ */\n+// TODO(ekl) support drop-last option like OneHotEncoder does?\n+private[ml] class EncodingIterator(cardinalities: Array[Int]) {\n+  /** The size of the output vector. */\n+  val size = cardinalities.map(i => if (i > 0) i else 1).sum\n+\n+  /**\n+   * @param value The row to iterate over, either a Double or Vector.\n+   * @param f The callback to invoke on each non-zero (index, value) output pair.\n+   */\n+  def foreachActive(value: Any, f: (Int, Double) => Unit) = value match {"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "This is too expensive for sparse vectors. We should call `vec.foreachActive`. Storing the cumulative number of features could help.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-16T12:18:36Z",
    "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the transforms required for R-style feature interactions. This transformer takes in\n+ * Double and Vector columns and outputs a flattened vector of interactions. To handle interaction,\n+ * we first one-hot encode nominal columns. Then, a vector of all their cross-products is\n+ * produced.\n+ *\n+ * For example, given the inputs Double(2), Vector(3, 4), the result would be Vector(6, 8) if\n+ * all columns were numeric. If the first input was nominal with four different values, the result\n+ * would then be Vector(0, 0, 0, 0, 3, 4, 0, 0).\n+ *\n+ * See https://stat.ethz.ch/R-manual/R-devel/library/base/html/formula.html for more\n+ * information about interactions in R formulae.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    checkParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, true))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    checkParams()\n+    val fieldIterators = getIterators(dataset)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var fieldIndex = row.length - 1\n+      while (fieldIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentIterator = fieldIterators(fieldIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentIterator.size\n+        currentIterator.foreachActive(row(fieldIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        fieldIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val args = $(inputCols).map { c =>\n+      dataset.schema(c).dataType match {\n+        case DoubleType => dataset(c)\n+        case _: VectorUDT => dataset(c)\n+        case _: NumericType | BooleanType => dataset(c).cast(DoubleType)\n+      }\n+    }\n+    val attrs = generateAttrs($(inputCols).map(col => dataset.schema(col)))\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(args: _*)).as($(outputCol), attrs.toMetadata()))\n+  }\n+\n+  private def getIterators(dataset: DataFrame): Array[EncodingIterator] = {\n+    def getCardinality(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal fields must have attr numValues defined.\"))\n+        case _ =>\n+          0  // treated as numeric\n+      }\n+    }\n+    $(inputCols).map { col =>\n+      val field = dataset.schema(col)\n+      val cardinalities = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getCardinality(Attribute.fromStructField(field)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(field).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getCardinality).toArray\n+      }\n+      new EncodingIterator(cardinalities)\n+    }.toArray\n+  }\n+\n+  private def generateAttrs(schema: Seq[StructField]): AttributeGroup = {\n+    var attrs: Seq[Attribute] = Nil\n+    schema.reverse.map { field =>\n+      val attrIterator = field.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(field)\n+          getAttributesAfterEncoding(None, Seq(attr))\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(field)\n+          getAttributesAfterEncoding(Some(group.name), group.attributes.get)\n+      }\n+      if (attrs.isEmpty) {\n+        attrs = attrIterator\n+      } else {\n+        attrs = attrIterator.flatMap { head =>\n+          attrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), attrs.toArray)\n+  }\n+\n+  private def getAttributesAfterEncoding(\n+      groupName: Option[String], attrs: Seq[Attribute]): Seq[Attribute] = {\n+    def format(i: Int, attrName: Option[String], value: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(i.toString)), value)\n+      parts.flatten.mkString(\"_\")\n+    }\n+    attrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  private def checkParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**  \n+ * An iterator over VectorUDT or Double that one-hot encodes nominal fields in the output.\n+ *\n+ * @param cardinalities An array defining the cardinality of each vector sub-field, or a single\n+ *                      value if the field is numeric. Fields with zero cardinality will not be\n+ *                      one-hot encoded (output verbatim).\n+ */\n+// TODO(ekl) support drop-last option like OneHotEncoder does?\n+private[ml] class EncodingIterator(cardinalities: Array[Int]) {\n+  /** The size of the output vector. */\n+  val size = cardinalities.map(i => if (i > 0) i else 1).sum\n+\n+  /**\n+   * @param value The row to iterate over, either a Double or Vector.\n+   * @param f The callback to invoke on each non-zero (index, value) output pair.\n+   */\n+  def foreachActive(value: Any, f: (Int, Double) => Unit) = value match {\n+    case d: Double =>\n+      assert(cardinalities.length == 1)\n+      val numOutputCols = cardinalities(0)\n+      if (numOutputCols > 0) {\n+        assert(\n+          d >= 0.0 && d == d.toInt && d < numOutputCols,\n+          s\"Values from column must be indices, but got $d.\")\n+        f(d.toInt, 1.0)\n+      } else {\n+        f(0, d)\n+      }\n+    case vec: Vector =>\n+      assert(cardinalities.length == vec.size,\n+        s\"Vector column size was ${vec.size}, expected ${cardinalities.length}\")\n+      val dense = vec.toDense"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`ArrayBuffer` is not used.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:10:56Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Done\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:21:28Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Only `Transformer` is used.\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:10:57Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Done\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:21:29Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}"
  }],
  "prId": 7987
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "minor: Use `while` instead of `for`. The latter is slow in Scala. Another option is using `scanLeft` (not as fast as `while` but saves some code)\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:11:29Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the feature interaction transform. This transformer takes in Double and Vector type\n+ * columns and outputs a flattened vector of their feature interactions. To handle interaction,\n+ * we first one-hot encode any nominal features. Then, a vector of the feature cross-products is\n+ * produced.\n+ *\n+ * For example, given the input feature values `Double(2)` and `Vector(3, 4)`, the output would be\n+ * `Vector(6, 8)` if all input features were numeric. If the first feature was instead nominal\n+ * with four categories, the output would then be `Vector(0, 0, 0, 0, 3, 4, 0, 0)`.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    validateParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, false))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    validateParams()\n+    val inputFeatures = $(inputCols).map(c => dataset.schema(c))\n+    val featureEncoders = getFeatureEncoders(inputFeatures)\n+    val featureAttrs = getFeatureAttrs(inputFeatures)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var featureIndex = row.length - 1\n+      while (featureIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentEncoder = featureEncoders(featureIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentEncoder.outputSize\n+        currentEncoder.foreachNonzeroOutput(row(featureIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        featureIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val featureCols = inputFeatures.map { f =>\n+      f.dataType match {\n+        case DoubleType => dataset(f.name)\n+        case _: VectorUDT => dataset(f.name)\n+        case _: NumericType | BooleanType => dataset(f.name).cast(DoubleType)\n+      }\n+    }\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(featureCols: _*)).as($(outputCol), featureAttrs.toMetadata()))\n+  }\n+\n+  /**\n+   * Creates a feature encoder for each input column, which supports efficient iteration over\n+   * one-hot encoded feature values. See also the class-level comment of [[FeatureEncoder]].\n+   *\n+   * @param features The input feature columns to create encoders for.\n+   */\n+  private def getFeatureEncoders(features: Seq[StructField]): Array[FeatureEncoder] = {\n+    def getNumFeatures(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          math.max(1, nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal features must have attr numValues defined.\")))\n+        case _ =>\n+          1  // numeric feature\n+      }\n+    }\n+    features.map { f =>\n+      val numFeatures = f.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getNumFeatures(Attribute.fromStructField(f)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(f).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getNumFeatures).toArray\n+      }\n+      new FeatureEncoder(numFeatures)\n+    }.toArray\n+  }\n+\n+  /**\n+   * Generates ML attributes for the output vector of all feature interactions. We make a best\n+   * effort to generate reasonable names for output features, based on the concatenation of the\n+   * interacting feature names and values delimited with `_`. When no feature name is specified,\n+   * we fall back to using the feature index (e.g. `foo:bar_2_0` may indicate an interaction\n+   * between the numeric `foo` feature and a nominal third feature from column `bar`.\n+   *\n+   * @param features The input feature columns to the Interaction transformer.\n+   */\n+  private def getFeatureAttrs(features: Seq[StructField]): AttributeGroup = {\n+    var featureAttrs: Seq[Attribute] = Nil\n+    features.reverse.foreach { f =>\n+      val encodedAttrs = f.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(f)\n+          encodedFeatureAttrs(Seq(attr), None)\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(f)\n+          encodedFeatureAttrs(group.attributes.get, Some(group.name))\n+      }\n+      if (featureAttrs.isEmpty) {\n+        featureAttrs = encodedAttrs\n+      } else {\n+        featureAttrs = encodedAttrs.flatMap { head =>\n+          featureAttrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), featureAttrs.toArray)\n+  }\n+\n+  /**\n+   * Generates the output ML attributes for a single input feature. Each output feature name has\n+   * up to three parts: the group name, feature name, and category name (for nominal features),\n+   * each separated by an underscore.\n+   *\n+   * @param inputAttrs The attributes of the input feature.\n+   * @param groupName Optional name of the input feature group (for Vector type features).\n+   */\n+  private def encodedFeatureAttrs(\n+      inputAttrs: Seq[Attribute],\n+      groupName: Option[String]): Seq[Attribute] = {\n+\n+    def format(\n+        index: Int,\n+        attrName: Option[String],\n+        categoryName: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(index.toString)), categoryName)\n+      parts.flatten.mkString(\"_\")\n+    }\n+\n+    inputAttrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  override def validateParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**\n+ * This class performs on-the-fly one-hot encoding of features as you iterate over them. To\n+ * indicate which input features should be one-hot encoded, an array of the feature counts\n+ * must be passed in ahead of time.\n+ *\n+ * @param numFeatures Array of feature counts for each input feature. For nominal features this\n+ *                    count is equal to the number of categories. For numeric features the count\n+ *                    should be set to 1.\n+ */\n+private[ml] class FeatureEncoder(numFeatures: Array[Int]) {\n+  assert(numFeatures.forall(_ > 0), \"Features counts must all be positive.\")\n+\n+  /** The size of the output vector. */\n+  val outputSize = numFeatures.sum\n+\n+  /** Precomputed offsets for the location of each output feature. */\n+  private val outputOffsets = {\n+    val arr = new Array[Int](numFeatures.length)\n+    for (i <- 1 until arr.length) {"
  }, {
    "author": {
      "login": "ericl"
    },
    "body": "Done\n",
    "commit": "1ae9ef0db969a774d6fdf19a154b78529859a3fb",
    "createdAt": "2015-09-17T20:21:31Z",
    "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.feature\n+\n+import scala.collection.mutable.{ArrayBuffer, ArrayBuilder}\n+\n+import org.apache.spark.SparkException\n+import org.apache.spark.annotation.Experimental\n+import org.apache.spark.ml.attribute._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.param.shared._\n+import org.apache.spark.ml.util.Identifiable\n+import org.apache.spark.ml.{Estimator, Model, Pipeline, PipelineModel, PipelineStage, Transformer}\n+import org.apache.spark.mllib.linalg.{Vector, VectorUDT, Vectors}\n+import org.apache.spark.sql.{DataFrame, Row}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.types._\n+\n+/**\n+ * :: Experimental ::\n+ * Implements the feature interaction transform. This transformer takes in Double and Vector type\n+ * columns and outputs a flattened vector of their feature interactions. To handle interaction,\n+ * we first one-hot encode any nominal features. Then, a vector of the feature cross-products is\n+ * produced.\n+ *\n+ * For example, given the input feature values `Double(2)` and `Vector(3, 4)`, the output would be\n+ * `Vector(6, 8)` if all input features were numeric. If the first feature was instead nominal\n+ * with four categories, the output would then be `Vector(0, 0, 0, 0, 3, 4, 0, 0)`.\n+ */\n+@Experimental\n+class Interaction(override val uid: String) extends Transformer\n+  with HasInputCols with HasOutputCol {\n+\n+  def this() = this(Identifiable.randomUID(\"interaction\"))\n+\n+  /** @group setParam */\n+  def setInputCols(values: Array[String]): this.type = set(inputCols, values)\n+\n+  /** @group setParam */\n+  def setOutputCol(value: String): this.type = set(outputCol, value)\n+\n+  // optimistic schema; does not contain any ML attributes\n+  override def transformSchema(schema: StructType): StructType = {\n+    validateParams()\n+    StructType(schema.fields :+ StructField($(outputCol), new VectorUDT, false))\n+  }\n+\n+  override def transform(dataset: DataFrame): DataFrame = {\n+    validateParams()\n+    val inputFeatures = $(inputCols).map(c => dataset.schema(c))\n+    val featureEncoders = getFeatureEncoders(inputFeatures)\n+    val featureAttrs = getFeatureAttrs(inputFeatures)\n+\n+    def interactFunc = udf { row: Row =>\n+      var indices = ArrayBuilder.make[Int]\n+      var values = ArrayBuilder.make[Double]\n+      var size = 1\n+      indices += 0\n+      values += 1.0\n+      var featureIndex = row.length - 1\n+      while (featureIndex >= 0) {\n+        val prevIndices = indices.result()\n+        val prevValues = values.result()\n+        val prevSize = size\n+        val currentEncoder = featureEncoders(featureIndex)\n+        indices = ArrayBuilder.make[Int]\n+        values = ArrayBuilder.make[Double]\n+        size *= currentEncoder.outputSize\n+        currentEncoder.foreachNonzeroOutput(row(featureIndex), (i, a) => {\n+          var j = 0\n+          while (j < prevIndices.length) {\n+            indices += prevIndices(j) + i * prevSize\n+            values += prevValues(j) * a\n+            j += 1\n+          }\n+        })\n+        featureIndex -= 1\n+      }\n+      Vectors.sparse(size, indices.result(), values.result()).compressed\n+    }\n+\n+    val featureCols = inputFeatures.map { f =>\n+      f.dataType match {\n+        case DoubleType => dataset(f.name)\n+        case _: VectorUDT => dataset(f.name)\n+        case _: NumericType | BooleanType => dataset(f.name).cast(DoubleType)\n+      }\n+    }\n+    dataset.select(\n+      col(\"*\"),\n+      interactFunc(struct(featureCols: _*)).as($(outputCol), featureAttrs.toMetadata()))\n+  }\n+\n+  /**\n+   * Creates a feature encoder for each input column, which supports efficient iteration over\n+   * one-hot encoded feature values. See also the class-level comment of [[FeatureEncoder]].\n+   *\n+   * @param features The input feature columns to create encoders for.\n+   */\n+  private def getFeatureEncoders(features: Seq[StructField]): Array[FeatureEncoder] = {\n+    def getNumFeatures(attr: Attribute): Int = {\n+      attr match {\n+        case nominal: NominalAttribute =>\n+          math.max(1, nominal.getNumValues.getOrElse(\n+            throw new SparkException(\"Nominal features must have attr numValues defined.\")))\n+        case _ =>\n+          1  // numeric feature\n+      }\n+    }\n+    features.map { f =>\n+      val numFeatures = f.dataType match {\n+        case _: NumericType | BooleanType =>\n+          Array(getNumFeatures(Attribute.fromStructField(f)))\n+        case _: VectorUDT =>\n+          val attrs = AttributeGroup.fromStructField(f).attributes.getOrElse(\n+            throw new SparkException(\"Vector attributes must be defined for interaction.\"))\n+          attrs.map(getNumFeatures).toArray\n+      }\n+      new FeatureEncoder(numFeatures)\n+    }.toArray\n+  }\n+\n+  /**\n+   * Generates ML attributes for the output vector of all feature interactions. We make a best\n+   * effort to generate reasonable names for output features, based on the concatenation of the\n+   * interacting feature names and values delimited with `_`. When no feature name is specified,\n+   * we fall back to using the feature index (e.g. `foo:bar_2_0` may indicate an interaction\n+   * between the numeric `foo` feature and a nominal third feature from column `bar`.\n+   *\n+   * @param features The input feature columns to the Interaction transformer.\n+   */\n+  private def getFeatureAttrs(features: Seq[StructField]): AttributeGroup = {\n+    var featureAttrs: Seq[Attribute] = Nil\n+    features.reverse.foreach { f =>\n+      val encodedAttrs = f.dataType match {\n+        case _: NumericType | BooleanType =>\n+          val attr = Attribute.fromStructField(f)\n+          encodedFeatureAttrs(Seq(attr), None)\n+        case _: VectorUDT =>\n+          val group = AttributeGroup.fromStructField(f)\n+          encodedFeatureAttrs(group.attributes.get, Some(group.name))\n+      }\n+      if (featureAttrs.isEmpty) {\n+        featureAttrs = encodedAttrs\n+      } else {\n+        featureAttrs = encodedAttrs.flatMap { head =>\n+          featureAttrs.map { tail =>\n+            NumericAttribute.defaultAttr.withName(head.name.get + \":\" + tail.name.get)\n+          }\n+        }\n+      }\n+    }\n+    new AttributeGroup($(outputCol), featureAttrs.toArray)\n+  }\n+\n+  /**\n+   * Generates the output ML attributes for a single input feature. Each output feature name has\n+   * up to three parts: the group name, feature name, and category name (for nominal features),\n+   * each separated by an underscore.\n+   *\n+   * @param inputAttrs The attributes of the input feature.\n+   * @param groupName Optional name of the input feature group (for Vector type features).\n+   */\n+  private def encodedFeatureAttrs(\n+      inputAttrs: Seq[Attribute],\n+      groupName: Option[String]): Seq[Attribute] = {\n+\n+    def format(\n+        index: Int,\n+        attrName: Option[String],\n+        categoryName: Option[String]): String = {\n+      val parts = Seq(groupName, Some(attrName.getOrElse(index.toString)), categoryName)\n+      parts.flatten.mkString(\"_\")\n+    }\n+\n+    inputAttrs.zipWithIndex.flatMap {\n+      case (nominal: NominalAttribute, i) =>\n+        if (nominal.values.isDefined) {\n+          nominal.values.get.map(\n+            v => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(v))))\n+        } else {\n+          Array.tabulate(nominal.getNumValues.get)(\n+            j => BinaryAttribute.defaultAttr.withName(format(i, nominal.name, Some(j.toString))))\n+        }\n+      case (a: Attribute, i) =>\n+        Seq(NumericAttribute.defaultAttr.withName(format(i, a.name, None)))\n+    }\n+  }\n+\n+  override def copy(extra: ParamMap): Interaction = defaultCopy(extra)\n+\n+  override def validateParams(): Unit = {\n+    require(get(inputCols).isDefined, \"Input cols must be defined first.\")\n+    require(get(outputCol).isDefined, \"Output col must be defined first.\")\n+    require($(inputCols).length > 0, \"Input cols must have non-zero length.\")\n+    require($(inputCols).distinct.length == $(inputCols).length, \"Input cols must be distinct.\")\n+  }\n+}\n+\n+/**\n+ * This class performs on-the-fly one-hot encoding of features as you iterate over them. To\n+ * indicate which input features should be one-hot encoded, an array of the feature counts\n+ * must be passed in ahead of time.\n+ *\n+ * @param numFeatures Array of feature counts for each input feature. For nominal features this\n+ *                    count is equal to the number of categories. For numeric features the count\n+ *                    should be set to 1.\n+ */\n+private[ml] class FeatureEncoder(numFeatures: Array[Int]) {\n+  assert(numFeatures.forall(_ > 0), \"Features counts must all be positive.\")\n+\n+  /** The size of the output vector. */\n+  val outputSize = numFeatures.sum\n+\n+  /** Precomputed offsets for the location of each output feature. */\n+  private val outputOffsets = {\n+    val arr = new Array[Int](numFeatures.length)\n+    for (i <- 1 until arr.length) {"
  }],
  "prId": 7987
}]