[{
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "Can we put those import above?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:06:36Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I still think that this method is not needed, just create a singe `def train(dataset: Dataset[_]): FMClassifierModel`?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:08:30Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train("
  }, {
    "author": {
      "login": "mob-ai"
    },
    "body": "> I still think that this method is not needed, just create a singe `def train(dataset: Dataset[_]): FMClassifierModel`?\r\n\r\n@zhengruifeng I refer to the implementation of LR. It will handle persistence. If dataset not be persisted, it would persist the dataset, and release the cache after train finish.\r\nOr should I cache dataset regardless of whether the dataset be cached?\r\n\r\nLogisticRegression.scala: 481\r\n\r\n```scala\r\n  override protected[spark] def train(dataset: Dataset[_]): LogisticRegressionModel = {\r\n    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\r\n    train(dataset, handlePersistence)\r\n  }\r\n\r\n  protected[spark] def train(\r\n      dataset: Dataset[_],\r\n      handlePersistence: Boolean): LogisticRegressionModel = instrumented { instr =>\r\n    val instances = extractInstances(dataset)\r\n\r\n    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\r\n\r\n    // train model code\r\n\r\n    if (handlePersistence) instances.unpersist()\r\n```\r\n",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T06:39:27Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train("
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "Yes, but this method `def train(dataset: Dataset[_], handlePersistence: Boolean)` is added for the old [`mllib.LogisticRegression`](https://github.com/apache/spark/blob/6378d4bc06cd1bb1a209bd5fb63d10ef52d75eb4/mllib/src/main/scala/org/apache/spark/mllib/classification/LogisticRegression.scala#L345).\r\n\r\nAs a new alg, FM do not need to have this method.\r\n\r\n>  Or should I cache dataset regardless of whether the dataset be cached?\r\n\r\nyou should cache the dataset, refer to [LinearSVC](https://github.com/apache/spark/blob/8a4378c6f0ca49f94fdeba08ca095721427e8635/mllib/src/main/scala/org/apache/spark/ml/classification/LinearSVC.scala#L165)",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T07:06:00Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train("
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "```scala\r\n  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\r\n    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\r\n    val data: RDD[(Double, OldVector)] = ...\r\n    if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\r\n    ...\r\n  }\r\n```",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-25T10:05:17Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train("
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "If the real training dataset is `data` not `instances`, why not cache `data` instead?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:10:34Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I guess we can put this import above",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:11:15Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)\n+\n+    if (handlePersistence) instances.unpersist()\n+\n+    val model = copyValues(new FMClassifierModel(uid, coefficients.asML, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val coefficients: Vector,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.LogisticLoss"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I guess we can mark it `lazy` and `transient`?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:12:04Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)\n+\n+    if (handlePersistence) instances.unpersist()\n+\n+    val model = copyValues(new FMClassifierModel(uid, coefficients.asML, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val coefficients: Vector,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.LogisticLoss\n+\n+  /**\n+   * Returns Factorization Machines coefficients\n+   * coefficients concat from 2-way coefficients, 1-way coefficients, global bias\n+   * index 0 ~ numFeatures*numFactors is 2-way coefficients,\n+   *   [i * numFactors + f] denotes i-th feature and f-th factor\n+   * Following indices are 1-way coefficients and global bias.\n+   */\n+  private val oldCoefficients: OldVector = coefficients"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`transient`?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:12:42Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)\n+\n+    if (handlePersistence) instances.unpersist()\n+\n+    val model = copyValues(new FMClassifierModel(uid, coefficients.asML, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val coefficients: Vector,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.LogisticLoss\n+\n+  /**\n+   * Returns Factorization Machines coefficients\n+   * coefficients concat from 2-way coefficients, 1-way coefficients, global bias\n+   * index 0 ~ numFeatures*numFactors is 2-way coefficients,\n+   *   [i * numFactors + f] denotes i-th feature and f-th factor\n+   * Following indices are 1-way coefficients and global bias.\n+   */\n+  private val oldCoefficients: OldVector = coefficients\n+\n+  private lazy val gradient = BaseFactorizationMachinesGradient.parseLoss("
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`coefficients` is now a `ml.Vector`, right?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:14:16Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)\n+\n+    if (handlePersistence) instances.unpersist()\n+\n+    val model = copyValues(new FMClassifierModel(uid, coefficients.asML, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val coefficients: Vector,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.LogisticLoss\n+\n+  /**\n+   * Returns Factorization Machines coefficients\n+   * coefficients concat from 2-way coefficients, 1-way coefficients, global bias\n+   * index 0 ~ numFeatures*numFactors is 2-way coefficients,\n+   *   [i * numFactors + f] denotes i-th feature and f-th factor\n+   * Following indices are 1-way coefficients and global bias.\n+   */\n+  private val oldCoefficients: OldVector = coefficients\n+\n+  private lazy val gradient = BaseFactorizationMachinesGradient.parseLoss(\n+    LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val rawPrediction: Double = gradient.getRawPrediction(features, oldCoefficients)\n+    Vectors.dense(Array(-rawPrediction, rawPrediction))\n+  }\n+\n+  override protected def raw2probabilityInPlace(rawPrediction: Vector): Vector = {\n+    rawPrediction match {\n+      case dv: DenseVector =>\n+        dv.values(1) = gradient.getPrediction(dv.values(1))\n+        dv.values(0) = 1.0 - dv.values(1)\n+        dv\n+      case sv: SparseVector =>\n+        throw new RuntimeException(\"Unexpected error in FMClassifierModel:\" +\n+          \" raw2probabilityInPlace encountered SparseVector\")\n+    }\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifierModel = {\n+    copyValues(new FMClassifierModel(\n+      uid, coefficients, numFeatures, numClasses), extra)\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def write: MLWriter =\n+    new FMClassifierModel.FMClassifierModelWriter(this)\n+\n+  override def toString: String = {\n+    s\"FMClassifierModel: \" +\n+      s\"uid = ${super.toString}, numClasses = $numClasses, numFeatures = $numFeatures, \" +\n+      s\"numFactors = ${$(numFactors)}, fitLinear = ${$(fitLinear)}, fitBias = ${$(fitBias)}\"\n+  }\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifierModel extends MLReadable[FMClassifierModel] {\n+\n+  @Since(\"3.0.0\")\n+  override def read: MLReader[FMClassifierModel] = new FMClassifierModelReader\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifierModel = super.load(path)\n+\n+  /** [[MLWriter]] instance for [[FMClassifierModel]] */\n+  private[FMClassifierModel] class FMClassifierModelWriter(\n+    instance: FMClassifierModel) extends MLWriter with Logging {\n+\n+    private case class Data(\n+      numFeatures: Int,\n+      numClasses: Int,\n+      coefficients: OldVector)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "can we split `coefficients` into three part: bias/linear/factors ?\r\nI think it is useful to obtain the factors matix in some cases.",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-01T03:17:15Z",
    "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.mllib.optimization.GradientDescent\n+import org.apache.spark.mllib.regression.{LabeledPoint => OldLabeledPoint}\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+  @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  import org.apache.spark.ml.regression.BaseFactorizationMachinesGradient.{LogisticLoss, parseLoss}\n+  import org.apache.spark.ml.regression.FMRegressor.initCoefficients\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = {\n+    require(value > 0 && value <= 1.0,\n+      s\"Fraction for mini-batch SGD must be in range (0, 1] but got $value\")\n+    set(miniBatchFraction, value)\n+  }\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.rdd.getStorageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val instances: RDD[OldLabeledPoint] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          OldLabeledPoint(label, features)\n+      }\n+\n+    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = instances.first().features.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val data = instances.map{ case OldLabeledPoint(label, features) => (label, features) }\n+\n+    // initialize coefficients\n+    val (initialCoefficients, coefficientsSize) = initCoefficients(\n+      numFeatures, $(numFactors), $(fitBias), $(fitLinear), $(initStd))\n+\n+    // optimize coefficients with gradient descent\n+    val gradient = parseLoss(\n+      LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+    val updater = parseSolver($(solver), coefficientsSize)\n+\n+    val optimizer = new GradientDescent(gradient, updater)\n+      .setStepSize($(stepSize))\n+      .setNumIterations($(maxIter))\n+      .setRegParam($(regParam))\n+      .setMiniBatchFraction($(miniBatchFraction))\n+      .setConvergenceTol($(tol))\n+    val coefficients = optimizer.optimize(data, initialCoefficients)\n+\n+    if (handlePersistence) instances.unpersist()\n+\n+    val model = copyValues(new FMClassifierModel(uid, coefficients.asML, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val coefficients: Vector,"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "This formula seems only for regression?\r\nFor classification, maybe a logistic function is needed?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T07:56:27Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "all support solvers should be listed here, like\r\n'Supported options: \"multinomial\" (default) and \"bernoulli\".'",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T07:57:56Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW."
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "```scala\r\nval instances = extractInstances(dataset)\r\nif (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\r\n```",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T07:59:17Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)"
  }, {
    "author": {
      "login": "mob-ai"
    },
    "body": "> ```scala\r\n> val instances = extractInstances(dataset)\r\n> if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\r\n> ```\r\n\r\n@zhengruifeng  `extractInstances` function return `RDD[Instance]`, but I need `RDD[(Double, OldVector)]` in train stage. Should I still get instances?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-11T01:57:02Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)"
  }, {
    "author": {
      "login": "mob-ai"
    },
    "body": "> ```scala\r\n> val instances = extractInstances(dataset)\r\n> if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\r\n> ```\r\n\r\n@zhengruifeng `handlePersistence` need be implemented like this.\r\n\r\n```\r\n  override protected[spark] def train(dataset: Dataset[_]): LogisticRegressionModel = {\r\n    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\r\n    train(dataset, handlePersistence)\r\n  }\r\n\r\n  protected[spark] def train(\r\n      dataset: Dataset[_],\r\n      handlePersistence: Boolean): LogisticRegressionModel = instrumented { instr =>\r\n    val instances = extractInstances(dataset)\r\n\r\n    if (handlePersistence) instances.persist(StorageLevel.MEMORY_AND_DISK)\r\n\r\n    // train model code\r\n\r\n    if (handlePersistence) instances.unpersist()\r\n```\r\n\r\nBut in previous review, you told me that I should not implement `handlePersistence`, because It's implement for mllib LR. I am confused.",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-11T02:11:41Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`class FMClassifierModel private[classification]`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:13:30Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel ("
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "move `numFeatures`, `numClasses` outof `FMClassifierModel`\r\nrefer to [LinearSVCModel](https://github.com/apache/spark/blob/5853e8b3301fd7b0bff721d5a47139afb17bfd2b/mllib/src/main/scala/org/apache/spark/ml/classification/LinearSVC.scala#L287)",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:22:24Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linearVector: Vector,\n+  @Since(\"3.0.0\") val factorMatrix: Matrix,\n+  @Since(\"3.0.0\") override val numFeatures: Int,"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I guess the var name `numFactors` is misleading,  #factors should be equal to #features.\r\n\r\nrefer to the name `vectorSize` in [W2V](https://github.com/apache/spark/blob/e7443d6412582aa16769e298c31d889a5ba0143c/mllib/src/main/scala/org/apache/spark/ml/feature/Word2Vec.scala#L47), I perfer rename `numFactors` to `factorSize`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:26:08Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`if (handlePersistence) data.unpersist()`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:27:26Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+",
    "line": 222
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "we do not name a method like `_train`, what about `trainImpl` or `FactorizationMachines.train`?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:28:45Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I'd perfer to define another prediction method using `bias`/`weights`/`factors` directly, to avoid  conversions to `mlllib.vector`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:30:33Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linearVector: Vector,\n+  @Since(\"3.0.0\") val factorMatrix: Matrix,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linearVector, factorMatrix, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val rawPrediction: Double = gradient.getRawPrediction(features, oldCoefficients)"
  }, {
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I guess then we do not need `oldCoefficients`/`gradient`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:34:05Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linearVector: Vector,\n+  @Since(\"3.0.0\") val factorMatrix: Matrix,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linearVector, factorMatrix, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val rawPrediction: Double = gradient.getRawPrediction(features, oldCoefficients)"
  }, {
    "author": {
      "login": "mob-ai"
    },
    "body": "> I guess then we do not need `oldCoefficients`/`gradient`\r\n\r\nemm...But then I have to implement the predict code twice...Actually I want to abstract it into one class.",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-11T03:35:53Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linearVector: Vector,\n+  @Since(\"3.0.0\") val factorMatrix: Matrix,\n+  @Since(\"3.0.0\") override val numFeatures: Int,\n+  @Since(\"3.0.0\") override val numClasses: Int)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linearVector, factorMatrix, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(numFactors), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val rawPrediction: Double = gradient.getRawPrediction(features, oldCoefficients)"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "what about renaming them to `linear`/`weights` & `factors`?",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:33:30Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,\n+      bias, linearVector, factorMatrix, numFeatures, numClasses))\n+    model\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linearVector: Vector,"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`copyValues(new FMClassifierModel(uid, bias, linearVector, factorMatrix, numFeatures, numClasses))`\r\nis enough, you do not need to define a var `model`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-08T10:35:34Z",
    "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setNumFactors(value: Int): this.type = set(numFactors, value)\n+  setDefault(numFactors -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Default is adamW.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected def train(dataset: Dataset[_]): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+    data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, numFactors, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = _train(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linearVector, factorMatrix) = splitCoefficients(\n+      coefficients, numFeatures, $(numFactors), $(fitBias), $(fitLinear))\n+\n+    val model = copyValues(new FMClassifierModel(uid,"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`FMClassifierModel` -> `FMClassificationModel`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-25T10:14:36Z",
    "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = \\sigma\\left( w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j \\right)\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFactorSize(value: Int): this.type = set(factorSize, value)\n+  setDefault(factorSize -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Supported options: \"gd\", \"adamW\".\n+   * Default: \"adamW\"\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+\n+    if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, factorSize, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = trainImpl(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linear, factors) = splitCoefficients(\n+      coefficients, numFeatures, $(factorSize), $(fitBias), $(fitLinear))\n+\n+    if (handlePersistence) data.unpersist()\n+\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors))\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel private[classification] ("
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`FMClassifierModelWriter` -> `FMClassificationModelWriter`\r\n",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-25T10:16:33Z",
    "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = \\sigma\\left( w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j \\right)\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFactorSize(value: Int): this.type = set(factorSize, value)\n+  setDefault(factorSize -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Supported options: \"gd\", \"adamW\".\n+   * Default: \"adamW\"\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+\n+    if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, factorSize, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = trainImpl(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linear, factors) = splitCoefficients(\n+      coefficients, numFeatures, $(factorSize), $(fitBias), $(fitLinear))\n+\n+    if (handlePersistence) data.unpersist()\n+\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors))\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel private[classification] (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linear: Vector,\n+  @Since(\"3.0.0\") val factors: Matrix)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @Since(\"3.0.0\")\n+  override val numClasses: Int = 2\n+\n+  @Since(\"3.0.0\")\n+  override val numFeatures: Int = linear.size\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linear, factors, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(factorSize), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val (rawPrediction, _) = gradient.getRawPrediction(features, oldCoefficients)\n+    Vectors.dense(Array(-rawPrediction, rawPrediction))\n+  }\n+\n+  override protected def raw2probabilityInPlace(rawPrediction: Vector): Vector = {\n+    rawPrediction match {\n+      case dv: DenseVector =>\n+        dv.values(1) = gradient.getPrediction(dv.values(1))\n+        dv.values(0) = 1.0 - dv.values(1)\n+        dv\n+      case sv: SparseVector =>\n+        throw new RuntimeException(\"Unexpected error in FMClassifierModel:\" +\n+          \" raw2probabilityInPlace encountered SparseVector\")\n+    }\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifierModel = {\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors), extra)\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def write: MLWriter =\n+    new FMClassifierModel.FMClassifierModelWriter(this)\n+\n+  override def toString: String = {\n+    s\"FMClassifierModel: \" +\n+      s\"uid = ${super.toString}, numClasses = $numClasses, numFeatures = $numFeatures, \" +\n+      s\"factorSize = ${$(factorSize)}, fitLinear = ${$(fitLinear)}, fitBias = ${$(fitBias)}\"\n+  }\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifierModel extends MLReadable[FMClassifierModel] {\n+\n+  @Since(\"3.0.0\")\n+  override def read: MLReader[FMClassifierModel] = new FMClassifierModelReader\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifierModel = super.load(path)\n+\n+  /** [[MLWriter]] instance for [[FMClassifierModel]] */\n+  private[FMClassifierModel] class FMClassifierModelWriter("
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "`FMClassifierModelReader` -> `FMClassificationModelReader`",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-25T10:17:19Z",
    "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = \\sigma\\left( w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j \\right)\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFactorSize(value: Int): this.type = set(factorSize, value)\n+  setDefault(factorSize -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Supported options: \"gd\", \"adamW\".\n+   * Default: \"adamW\"\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+\n+    if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, factorSize, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = trainImpl(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linear, factors) = splitCoefficients(\n+      coefficients, numFeatures, $(factorSize), $(fitBias), $(fitLinear))\n+\n+    if (handlePersistence) data.unpersist()\n+\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors))\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel private[classification] (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linear: Vector,\n+  @Since(\"3.0.0\") val factors: Matrix)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @Since(\"3.0.0\")\n+  override val numClasses: Int = 2\n+\n+  @Since(\"3.0.0\")\n+  override val numFeatures: Int = linear.size\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linear, factors, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(factorSize), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {\n+    val (rawPrediction, _) = gradient.getRawPrediction(features, oldCoefficients)\n+    Vectors.dense(Array(-rawPrediction, rawPrediction))\n+  }\n+\n+  override protected def raw2probabilityInPlace(rawPrediction: Vector): Vector = {\n+    rawPrediction match {\n+      case dv: DenseVector =>\n+        dv.values(1) = gradient.getPrediction(dv.values(1))\n+        dv.values(0) = 1.0 - dv.values(1)\n+        dv\n+      case sv: SparseVector =>\n+        throw new RuntimeException(\"Unexpected error in FMClassifierModel:\" +\n+          \" raw2probabilityInPlace encountered SparseVector\")\n+    }\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifierModel = {\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors), extra)\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def write: MLWriter =\n+    new FMClassifierModel.FMClassifierModelWriter(this)\n+\n+  override def toString: String = {\n+    s\"FMClassifierModel: \" +\n+      s\"uid = ${super.toString}, numClasses = $numClasses, numFeatures = $numFeatures, \" +\n+      s\"factorSize = ${$(factorSize)}, fitLinear = ${$(fitLinear)}, fitBias = ${$(fitBias)}\"\n+  }\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifierModel extends MLReadable[FMClassifierModel] {\n+\n+  @Since(\"3.0.0\")\n+  override def read: MLReader[FMClassifierModel] = new FMClassifierModelReader\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifierModel = super.load(path)\n+\n+  /** [[MLWriter]] instance for [[FMClassifierModel]] */\n+  private[FMClassifierModel] class FMClassifierModelWriter(\n+    instance: FMClassifierModel) extends MLWriter with Logging {\n+\n+    private case class Data(\n+      bias: Double,\n+      linear: Vector,\n+      factors: Matrix)\n+\n+    override protected def saveImpl(path: String): Unit = {\n+      DefaultParamsWriter.saveMetadata(instance, path, sc)\n+      val data = Data(instance.bias, instance.linear, instance.factors)\n+      val dataPath = new Path(path, \"data\").toString\n+      sparkSession.createDataFrame(Seq(data)).repartition(1).write.parquet(dataPath)\n+    }\n+  }\n+\n+  private class FMClassifierModelReader extends MLReader[FMClassifierModel] {"
  }],
  "prId": 26124
}, {
  "comments": [{
    "author": {
      "login": "zhengruifeng"
    },
    "body": "I know it will impl the prediction function twice, but impl it in the .ml side will avoid\r\n1, vector conversion from .ml to .mllib\r\n2, having two model coefficients in memory, the FMModel is usually much larger than other linear models.",
    "commit": "9bd6cbffa3adef737070c24c4ccf4bbb423a0a05",
    "createdAt": "2019-11-25T10:37:46Z",
    "diffHunk": "@@ -0,0 +1,333 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.classification\n+\n+import org.apache.hadoop.fs.Path\n+\n+import org.apache.spark.annotation.Since\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.linalg._\n+import org.apache.spark.ml.param._\n+import org.apache.spark.ml.regression.{FactorizationMachines, FactorizationMachinesParams}\n+import org.apache.spark.ml.regression.FactorizationMachines._\n+import org.apache.spark.ml.util._\n+import org.apache.spark.ml.util.Instrumentation.instrumented\n+import org.apache.spark.mllib.linalg.{Vector => OldVector}\n+import org.apache.spark.mllib.linalg.VectorImplicits._\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.{Dataset, Row}\n+import org.apache.spark.sql.functions.col\n+import org.apache.spark.storage.StorageLevel\n+\n+/**\n+ * Params for FMClassifier.\n+ */\n+private[classification] trait FMClassifierParams extends ProbabilisticClassifierParams\n+  with FactorizationMachinesParams {\n+}\n+\n+/**\n+ * Factorization Machines learning algorithm for classification.\n+ * It supports normal gradient descent and AdamW solver.\n+ *\n+ * The implementation is based upon:\n+ * <a href=\"https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf\">\n+ * S. Rendle. \"Factorization machines\" 2010</a>.\n+ *\n+ * FM is able to estimate interactions even in problems with huge sparsity\n+ * (like advertising and recommendation system).\n+ * FM formula is:\n+ * {{{\n+ *   y = \\sigma\\left( w_0 + \\sum\\limits^n_{i-1} w_i x_i +\n+ *     \\sum\\limits^n_{i=1} \\sum\\limits^n_{j=i+1} \\langle v_i, v_j \\rangle x_i x_j \\right)\n+ * }}}\n+ * First two terms denote global bias and linear term (as same as linear regression),\n+ * and last term denotes pairwise interactions term. {{{v_i}}} describes the i-th variable\n+ * with k factors.\n+ *\n+ * FM classification model uses logistic loss which can be solved by gradient descent method, and\n+ * regularization terms like L2 are usually added to the loss function to prevent overfitting.\n+ *\n+ * @note Multiclass labels are not currently supported.\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifier @Since(\"3.0.0\") (\n+    @Since(\"3.0.0\") override val uid: String)\n+  extends ProbabilisticClassifier[Vector, FMClassifier, FMClassifierModel]\n+  with FactorizationMachines with FMClassifierParams with DefaultParamsWritable with Logging {\n+\n+  @Since(\"3.0.0\")\n+  def this() = this(Identifiable.randomUID(\"fmc\"))\n+\n+  /**\n+   * Set the dimensionality of the factors.\n+   * Default is 8.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFactorSize(value: Int): this.type = set(factorSize, value)\n+  setDefault(factorSize -> 8)\n+\n+  /**\n+   * Set whether to fit global bias term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitBias(value: Boolean): this.type = set(fitBias, value)\n+  setDefault(fitBias -> true)\n+\n+  /**\n+   * Set whether to fit linear term.\n+   * Default is true.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setFitLinear(value: Boolean): this.type = set(fitLinear, value)\n+  setDefault(fitLinear -> true)\n+\n+  /**\n+   * Set the L2 regularization parameter.\n+   * Default is 0.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setRegParam(value: Double): this.type = set(regParam, value)\n+  setDefault(regParam -> 0.0)\n+\n+  /**\n+   * Set the mini-batch fraction parameter.\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMiniBatchFraction(value: Double): this.type = set(miniBatchFraction, value)\n+  setDefault(miniBatchFraction -> 1.0)\n+\n+  /**\n+   * Set the standard deviation of initial coefficients.\n+   * Default is 0.01.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setInitStd(value: Double): this.type = set(initStd, value)\n+  setDefault(initStd -> 0.01)\n+\n+  /**\n+   * Set the maximum number of iterations.\n+   * Default is 100.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setMaxIter(value: Int): this.type = set(maxIter, value)\n+  setDefault(maxIter -> 100)\n+\n+  /**\n+   * Set the initial step size for the first step (like learning rate).\n+   * Default is 1.0.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setStepSize(value: Double): this.type = set(stepSize, value)\n+  setDefault(stepSize -> 1.0)\n+\n+  /**\n+   * Set the convergence tolerance of iterations.\n+   * Default is 1E-6.\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setTol(value: Double): this.type = set(tol, value)\n+  setDefault(tol -> 1E-6)\n+\n+  /**\n+   * Set the solver algorithm used for optimization.\n+   * Supported options: \"gd\", \"adamW\".\n+   * Default: \"adamW\"\n+   *\n+   * @group setParam\n+   */\n+  @Since(\"3.0.0\")\n+  def setSolver(value: String): this.type = set(solver, value)\n+  setDefault(solver -> AdamW)\n+\n+  override protected[spark] def train(dataset: Dataset[_]): FMClassifierModel = {\n+    val handlePersistence = dataset.storageLevel == StorageLevel.NONE\n+    train(dataset, handlePersistence)\n+  }\n+\n+  protected[spark] def train(\n+      dataset: Dataset[_],\n+      handlePersistence: Boolean): FMClassifierModel = instrumented { instr =>\n+    val data: RDD[(Double, OldVector)] =\n+      dataset.select(col($(labelCol)), col($(featuresCol))).rdd.map {\n+        case Row(label: Double, features: Vector) =>\n+          require(label == 0 || label == 1, s\"FMClassifier was given\" +\n+            s\" dataset with invalid label $label.  Labels must be in {0,1}; note that\" +\n+            s\" FMClassifier currently only supports binary classification.\")\n+          (label, features)\n+      }\n+\n+    if (handlePersistence) data.persist(StorageLevel.MEMORY_AND_DISK)\n+\n+    val numClasses = 2\n+    if (isDefined(thresholds)) {\n+      require($(thresholds).length == numClasses, this.getClass.getSimpleName +\n+        \".train() called with non-matching numClasses and thresholds.length.\" +\n+        s\" numClasses=$numClasses, but thresholds has length ${$(thresholds).length}\")\n+    }\n+\n+    instr.logPipelineStage(this)\n+    instr.logDataset(dataset)\n+    instr.logParams(this, factorSize, fitBias, fitLinear, regParam,\n+      miniBatchFraction, initStd, maxIter, stepSize, tol, solver)\n+    instr.logNumClasses(numClasses)\n+\n+    val numFeatures = data.first()._2.size\n+    instr.logNumFeatures(numFeatures)\n+\n+    val coefficients = trainImpl(data, numFeatures, LogisticLoss)\n+\n+    val (bias, linear, factors) = splitCoefficients(\n+      coefficients, numFeatures, $(factorSize), $(fitBias), $(fitLinear))\n+\n+    if (handlePersistence) data.unpersist()\n+\n+    copyValues(new FMClassifierModel(uid, bias, linear, factors))\n+  }\n+\n+  @Since(\"3.0.0\")\n+  override def copy(extra: ParamMap): FMClassifier = defaultCopy(extra)\n+}\n+\n+@Since(\"3.0.0\")\n+object FMClassifier extends DefaultParamsReadable[FMClassifier] {\n+\n+  @Since(\"3.0.0\")\n+  override def load(path: String): FMClassifier = super.load(path)\n+}\n+\n+/**\n+ * Model produced by [[FMClassifier]]\n+ */\n+@Since(\"3.0.0\")\n+class FMClassifierModel private[classification] (\n+  @Since(\"3.0.0\") override val uid: String,\n+  @Since(\"3.0.0\") val bias: Double,\n+  @Since(\"3.0.0\") val linear: Vector,\n+  @Since(\"3.0.0\") val factors: Matrix)\n+  extends ProbabilisticClassificationModel[Vector, FMClassifierModel]\n+    with FMClassifierParams with MLWritable {\n+\n+  @Since(\"3.0.0\")\n+  override val numClasses: Int = 2\n+\n+  @Since(\"3.0.0\")\n+  override val numFeatures: Int = linear.size\n+\n+  @transient private lazy val oldCoefficients: OldVector =\n+    combineCoefficients(bias, linear, factors, $(fitBias), $(fitLinear))\n+\n+  @transient private lazy val gradient = parseLoss(\n+    LogisticLoss, $(factorSize), $(fitBias), $(fitLinear), numFeatures)\n+\n+  override protected def predictRaw(features: Vector): Vector = {",
    "line": 257
  }],
  "prId": 26124
}]