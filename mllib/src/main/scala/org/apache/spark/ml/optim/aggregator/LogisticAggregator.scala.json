[{
  "comments": [{
    "author": {
      "login": "hhbyyh"
    },
    "body": "For the convenience of other reviewers, I checked this part and the new implementation delegates the merge, gradient, weight and loss to the common implementation in DifferentiableLossAggregator, and made no further modification from the original implementation. LGTM.",
    "commit": "cb40b3189b546283635683d7711e0e2e28366034",
    "createdAt": "2017-06-26T22:04:58Z",
    "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.ml.optim.aggregator\n+\n+import org.apache.spark.broadcast.Broadcast\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.ml.feature.Instance\n+import org.apache.spark.ml.linalg.{DenseVector, Vector}\n+import org.apache.spark.mllib.util.MLUtils\n+\n+/**\n+ * LogisticAggregator computes the gradient and loss for binary or multinomial logistic (softmax)\n+ * loss function, as used in classification for instances in sparse or dense vector in an online\n+ * fashion.\n+ *\n+ * Two LogisticAggregators can be merged together to have a summary of loss and gradient of\n+ * the corresponding joint dataset.\n+ *\n+ * For improving the convergence rate during the optimization process and also to prevent against\n+ * features with very large variances exerting an overly large influence during model training,\n+ * packages like R's GLMNET perform the scaling to unit variance and remove the mean in order to\n+ * reduce the condition number. The model is then trained in this scaled space, but returns the\n+ * coefficients in the original scale. See page 9 in\n+ * http://cran.r-project.org/web/packages/glmnet/glmnet.pdf\n+ *\n+ * However, we don't want to apply the [[org.apache.spark.ml.feature.StandardScaler]] on the\n+ * training dataset, and then cache the standardized dataset since it will create a lot of overhead.\n+ * As a result, we perform the scaling implicitly when we compute the objective function (though\n+ * we do not subtract the mean).\n+ *\n+ * Note that there is a difference between multinomial (softmax) and binary loss. The binary case\n+ * uses one outcome class as a \"pivot\" and regresses the other class against the pivot. In the\n+ * multinomial case, the softmax loss function is used to model each class probability\n+ * independently. Using softmax loss produces `K` sets of coefficients, while using a pivot class\n+ * produces `K - 1` sets of coefficients (a single coefficient vector in the binary case). In the\n+ * binary case, we can say that the coefficients are shared between the positive and negative\n+ * classes. When regularization is applied, multinomial (softmax) loss will produce a result\n+ * different from binary loss since the positive and negative don't share the coefficients while the\n+ * binary regression shares the coefficients between positive and negative.\n+ *\n+ * The following is a mathematical derivation for the multinomial (softmax) loss.\n+ *\n+ * The probability of the multinomial outcome $y$ taking on any of the K possible outcomes is:\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    P(y_i=0|\\vec{x}_i, \\beta) = \\frac{e^{\\vec{x}_i^T \\vec{\\beta}_0}}{\\sum_{k=0}^{K-1}\n+ *       e^{\\vec{x}_i^T \\vec{\\beta}_k}} \\\\\n+ *    P(y_i=1|\\vec{x}_i, \\beta) = \\frac{e^{\\vec{x}_i^T \\vec{\\beta}_1}}{\\sum_{k=0}^{K-1}\n+ *       e^{\\vec{x}_i^T \\vec{\\beta}_k}}\\\\\n+ *    P(y_i=K-1|\\vec{x}_i, \\beta) = \\frac{e^{\\vec{x}_i^T \\vec{\\beta}_{K-1}}\\,}{\\sum_{k=0}^{K-1}\n+ *       e^{\\vec{x}_i^T \\vec{\\beta}_k}}\n+ *    $$\n+ * </blockquote>\n+ *\n+ * The model coefficients $\\beta = (\\beta_0, \\beta_1, \\beta_2, ..., \\beta_{K-1})$ become a matrix\n+ * which has dimension of $K \\times (N+1)$ if the intercepts are added. If the intercepts are not\n+ * added, the dimension will be $K \\times N$.\n+ *\n+ * Note that the coefficients in the model above lack identifiability. That is, any constant scalar\n+ * can be added to all of the coefficients and the probabilities remain the same.\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    \\begin{align}\n+ *    \\frac{e^{\\vec{x}_i^T \\left(\\vec{\\beta}_0 + \\vec{c}\\right)}}{\\sum_{k=0}^{K-1}\n+ *       e^{\\vec{x}_i^T \\left(\\vec{\\beta}_k + \\vec{c}\\right)}}\n+ *    = \\frac{e^{\\vec{x}_i^T \\vec{\\beta}_0}e^{\\vec{x}_i^T \\vec{c}}\\,}{e^{\\vec{x}_i^T \\vec{c}}\n+ *       \\sum_{k=0}^{K-1} e^{\\vec{x}_i^T \\vec{\\beta}_k}}\n+ *    = \\frac{e^{\\vec{x}_i^T \\vec{\\beta}_0}}{\\sum_{k=0}^{K-1} e^{\\vec{x}_i^T \\vec{\\beta}_k}}\n+ *    \\end{align}\n+ *    $$\n+ * </blockquote>\n+ *\n+ * However, when regularization is added to the loss function, the coefficients are indeed\n+ * identifiable because there is only one set of coefficients which minimizes the regularization\n+ * term. When no regularization is applied, we choose the coefficients with the minimum L2\n+ * penalty for consistency and reproducibility. For further discussion see:\n+ *\n+ * Friedman, et al. \"Regularization Paths for Generalized Linear Models via Coordinate Descent\"\n+ *\n+ * The loss of objective function for a single instance of data (we do not include the\n+ * regularization term here for simplicity) can be written as\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    \\begin{align}\n+ *    \\ell\\left(\\beta, x_i\\right) &= -log{P\\left(y_i \\middle| \\vec{x}_i, \\beta\\right)} \\\\\n+ *    &= log\\left(\\sum_{k=0}^{K-1}e^{\\vec{x}_i^T \\vec{\\beta}_k}\\right) - \\vec{x}_i^T \\vec{\\beta}_y\\\\\n+ *    &= log\\left(\\sum_{k=0}^{K-1} e^{margins_k}\\right) - margins_y\n+ *    \\end{align}\n+ *    $$\n+ * </blockquote>\n+ *\n+ * where ${margins}_k = \\vec{x}_i^T \\vec{\\beta}_k$.\n+ *\n+ * For optimization, we have to calculate the first derivative of the loss function, and a simple\n+ * calculation shows that\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    \\begin{align}\n+ *    \\frac{\\partial \\ell(\\beta, \\vec{x}_i, w_i)}{\\partial \\beta_{j, k}}\n+ *    &= x_{i,j} \\cdot w_i \\cdot \\left(\\frac{e^{\\vec{x}_i \\cdot \\vec{\\beta}_k}}{\\sum_{k'=0}^{K-1}\n+ *      e^{\\vec{x}_i \\cdot \\vec{\\beta}_{k'}}\\,} - I_{y=k}\\right) \\\\\n+ *    &= x_{i, j} \\cdot w_i \\cdot multiplier_k\n+ *    \\end{align}\n+ *    $$\n+ * </blockquote>\n+ *\n+ * where $w_i$ is the sample weight, $I_{y=k}$ is an indicator function\n+ *\n+ *  <blockquote>\n+ *    $$\n+ *    I_{y=k} = \\begin{cases}\n+ *          1 & y = k \\\\\n+ *          0 & else\n+ *       \\end{cases}\n+ *    $$\n+ * </blockquote>\n+ *\n+ * and\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    multiplier_k = \\left(\\frac{e^{\\vec{x}_i \\cdot \\vec{\\beta}_k}}{\\sum_{k=0}^{K-1}\n+ *       e^{\\vec{x}_i \\cdot \\vec{\\beta}_k}} - I_{y=k}\\right)\n+ *    $$\n+ * </blockquote>\n+ *\n+ * If any of margins is larger than 709.78, the numerical computation of multiplier and loss\n+ * function will suffer from arithmetic overflow. This issue occurs when there are outliers in\n+ * data which are far away from the hyperplane, and this will cause the failing of training once\n+ * infinity is introduced. Note that this is only a concern when max(margins) &gt; 0.\n+ *\n+ * Fortunately, when max(margins) = maxMargin &gt; 0, the loss function and the multiplier can\n+ * easily be rewritten into the following equivalent numerically stable formula.\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    \\ell\\left(\\beta, x\\right) = log\\left(\\sum_{k=0}^{K-1} e^{margins_k - maxMargin}\\right) -\n+ *       margins_{y} + maxMargin\n+ *    $$\n+ * </blockquote>\n+ *\n+ * Note that each term, $(margins_k - maxMargin)$ in the exponential is no greater than zero; as a\n+ * result, overflow will not happen with this formula.\n+ *\n+ * For $multiplier$, a similar trick can be applied as the following,\n+ *\n+ * <blockquote>\n+ *    $$\n+ *    multiplier_k = \\left(\\frac{e^{\\vec{x}_i \\cdot \\vec{\\beta}_k - maxMargin}}{\\sum_{k'=0}^{K-1}\n+ *       e^{\\vec{x}_i \\cdot \\vec{\\beta}_{k'} - maxMargin}} - I_{y=k}\\right)\n+ *    $$\n+ * </blockquote>\n+ *\n+ *\n+ * @param bcCoefficients The broadcast coefficients corresponding to the features.\n+ * @param bcFeaturesStd The broadcast standard deviation values of the features.\n+ * @param numClasses the number of possible outcomes for k classes classification problem in\n+ *                   Multinomial Logistic Regression.\n+ * @param fitIntercept Whether to fit an intercept term.\n+ * @param multinomial Whether to use multinomial (softmax) or binary loss\n+ * @note In order to avoid unnecessary computation during calculation of the gradient updates\n+ * we lay out the coefficients in column major order during training. This allows us to\n+ * perform feature standardization once, while still retaining sequential memory access\n+ * for speed. We convert back to row major order when we create the model,\n+ * since this form is optimal for the matrix operations used for prediction.\n+ */\n+private[ml] class LogisticAggregator(\n+    bcFeaturesStd: Broadcast[Array[Double]],\n+    numClasses: Int,\n+    fitIntercept: Boolean,\n+    multinomial: Boolean)(bcCoefficients: Broadcast[Vector])\n+  extends DifferentiableLossAggregator[Instance, LogisticAggregator] with Logging {\n+\n+  private val numFeatures = bcFeaturesStd.value.length\n+  private val numFeaturesPlusIntercept = if (fitIntercept) numFeatures + 1 else numFeatures\n+  private val coefficientSize = bcCoefficients.value.size\n+  protected override val dim: Int = coefficientSize\n+  if (multinomial) {\n+    require(numClasses ==  coefficientSize / numFeaturesPlusIntercept, s\"The number of \" +\n+      s\"coefficients should be ${numClasses * numFeaturesPlusIntercept} but was $coefficientSize\")\n+  } else {\n+    require(coefficientSize == numFeaturesPlusIntercept, s\"Expected $numFeaturesPlusIntercept \" +\n+      s\"coefficients but got $coefficientSize\")\n+    require(numClasses == 1 || numClasses == 2, s\"Binary logistic aggregator requires numClasses \" +\n+      s\"in {1, 2} but found $numClasses.\")\n+  }\n+\n+  @transient private lazy val coefficientsArray: Array[Double] = bcCoefficients.value match {\n+    case DenseVector(values) => values\n+    case _ => throw new IllegalArgumentException(s\"coefficients only supports dense vector but \" +\n+      s\"got type ${bcCoefficients.value.getClass}.)\")\n+  }\n+\n+  if (multinomial && numClasses <= 2) {\n+    logInfo(s\"Multinomial logistic regression for binary classification yields separate \" +\n+      s\"coefficients for positive and negative classes. When no regularization is applied, the\" +\n+      s\"result will be effectively the same as binary logistic regression. When regularization\" +\n+      s\"is applied, multinomial loss will produce a result different from binary loss.\")\n+  }\n+\n+  /** Update gradient and loss using binary loss function. */\n+  private def binaryUpdateInPlace(features: Vector, weight: Double, label: Double): Unit = {\n+\n+    val localFeaturesStd = bcFeaturesStd.value\n+    val localCoefficients = coefficientsArray\n+    val localGradientArray = gradientSumArray\n+    val margin = - {\n+      var sum = 0.0\n+      features.foreachActive { (index, value) =>\n+        if (localFeaturesStd(index) != 0.0 && value != 0.0) {\n+          sum += localCoefficients(index) * value / localFeaturesStd(index)\n+        }\n+      }\n+      if (fitIntercept) sum += localCoefficients(numFeaturesPlusIntercept - 1)\n+      sum\n+    }\n+\n+    val multiplier = weight * (1.0 / (1.0 + math.exp(margin)) - label)\n+\n+    features.foreachActive { (index, value) =>\n+      if (localFeaturesStd(index) != 0.0 && value != 0.0) {\n+        localGradientArray(index) += multiplier * value / localFeaturesStd(index)\n+      }\n+    }\n+\n+    if (fitIntercept) {\n+      localGradientArray(numFeaturesPlusIntercept - 1) += multiplier\n+    }\n+\n+    if (label > 0) {\n+      // The following is equivalent to log(1 + exp(margin)) but more numerically stable.\n+      lossSum += weight * MLUtils.log1pExp(margin)\n+    } else {\n+      lossSum += weight * (MLUtils.log1pExp(margin) - margin)\n+    }\n+  }\n+\n+  /** Update gradient and loss using multinomial (softmax) loss function. */\n+  private def multinomialUpdateInPlace(features: Vector, weight: Double, label: Double): Unit = {\n+    // TODO: use level 2 BLAS operations\n+    /*\n+      Note: this can still be used when numClasses = 2 for binary\n+      logistic regression without pivoting.\n+     */\n+    val localFeaturesStd = bcFeaturesStd.value\n+    val localCoefficients = coefficientsArray\n+    val localGradientArray = gradientSumArray\n+\n+    // marginOfLabel is margins(label) in the formula\n+    var marginOfLabel = 0.0\n+    var maxMargin = Double.NegativeInfinity\n+\n+    val margins = new Array[Double](numClasses)\n+    features.foreachActive { (index, value) =>\n+      val stdValue = value / localFeaturesStd(index)\n+      var j = 0\n+      while (j < numClasses) {\n+        margins(j) += localCoefficients(index * numClasses + j) * stdValue\n+        j += 1\n+      }\n+    }\n+    var i = 0\n+    while (i < numClasses) {\n+      if (fitIntercept) {\n+        margins(i) += localCoefficients(numClasses * numFeatures + i)\n+      }\n+      if (i == label.toInt) marginOfLabel = margins(i)\n+      if (margins(i) > maxMargin) {\n+        maxMargin = margins(i)\n+      }\n+      i += 1\n+    }\n+\n+    /**\n+     * When maxMargin is greater than 0, the original formula could cause overflow.\n+     * We address this by subtracting maxMargin from all the margins, so it's guaranteed\n+     * that all of the new margins will be smaller than zero to prevent arithmetic overflow.\n+     */\n+    val multipliers = new Array[Double](numClasses)\n+    val sum = {\n+      var temp = 0.0\n+      var i = 0\n+      while (i < numClasses) {\n+        if (maxMargin > 0) margins(i) -= maxMargin\n+        val exp = math.exp(margins(i))\n+        temp += exp\n+        multipliers(i) = exp\n+        i += 1\n+      }\n+      temp\n+    }\n+\n+    margins.indices.foreach { i =>\n+      multipliers(i) = multipliers(i) / sum - (if (label == i) 1.0 else 0.0)\n+    }\n+    features.foreachActive { (index, value) =>\n+      if (localFeaturesStd(index) != 0.0 && value != 0.0) {\n+        val stdValue = value / localFeaturesStd(index)\n+        var j = 0\n+        while (j < numClasses) {\n+          localGradientArray(index * numClasses + j) += weight * multipliers(j) * stdValue\n+          j += 1\n+        }\n+      }\n+    }\n+    if (fitIntercept) {\n+      var i = 0\n+      while (i < numClasses) {\n+        localGradientArray(numFeatures * numClasses + i) += weight * multipliers(i)\n+        i += 1\n+      }\n+    }\n+\n+    val loss = if (maxMargin > 0) {\n+      math.log(sum) - marginOfLabel + maxMargin\n+    } else {\n+      math.log(sum) - marginOfLabel\n+    }\n+    lossSum += weight * loss\n+  }\n+\n+  /**\n+   * Add a new training instance to this LogisticAggregator, and update the loss and gradient\n+   * of the objective function.\n+   *\n+   * @param instance The instance of data point to be added.\n+   * @return This LogisticAggregator object.\n+   */\n+  def add(instance: Instance): this.type = {\n+    instance match { case Instance(label, weight, features) =>\n+      require(numFeatures == features.size, s\"Dimensions mismatch when adding new instance.\" +\n+        s\" Expecting $numFeatures but got ${features.size}.\")\n+      require(weight >= 0.0, s\"instance weight, $weight has to be >= 0.0\")\n+\n+      if (weight == 0.0) return this\n+\n+      if (multinomial) {\n+        multinomialUpdateInPlace(features, weight, label)\n+      } else {\n+        binaryUpdateInPlace(features, weight, label)\n+      }\n+      weightSum += weight\n+      this\n+    }\n+  }",
    "line": 363
  }],
  "prId": 18305
}]