[{
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "`impl` is usually used for private code or implementation of a public interface. So we should either move `Node` to `ml.tree` and keep the subclasses under `impl` (then we cannot use sealed), or move everything to `ml.tree`.\n",
    "commit": "6aae25587cdcadc0e5d68078ca77d0cdee59e6e4",
    "createdAt": "2015-04-16T00:38:05Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.impl.tree"
  }, {
    "author": {
      "login": "jkbradley"
    },
    "body": "I'll move stuff to ml.tree.  I'll also make as many classes final as possible.\n",
    "commit": "6aae25587cdcadc0e5d68078ca77d0cdee59e6e4",
    "createdAt": "2015-04-16T17:57:59Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.impl.tree"
  }],
  "prId": 5530
}, {
  "comments": [{
    "author": {
      "login": "mengxr"
    },
    "body": "Should be `private` instead of `private[tree] since this is only called by`subtreeToString`.\n",
    "commit": "6aae25587cdcadc0e5d68078ca77d0cdee59e6e4",
    "createdAt": "2015-04-16T06:39:22Z",
    "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.ml.impl.tree\n+\n+import org.apache.spark.mllib.linalg.Vector\n+import org.apache.spark.mllib.tree.model.{InformationGainStats => OldInformationGainStats,\n+  Node => OldNode, Predict => OldPredict}\n+\n+\n+/**\n+ * Decision tree node interface.\n+ */\n+sealed trait Node extends Serializable {\n+\n+  // TODO: Add aggregate stats (once available).  This will happen after we move the DecisionTree\n+  //       code into the new API and deprecate the old API.\n+\n+  /** Prediction this node makes (or would make, if it is an internal node) */\n+  def prediction: Double\n+\n+  /** Impurity measure at this node (for training data) */\n+  def impurity: Double\n+\n+  /** Recursive prediction helper method */\n+  private[ml] def predict(features: Vector): Double = prediction\n+\n+  /**\n+   * Get the number of nodes in tree below this node, including leaf nodes.\n+   * E.g., if this is a leaf, returns 0.  If both children are leaves, returns 2.\n+   */\n+  private[tree] def numDescendants: Int\n+\n+  /**\n+   * Recursive print function.\n+   * @param indentFactor  The number of spaces to add to each level of indentation.\n+   */\n+  private[tree] def subtreeToString(indentFactor: Int = 0): String\n+\n+  /**\n+   * Get depth of tree from this node.\n+   * E.g.: Depth 0 means this is a leaf node.  Depth 1 means 1 internal and 2 leaf nodes.\n+   */\n+  private[tree] def subtreeDepth: Int\n+\n+  /**\n+   * Create a copy of this node in the old Node format, recursively creating child nodes as needed.\n+   * @param id  Node ID using old format IDs\n+   */\n+  private[ml] def toOld(id: Int): OldNode\n+}\n+\n+private[ml] object Node {\n+\n+  /**\n+   * Create a new Node from the old Node format, recursively creating child nodes as needed.\n+   */\n+  def fromOld(oldNode: OldNode): Node = {\n+    if (oldNode.isLeaf) {\n+      // TODO: Once the implementation has been moved to this API, then include sufficient\n+      //       statistics here.\n+      new LeafNode(prediction = oldNode.predict.predict, impurity = oldNode.impurity)\n+    } else {\n+      val gain = if (oldNode.stats.nonEmpty) {\n+        oldNode.stats.get.gain\n+      } else {\n+        0.0\n+      }\n+      new InternalNode(prediction = oldNode.predict.predict, impurity = oldNode.impurity,\n+        gain = gain, leftChild = fromOld(oldNode.leftNode.get),\n+        rightChild = fromOld(oldNode.rightNode.get), split = Split.fromOld(oldNode.split.get))\n+    }\n+  }\n+\n+  /**\n+   * Helper method for [[Node.subtreeToString()]].\n+   * @param split  Split to print\n+   * @param left  Indicates whether this is the part of the split going to the left,\n+   *              or that going to the right.\n+   */\n+  private[tree] def splitToString(split: Split, left: Boolean): String = {"
  }],
  "prId": 5530
}]