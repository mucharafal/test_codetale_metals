[{
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "nit: weird spacing (1 space?)\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:09:57Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "getAllClasses, getClasses, and findClasses perhaps could be renamed to something like getClassesFromJar, getClasses, and getClassesFromDir, respectively.\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:39:12Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Will this exclude staticModules?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:42:52Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "nit: perhaps filterNot(shouldExclude)\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:45:13Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "Also, would it make more sense to return a Set?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:55:24Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "What... what is the expected format of these filenames?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:47:32Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))"
  }, {
    "author": {
      "login": "aarondav"
    },
    "body": "Ah, here is an example: `jar:file:/home/aaron/spark/assembly/target/scala-2.10/spark-assembly-1.0.0-SNAPSHOT-hadoop1.0.4.jar!/org/apache/spark`\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:52:48Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "file.getName.stripSuffix(\".class\")\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T06:57:56Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq\n+  }\n+\n+  private def findClasses(directory: File, packageName: String): Seq[Class[_]] = {\n+    val classes = mutable.ArrayBuffer[Class[_]]()\n+    if (!directory.exists()) {\n+      return classes\n+    }\n+    val files = directory.listFiles()\n+    for (file <- files) {\n+      if (file.isDirectory) {\n+        classes ++= findClasses(file, packageName + \".\" + file.getName)\n+      } else if (file.getName.endsWith(\".class\")) {\n+        val className = file.getName.substring(0, file.getName.length() - 6)"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Is there a particular reason this is not just\n\n```\nfor (entry <- enums if entry.endsWith(\".class\")) {\n   classes += ...\n}\n```\n\n?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T07:08:53Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "ScrapCodes"
    },
    "body": "We can actually get rid of this part, since mostly what we have on classpath is an assembly jar. This is useful if we would support this facility even with assemble-deps target. Incase not we can document that this works only with `sbt/sbt assembly` command.\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T07:59:46Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq\n+  }\n+\n+  private def findClasses(directory: File, packageName: String): Seq[Class[_]] = {"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "I think it's nice to have it here for that reason - unless you think there is something buggy/wrong about it?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T20:26:44Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq\n+  }\n+\n+  private def findClasses(directory: File, packageName: String): Seq[Class[_]] = {"
  }, {
    "author": {
      "login": "ScrapCodes"
    },
    "body": "There is nothing wrong about it. But I can think of scenarios where results can be unpredictable. Lets say we had some class as private[x] in our codebase and we do assemble-deps, and then we change it back to public or private and do sbt package then it would still report it as private[x], I have not tested it but it is possible. \n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-24T06:29:31Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||\n+    name.contains(\"$sp\")\n+  }\n+\n+  /**\n+   * Scans all classes accessible from the context class loader which belong to the given package\n+   * and subpackages both from directories and jars present on the classpath.\n+   */\n+  private def getClasses(packageName: String,\n+      classLoader: ClassLoader = Thread.currentThread().getContextClassLoader): Seq[String] = {\n+    val path = packageName.replace('.', '/')\n+    val resources = classLoader.getResources(path)\n+\n+    val jars = resources.filter(x => x.getProtocol == \"jar\")\n+      .map(_.getFile.split(\":\")(1).split(\"!\")(0))\n+    val classesFromJars = jars.map(getAllClasses(_, path)).flatten\n+\n+    val dirs = resources.filter(x => x.getProtocol == \"file\")\n+      .map(x => new File(x.getFile.split(\":\").last))\n+    val classFromDirs = dirs.map(findClasses(_, packageName)).flatten\n+\n+    (classFromDirs ++ classesFromJars).map(_.getName).filter(!shouldExclude(_)).toSeq\n+  }\n+\n+  private def findClasses(directory: File, packageName: String): Seq[Class[_]] = {"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "ScrapCodes"
    },
    "body": "Not sure why you are excluding endsWith .class ?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T08:02:14Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||"
  }, {
    "author": {
      "login": "pwendell"
    },
    "body": "The scala compiler creates some extra classes called, e.g.\n\n```\nError determining visibility: org.apache.spark.repl.SparkMemberHandlers$class\nError determining visibility: org.apache.spark.AccumulatorParam$class\nError determining visibility: org.apache.spark.streaming.receivers.Receiver$class\nError determining visibility: org.apache.spark.util.random.RandomSampler$class\n```\n\nI don't really know what those are for but they aren't user-facing so I think we can exclude them.\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T20:29:02Z",
    "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+     try {\n+       /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+          is a module or class. */\n+\n+       val privateAsClass = mirror\n+         .staticClass(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       val privateAsModule = mirror\n+         .staticModule(className)\n+         .privateWithin\n+         .fullName\n+         .startsWith(packageName)\n+\n+       privateAsClass || privateAsModule\n+     } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+  /**\n+   * Get all classes in a package from a jar file.\n+   */\n+  private def getAllClasses(jarPath: String, packageName: String) = {\n+    val jar = new JarFile(new File(jarPath))\n+    val enums = jar.entries().map(_.getName).filter(_.startsWith(packageName))\n+    val classes = mutable.HashSet[Class[_]]()\n+    for (entry <- enums) {\n+      if (!entry.endsWith(\"/\") && !entry.endsWith(\"MANIFEST.MF\") && !entry.endsWith(\"properties\")) {\n+        classes += Class.forName(entry.trim.replaceAll(\".class\", \"\").replace('/', '.'))\n+      }\n+    }\n+    classes\n+  }\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    Try(mirror.staticClass(name)).isFailure ||\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "Would it be possible to make this \"$class\", since all your examples would match that? It at least makes it clear we're not trying to exclude .class files (which aren't excluded anyway because presumably this name doesn't happen to include the extension).\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-23T22:14:47Z",
    "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+import scala.util.Try\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+      try {\n+        /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+           is a module or class. */\n+\n+        val privateAsClass = mirror\n+          .staticClass(className)\n+          .privateWithin\n+          .fullName\n+          .startsWith(packageName)\n+\n+        val privateAsModule = mirror\n+          .staticModule(className)\n+          .privateWithin\n+          .fullName\n+          .startsWith(packageName)\n+\n+        privateAsClass || privateAsModule\n+      } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    name.contains(\"anon\") ||\n+    name.endsWith(\"class\") ||"
  }],
  "prId": 207
}, {
  "comments": [{
    "author": {
      "login": "aarondav"
    },
    "body": "I keep trying to come up with a valid class name that contains \"anon\". In the dictionary, there seems to be Canon, Lebanon, and, of course, anonymous. We're probably safe?\n",
    "commit": "22ae267b368669455666a3f9b18294662b4e3276",
    "createdAt": "2014-03-24T17:49:51Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.tools\n+\n+import java.io.File\n+import java.util.jar.JarFile\n+\n+import scala.collection.mutable\n+import scala.collection.JavaConversions._\n+import scala.reflect.runtime.universe.runtimeMirror\n+\n+/**\n+ * A tool for generating classes to be excluded during binary checking with MIMA. It is expected\n+ * that this tool is run with ./spark-class.\n+ *\n+ * MIMA itself only supports JVM-level visibility and doesn't account for package-private classes.\n+ * This tool looks at all currently package-private classes and generates exclusions for them. Note\n+ * that this approach is not sound. It can lead to false positives if we move or rename a previously\n+ * package-private class. It can lead to false negatives if someone explicitly makes a class\n+ * package-private that wasn't before. This exists only to help catch certain classes of changes\n+ * which might be difficult to catch during review.\n+ */\n+object GenerateMIMAIgnore {\n+  private val classLoader = Thread.currentThread().getContextClassLoader\n+  private val mirror = runtimeMirror(classLoader)\n+\n+  private def classesPrivateWithin(packageName: String): Set[String] = {\n+\n+    val classes = getClasses(packageName, classLoader)\n+    val privateClasses = mutable.HashSet[String]()\n+\n+    def isPackagePrivate(className: String) = {\n+      try {\n+        /* Couldn't figure out if it's possible to determine a-priori whether a given symbol\n+           is a module or class. */\n+\n+        val privateAsClass = mirror\n+          .staticClass(className)\n+          .privateWithin\n+          .fullName\n+          .startsWith(packageName)\n+\n+        val privateAsModule = mirror\n+          .staticModule(className)\n+          .privateWithin\n+          .fullName\n+          .startsWith(packageName)\n+\n+        privateAsClass || privateAsModule\n+      } catch {\n+        case _: Throwable => {\n+          println(\"Error determining visibility: \" + className)\n+          false\n+        }\n+      }\n+    }\n+\n+    for (className <- classes) {\n+      val directlyPrivateSpark = isPackagePrivate(className)\n+\n+      /* Inner classes defined within a private[spark] class or object are effectively\n+         invisible, so we account for them as package private. */\n+      val indirectlyPrivateSpark = {\n+        val maybeOuter = className.toString.takeWhile(_ != '$')\n+        if (maybeOuter != className) {\n+          isPackagePrivate(maybeOuter)\n+        } else {\n+          false\n+        }\n+      }\n+      if (directlyPrivateSpark || indirectlyPrivateSpark) privateClasses += className\n+    }\n+    privateClasses.flatMap(c => Seq(c, c.replace(\"$\", \"#\"))).toSet\n+  }\n+\n+  def main(args: Array[String]) {\n+    scala.tools.nsc.io.File(\".mima-excludes\").\n+      writeAll(classesPrivateWithin(\"org.apache.spark\").mkString(\"\\n\"))\n+    println(\"Created : .mima-excludes in current directory.\")\n+  }\n+\n+\n+  private def shouldExclude(name: String) = {\n+    // Heuristic to remove JVM classes that do not correspond to user-facing classes in Scala\n+    name.contains(\"anon\") ||",
    "line": 100
  }],
  "prId": 207
}]