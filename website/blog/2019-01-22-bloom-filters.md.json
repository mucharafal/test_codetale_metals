[
  {
    "id" : "929b281e-7c5c-4bca-9b2f-ca74def027d3",
    "prId" : 486,
    "comments" : [
      {
        "id" : "5d2d875f-280d-4e81-af82-514a1aba599f",
        "parentId" : null,
        "author" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "body" : "a[nd] compute",
        "createdAt" : "2019-01-24T22:21:34Z",
        "updatedAt" : "2019-01-25T14:13:42Z",
        "lastEditedBy" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fbf0efae8c41c1e194a372bfa75b7e602079e8e5",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,427 @@\n+---\n+author: Ólafur Páll Geirsson\n+title: Low-memory symbol indexing with bloom filters\n+authorURL: https://twitter.com/olafurpg\n+authorImageURL: https://avatars2.githubusercontent.com/u/1408093?s=460&v=4\n+---\n+\n+The latest Metals release introduces three new in-memory indexes to implement\n+the features \"find symbol references\" and \"fuzzy symbol search\". Indexes are\n+important to provide fast response times for user requests but they come at the\n+price of higher memory usage. To keep memory usage low, Metals uses a data\n+structure called bloom filters that implements space-efficient sets. Thanks to\n+bloom filters, the three new indexes added in the last release use only a few\n+megabytes of memory even for large projects with >500k lines of code.\n+\n+In this post, we look into how Metals uses bloom filters for fast indexing with\n+small memory footprint. We explain what bloom filters are and how we can encode\n+problems like fuzzy searching to take advantage of the nice properties of bloom\n+filters. Finally, we evaluate these new features on a real-world project: the\n+[Akka](https://github.com/akka/akka) build.\n+\n+<!-- truncate -->\n+\n+The work presented in this post was done as part of my job at the\n+[Scala Center](https://scala.epfl.ch/).\n+\n+<style>\n+blockquote {\n+  background-color: rgba(100, 205, 255, 0.3);\n+  border-left: 8px solid #64cdff;\n+}\n+</style>\n+\n+## Bloom filters\n+\n+[Bloom filters](https://en.wikipedia.org/wiki/Bloom_filter) are a probabilistic\n+data structure that implements space-efficient sets. The difference between a\n+bloom filter and a regular set such as `HashSet` is that bloom filters have the\n+following limitations:\n+\n+- the `contains(element)` method may return false positives, meaning it can\n+  occasionally return true even when the element is not a member of the set.\n+- when creating a bloom filter, you must provide an estimate for how many\n+  elements will be added to the set. A large estimate results in lower false\n+  positive rates for the `contains(element)` method at the cost of higher space\n+  usage. Conversely, a low estimate results in lower memory usage at the cost of\n+  higher false positives for the `contains(element)` method.\n+- you can't iterate through the elements of a bloom filter.\n+\n+In exchange for these limitations, bloom filters are able to compress a large\n+number of elements into a small number of bits. Due to their space-efficiency,\n+bloom filters are used in a many applications ranging from browsers, CDNs and\n+cryptocurrencies. In the next sections, we'll explore how bloom filters can also\n+be used in the context of a language server like Metals.\n+\n+## Find symbol references\n+\n+The \"find symbol references\" feature shows all usages of a given symbol. For\n+example, in the demo below we find 843 references to the method `Actor.sender()`\n+in the Akka build.\n+\n+![Find symbol references example](https://user-images.githubusercontent.com/1408093/51531254-3a368280-1e3d-11e9-8df2-4560c6294e35.gif)\n+\n+Find symbol references is helpful for users when exploring a codebase and it's\n+also an important component for Metals to implement other features down the road\n+such as \"rename symbol\".\n+\n+The challenge when implementing find references is that large projects have many\n+symbol references. Iterating through all symbol references for every source file\n+on every request is too slow. Most symbols only appear only in a few source\n+files so we need some way to reduce the search state.\n+\n+Metals uses bloom filters to reduce the number of files we search when looking\n+for a symbol reference. For every file on disk, we keep an in-memory bloom\n+filter which contains the set of all referenced symbols in that file. When\n+looking for references to a given symbol, we skip files when their accompanying\n+bloom filter is guaranteed not to contain a reference to that symbol. False\n+positive results from the bloom filter are not a problem because they only slow\n+down the response but don't compromise the correctness of the final result.\n+\n+Concretely, Metals keeps an in-memory map where keys are paths to source files\n+in the workspace.\n+\n+```scala\n+val references: Map[Path, BloomFilter[Symbol]]\n+```\n+\n+The values represent the set of\n+[SemanticDB symbols](https://scalameta.org/docs/semanticdb/specification.html)\n+referenced in that file. A nice property of keying the map by file paths is that\n+we can incrementally update the map as files change. When a file is re-compiled\n+producing a new SemanticDB file, we throw out the old bloom filter a compute a"
  },
  {
    "id" : "4dcc9774-5658-4812-9ec1-bf318c10ca6b",
    "prId" : 486,
    "comments" : [
      {
        "id" : "432fc696-54b1-4765-82b9-40c5fb7e1ac3",
        "parentId" : null,
        "author" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "body" : "in ~a~ many",
        "createdAt" : "2019-01-24T22:22:34Z",
        "updatedAt" : "2019-01-25T14:13:42Z",
        "lastEditedBy" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fbf0efae8c41c1e194a372bfa75b7e602079e8e5",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,427 @@\n+---\n+author: Ólafur Páll Geirsson\n+title: Low-memory symbol indexing with bloom filters\n+authorURL: https://twitter.com/olafurpg\n+authorImageURL: https://avatars2.githubusercontent.com/u/1408093?s=460&v=4\n+---\n+\n+The latest Metals release introduces three new in-memory indexes to implement\n+the features \"find symbol references\" and \"fuzzy symbol search\". Indexes are\n+important to provide fast response times for user requests but they come at the\n+price of higher memory usage. To keep memory usage low, Metals uses a data\n+structure called bloom filters that implements space-efficient sets. Thanks to\n+bloom filters, the three new indexes added in the last release use only a few\n+megabytes of memory even for large projects with >500k lines of code.\n+\n+In this post, we look into how Metals uses bloom filters for fast indexing with\n+small memory footprint. We explain what bloom filters are and how we can encode\n+problems like fuzzy searching to take advantage of the nice properties of bloom\n+filters. Finally, we evaluate these new features on a real-world project: the\n+[Akka](https://github.com/akka/akka) build.\n+\n+<!-- truncate -->\n+\n+The work presented in this post was done as part of my job at the\n+[Scala Center](https://scala.epfl.ch/).\n+\n+<style>\n+blockquote {\n+  background-color: rgba(100, 205, 255, 0.3);\n+  border-left: 8px solid #64cdff;\n+}\n+</style>\n+\n+## Bloom filters\n+\n+[Bloom filters](https://en.wikipedia.org/wiki/Bloom_filter) are a probabilistic\n+data structure that implements space-efficient sets. The difference between a\n+bloom filter and a regular set such as `HashSet` is that bloom filters have the\n+following limitations:\n+\n+- the `contains(element)` method may return false positives, meaning it can\n+  occasionally return true even when the element is not a member of the set.\n+- when creating a bloom filter, you must provide an estimate for how many\n+  elements will be added to the set. A large estimate results in lower false\n+  positive rates for the `contains(element)` method at the cost of higher space\n+  usage. Conversely, a low estimate results in lower memory usage at the cost of\n+  higher false positives for the `contains(element)` method.\n+- you can't iterate through the elements of a bloom filter.\n+\n+In exchange for these limitations, bloom filters are able to compress a large\n+number of elements into a small number of bits. Due to their space-efficiency,\n+bloom filters are used in a many applications ranging from browsers, CDNs and"
  },
  {
    "id" : "244abfe2-a1a5-4e19-9041-7576012aa3c9",
    "prId" : 486,
    "comments" : [
      {
        "id" : "3ec349be-4fc5-4dd1-bc5e-a8dbf7165884",
        "parentId" : null,
        "author" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "body" : "search ~state~ space?",
        "createdAt" : "2019-01-24T22:38:44Z",
        "updatedAt" : "2019-01-25T14:13:42Z",
        "lastEditedBy" : {
          "login" : "marcelocenerine",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1107367?u=79f0734ad984a1b4e0b35316a29ece136c814f62&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d7d8c04-f644-4969-a4e0-77c1e400fa6a",
        "parentId" : "3ec349be-4fc5-4dd1-bc5e-a8dbf7165884",
        "author" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "body" : "Good catch! I replaced \"search state\" with \"search space\" in several places 🙏 ",
        "createdAt" : "2019-01-25T10:29:04Z",
        "updatedAt" : "2019-01-25T14:13:42Z",
        "lastEditedBy" : {
          "login" : "olafurpg",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/1408093?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fbf0efae8c41c1e194a372bfa75b7e602079e8e5",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,427 @@\n+---\n+author: Ólafur Páll Geirsson\n+title: Low-memory symbol indexing with bloom filters\n+authorURL: https://twitter.com/olafurpg\n+authorImageURL: https://avatars2.githubusercontent.com/u/1408093?s=460&v=4\n+---\n+\n+The latest Metals release introduces three new in-memory indexes to implement\n+the features \"find symbol references\" and \"fuzzy symbol search\". Indexes are\n+important to provide fast response times for user requests but they come at the\n+price of higher memory usage. To keep memory usage low, Metals uses a data\n+structure called bloom filters that implements space-efficient sets. Thanks to\n+bloom filters, the three new indexes added in the last release use only a few\n+megabytes of memory even for large projects with >500k lines of code.\n+\n+In this post, we look into how Metals uses bloom filters for fast indexing with\n+small memory footprint. We explain what bloom filters are and how we can encode\n+problems like fuzzy searching to take advantage of the nice properties of bloom\n+filters. Finally, we evaluate these new features on a real-world project: the\n+[Akka](https://github.com/akka/akka) build.\n+\n+<!-- truncate -->\n+\n+The work presented in this post was done as part of my job at the\n+[Scala Center](https://scala.epfl.ch/).\n+\n+<style>\n+blockquote {\n+  background-color: rgba(100, 205, 255, 0.3);\n+  border-left: 8px solid #64cdff;\n+}\n+</style>\n+\n+## Bloom filters\n+\n+[Bloom filters](https://en.wikipedia.org/wiki/Bloom_filter) are a probabilistic\n+data structure that implements space-efficient sets. The difference between a\n+bloom filter and a regular set such as `HashSet` is that bloom filters have the\n+following limitations:\n+\n+- the `contains(element)` method may return false positives, meaning it can\n+  occasionally return true even when the element is not a member of the set.\n+- when creating a bloom filter, you must provide an estimate for how many\n+  elements will be added to the set. A large estimate results in lower false\n+  positive rates for the `contains(element)` method at the cost of higher space\n+  usage. Conversely, a low estimate results in lower memory usage at the cost of\n+  higher false positives for the `contains(element)` method.\n+- you can't iterate through the elements of a bloom filter.\n+\n+In exchange for these limitations, bloom filters are able to compress a large\n+number of elements into a small number of bits. Due to their space-efficiency,\n+bloom filters are used in a many applications ranging from browsers, CDNs and\n+cryptocurrencies. In the next sections, we'll explore how bloom filters can also\n+be used in the context of a language server like Metals.\n+\n+## Find symbol references\n+\n+The \"find symbol references\" feature shows all usages of a given symbol. For\n+example, in the demo below we find 843 references to the method `Actor.sender()`\n+in the Akka build.\n+\n+![Find symbol references example](https://user-images.githubusercontent.com/1408093/51531254-3a368280-1e3d-11e9-8df2-4560c6294e35.gif)\n+\n+Find symbol references is helpful for users when exploring a codebase and it's\n+also an important component for Metals to implement other features down the road\n+such as \"rename symbol\".\n+\n+The challenge when implementing find references is that large projects have many\n+symbol references. Iterating through all symbol references for every source file\n+on every request is too slow. Most symbols only appear only in a few source\n+files so we need some way to reduce the search state.\n+\n+Metals uses bloom filters to reduce the number of files we search when looking\n+for a symbol reference. For every file on disk, we keep an in-memory bloom\n+filter which contains the set of all referenced symbols in that file. When\n+looking for references to a given symbol, we skip files when their accompanying\n+bloom filter is guaranteed not to contain a reference to that symbol. False\n+positive results from the bloom filter are not a problem because they only slow\n+down the response but don't compromise the correctness of the final result.\n+\n+Concretely, Metals keeps an in-memory map where keys are paths to source files\n+in the workspace.\n+\n+```scala\n+val references: Map[Path, BloomFilter[Symbol]]\n+```\n+\n+The values represent the set of\n+[SemanticDB symbols](https://scalameta.org/docs/semanticdb/specification.html)\n+referenced in that file. A nice property of keying the map by file paths is that\n+we can incrementally update the map as files change. When a file is re-compiled\n+producing a new SemanticDB file, we throw out the old bloom filter a compute a\n+new one from scratch.\n+\n+To implement the search, we iterate through all entries of the map and only read\n+SemanticDB files from disk when their accompanying bloom filter is likely to\n+contain the query symbol.\n+\n+```scala\n+val query = // ...\n+for {\n+  (path, bloom) <- references\n+  if bloom.mightContain(query)\n+  symbolOccurrence <- readSemanticdbOccurrences(path) // read from disk\n+  if isSameSymbol(query, symbolOccurrence)\n+} yield symbolOccurrence\n+```\n+\n+In the actual Metals implementation, we additionally take care of adjusting\n+positions of the results in case the source file contents have changed since the\n+SemanticDB file was created.\n+\n+## Fuzzy symbol search\n+\n+The \"fuzzy symbol search\" feature allows you to navigate to a symbol definition\n+in the workspace sources or library dependencies by typing the symbol's name.\n+\n+![Fuzzy symbol search example](https://user-images.githubusercontent.com/1408093/51537603-44fa1300-1e4f-11e9-84f2-eb7d4c6fc7ef.gif)\n+\n+The search is fuzzy, meaning the query doesn't have to be an exact match or a\n+substring match with the target symbol. For example, we want the query `ReaSer`\n+to match the symbol `ReactDOMServer`. Additionally, all-lowercase queries are\n+treated as case-insensitive so that searching for `nelis` matches the symbol\n+`NonEmptyList`.\n+\n+Like with find symbol references, the challenge when implementing fuzzy symbol\n+search is that we have little time to respond and a lot of symbols to search.\n+Testing the search query against every source file the workspace and every entry\n+in the library classpath is too slow.\n+\n+Metals uses bloom filters to reduce the search state so that we only look at\n+places that are likely to contain matches for the query. We have two different\n+indexes, one for workspace sources and another one for the library classpath.\n+\n+### Workspace sources\n+\n+The first index is a map keyed by source files in the workspace.\n+\n+```scala\n+val inWorkspace: Map[Path, BloomFilter[String]]\n+```\n+\n+The values of the map is the set of all possible sub-queries that match symbols\n+defined in that source file. For example, consider the code below.\n+\n+```scala\n+package data\n+class NonEmptyListSpec { ... }\n+object Props { ... }\n+```\n+\n+For this source file, we insert the following sub-queries into the index.\n+\n+```txt\n+d\n+da\n+dat\n+data\n+N\n+No\n+Non\n+L\n+Li\n+Lis\n+List\n+S\n+Sp\n+Spe\n+Spec\n+NEL\n+NES\n+ELS\n+P\n+Pr\n+Pro\n+Prop\n+Props\n+```\n+\n+When searching for a query like `NoLi`, we split the query into the words `No`\n+and `Li` and visit only files whose bloom filter contains all of those exact\n+sub-queries. We include trigrams of the uppercase characters to further reduce\n+the search state for queries like `NELS` that have few lowercase character.\n+\n+For all-lowercase queries, we return the union of results from multiple\n+capitalization combinations in order to support case-insensitive searches. For\n+example, the query `neli` returns all results matching any of the following\n+queries.\n+\n+```txt\n+neli\n+Neli\n+NEli\n+NeLi\n+NelI\n+NELi\n+NElI\n+NeLI\n+NELI\n+```\n+\n+To implement the search, we iterate through all entries of the in-memory map and\n+only visit the source files on disk whose bloom filter might contain a match for\n+the query.\n+\n+```scala\n+val query = ...\n+for {\n+  (file, bloom) <- inWorkspace\n+  if bloom.mightContain(query)\n+  symbol <- parseSymbols(file) // reads from disk\n+  if isFuzzyMatch(query, symbol)\n+} yield symbol\n+```\n+\n+Like with find symbol references, false positive results from the bloom filter\n+slow down the response but don't compromise the correctness of the result. Also,\n+we incrementally update the map as files in the workspace change by removing old\n+entries and compute a new bloom filter for the updated source file.\n+\n+### Library classpath\n+\n+The library classpath index is similar to the workspace sources index except the\n+keys of the map are package symbols (example `scala/collection/`) instead of\n+file paths.\n+\n+```scala\n+val inClasspath: Map[Symbol, (BloomFilter[String], Seq[Symbol])]\n+```\n+\n+Unlike the workspace sources index, the library classpath index does not need to\n+be incrementally updated when files re-compile. The bloom filters in the values\n+of the map use the same sub-query technique as the bloom filters in the\n+workspace sources index. For each bloom filter, we additionally store a listing\n+of all members of that package. If a query matches a given bloom filter, we test\n+the fuzzy search against all members of the package.\n+\n+```scala\n+val query = ...\n+for {\n+  (pkg, (bloom, packageMembers)) <- inClasspath\n+  if bloom.mightContain(query)\n+  member <- packageMembers\n+  if isFuzzyMatch(query, symbol(pkg, member))\n+  definitionOnDisk <- findDefinition(member) // writes to disk\n+} yield definitionOnDisk\n+```\n+\n+Due to how the Language Server Protocol works, the `findDefinition` method\n+writes sources of library dependencies to disk so the editor can find the symbol\n+definition location. To reduce the number of files written to disk, Metals\n+limits the number of non-exact search results from the library classpath index.\n+\n+In the actual Metals implementation, the listing of package members is GZIP\n+compressed to reduce memory usage and the members are decompressed on-demand\n+when a bloom filter matches the query.\n+\n+## Evaluation\n+\n+We test Metals on the [Akka codebase](https://github.com/akka/akka) to evaluate\n+the performance of our bloom filter indexes. Akka is a library to build highly\n+concurrent, distributed, and resilient message-driven applications on the JVM.\n+\n+![Akka repository](https://user-images.githubusercontent.com/1408093/51541018-159bd400-1e58-11e9-9181-cf2e32a0a40b.png)\n+\n+The Akka codebase has 300-600k lines of code depending on whether you include\n+comments and/or Java sources. Metals indexes both Java and Scala sources for\n+fuzzy symbol search but only Scala sources for find symbol references.\n+\n+```\n+$ git clone https://github.com/akka/akka.git\n+$ cd akka\n+$ loc\n+Language  Files    Lines   Blank  Comment     Code\n+Scala     1,951  358,149  57,528   76,605  224,016\n+Java        486  250,609  19,838   51,291  179,480\n+```\n+\n+We open the base directory with Visual Studio Code and update the \"Metals Server\n+Properties\" setting to `-Dmetals.statistics=all` to enable additional\n+logging output. We import the build, open the file `Actor.scala` and wait until\n+compilation has finished. It is normal if this step takes several minutes to\n+complete.\n+\n+### Response times\n+\n+First, we measure the response times for find symbol references.\n+\n+```\n+time: found 8 references to symbol 'akka/actor/ActorCell.contextStack.' in 8ms\n+time: found 11 references to symbol 'akka/actor/Actor#postRestart().' in 17ms\n+time: found 146 references to symbol 'akka/actor/PoisonPill.' in 0.16s\n+time: found 163 references to symbol 'scala/collection/IterableLike#head().' in 0.23s\n+time: found 1027 references to symbol 'akka/actor/Actor#' in 0.5s\n+time: found 816 references to symbol 'scala/package.Throwable#' in 0.63s\n+time: found 6103 references to symbol 'scala/Predef.String#' in 1.54s\n+```\n+\n+Response times range from 8ms up to 1.6s depending on the number of results. The\n+6103 references to `String` origin from 913 source files, which is almost half\n+of all Scala source files in the repository. These numbers do not take into\n+account the delay in the editor to display the results in the UI. For large\n+results like `String`, this delay can be several seconds depending on the\n+editor.\n+\n+Next, we measure the response times for fuzzy symbol search.\n+\n+```\n+time: found 0 results for query 'ConfigSEr' in 13ms\n+time: found 10 results for query 'ConfigSer' in 0.1s\n+time: found 105 results for query 'ActorRef' in 0.21s\n+time: found 105 results for query 'actorref' in 0.31s\n+time: found 1002 results for query 'actor' in 0.54s\n+time: found 3974 results for query 'S' in 1.98s\n+```\n+\n+Response times range from 13ms up to 2s depending on the query and number of\n+results. Queries with typos like `ConfigSEr` have 0 results and respond\n+instantly, while generic queries like `S` have ~4k results and take 2 seconds to\n+respond. Observe that all-lowercase queries like `actorref` are slower than\n+capitalized queries like `ActorRef`, which is expected because we test multiple\n+capitalization combinations for case-insensitive searches.\n+\n+### Memory usage\n+\n+Next, we look at the memory usage of the bloom filter indexes. The numbers are\n+computed with [JOL](https://openjdk.java.net/projects/code-tools/jol/)\n+`GraphLayout` and the element counts are approximate number of insertions into\n+the bloom filters.\n+\n+```\n+memory: references index using 3.72M (274,747 elements)\n+memory: workspace symbol index using 1.89M (173,419 elements)\n+memory: classpath symbol index using 1.72M (382,243 elements)\n+```\n+\n+The three bloom filter indexes use 8Mb combined for the entire Akka build. The\n+8Mb include the maps with file/symbol keys and also a GZIP compressed listing of\n+package members for the classpath symbol index. For comparison, the\n+[goto definition index](https://scalameta.org/metals/blog/2018/12/12/fast-goto-definition.html)\n+that does not use bloom filters requires 16Mb alone.\n+\n+```\n+memory: definition index using 15.9M (337,532 lines Scala)\n+```\n+\n+### Indexing time\n+\n+Next, we look at the time it takes to construct the indexes after build import.\n+\n+```\n+time: imported build in 2.41s\n+time: updated build targets in 0.12s\n+time: started file watcher in 4.36s\n+time: indexed library classpath in 0.8s\n+time: indexed workspace SemanticDBs in 2.18s\n+time: indexed workspace sources in 3.35s\n+time: indexed library sources in 1.59s\n+```\n+\n+The Akka build contains many source files but few library dependencies. The\n+bottle-neck appears to be starting the file watcher and parsing all `*.scala`\n+and `*.java` sources in the workspace. The following flamegraph shows a detailed\n+breakdown of what goes on during indexing.\n+\n+<a href=\"https://geirsson.com/assets/metals-akka-initialize.svg\" target=\"_blank\">\n+  <img src=\"https://i.imgur.com/Xhr1wXp.jpg\" alt=\"Akka indexing flamegraph\">\n+</a>\n+\n+> Click on image to interactively explore the flamegraph.\n+\n+Some observations:\n+\n+- it's slower to start the file watcher than compute all three indexes for find\n+  symbol references and fuzzy symbol search, combined.\n+- the method `BloomFilter.put()` accounts for 2.26% of the total runtime.\n+\n+For comparison, below is another flamegraph for the same indexing pipeline but\n+in a different project, [Prisma](https://github.com/prisma/prisma). The total\n+indexing time is around 8 seconds on a cold server for both Akka and Prisma but\n+the distribution is different for how long each indexing task takes. Prisma has\n+fewer sources (80k lines of Scala code, no Java) and a larger number of library\n+dependencies compared to Akka.\n+\n+<a href=\"https://geirsson.com/assets/metals-prisma-initialize.svg\" target=\"_blank\">\n+  <img src=\"https://i.imgur.com/JR3SNx6.jpg\" alt=\"Prisma indexing flamegraph\">\n+</a>\n+\n+> Click on image to interactively explore the flamegraph.\n+\n+Computing the bloom filter indexes for find symbol references and fuzzy symbol\n+search takes proportionally even less time in Prisma compared to Akka. The\n+Prisma project is a good representation for projects with less than 100k lines\n+of code and a large number of library dependencies.\n+\n+## Conclusion\n+\n+Metals uses three bloom filter indexes to implement the features \"find symbol\n+references\" and \"fuzzy symbol search\". On a case study project containing 600k\n+lines of code, all three indexes use 8Mb of memory combined and enable\n+sub-second response times for most user requests. Response times for fuzzy\n+symbol search is occasionally slower for short queries like `S` but this\n+limitation is not inherent with the bloom filter indexing approach and may be\n+addressed in future releases.\n+\n+Computing the bloom filter indexes takes 4s in our case-study project, out of\n+total 16s for the combined \"import build\" and \"indexing\" steps. These steps run\n+whenever Metals starts in an existing project or after the build changes. Can\n+indexing be made faster? Probably yes, but the user experience will still remain\n+bottle-necked by sbt build export and compilation of workspace sources, which\n+frequently take many minutes to complete on large projects.\n+\n+The indexes are in-memory maps where the keys are file paths and values are\n+bloom filters. When files change, we can incrementally update the indexes by\n+computing a new bloom filter for the updated source file.\n+\n+The bloom filter indexes are only used to narrow down the search state by"
  }
]