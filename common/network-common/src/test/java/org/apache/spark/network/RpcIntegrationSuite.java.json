[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Wrong place.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:22:04Z",
    "diffHunk": "@@ -17,17 +17,21 @@\n \n package org.apache.spark.network;\n \n+import java.io.*;\n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n \n import com.google.common.collect.Sets;\n+import com.google.common.io.Files;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.spark.network.buffer.ManagedBuffer;"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `(`",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:23:23Z",
    "diffHunk": "@@ -85,10 +96,52 @@ public void receive(TransportClient client, ByteBuffer message) {\n     oneWayMsgs = new ArrayList<>();\n   }\n \n+  private static void receiveStream(String msg, StreamData streamData) {\n+    try {\n+      if (msg.startsWith(\"fail/\")) {\n+        String[] parts = msg.split(\"/\");\n+        switch(parts[1]) {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `:`",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:25:09Z",
    "diffHunk": "@@ -130,6 +183,59 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream: streams) {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "add empty line",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:28:24Z",
    "diffHunk": "@@ -130,6 +183,59 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream: streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {\n+      try {\n+        streamCallback.waitForCompletionAndVerify(TimeUnit.SECONDS.toMillis(5));\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+\n+\n+    if (!sem.tryAcquire(streams.length, 5, TimeUnit.SECONDS)) {\n+      fail(\"Timeout getting response from the server\");\n+    }\n+    client.close();\n+    return res;\n+  }\n+\n+  private static class RpcStreamCallback implements RpcResponseCallback {\n+    final String streamId;\n+    final RpcResult res;\n+    final Semaphore sem;\n+    RpcStreamCallback(String streamId, RpcResult res, Semaphore sem) {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "space before `:`",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:29:08Z",
    "diffHunk": "@@ -193,10 +299,78 @@ public void sendOneWayMessage() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void sendRpcWithStreamOneAtATime() throws Exception {\n+    for (String stream: StreamTestHelper.STREAMS) {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I'm trying to follow the logic here...\r\n\r\n- in L215, client sends a stream to the remote\r\n- in L82, remote receives the stream and registers the callback\r\n- here, you wait for the callbacks to finish in the order they were registered.\r\n\r\nIsn't there a race between steps 2 and 3, as in you might miss one or more callback registration?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-14T22:30:30Z",
    "diffHunk": "@@ -130,6 +200,60 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream : streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "oh great point, thanks for catching that.  I will move this after the semaphore check, that will ensure that everything has been added to `streamCallbacks`",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-15T16:24:09Z",
    "diffHunk": "@@ -130,6 +200,60 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream : streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: add empty line",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-14T22:34:23Z",
    "diffHunk": "@@ -207,9 +400,67 @@ private void assertErrorsContain(Set<String> errors, Set<String> contains) {\n           break;\n         }\n       }\n-      assertTrue(\"Could not find error containing \" + contain + \"; errors: \" + errors, foundMatch);\n+      if (!foundMatch) {\n+        notFound.add(contain);\n+      }\n+    }\n+    return new ImmutablePair<>(remainingErrors, notFound);\n+  }\n+\n+  private static class VerifyingStreamCallback implements StreamCallbackWithID {\n+    final String streamId;\n+    final StreamSuite.TestCallback helper;\n+    final OutputStream out;\n+    final File outFile;\n+    VerifyingStreamCallback(String streamId) throws IOException {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "ping",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-26T17:30:19Z",
    "diffHunk": "@@ -207,9 +400,67 @@ private void assertErrorsContain(Set<String> errors, Set<String> contains) {\n           break;\n         }\n       }\n-      assertTrue(\"Could not find error containing \" + contain + \"; errors: \" + errors, foundMatch);\n+      if (!foundMatch) {\n+        notFound.add(contain);\n+      }\n+    }\n+    return new ImmutablePair<>(remainingErrors, notFound);\n+  }\n+\n+  private static class VerifyingStreamCallback implements StreamCallbackWithID {\n+    final String streamId;\n+    final StreamSuite.TestCallback helper;\n+    final OutputStream out;\n+    final File outFile;\n+    VerifyingStreamCallback(String streamId) throws IOException {"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "whoops, sorry I missed this one.  fixed now",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-26T17:38:38Z",
    "diffHunk": "@@ -207,9 +400,67 @@ private void assertErrorsContain(Set<String> errors, Set<String> contains) {\n           break;\n         }\n       }\n-      assertTrue(\"Could not find error containing \" + contain + \"; errors: \" + errors, foundMatch);\n+      if (!foundMatch) {\n+        notFound.add(contain);\n+      }\n+    }\n+    return new ImmutablePair<>(remainingErrors, notFound);\n+  }\n+\n+  private static class VerifyingStreamCallback implements StreamCallbackWithID {\n+    final String streamId;\n+    final StreamSuite.TestCallback helper;\n+    final OutputStream out;\n+    final File outFile;\n+    VerifyingStreamCallback(String streamId) throws IOException {"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: remove",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-14T22:35:09Z",
    "diffHunk": "@@ -207,9 +400,67 @@ private void assertErrorsContain(Set<String> errors, Set<String> contains) {\n           break;\n         }\n       }\n-      assertTrue(\"Could not find error containing \" + contain + \"; errors: \" + errors, foundMatch);\n+      if (!foundMatch) {\n+        notFound.add(contain);\n+      }\n+    }\n+    return new ImmutablePair<>(remainingErrors, notFound);\n+  }\n+\n+  private static class VerifyingStreamCallback implements StreamCallbackWithID {\n+    final String streamId;\n+    final StreamSuite.TestCallback helper;\n+    final OutputStream out;\n+    final File outFile;\n+    VerifyingStreamCallback(String streamId) throws IOException {\n+      if (streamId.equals(\"file\")) {\n+        outFile = File.createTempFile(\"data\", \".tmp\", testData.tempDir);\n+        out = new FileOutputStream(outFile);\n+      } else {\n+        out = new ByteArrayOutputStream();\n+        outFile = null;\n+      }\n+      this.streamId = streamId;\n+      helper = new StreamSuite.TestCallback(out);\n+    }\n+\n+    void waitForCompletionAndVerify(long timeoutMs) throws IOException {\n+      helper.waitForCompletion(timeoutMs);\n+      if (streamId.equals(\"file\")) {\n+        assertTrue(\"File stream did not match.\", Files.equal(testData.testFile, outFile));\n+      } else {\n+        byte[] result = ((ByteArrayOutputStream)out).toByteArray();\n+        ByteBuffer srcBuffer = testData.srcBuffer(streamId);\n+        ByteBuffer base;\n+        synchronized (srcBuffer) {\n+          base = srcBuffer.duplicate();\n+        }\n+        byte[] expected = new byte[base.remaining()];\n+        base.get(expected);\n+        assertEquals(expected.length, result.length);\n+        assertTrue(\"buffers don't match\", Arrays.equals(expected, result));\n+"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Isn't the wait part now redundant, after you waited for the semaphore?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-15T17:55:01Z",
    "diffHunk": "@@ -130,6 +200,59 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream : streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+\n+    if (!sem.tryAcquire(streams.length, 5, TimeUnit.SECONDS)) {\n+      fail(\"Timeout getting response from the server\");\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {\n+      try {\n+        streamCallback.waitForCompletionAndVerify(TimeUnit.SECONDS.toMillis(5));"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Method throws `Exception`, so this seems unnecessary.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-15T17:55:46Z",
    "diffHunk": "@@ -130,6 +200,59 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream : streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+\n+    if (!sem.tryAcquire(streams.length, 5, TimeUnit.SECONDS)) {\n+      fail(\"Timeout getting response from the server\");\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {\n+      try {\n+        streamCallback.waitForCompletionAndVerify(TimeUnit.SECONDS.toMillis(5));\n+      } catch (IOException e) {"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "`forEach` doesn't like the IOException",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-19T20:00:48Z",
    "diffHunk": "@@ -130,6 +200,59 @@ public void onFailure(Throwable e) {\n     return res;\n   }\n \n+  private RpcResult sendRpcWithStream(String... streams) throws Exception {\n+    TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort());\n+    final Semaphore sem = new Semaphore(0);\n+    RpcResult res = new RpcResult();\n+    res.successMessages = Collections.synchronizedSet(new HashSet<String>());\n+    res.errorMessages = Collections.synchronizedSet(new HashSet<String>());\n+\n+    for (String stream : streams) {\n+      int idx = stream.lastIndexOf('/');\n+      ManagedBuffer meta = new NioManagedBuffer(JavaUtils.stringToBytes(stream));\n+      String streamName = (idx == -1) ? stream : stream.substring(idx + 1);\n+      ManagedBuffer data = testData.openStream(conf, streamName);\n+      client.uploadStream(meta, data, new RpcStreamCallback(stream, res, sem));\n+    }\n+\n+    if (!sem.tryAcquire(streams.length, 5, TimeUnit.SECONDS)) {\n+      fail(\"Timeout getting response from the server\");\n+    }\n+    streamCallbacks.values().forEach(streamCallback -> {\n+      try {\n+        streamCallback.waitForCompletionAndVerify(TimeUnit.SECONDS.toMillis(5));\n+      } catch (IOException e) {"
  }],
  "prId": 21346
}]