[{
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: `volatile`",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-21T01:24:30Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.crypto;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.netty.channel.Channel;\n+import org.junit.After;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.apache.spark.network.TestUtils;\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.RpcResponseCallback;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientBootstrap;\n+import org.apache.spark.network.sasl.SaslServerBootstrap;\n+import org.apache.spark.network.sasl.SecretKeyHolder;\n+import org.apache.spark.network.server.RpcHandler;\n+import org.apache.spark.network.server.StreamManager;\n+import org.apache.spark.network.server.TransportServer;\n+import org.apache.spark.network.server.TransportServerBootstrap;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class AuthIntegrationSuite {\n+\n+  private AuthTestCtx ctx;\n+\n+  @After\n+  public void cleanUp() throws Exception {\n+    if (ctx != null) {\n+      ctx.close();\n+    }\n+    ctx = null;\n+  }\n+\n+  @Test\n+  public void testNewAuth() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\");\n+    ctx.createClient(\"secret\");\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+    assertTrue(ctx.authRpcHandler.doDelegate);\n+  }\n+\n+  @Test\n+  public void testAuthFailure() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"server\");\n+\n+    try {\n+      ctx.createClient(\"client\");\n+      fail(\"Should have failed to create client.\");\n+    } catch (Exception e) {\n+      assertFalse(ctx.authRpcHandler.doDelegate);\n+      assertFalse(ctx.serverChannel.isActive());\n+    }\n+  }\n+\n+  @Test\n+  public void testSaslServerFallback() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\", true);\n+    ctx.createClient(\"secret\", false);\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+  }\n+\n+  @Test\n+  public void testSaslClientFallback() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\", false);\n+    ctx.createClient(\"secret\", true);\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+  }\n+\n+  @Test\n+  public void testAuthReplay() throws Exception {\n+    // This test covers the case where an attacker replays a challenge message sniffed from the\n+    // network, but doesn't know the actual secret. The server should close the connection as\n+    // soon as a message is sent after authentication is performed. This is emulated by removing\n+    // the client encryption handler after authentication.\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\");\n+    ctx.createClient(\"secret\");\n+\n+    assertNotNull(ctx.client.getChannel().pipeline()\n+      .remove(TransportCipher.ENCRYPTION_HANDLER_NAME));\n+\n+    try {\n+      ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+      fail(\"Should have failed unencrypted RPC.\");\n+    } catch (Exception e) {\n+      assertTrue(ctx.authRpcHandler.doDelegate);\n+    }\n+  }\n+\n+  private class AuthTestCtx {\n+\n+    private final String appId = \"testAppId\";\n+    private final TransportConf conf;\n+    private final TransportContext ctx;\n+\n+    TransportClient client;\n+    TransportServer server;\n+    Channel serverChannel;"
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: `volatile`",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-21T01:24:37Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.crypto;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.netty.channel.Channel;\n+import org.junit.After;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.apache.spark.network.TestUtils;\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.RpcResponseCallback;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientBootstrap;\n+import org.apache.spark.network.sasl.SaslServerBootstrap;\n+import org.apache.spark.network.sasl.SecretKeyHolder;\n+import org.apache.spark.network.server.RpcHandler;\n+import org.apache.spark.network.server.StreamManager;\n+import org.apache.spark.network.server.TransportServer;\n+import org.apache.spark.network.server.TransportServerBootstrap;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class AuthIntegrationSuite {\n+\n+  private AuthTestCtx ctx;\n+\n+  @After\n+  public void cleanUp() throws Exception {\n+    if (ctx != null) {\n+      ctx.close();\n+    }\n+    ctx = null;\n+  }\n+\n+  @Test\n+  public void testNewAuth() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\");\n+    ctx.createClient(\"secret\");\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+    assertTrue(ctx.authRpcHandler.doDelegate);\n+  }\n+\n+  @Test\n+  public void testAuthFailure() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"server\");\n+\n+    try {\n+      ctx.createClient(\"client\");\n+      fail(\"Should have failed to create client.\");\n+    } catch (Exception e) {\n+      assertFalse(ctx.authRpcHandler.doDelegate);\n+      assertFalse(ctx.serverChannel.isActive());\n+    }\n+  }\n+\n+  @Test\n+  public void testSaslServerFallback() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\", true);\n+    ctx.createClient(\"secret\", false);\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+  }\n+\n+  @Test\n+  public void testSaslClientFallback() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\", false);\n+    ctx.createClient(\"secret\", true);\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+  }\n+\n+  @Test\n+  public void testAuthReplay() throws Exception {\n+    // This test covers the case where an attacker replays a challenge message sniffed from the\n+    // network, but doesn't know the actual secret. The server should close the connection as\n+    // soon as a message is sent after authentication is performed. This is emulated by removing\n+    // the client encryption handler after authentication.\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\");\n+    ctx.createClient(\"secret\");\n+\n+    assertNotNull(ctx.client.getChannel().pipeline()\n+      .remove(TransportCipher.ENCRYPTION_HANDLER_NAME));\n+\n+    try {\n+      ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+      fail(\"Should have failed unencrypted RPC.\");\n+    } catch (Exception e) {\n+      assertTrue(ctx.authRpcHandler.doDelegate);\n+    }\n+  }\n+\n+  private class AuthTestCtx {\n+\n+    private final String appId = \"testAppId\";\n+    private final TransportConf conf;\n+    private final TransportContext ctx;\n+\n+    TransportClient client;\n+    TransportServer server;\n+    Channel serverChannel;\n+    AuthRpcHandler authRpcHandler;"
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: please also check `delegate` type to ensure it doesn't use `sasl`",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-21T01:27:31Z",
    "diffHunk": "@@ -0,0 +1,211 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.crypto;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.netty.channel.Channel;\n+import org.junit.After;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.apache.spark.network.TestUtils;\n+import org.apache.spark.network.TransportContext;\n+import org.apache.spark.network.client.RpcResponseCallback;\n+import org.apache.spark.network.client.TransportClient;\n+import org.apache.spark.network.client.TransportClientBootstrap;\n+import org.apache.spark.network.sasl.SaslServerBootstrap;\n+import org.apache.spark.network.sasl.SecretKeyHolder;\n+import org.apache.spark.network.server.RpcHandler;\n+import org.apache.spark.network.server.StreamManager;\n+import org.apache.spark.network.server.TransportServer;\n+import org.apache.spark.network.server.TransportServerBootstrap;\n+import org.apache.spark.network.util.JavaUtils;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+\n+public class AuthIntegrationSuite {\n+\n+  private AuthTestCtx ctx;\n+\n+  @After\n+  public void cleanUp() throws Exception {\n+    if (ctx != null) {\n+      ctx.close();\n+    }\n+    ctx = null;\n+  }\n+\n+  @Test\n+  public void testNewAuth() throws Exception {\n+    ctx = new AuthTestCtx();\n+    ctx.createServer(\"secret\");\n+    ctx.createClient(\"secret\");\n+\n+    ByteBuffer reply = ctx.client.sendRpcSync(JavaUtils.stringToBytes(\"Ping\"), 5000);\n+    assertEquals(\"Pong\", JavaUtils.bytesToString(reply));\n+    assertTrue(ctx.authRpcHandler.doDelegate);",
    "line": 68
  }],
  "prId": 16521
}]