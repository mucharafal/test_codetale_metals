[{
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "@normanmaurer . `dev/lint-java` complains at this line and line 76.\r\n```\r\n[ERROR] src/test/java/org/apache/spark/network/crypto/TransportCipherTest.java:[70] (regexp) RegexpSinglelineJava: Avoid throwing error in application code.\r\n[ERROR] src/test/java/org/apache/spark/network/crypto/TransportCipherTest.java:[76] (regexp) RegexpSinglelineJava: Avoid throwing error in application code.\r\n```",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:12:29Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "normanmaurer"
    },
    "body": "I know but I want to throw this as the test actually test exactly for this scenario ;)",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:13:55Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Can we use `*Exception` instead in this test code?",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:14:39Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "The commons-crypto library throws `InternalError` so to test that behavior you have to use that error.",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:15:45Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Found somewhere that you can use `// CHECKSTYLE:OFF` and `// CHECKSTYLE:ON` comments to disable checkstyle for some code.",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:39:57Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Got it. +1 for @vanzin 's advice.",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:41:32Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }, {
    "author": {
      "login": "normanmaurer"
    },
    "body": "Just pushed this change... lets see if it works :)",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:43:50Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            throw new InternalError();"
  }],
  "prId": 26609
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: these comments are redundant. If you want to comment that this mimics the `commons-crypto` library then it would be better, otherwise just remove them.",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:47:20Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError"
  }],
  "prId": 26609
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: indented too far (use 4 spaces here)",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:51:56Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {"
  }],
  "prId": 26609
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Can't you mock `CryptoInputStream` directly?\r\n\r\n`when(mockInputStream.read(any()).thenThrow(new InternalError())`?",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T18:54:42Z",
    "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);"
  }],
  "prId": 26609
}, {
  "comments": [{
    "author": {
      "login": "dongjoon-hyun"
    },
    "body": "Oops. Sorry, we changed the accepted style. Please change like the following. I double-checked the following is working.\r\n```java\r\n            // checkstyle.off: RegexpSinglelineJava\r\n             throw new InternalError();\r\n            // checkstyle.on: RegexpSinglelineJava\r\n```",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T19:18:34Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            // CHECKSTYLE:OFF\n+            throw new InternalError();\n+            // CHECKSTYLE:ON"
  }, {
    "author": {
      "login": "normanmaurer"
    },
    "body": "I think I not need this anymore as I just use mocking now. Thanks anyway :)",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T19:19:24Z",
    "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+            new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);\n+        when(cipher.getBlockSize()).thenReturn(8);\n+        when(cipher.getAlgorithm()).thenReturn(algorithm);\n+\n+        return new CryptoInputStream(new ChannelInput(ch), cipher, 1024,\n+                null, new IvParameterSpec(new byte[0])) {\n+          @Override\n+          public int read(ByteBuffer dst) {\n+            // Simulate throwing InternalError\n+            // CHECKSTYLE:OFF\n+            throw new InternalError();\n+            // CHECKSTYLE:ON"
  }],
  "prId": 26609
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This variable is not needed anymore.",
    "commit": "fb79d0ac15c6f572ec3d26fde4e73727cff95a9d",
    "createdAt": "2019-11-21T19:35:51Z",
    "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.spark.network.crypto;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.apache.commons.crypto.stream.input.ChannelInput;\n+import org.apache.spark.network.util.MapConfigProvider;\n+import org.apache.spark.network.util.TransportConf;\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Test;\n+\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TransportCipherTest {\n+\n+  @Test\n+  public void testBufferNotLeaksOnInternalError() throws IOException {\n+    String algorithm = \"TestAlgorithm\";\n+    TransportConf conf = new TransportConf(\"Test\", MapConfigProvider.EMPTY);\n+    TransportCipher cipher = new TransportCipher(conf.cryptoConf(), conf.cipherTransformation(),\n+      new SecretKeySpec(new byte[256], algorithm), new byte[0], new byte[0]) {\n+\n+      @Override\n+      CryptoOutputStream createOutputStream(WritableByteChannel ch) {\n+        return null;\n+      }\n+\n+      @Override\n+      CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+        CryptoCipher cipher = mock(CryptoCipher.class);"
  }],
  "prId": 26609
}]