[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Could you change the code so that these maps are not necessary?\n\nYou have a single `AesCipher` instance for each channel. So having a map here is already weird since this class won't ever have to deal with more than a single channel. You seem to be using it as a cache so you don't have to figure out how to propagate the input streams to the channel handlers; instead, just have the channel handlers hold a reference to the stream somehow.\n\n(BTW I already asked for this in my previous review. In fact, you don't need this map at all currently for the output stream since you already did some of that work.)\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:09:44Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "It's generally bad practice to modify input parameters. Are you sure this is ok?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:11:23Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "As with the previous comment, it's weird to modify input parameters. Instead, you should be returning a new message with the response data.\n\nIn fact, it feels like this method actually belongs in `SaslRpcHandler`, where it's called. There's nothing in this method that is related to the `AesCipher` class. It also needs a better name (e.g. `createResponseMessage`).\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:15:22Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why are these empty properties being created? Why isn't the transport config being used?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:15:52Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Fields initialized in the constructor should generally be `final`.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:16:53Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`try...finally`\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:17:07Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;\n+    private CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      cos.close();"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Both of them will throw exception, if use \"try...finally\", exception will be throw in finally block.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-25T07:48:01Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;\n+    private CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      cos.close();"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "That's the point. You want to execute the other close callbacks even if `cos.close()` throws.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-25T16:46:53Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;\n+    private CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      cos.close();"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Loggers should be static. Also, why not just use the logger from the parent class?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:17:52Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;\n+    private CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      cos.close();\n+      super.close(ctx, promise);\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Same comment.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:18:09Z",
    "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  private HashMap<ReadableByteChannel, CryptoInputStream> inputStreamMap;\n+  private HashMap<WritableByteChannel, CryptoOutputStream> outputStreamMap;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    properties.setProperty(CryptoInputStream.STREAM_BUFFER_SIZE_KEY,\n+      String.valueOf(STREAM_BUFFER_SIZE));\n+    this.properties = properties;\n+\n+    inputStreamMap = new HashMap<>();\n+    outputStreamMap= new HashMap<>();\n+\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    if (!outputStreamMap.containsKey(ch)) {\n+      outputStreamMap.put(ch, new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec));\n+    }\n+\n+    return outputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    if (!inputStreamMap.containsKey(ch)) {\n+      inputStreamMap.put(ch, new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec));\n+    }\n+\n+    return inputStreamMap.get(ch);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Generate a request config message which send to remote peer.\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage requestConfigMessage(TransportConf conf) {\n+    int keySize = conf.saslEncryptionAesCipherKeySizeBits();\n+    if (keySize % 8 != 0) {\n+      throw new IllegalArgumentException(\"The AES cipher key size in bits should be a multiple \" +\n+        \"of byte\");\n+    }\n+    return new AesConfigMessage(keySize/8, null, null, null, null);\n+  }\n+\n+  /**\n+   * Generate the configuration message according to request config message.\n+   * @param configMessage The request config message comes from remote.\n+   * @return Configuration message for sending.\n+   */\n+  public static AesConfigMessage responseConfigMessage(AesConfigMessage configMessage){\n+\n+    Properties properties = new Properties();\n+    int keyLen = configMessage.keySize;\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keyLen];\n+      byte[] outKey = new byte[keyLen];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      configMessage.setParameters(keyLen, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES negotiation exception\", e);\n+      throw Throwables.propagate(e);\n+    }\n+\n+    return configMessage;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private ByteArrayWritableChannel byteChannel;\n+    private CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      cos.close();\n+      super.close(ctx, promise);\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private CryptoInputStream cis;\n+    private ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cis = cipher.CreateInputStream(byteChannel);\n+      totalDecrypted = 0;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      while (in.isReadable()) {\n+        byteChannel.feedData(in);\n+        int i;\n+        byte[] decryptedData = new byte[byteChannel.length()];\n+        int offset = 0;\n+        while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+          offset += i;\n+          if (offset >= decryptedData.length) {\n+            break;\n+          }\n+        }\n+\n+        totalDecrypted += offset;\n+        byteChannel.reset();\n+        ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+      }\n+\n+      in.release();\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      cis.close();\n+      logger.debug(\"{} channel decrypted {} bytes\", ctx.channel(), totalDecrypted);\n+      super.channelInactive(ctx);\n+    }\n+  }\n+\n+  private static class EncryptMessage extends AbstractReferenceCounted implements FileRegion {\n+    private final Logger logger = LoggerFactory.getLogger(EncryptMessage.class);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: move static fields before instance fields.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:34:24Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: method names should start with lower-case letters.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:37:14Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: lower case.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:37:20Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: space before `{`\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:41:09Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why use the empty `properties` instead of using the given `TransportConf`?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:41:55Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: doesn't seem particularly useful, especially on close.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:46:04Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private static Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cis = cipher.CreateInputStream(byteChannel);\n+      this.totalDecrypted = 0;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      while (in.isReadable()) {\n+        byteChannel.feedData(in);\n+        int i;\n+        byte[] decryptedData = new byte[byteChannel.length()];\n+        int offset = 0;\n+        while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+          offset += i;\n+          if (offset >= decryptedData.length) {\n+            break;\n+          }\n+        }\n+\n+        totalDecrypted += offset;\n+        byteChannel.reset();\n+        ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+      }\n+\n+      in.release();\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+        logger.debug(\"{} channel decrypted {} bytes.\", ctx.channel(), totalDecrypted);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "If this is only used for the debug message, I'd just remove it.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:47:08Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private static Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: `bytesWritten`\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:48:01Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private static Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cis = cipher.CreateInputStream(byteChannel);\n+      this.totalDecrypted = 0;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      while (in.isReadable()) {\n+        byteChannel.feedData(in);\n+        int i;\n+        byte[] decryptedData = new byte[byteChannel.length()];\n+        int offset = 0;\n+        while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+          offset += i;\n+          if (offset >= decryptedData.length) {\n+            break;\n+          }\n+        }\n+\n+        totalDecrypted += offset;\n+        byteChannel.reset();\n+        ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+      }\n+\n+      in.release();\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+        logger.debug(\"{} channel decrypted {} bytes.\", ctx.channel(), totalDecrypted);\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptMessage extends AbstractReferenceCounted implements FileRegion {\n+    private static final Logger logger = LoggerFactory.getLogger(EncryptMessage.class);\n+\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {\n+      Preconditions.checkArgument(msg instanceof ByteBuf || msg instanceof FileRegion,\n+        \"Unrecognized message type: %s\", msg.getClass().getName());\n+      this.isByteBuf = msg instanceof ByteBuf;\n+      this.buf = isByteBuf ? (ByteBuf) msg : null;\n+      this.region = isByteBuf ? null : (FileRegion) msg;\n+      this.transferred = 0;\n+      byteRawChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      this.cos = cos;\n+      byteEncChannel = ch;\n+    }\n+\n+    @Override\n+    public long count() {\n+      return isByteBuf ? buf.readableBytes() : region.count();\n+    }\n+\n+    @Override\n+    public long position() {\n+      return 0;\n+    }\n+\n+    @Override\n+    public long transfered() {\n+      return transferred;\n+    }\n+\n+    @Override\n+    public long transferTo(WritableByteChannel target, long position) throws IOException {\n+      Preconditions.checkArgument(position == transfered(), \"Invalid position.\");\n+\n+      do {\n+        if (currentEncrypted == null) {\n+          encryptMore();\n+        }\n+\n+        int byteWritten = currentEncrypted.remaining();"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`private`\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:48:34Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private static Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cis = cipher.CreateInputStream(byteChannel);\n+      this.totalDecrypted = 0;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      while (in.isReadable()) {\n+        byteChannel.feedData(in);\n+        int i;\n+        byte[] decryptedData = new byte[byteChannel.length()];\n+        int offset = 0;\n+        while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+          offset += i;\n+          if (offset >= decryptedData.length) {\n+            break;\n+          }\n+        }\n+\n+        totalDecrypted += offset;\n+        byteChannel.reset();\n+        ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+      }\n+\n+      in.release();\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+        logger.debug(\"{} channel decrypted {} bytes.\", ctx.channel(), totalDecrypted);\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptMessage extends AbstractReferenceCounted implements FileRegion {\n+    private static final Logger logger = LoggerFactory.getLogger(EncryptMessage.class);\n+\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {\n+      Preconditions.checkArgument(msg instanceof ByteBuf || msg instanceof FileRegion,\n+        \"Unrecognized message type: %s\", msg.getClass().getName());\n+      this.isByteBuf = msg instanceof ByteBuf;\n+      this.buf = isByteBuf ? (ByteBuf) msg : null;\n+      this.region = isByteBuf ? null : (FileRegion) msg;\n+      this.transferred = 0;\n+      byteRawChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      this.cos = cos;\n+      byteEncChannel = ch;\n+    }\n+\n+    @Override\n+    public long count() {\n+      return isByteBuf ? buf.readableBytes() : region.count();\n+    }\n+\n+    @Override\n+    public long position() {\n+      return 0;\n+    }\n+\n+    @Override\n+    public long transfered() {\n+      return transferred;\n+    }\n+\n+    @Override\n+    public long transferTo(WritableByteChannel target, long position) throws IOException {\n+      Preconditions.checkArgument(position == transfered(), \"Invalid position.\");\n+\n+      do {\n+        if (currentEncrypted == null) {\n+          encryptMore();\n+        }\n+\n+        int byteWritten = currentEncrypted.remaining();\n+        target.write(currentEncrypted);\n+        byteWritten -= currentEncrypted.remaining();\n+        transferred += byteWritten;\n+        if (!currentEncrypted.hasRemaining()) {\n+          currentEncrypted = null;\n+          byteEncChannel.reset();\n+        }\n+      } while (transferred < count());\n+\n+      logger.debug(\"{} transferred total {} bytes\", target, transferred);\n+\n+      return transferred;\n+    }\n+\n+    public void encryptMore() throws IOException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Same thing, log doesn't look particularly interesting.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:49:53Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.CreateOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private static Logger logger = LoggerFactory.getLogger(AesDecryptHandler.class);\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+    private long totalDecrypted;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cis = cipher.CreateInputStream(byteChannel);\n+      this.totalDecrypted = 0;\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      while (in.isReadable()) {\n+        byteChannel.feedData(in);\n+        int i;\n+        byte[] decryptedData = new byte[byteChannel.length()];\n+        int offset = 0;\n+        while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+          offset += i;\n+          if (offset >= decryptedData.length) {\n+            break;\n+          }\n+        }\n+\n+        totalDecrypted += offset;\n+        byteChannel.reset();\n+        ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+      }\n+\n+      in.release();\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+        logger.debug(\"{} channel decrypted {} bytes.\", ctx.channel(), totalDecrypted);\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptMessage extends AbstractReferenceCounted implements FileRegion {\n+    private static final Logger logger = LoggerFactory.getLogger(EncryptMessage.class);\n+\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {\n+      Preconditions.checkArgument(msg instanceof ByteBuf || msg instanceof FileRegion,\n+        \"Unrecognized message type: %s\", msg.getClass().getName());\n+      this.isByteBuf = msg instanceof ByteBuf;\n+      this.buf = isByteBuf ? (ByteBuf) msg : null;\n+      this.region = isByteBuf ? null : (FileRegion) msg;\n+      this.transferred = 0;\n+      byteRawChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      this.cos = cos;\n+      byteEncChannel = ch;\n+    }\n+\n+    @Override\n+    public long count() {\n+      return isByteBuf ? buf.readableBytes() : region.count();\n+    }\n+\n+    @Override\n+    public long position() {\n+      return 0;\n+    }\n+\n+    @Override\n+    public long transfered() {\n+      return transferred;\n+    }\n+\n+    @Override\n+    public long transferTo(WritableByteChannel target, long position) throws IOException {\n+      Preconditions.checkArgument(position == transfered(), \"Invalid position.\");\n+\n+      do {\n+        if (currentEncrypted == null) {\n+          encryptMore();\n+        }\n+\n+        int byteWritten = currentEncrypted.remaining();\n+        target.write(currentEncrypted);\n+        byteWritten -= currentEncrypted.remaining();\n+        transferred += byteWritten;\n+        if (!currentEncrypted.hasRemaining()) {\n+          currentEncrypted = null;\n+          byteEncChannel.reset();\n+        }\n+      } while (transferred < count());\n+\n+      logger.debug(\"{} transferred total {} bytes\", target, transferred);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: lower case for methods.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:59:20Z",
    "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream CreateOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream CreateInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf){\n+    int keySize = conf.AesCipherKeySize();"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This can be private, right?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-02T01:33:18Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Can be private?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-02T01:33:25Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You still haven't addressed this comment. Why are you using an empty config instead of the values in the `TransportConf` parameter? With your code, for example, there's no way for someone to disable the use of OpenSSL since you'll be using the default value in `CryptoCipherFactory`.\n\nBasically you need something like `CryptoStreamUtils.toCryptoConf` for this code.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-02T01:37:06Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "minor: `do..while` might be clearer.\n\n```\nint read;\nint offset;\ndo {\n  read = cis.read...\n  offset += read;\n} while (read > 0 && offset < decryptedData.length);\n```\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-02T01:39:51Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      int i;\n+      byte[] decryptedData = new byte[byteChannel.length()];\n+      int offset = 0;\n+      while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: class names should preferably not have verbs (use `EncryptedMessage` instead).\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-02T01:40:46Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  public CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  public CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = new Properties();\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      int i;\n+      byte[] decryptedData = new byte[byteChannel.length()];\n+      int offset = 0;\n+      while ((i = cis.read(decryptedData, offset, decryptedData.length - offset)) > 0) {\n+        offset += i;\n+        if (offset >= decryptedData.length) {\n+          break;\n+        }\n+      }\n+\n+      ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptMessage extends AbstractReferenceCounted implements FileRegion {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "final?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-07T19:08:10Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "You're not adding configs for `CryptoRandomFactory` here. Really what you want here is `CryptoStreamUtils.toCryptoConf`, but `TransportConf` doesn't really have the interface to support that. So at least add a TODO so that we know that this needs to be done.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-07T19:10:59Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = getProperties(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static Properties getProperties(TransportConf conf) {\n+    Properties props = new Properties();\n+    props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Can you use `public int write(ByteBuffer src)` here instead of the `byte[]` overload?\n\nEDIT: nevermind, `byteRawChannel` is not a ByteBuffer.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-07T19:24:44Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = getProperties(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static Properties getProperties(TransportConf conf) {\n+    Properties props = new Properties();\n+    props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+    return props;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      byte[] decryptedData = new byte[byteChannel.readableBytes()];\n+      int offset = 0;\n+      while (offset < decryptedData.length) {\n+        offset += cis.read(decryptedData, offset, decryptedData.length - offset);\n+      }\n+\n+      ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptedMessage extends AbstractReferenceCounted implements FileRegion {\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptedMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {\n+      Preconditions.checkArgument(msg instanceof ByteBuf || msg instanceof FileRegion,\n+        \"Unrecognized message type: %s\", msg.getClass().getName());\n+      this.isByteBuf = msg instanceof ByteBuf;\n+      this.buf = isByteBuf ? (ByteBuf) msg : null;\n+      this.region = isByteBuf ? null : (FileRegion) msg;\n+      this.transferred = 0;\n+      byteRawChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      this.cos = cos;\n+      byteEncChannel = ch;\n+    }\n+\n+    @Override\n+    public long count() {\n+      return isByteBuf ? buf.readableBytes() : region.count();\n+    }\n+\n+    @Override\n+    public long position() {\n+      return 0;\n+    }\n+\n+    @Override\n+    public long transfered() {\n+      return transferred;\n+    }\n+\n+    @Override\n+    public long transferTo(WritableByteChannel target, long position) throws IOException {\n+      Preconditions.checkArgument(position == transfered(), \"Invalid position.\");\n+\n+      do {\n+        if (currentEncrypted == null) {\n+          encryptMore();\n+        }\n+\n+        int bytesWritten = currentEncrypted.remaining();\n+        target.write(currentEncrypted);\n+        bytesWritten -= currentEncrypted.remaining();\n+        transferred += bytesWritten;\n+        if (!currentEncrypted.hasRemaining()) {\n+          currentEncrypted = null;\n+          byteEncChannel.reset();\n+        }\n+      } while (transferred < count());\n+\n+      return transferred;\n+    }\n+\n+    private void encryptMore() throws IOException {\n+      byteRawChannel.reset();\n+\n+      if (isByteBuf) {\n+        int copied = byteRawChannel.write(buf.nioBuffer());\n+        buf.skipBytes(copied);\n+      } else {\n+        region.transferTo(byteRawChannel, region.transfered());\n+      }\n+      cos.write(byteRawChannel.getData(), 0, byteRawChannel.length());",
    "line": 274
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: `this.` (also below)\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-07T19:26:43Z",
    "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = getProperties(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  private static Properties getProperties(TransportConf conf) {\n+    Properties props = new Properties();\n+    props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+    return props;\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      byte[] decryptedData = new byte[byteChannel.readableBytes()];\n+      int offset = 0;\n+      while (offset < decryptedData.length) {\n+        offset += cis.read(decryptedData, offset, decryptedData.length - offset);\n+      }\n+\n+      ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptedMessage extends AbstractReferenceCounted implements FileRegion {\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptedMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {\n+      Preconditions.checkArgument(msg instanceof ByteBuf || msg instanceof FileRegion,\n+        \"Unrecognized message type: %s\", msg.getClass().getName());\n+      this.isByteBuf = msg instanceof ByteBuf;\n+      this.buf = isByteBuf ? (ByteBuf) msg : null;\n+      this.region = isByteBuf ? null : (FileRegion) msg;\n+      this.transferred = 0;\n+      byteRawChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: Please document that `cos` will be redirected to `ch`.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T06:19:39Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = CryptoStreamUtils.toCryptoConf(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * CryptoStreamUtils is used to convert config from TransportConf to AES Crypto config.\n+   */\n+  private static class CryptoStreamUtils {\n+    public static Properties toCryptoConf(TransportConf conf) {\n+      Properties props = new Properties();\n+      if (conf.aesCipherClass() != null) {\n+        props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+      }\n+      return props;\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      byte[] decryptedData = new byte[byteChannel.readableBytes()];\n+      int offset = 0;\n+      while (offset < decryptedData.length) {\n+        offset += cis.read(decryptedData, offset, decryptedData.length - offset);\n+      }\n+\n+      ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptedMessage extends AbstractReferenceCounted implements FileRegion {\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptedMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {",
    "line": 216
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "ch is used to create the output encrypt stream, the document at L208 describe the reason to use two helper channel.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T13:03:09Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = CryptoStreamUtils.toCryptoConf(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * CryptoStreamUtils is used to convert config from TransportConf to AES Crypto config.\n+   */\n+  private static class CryptoStreamUtils {\n+    public static Properties toCryptoConf(TransportConf conf) {\n+      Properties props = new Properties();\n+      if (conf.aesCipherClass() != null) {\n+        props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+      }\n+      return props;\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);\n+\n+      byte[] decryptedData = new byte[byteChannel.readableBytes()];\n+      int offset = 0;\n+      while (offset < decryptedData.length) {\n+        offset += cis.read(decryptedData, offset, decryptedData.length - offset);\n+      }\n+\n+      ctx.fireChannelRead(Unpooled.wrappedBuffer(decryptedData, 0, decryptedData.length));\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+      try {\n+        cis.close();\n+      } finally {\n+        super.channelInactive(ctx);\n+      }\n+    }\n+  }\n+\n+  private static class EncryptedMessage extends AbstractReferenceCounted implements FileRegion {\n+    private final boolean isByteBuf;\n+    private final ByteBuf buf;\n+    private final FileRegion region;\n+    private long transferred;\n+    private CryptoOutputStream cos;\n+\n+    // Due to streaming issue CRYPTO-125: https://issues.apache.org/jira/browse/CRYPTO-125, it has\n+    // to utilize two helper ByteArrayWritableChannel for streaming. One is used to receive raw data\n+    // from upper handler, another is used to store encrypted data.\n+    private ByteArrayWritableChannel byteEncChannel;\n+    private ByteArrayWritableChannel byteRawChannel;\n+\n+    private ByteBuffer currentEncrypted;\n+\n+    EncryptedMessage(CryptoOutputStream cos, Object msg, ByteArrayWritableChannel ch) {",
    "line": 216
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "`in` should be `retain`ed.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T06:41:50Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = CryptoStreamUtils.toCryptoConf(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * CryptoStreamUtils is used to convert config from TransportConf to AES Crypto config.\n+   */\n+  private static class CryptoStreamUtils {\n+    public static Properties toCryptoConf(TransportConf conf) {\n+      Properties props = new Properties();\n+      if (conf.aesCipherClass() != null) {\n+        props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+      }\n+      return props;\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Does `Apache Common Crypto` provide any API to decrypt `ByteBuffer`? If so, could you use it because the code will be much simpler (e.g., `ByteArrayReadableChannel` is totally not needed.)?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T07:09:30Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = CryptoStreamUtils.toCryptoConf(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * CryptoStreamUtils is used to convert config from TransportConf to AES Crypto config.\n+   */\n+  private static class CryptoStreamUtils {\n+    public static Properties toCryptoConf(TransportConf conf) {\n+      Properties props = new Properties();\n+      if (conf.aesCipherClass() != null) {\n+        props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+      }\n+      return props;\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Commons Crypto does provide ByteBuffer decryption in both openSslCipher and jceCipher,  named update(ByteBuffer in, ByteBuffer out). But here we are using encryption/decryption streaming way to do the decryption.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T08:38:38Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;\n+    inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    inIvSpec = new IvParameterSpec(inIv);\n+    outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    outIvSpec = new IvParameterSpec(outIv);\n+  }\n+\n+  public AesCipher(AesConfigMessage configMessage) throws IOException  {\n+    this(new Properties(), configMessage.inKey, configMessage.outKey,\n+      configMessage.inIv, configMessage.outIv);\n+  }\n+\n+  /**\n+   * Create AES crypto output stream\n+   * @param ch The underlying channel to write out.\n+   * @return Return output crypto stream for encryption.\n+   * @throws IOException\n+   */\n+  private CryptoOutputStream createOutputStream(WritableByteChannel ch) throws IOException {\n+    return new CryptoOutputStream(TRANSFORM, properties, ch, outKeySpec, outIvSpec);\n+  }\n+\n+  /**\n+   * Create AES crypto input stream\n+   * @param ch The underlying channel used to read data.\n+   * @return Return input crypto stream for decryption.\n+   * @throws IOException\n+   */\n+  private CryptoInputStream createInputStream(ReadableByteChannel ch) throws IOException {\n+    return new CryptoInputStream(TRANSFORM, properties, ch, inKeySpec, inIvSpec);\n+  }\n+\n+  /**\n+   * Add handlers to channel\n+   * @param ch the channel for adding handlers\n+   * @throws IOException\n+   */\n+  public void addToChannel(Channel ch) throws IOException {\n+    ch.pipeline()\n+      .addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(this))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(this));\n+  }\n+\n+  /**\n+   * Create the configuration message\n+   * @param conf is the local transport configuration.\n+   * @return Config message for sending.\n+   */\n+  public static AesConfigMessage createConfigMessage(TransportConf conf) {\n+    int keySize = conf.aesCipherKeySize();\n+    Properties properties = CryptoStreamUtils.toCryptoConf(conf);\n+\n+    try {\n+      int paramLen = CryptoCipherFactory.getCryptoCipher(AesCipher.TRANSFORM, properties)\n+        .getBlockSize();\n+      byte[] inKey = new byte[keySize];\n+      byte[] outKey = new byte[keySize];\n+      byte[] inIv = new byte[paramLen];\n+      byte[] outIv = new byte[paramLen];\n+\n+      CryptoRandom random = CryptoRandomFactory.getCryptoRandom(properties);\n+      random.nextBytes(inKey);\n+      random.nextBytes(outKey);\n+      random.nextBytes(inIv);\n+      random.nextBytes(outIv);\n+\n+      return new AesConfigMessage(keySize, inKey, inIv, outKey, outIv);\n+    } catch (Exception e) {\n+      logger.error(\"AES config error\", e);\n+      throw Throwables.propagate(e);\n+    }\n+  }\n+\n+  /**\n+   * CryptoStreamUtils is used to convert config from TransportConf to AES Crypto config.\n+   */\n+  private static class CryptoStreamUtils {\n+    public static Properties toCryptoConf(TransportConf conf) {\n+      Properties props = new Properties();\n+      if (conf.aesCipherClass() != null) {\n+        props.setProperty(CryptoCipherFactory.CLASSES_KEY, conf.aesCipherClass());\n+      }\n+      return props;\n+    }\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final ByteArrayWritableChannel byteChannel;\n+    private final CryptoOutputStream cos;\n+\n+    AesEncryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+      cos = cipher.createOutputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptedMessage(cos, msg, byteChannel), promise);\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+      try {\n+        cos.close();\n+      } finally {\n+        super.close(ctx, promise);\n+      }\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final CryptoInputStream cis;\n+    private final ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) throws IOException {\n+      byteChannel = new ByteArrayReadableChannel();\n+      cis = cipher.createInputStream(byteChannel);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+      byteChannel.feedData(in);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "This constructor is not used outside. Could you remove it?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T07:00:51Z",
    "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Properties;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Throwables;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.cipher.CryptoCipherFactory;\n+import org.apache.commons.crypto.random.CryptoRandom;\n+import org.apache.commons.crypto.random.CryptoRandomFactory;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+import org.apache.spark.network.util.TransportConf;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class AesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(AesCipher.class);\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+  public static final int STREAM_BUFFER_SIZE = 1024 * 32;\n+  public static final String TRANSFORM = \"AES/CTR/NoPadding\";\n+\n+  private final SecretKeySpec inKeySpec;\n+  private final IvParameterSpec inIvSpec;\n+  private final SecretKeySpec outKeySpec;\n+  private final IvParameterSpec outIvSpec;\n+  private final Properties properties;\n+\n+  public AesCipher(\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    this.properties = properties;"
  }],
  "prId": 15172
}]