[{
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "typo: CHALLENGE",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-11T17:09:26Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CCHALLENGE: a byte sequence used as a challenge to the server."
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "typo: RESPONSE",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-11T17:12:05Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CCHALLENGE: a byte sequence used as a challenge to the server.\n+- ||: concatenation operator.\n+\n+When strings are used where byte arrays are expected, the UTF-8 representation of the string\n+is assumed.\n+\n+To respond to the challenge, the server should consider the byte array as representing an\n+arbitrary-length integer, and respond with the value of the integer plus one.\n+\n+\n+Server Response And Challenge\n+-----------------------------\n+\n+Once the client challenge is received, the server will generate the same auth key by\n+using the same algorithm the client has used. It will then verify the client challenge:\n+if the APP_ID and ANONCE fields match, the server knows that the client has the shared\n+secret. The server then creates a response to the client challenge, to prove that it also\n+has the secret key, and provides parameters to be used when creating the session key.\n+\n+The following describes the response from the server:\n+\n+    SERVER_CHALLENGE = (\n+        ENC(APP_ID || ANONCE || RESPONSE),\n+        ENC(SNONCE),\n+        ENC(INIV),\n+        ENC(OUTIV))\n+\n+Where:\n+\n+- CRESPONSE: the server's response to the client challenge."
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "squito"
    },
    "body": "reasonable",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-11T17:13:05Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CCHALLENGE: a byte sequence used as a challenge to the server.\n+- ||: concatenation operator.\n+\n+When strings are used where byte arrays are expected, the UTF-8 representation of the string\n+is assumed.\n+\n+To respond to the challenge, the server should consider the byte array as representing an\n+arbitrary-length integer, and respond with the value of the integer plus one.\n+\n+\n+Server Response And Challenge\n+-----------------------------\n+\n+Once the client challenge is received, the server will generate the same auth key by\n+using the same algorithm the client has used. It will then verify the client challenge:\n+if the APP_ID and ANONCE fields match, the server knows that the client has the shared\n+secret. The server then creates a response to the client challenge, to prove that it also\n+has the secret key, and provides parameters to be used when creating the session key.\n+\n+The following describes the response from the server:\n+\n+    SERVER_CHALLENGE = (\n+        ENC(APP_ID || ANONCE || RESPONSE),\n+        ENC(SNONCE),\n+        ENC(INIV),\n+        ENC(OUTIV))\n+\n+Where:\n+\n+- CRESPONSE: the server's response to the client challenge.\n+- SNONCE: a nonce to be used as salt when generating the session key.\n+- INIV: initialization vector used to initialize the input channel of the client.\n+- OUTIV: initialization vector used to initialize the output channel of the client.\n+\n+At this point the server considers the client to be authenticated, and will try to\n+decrypt any data further sent by the client using the session key.\n+\n+\n+Default Algorithms\n+------------------\n+\n+Configuration options are available for the KDF and cipher algorithms to use.\n+\n+The default KDF is \"PBKDF2WithHmacSHA1\". Users should be able to select any algorithm\n+from those supported by the `javax.crypto.SecretKeyFactory` class, as long as they support\n+PBEKeySpec when generating keys. The default number of iterations is calculated to take a\n+resonable amount of time on modern CPUs. See the documentation in TransportConf for more"
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "jsoltren"
    },
    "body": "It might be helpful to mention the current shared secret generation and distribution mechanisms to drive the point that these are, hopefully, stronger than DIGEST-MD5 or possibly even AES.",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-18T19:49:02Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.",
    "line": 22
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "That is discussed in `SecurityManager.scala`.",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-18T19:57:46Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.",
    "line": 22
  }],
  "prId": 16521
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "The server doesn't verify a nonce was used or not, so it don't prevents replay attacks. Right?",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-21T01:06:46Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CHALLENGE: a byte sequence used as a challenge to the server.\n+- ||: concatenation operator.\n+\n+When strings are used where byte arrays are expected, the UTF-8 representation of the string\n+is assumed.\n+\n+To respond to the challenge, the server should consider the byte array as representing an\n+arbitrary-length integer, and respond with the value of the integer plus one.\n+\n+\n+Server Response And Challenge\n+-----------------------------\n+\n+Once the client challenge is received, the server will generate the same auth key by\n+using the same algorithm the client has used. It will then verify the client challenge:\n+if the APP_ID and ANONCE fields match, the server knows that the client has the shared\n+secret. The server then creates a response to the client challenge, to prove that it also\n+has the secret key, and provides parameters to be used when creating the session key.\n+\n+The following describes the response from the server:\n+\n+    SERVER_CHALLENGE = (\n+        ENC(APP_ID || ANONCE || RESPONSE),\n+        ENC(SNONCE),\n+        ENC(INIV),\n+        ENC(OUTIV))\n+\n+Where:\n+\n+- RESPONSE: the server's response to the client challenge.\n+- SNONCE: a nonce to be used as salt when generating the session key.\n+- INIV: initialization vector used to initialize the input channel of the client.\n+- OUTIV: initialization vector used to initialize the output channel of the client.\n+\n+At this point the server considers the client to be authenticated, and will try to\n+decrypt any data further sent by the client using the session key.\n+\n+\n+Default Algorithms\n+------------------\n+\n+Configuration options are available for the KDF and cipher algorithms to use.\n+\n+The default KDF is \"PBKDF2WithHmacSHA1\". Users should be able to select any algorithm\n+from those supported by the `javax.crypto.SecretKeyFactory` class, as long as they support\n+PBEKeySpec when generating keys. The default number of iterations was chosen to take a\n+reasonable amount of time on modern CPUs. See the documentation in TransportConf for more\n+details.\n+\n+The default cipher algorithm is \"AES/CTR/NoPadding\". Users should be able to select any\n+algorithm supported by the commons-crypto library. It should allow the cipher to operate\n+in stream mode.\n+\n+The default key length is 128 (bits).\n+\n+\n+Implementation Details\n+----------------------\n+\n+The commons-crypto library currently only supports AES ciphers, and requires an initialization\n+vector (IV). This first version of the protocol does not explicitly include the IV in the client\n+challenge message. Instead, the IV should be derived from the nonce, including the needed bytes, and\n+padding the IV with zeroes in case the nonce is not long enough.\n+\n+Future versions of the protocol might add support for new ciphers and explicitly include needed\n+configuration parameters in the messages.\n+\n+\n+Threat Assessment\n+-----------------\n+\n+The protocol is secure against different forms of attack:\n+\n+* Eavesdropping: the protocol is built on the assumption that it's computationally infeasible\n+  to calculate the original secret from the encrypted messages. Neither the secret nor any\n+  encryption keys are transmitted on the wire, encrypted or not.\n+\n+* Man-in-the-middle: because the protocol performs mutual authentication, both ends need to\n+  know the shared secret to be able to decrypt session data. Even if an attacker is able to insert a\n+  malicious \"proxy\" between endpoints, the attacker won't be able to read any of the data exchanged\n+  between client and server, nor insert arbitrary commands for the server to execute.\n+\n+* Replay attacks: the use of nonces when generating keys prevents an attacker from being able to",
    "line": 148
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "This is explained in the paragraph after the bullet list. The server always generates new nonces for sessions, so replaying the challenge will not allow an attacker to establish a session.",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-23T19:04:36Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CHALLENGE: a byte sequence used as a challenge to the server.\n+- ||: concatenation operator.\n+\n+When strings are used where byte arrays are expected, the UTF-8 representation of the string\n+is assumed.\n+\n+To respond to the challenge, the server should consider the byte array as representing an\n+arbitrary-length integer, and respond with the value of the integer plus one.\n+\n+\n+Server Response And Challenge\n+-----------------------------\n+\n+Once the client challenge is received, the server will generate the same auth key by\n+using the same algorithm the client has used. It will then verify the client challenge:\n+if the APP_ID and ANONCE fields match, the server knows that the client has the shared\n+secret. The server then creates a response to the client challenge, to prove that it also\n+has the secret key, and provides parameters to be used when creating the session key.\n+\n+The following describes the response from the server:\n+\n+    SERVER_CHALLENGE = (\n+        ENC(APP_ID || ANONCE || RESPONSE),\n+        ENC(SNONCE),\n+        ENC(INIV),\n+        ENC(OUTIV))\n+\n+Where:\n+\n+- RESPONSE: the server's response to the client challenge.\n+- SNONCE: a nonce to be used as salt when generating the session key.\n+- INIV: initialization vector used to initialize the input channel of the client.\n+- OUTIV: initialization vector used to initialize the output channel of the client.\n+\n+At this point the server considers the client to be authenticated, and will try to\n+decrypt any data further sent by the client using the session key.\n+\n+\n+Default Algorithms\n+------------------\n+\n+Configuration options are available for the KDF and cipher algorithms to use.\n+\n+The default KDF is \"PBKDF2WithHmacSHA1\". Users should be able to select any algorithm\n+from those supported by the `javax.crypto.SecretKeyFactory` class, as long as they support\n+PBEKeySpec when generating keys. The default number of iterations was chosen to take a\n+reasonable amount of time on modern CPUs. See the documentation in TransportConf for more\n+details.\n+\n+The default cipher algorithm is \"AES/CTR/NoPadding\". Users should be able to select any\n+algorithm supported by the commons-crypto library. It should allow the cipher to operate\n+in stream mode.\n+\n+The default key length is 128 (bits).\n+\n+\n+Implementation Details\n+----------------------\n+\n+The commons-crypto library currently only supports AES ciphers, and requires an initialization\n+vector (IV). This first version of the protocol does not explicitly include the IV in the client\n+challenge message. Instead, the IV should be derived from the nonce, including the needed bytes, and\n+padding the IV with zeroes in case the nonce is not long enough.\n+\n+Future versions of the protocol might add support for new ciphers and explicitly include needed\n+configuration parameters in the messages.\n+\n+\n+Threat Assessment\n+-----------------\n+\n+The protocol is secure against different forms of attack:\n+\n+* Eavesdropping: the protocol is built on the assumption that it's computationally infeasible\n+  to calculate the original secret from the encrypted messages. Neither the secret nor any\n+  encryption keys are transmitted on the wire, encrypted or not.\n+\n+* Man-in-the-middle: because the protocol performs mutual authentication, both ends need to\n+  know the shared secret to be able to decrypt session data. Even if an attacker is able to insert a\n+  malicious \"proxy\" between endpoints, the attacker won't be able to read any of the data exchanged\n+  between client and server, nor insert arbitrary commands for the server to execute.\n+\n+* Replay attacks: the use of nonces when generating keys prevents an attacker from being able to",
    "line": 148
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "Yeah. I didn't read the codes correctly.",
    "commit": "39df4b312997e4c2f9bacfb9da2d5adaad8af509",
    "createdAt": "2017-01-23T21:56:23Z",
    "diffHunk": "@@ -0,0 +1,158 @@\n+Spark Auth Protocol and AES Encryption Support\n+==============================================\n+\n+This file describes an auth protocol used by Spark as a more secure alternative to DIGEST-MD5. This\n+protocol is built on symmetric key encryption, based on the assumption that the two endpoints being\n+authenticated share a common secret, which is how Spark authentication currently works. The protocol\n+provides mutual authentication, meaning that after the negotiation both parties know that the remote\n+side knows the shared secret. The protocol is influenced by the ISO/IEC 9798 protocol, although it's\n+not an implementation of it.\n+\n+This protocol could be replaced with TLS PSK, except no PSK ciphers are available in the currently\n+released JREs.\n+\n+The protocol aims at solving the following shortcomings in Spark's current usage of DIGEST-MD5:\n+\n+- MD5 is an aging hash algorithm with known weaknesses, and a more secure alternative is desired.\n+- DIGEST-MD5 has a pre-defined set of ciphers for which it can generate keys. The only\n+  viable, supported cipher these days is 3DES, and a more modern alternative is desired.\n+- Encrypting AES session keys with 3DES doesn't solve the issue, since the weakest link\n+  in the negotiation would still be MD5 and 3DES.\n+\n+The protocol assumes that the shared secret is generated and distributed in a secure manner.\n+\n+The protocol always negotiates encryption keys. If encryption is not desired, the existing\n+SASL-based authentication, or no authentication at all, can be chosen instead.\n+\n+When messages are described below, it's expected that the implementation should support\n+arbitrary sizes for fields that don't have a fixed size.\n+\n+Client Challenge\n+----------------\n+\n+The auth negotiation is started by the client. The client starts by generating an encryption\n+key based on the application's shared secret, and a nonce.\n+\n+    KEY = KDF(SECRET, SALT, KEY_LENGTH)\n+\n+Where:\n+- KDF(): a key derivation function that takes a secret, a salt, a configurable number of\n+  iterations, and a configurable key length.\n+- SALT: a byte sequence used to salt the key derivation function.\n+- KEY_LENGTH: length of the encryption key to generate.\n+\n+\n+The client generates a message with the following content:\n+\n+    CLIENT_CHALLENGE = (\n+        APP_ID,\n+        KDF,\n+        ITERATIONS,\n+        CIPHER,\n+        KEY_LENGTH,\n+        ANONCE,\n+        ENC(APP_ID || ANONCE || CHALLENGE))\n+\n+Where:\n+\n+- APP_ID: the application ID which the server uses to identify the shared secret.\n+- KDF: the key derivation function described above.\n+- ITERATIONS: number of iterations to run the KDF when generating keys.\n+- CIPHER: the cipher used to encrypt data.\n+- KEY_LENGTH: length of the encryption keys to generate, in bits.\n+- ANONCE: the nonce used as the salt when generating the auth key.\n+- ENC(): an encryption function that uses the cipher and the generated key. This function\n+  will also be used in the definition of other messages below.\n+- CHALLENGE: a byte sequence used as a challenge to the server.\n+- ||: concatenation operator.\n+\n+When strings are used where byte arrays are expected, the UTF-8 representation of the string\n+is assumed.\n+\n+To respond to the challenge, the server should consider the byte array as representing an\n+arbitrary-length integer, and respond with the value of the integer plus one.\n+\n+\n+Server Response And Challenge\n+-----------------------------\n+\n+Once the client challenge is received, the server will generate the same auth key by\n+using the same algorithm the client has used. It will then verify the client challenge:\n+if the APP_ID and ANONCE fields match, the server knows that the client has the shared\n+secret. The server then creates a response to the client challenge, to prove that it also\n+has the secret key, and provides parameters to be used when creating the session key.\n+\n+The following describes the response from the server:\n+\n+    SERVER_CHALLENGE = (\n+        ENC(APP_ID || ANONCE || RESPONSE),\n+        ENC(SNONCE),\n+        ENC(INIV),\n+        ENC(OUTIV))\n+\n+Where:\n+\n+- RESPONSE: the server's response to the client challenge.\n+- SNONCE: a nonce to be used as salt when generating the session key.\n+- INIV: initialization vector used to initialize the input channel of the client.\n+- OUTIV: initialization vector used to initialize the output channel of the client.\n+\n+At this point the server considers the client to be authenticated, and will try to\n+decrypt any data further sent by the client using the session key.\n+\n+\n+Default Algorithms\n+------------------\n+\n+Configuration options are available for the KDF and cipher algorithms to use.\n+\n+The default KDF is \"PBKDF2WithHmacSHA1\". Users should be able to select any algorithm\n+from those supported by the `javax.crypto.SecretKeyFactory` class, as long as they support\n+PBEKeySpec when generating keys. The default number of iterations was chosen to take a\n+reasonable amount of time on modern CPUs. See the documentation in TransportConf for more\n+details.\n+\n+The default cipher algorithm is \"AES/CTR/NoPadding\". Users should be able to select any\n+algorithm supported by the commons-crypto library. It should allow the cipher to operate\n+in stream mode.\n+\n+The default key length is 128 (bits).\n+\n+\n+Implementation Details\n+----------------------\n+\n+The commons-crypto library currently only supports AES ciphers, and requires an initialization\n+vector (IV). This first version of the protocol does not explicitly include the IV in the client\n+challenge message. Instead, the IV should be derived from the nonce, including the needed bytes, and\n+padding the IV with zeroes in case the nonce is not long enough.\n+\n+Future versions of the protocol might add support for new ciphers and explicitly include needed\n+configuration parameters in the messages.\n+\n+\n+Threat Assessment\n+-----------------\n+\n+The protocol is secure against different forms of attack:\n+\n+* Eavesdropping: the protocol is built on the assumption that it's computationally infeasible\n+  to calculate the original secret from the encrypted messages. Neither the secret nor any\n+  encryption keys are transmitted on the wire, encrypted or not.\n+\n+* Man-in-the-middle: because the protocol performs mutual authentication, both ends need to\n+  know the shared secret to be able to decrypt session data. Even if an attacker is able to insert a\n+  malicious \"proxy\" between endpoints, the attacker won't be able to read any of the data exchanged\n+  between client and server, nor insert arbitrary commands for the server to execute.\n+\n+* Replay attacks: the use of nonces when generating keys prevents an attacker from being able to",
    "line": 148
  }],
  "prId": 16521
}]