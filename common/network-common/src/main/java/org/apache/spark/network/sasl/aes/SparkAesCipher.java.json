[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I think it would be better to modify `SaslEncryption` to work with `ByteBuffer` (or event `ByteBuf`) instead of `byte[]`; that way the AES implementation would be more efficient. This should be pretty easy for the decryption side, maybe a little more complicated on the encrypting side.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-23T18:43:14Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I suppose you were talking about SaslEncrytionbackend. Actually, the real underlying interfaces of wrap/unwrap are defined by SaslClient which provided by java security. \n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-26T02:07:08Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "wrap/unwrap APIs are defined by SaslClient interface of Java Security.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-26T08:11:38Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "See previous comment. You do not need to implement JDK interfaces here, especially because they don't really add any needed functionality.\n\nThey're needed for the SASL encryption backend because that's how you do it with those APIs. It doesn't need the AES encryption code needs to implement those APIs too.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-26T17:17:23Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "There's a lot of allocation / copying going on here... using `ByteBuffer`, or even sticking to `byte[]` but with APIs that allow you to provide offset + count, would be better.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-23T18:48:53Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {\n+    byte[] mac = integrity.getHMAC(data, offset, len);\n+    integrity.incMySeqNum();\n+\n+    // Padding based on cipher\n+    byte[] padding;\n+    if (\"AES/CBC/NoPadding\".equals(encryptor.getAlgorithm())) {\n+      int bs = encryptor.getBlockSize();\n+      int pad = bs - (len + 10) % bs;\n+      padding = new byte[pad];\n+      for (int i = 0; i < pad; i ++) {\n+        padding[i] = (byte) pad;\n+      }\n+    } else {\n+      padding = EMPTY_BYTE_ARRAY;\n+    }\n+\n+    // Encrypt\n+    byte[] encrypted = new byte[len + 10 + padding.length + 4];\n+    try {\n+      int n = encryptor.update(data, offset, len, encrypted, 0);\n+      n += encryptor.update(padding, 0, padding.length, encrypted, n);\n+      encryptor.update(mac, 0, 10, encrypted, n);\n+    } catch (ShortBufferException sbe) {\n+      // This should not happen\n+      throw new SaslException(\"Error happens during encrypt data\", sbe);\n+    }\n+\n+    // Append seqNum used for mac\n+    System.arraycopy(integrity.getSeqNum(), 0, encrypted, encrypted.length - 4, 4);\n+\n+    return encrypted;\n+  }\n+\n+  /**\n+   * Decrypt input data. The input composes of (msg, padding if needed, mac) and sequence num.\n+   * The result is msg.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new decrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] unwrap(byte[] data, int offset, int len) throws SaslException {\n+    // Get plaintext and seqNum\n+    byte[] decrypted = new byte[len - 4];\n+    byte[] peerSeqNum = new byte[4];\n+    try {\n+      decryptor.update(data, offset, len - 4, decrypted, 0);\n+    } catch (ShortBufferException sbe) {\n+      throw new SaslException(\"Error happens during decrypt data\", sbe);\n+    }\n+    System.arraycopy(data, offset + decrypted.length, peerSeqNum, 0, 4);\n+\n+    // Get msg and mac\n+    byte[] msg = new byte[decrypted.length - 10];\n+    byte[] mac = new byte[10];\n+\n+    System.arraycopy(decrypted, msg.length, mac, 0, 10);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "There's a lot of code in this class that I would have expected to be in commons-crypto; after all, the intent of that library is to make it easy to use crypto, and the code in this class definitely does not look \"easy\".\n\nWhy isn't the library handling most of this? Can we make enhancements to the library first so that it better covers this use case?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-23T18:52:05Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I suppose the \"extra\" code you mentioned is about the integrity helper class and some padding operation. The padding  operation should be removed since it is not a correct use case., I will remove it accordingly. While the Integrity helper class is more related to SASL compared to common crypto library to some extend, the sequence number and HMAC are more like SASL transport context. I think common crypto library, as a general cipher might not appropriate to implement it.   I think it would be better to retain it and do some optimization. What do you think?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-26T08:10:21Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Yes, mostly the HMAC and sequence number. On second though, they seem completely unnecessary. Those are better left to other layers in the networking stack.\n\nNote the goal here is not to implement \"SASL encryption\" using AES; it's just to provide AES encryption. You do not need to implement it using the JDK's SASL interfaces; once authentication is done, you can just use the most optimized API for the encryption library you're using. In the case of AES/commons crypto, that should be a simple netty channel handler, not an implementation that implements the JDK's wrap / unwrap for no reason.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-26T17:16:22Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Seq number and HMAC are necessary parts of SASL encryption,  Seq number can make same data with different offsets different, and HMAC is used for integrity check, see com.sun.security.sasl.digest.DigestMD5Base class from JDK as example.\n\nJDK's SASL framework doesn't provide interface to transfer AES cipher, it creates cipher interanlly. For example DigestMD5 client create cipher internally (DigestMD5Base.java:1219). However, it provides SaslEncryptBackend interface for user to customize the SASL client/server, that's why the patch implements wrap/unwrap. \n\nAnother way to make patch clean and clear is to add AES cipher support in JDK's Digest-MD5 mechanism or change JDK SASL framework to provide a interface support registering customized cipher, but that would be slow and depends on JDK release.  \n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-27T03:47:44Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "You're missing my point.\n\nThe goal is not to implement \"SASL encryption\". The goal is to implement _encryption_.\n\nThe AES encryption being added does _NOT_ need to follow any of the JVM's SASL APIs, because that's not the goal.\n\nBasically, when using AES, you're using SASL strictly for authentication.\n- open connection\n- authenticate using SASL\n- set up a netty channel handler that does encryption using AES\n\n_There is no SASL required in the last step._ The only reason it's involved in the last step now is because for DIGEST-MD5, the JDK mixes authentication and encryption. That is _not_ the case with AES.\n\nYou're writing suboptimal code just because you're trying to support a non-feature. If you ignore SASL once authentication is done, you can write much simpler and better code for the AES path.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-27T17:01:40Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Thanks for elaboration. I agree that implement a AES encryption can make code simpler.\n\nHowever, the original requirement is to replace the SASL encryption cipher with AES cipher when \"auth-conf\" is configured, which means we need to ensure both integrity and privacy protection in the last step you mentioned above. That's why the patch looks like implementing a SASL encryption. If we are going to implement a AES encryption over-the-wire not exactly same as auth-conf defined (bypass integrity check), then the code can be simpler and performance can also be improved. Which do we prefer?\n\nAbout setup Netty channel handler, the SaslEncryption class wraps the SaslEncryptionBackend as netty channelhandlers and add to channel pipeline. So implement SaslEncryptionBackend does same thing with setup separated netty channel handler, just different function name.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-28T05:54:10Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "The key negotiation part is fine. That doesn't need to change.\n\nBut I'm strongly against your argument that because `SaslEncryption` exists you shouldn't change it. That's an internal Spark class, you have all the right to change it. If you change it to work with ByteBuffers, the AES path automatically becomes more efficient, while there's no gain or loss for the old SASL-based path. Yes it's more code churn, but for a good cause.\n\nSimilarly, all your arguments about needing to calculate an HMAC and keep a sequence number are based on the internal JVM implementation of DIGEST-MD5 encryption. That's irrelevant to what you're trying to achieve here. Meaning that code is not necessary.\n\nBasically, being blunt, what I'm saying is that I'm opposed to your current approach and I will -1 your patch the way it is.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-28T17:28:09Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "In fact, you don't even need to touch `SaslEncryption` at all. After you negotiate the keys, you can just install an AES-specific netty handler directly into the pipeline, instead of calling `SaslEncryption.addToChannel`.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-28T17:46:00Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I understand your proposal and OK with the proposal, it should be more simpler.  I will update the patch accordingly.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-28T22:22:44Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I have removed the integrity check code it looks a bit simple now.\n\nAlso I am following your advice to setup netty channel handler for AES path and found SaslEncryption implement channel handler with lazy encryption and also it breaks incomming msg to chunks for transfer.  So I'm concerning about whether we need to do same mechanism with Sasl encryption for netty channel handler, or just a simple implement that encrypt and decrypt the incoming msg. Could you please help to give some advice?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-29T03:44:36Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "Lazy encryption is necessary, because the outbound pipeline is multi-threaded, and multiple threads might trigger the AES handler at the same time. So instead of encrypting in the handler method, you need to do like the SASL code and do it in a `FileRegion` implementation.\n\nFor AES, chunking should not be necessary. The SASL code chunks because it needs to know the size of each encrypted frame, to feed it to the `unwrap` method, otherwise decryption doesn't work. (Also to curb memory usage and avoid really large byte arrays.) AES should be able to decrypt the incoming bytes as they arrive, without the need for well-defined frames.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-29T16:53:34Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I have some concern need your help to confirm. \n1. According to AES cipher API definition, it need to know the size of the encrypted data. I'm not sure whether AES decrypt incoming bytes without well-defined frames. Does receiver will receive exactly same message/ByteBuf from sender without decoding?  \n2. It seems the new netty channel will look most same as SaslEncryption except the chunking you mentioned. So I think it would be better if we can reuse SaslEncryption here since chunking is also a optimization as it described.  Could you please help to advice?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-03T15:00:49Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "> I'm not sure whether AES decrypt incoming bytes without well-defined frames.\n\nThat's easily figured out. Just write some code to try it out!\n\nI actually specifically asked for test cases in Commons Crypto where the the size of blocks being encrypted and decrypted were different, because that should work when you're talking about decrypting a stream. You shouldn't need to frame things like you have to do with SASL.\n\n>  So I think it would be better if we can reuse SaslEncryption\n\nAs I've said already, this is all Spark code and you can do whatever you think is best. I've given you guidelines to what I think the solution would look like. But I'm not gonna give you super-fine-grained instructions on how to achieve that, otherwise I'd just write the code myself.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-03T17:14:15Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "I have update the preliminary patch to use AES encryption steaming as suggested, could you please help to review it? \n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-12T02:40:29Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Aside from the \"why so much copying\" and \"why not use ByteBuffer\" comments, there's a lot of magic numbers being used around this code...\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-23T19:00:45Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {\n+    byte[] mac = integrity.getHMAC(data, offset, len);\n+    integrity.incMySeqNum();\n+\n+    // Padding based on cipher\n+    byte[] padding;\n+    if (\"AES/CBC/NoPadding\".equals(encryptor.getAlgorithm())) {\n+      int bs = encryptor.getBlockSize();\n+      int pad = bs - (len + 10) % bs;\n+      padding = new byte[pad];\n+      for (int i = 0; i < pad; i ++) {\n+        padding[i] = (byte) pad;\n+      }\n+    } else {\n+      padding = EMPTY_BYTE_ARRAY;\n+    }\n+\n+    // Encrypt\n+    byte[] encrypted = new byte[len + 10 + padding.length + 4];"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Fixed magic numbers.\n\nActually, most of copies in wrap/unwrap are doing filling data not full copy, which should not cause any performance loss. Other copies also cannot be eliminated through ByteBuffer.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-09-27T07:36:10Z",
    "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import javax.crypto.Cipher;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.commons.crypto.cipher.CryptoCipher;\n+import org.apache.commons.crypto.utils.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * AES cipher for encryption and decryption.\n+ */\n+public class SparkAesCipher {\n+  private static final Logger logger = LoggerFactory.getLogger(SparkAesCipher.class);\n+  private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+  public final static String supportedTransformation[] = {\n+    \"AES/CBC/NoPadding\", \"AES/CTR/NoPadding\"\n+  };\n+\n+  private final CryptoCipher encryptor;\n+  private final CryptoCipher decryptor;\n+\n+  private final Integrity integrity;\n+\n+  public SparkAesCipher(\n+      String cipherTransformation,\n+      Properties properties,\n+      byte[] inKey,\n+      byte[] outKey,\n+      byte[] inIv,\n+      byte[] outIv) throws IOException {\n+    if (!Arrays.asList(supportedTransformation).contains(cipherTransformation)) {\n+      logger.warn(\"AES cipher transformation is not supported: \" + cipherTransformation);\n+      cipherTransformation = \"AES/CTR/NoPadding\";\n+      logger.warn(\"Use default AES/CTR/NoPadding\");\n+    }\n+\n+    final SecretKeySpec inKeySpec = new SecretKeySpec(inKey, \"AES\");\n+    final IvParameterSpec inIvSpec = new IvParameterSpec(inIv);\n+    final SecretKeySpec outKeySpec = new SecretKeySpec(outKey, \"AES\");\n+    final IvParameterSpec outIvSpec = new IvParameterSpec(outIv);\n+\n+    // Encryptor\n+    encryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize encryptor\");\n+      encryptor.init(Cipher.ENCRYPT_MODE, outKeySpec, outIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize encryptor\", e);\n+    }\n+\n+    // Decryptor\n+    decryptor = Utils.getCipherInstance(cipherTransformation, properties);\n+    try {\n+      logger.debug(\"Initialize decryptor\");\n+      decryptor.init(Cipher.DECRYPT_MODE, inKeySpec, inIvSpec);\n+    } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n+      throw new IOException(\"Failed to initialize decryptor\", e);\n+    }\n+\n+    integrity = new Integrity(outKey, inKey);\n+  }\n+\n+  /**\n+   * Encrypts input data. The result composes of (msg, padding if needed, mac) and sequence num.\n+   * @param data the input byte array\n+   * @param offset the offset in input where the input starts\n+   * @param len the input length\n+   * @return the new encrypted byte array.\n+   * @throws SaslException if error happens\n+   */\n+  public byte[] wrap(byte[] data, int offset, int len) throws SaslException {\n+    byte[] mac = integrity.getHMAC(data, offset, len);\n+    integrity.incMySeqNum();\n+\n+    // Padding based on cipher\n+    byte[] padding;\n+    if (\"AES/CBC/NoPadding\".equals(encryptor.getAlgorithm())) {\n+      int bs = encryptor.getBlockSize();\n+      int pad = bs - (len + 10) % bs;\n+      padding = new byte[pad];\n+      for (int i = 0; i < pad; i ++) {\n+        padding[i] = (byte) pad;\n+      }\n+    } else {\n+      padding = EMPTY_BYTE_ARRAY;\n+    }\n+\n+    // Encrypt\n+    byte[] encrypted = new byte[len + 10 + padding.length + 4];"
  }],
  "prId": 15172
}]