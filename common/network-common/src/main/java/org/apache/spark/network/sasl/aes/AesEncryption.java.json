[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why isn't this done once in the constructor? Then you can explicitly close it in the `channelInactive` callback, and avoid the cache in `AesCipher` too.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T23:14:12Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+\n+public class AesEncryption {\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  public static void addToChannel(Channel ch, AesCipher cipher) {\n+    ch.pipeline().addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(cipher))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(cipher));\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final AesCipher cipher;\n+    private ByteArrayWritableChannel byteChannel;\n+\n+    AesEncryptHandler(AesCipher cipher) {\n+      this.cipher = cipher;\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n+      throws Exception {\n+      ctx.write(new EncryptMessage(cipher, msg, byteChannel), promise);\n+    }\n+  }\n+\n+  private static class AesDecryptHandler extends ChannelInboundHandlerAdapter {\n+    private final AesCipher cipher;\n+    private CryptoInputStream cis;\n+    private ByteArrayReadableChannel byteChannel;\n+\n+    AesDecryptHandler(AesCipher cipher) {\n+      this.cipher = cipher;\n+      byteChannel = new ByteArrayReadableChannel();\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object data) throws Exception {\n+      ByteBuf in = (ByteBuf) data;\n+\n+      try {\n+        while (in.isReadable()) {\n+          byteChannel.feedData(in);\n+          cis = cipher.CreateInputStream(byteChannel);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Not sure why you need `ByteArrayWritableChannel`? `CryptoOutputStream` is already a `WritableByteChannel`, can't you write directly to it in `EncryptMessage`?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T23:18:43Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+\n+public class AesEncryption {\n+  public static final String ENCRYPTION_HANDLER_NAME = \"AesEncryption\";\n+  public static final String DECRYPTION_HANDLER_NAME = \"AesDecryption\";\n+\n+  public static void addToChannel(Channel ch, AesCipher cipher) {\n+    ch.pipeline().addFirst(ENCRYPTION_HANDLER_NAME, new AesEncryptHandler(cipher))\n+      .addFirst(DECRYPTION_HANDLER_NAME, new AesDecryptHandler(cipher));\n+  }\n+\n+  private static class AesEncryptHandler extends ChannelOutboundHandlerAdapter {\n+    private final AesCipher cipher;\n+    private ByteArrayWritableChannel byteChannel;\n+\n+    AesEncryptHandler(AesCipher cipher) {\n+      this.cipher = cipher;\n+      byteChannel = new ByteArrayWritableChannel(AesCipher.STREAM_BUFFER_SIZE);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I'm not a big fan of this class. It seems to be complicating the code instead of helping.\n\nInstead, if these static nested classes were instead child classes of `AesCipher`, you could simplify the code a lot.\n\nFirst, instead of adding the `negotiate` method to the SASL-related classes, it could live in the AesCipher code. e.g., following up on my comment in `SaslRpcHandler`:\n\n```\nif (!isAuthenticated) {\n  // code around current L125\n}\n\n// Here goes code to finish the AES key negotiation.\nAesCipher cipher = new AesCipher(...);\nrpcCallback.reply(cipher.createConfigMessage(...));\ncipher.addToChannel(...);\n```\n\n(Didn't really look at API details but hope you get the idea.)\n\nSecond, if things like `AesEncryptHandler` and `EncryptMessage` were nested non-static classes, you could remove the stream caches you have, making their life cycle more explicitly managed (and removing some weird code in the process).\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T23:28:46Z",
    "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.sasl.aes;\n+\n+import java.io.IOException;\n+import java.nio.channels.WritableByteChannel;\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.*;\n+import io.netty.util.AbstractReferenceCounted;\n+import org.apache.commons.crypto.stream.CryptoInputStream;\n+import org.apache.commons.crypto.stream.CryptoOutputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.spark.network.util.ByteArrayReadableChannel;\n+import org.apache.spark.network.util.ByteArrayWritableChannel;\n+\n+public class AesEncryption {"
  }],
  "prId": 15172
}]