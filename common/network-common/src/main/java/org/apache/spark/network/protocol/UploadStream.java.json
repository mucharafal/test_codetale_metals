[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "as a stream?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:05:15Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read in a stream."
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "The `equals()` and `hashCode()` implementations of this `UploadStream` class appear to differ slightly: the `equals()` method only checks equality of the `requestIds`, whereas this hashCode is checking both the `requestId` and the `body()`. I'm not sure what a `ManagedBuffer`'s `hashCode()` is: the `hashCode()` might not depend on the buffer contents, in which case this could lead to false hashCode mismatches for equal requests. Should we use just `requestId` here instead?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-30T22:13:12Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {\n+  /** Used to link an RPC request with its response. */\n+  public final long requestId;\n+  public final ManagedBuffer meta;\n+  public final long bodyByteCount;\n+\n+  public UploadStream(long requestId, ManagedBuffer meta, ManagedBuffer body) {\n+    super(body, false); // body is *not* included in the frame\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    bodyByteCount = body.size();\n+  }\n+\n+  // this version is called when decoding the bytes on the receiving end.  The body is handled\n+  // separately.\n+  private UploadStream(long requestId, ManagedBuffer meta, long bodyByteCount) {\n+    super(null, false);\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    this.bodyByteCount = bodyByteCount;\n+  }\n+\n+  @Override\n+  public Type type() { return Type.UploadStream; }\n+\n+  @Override\n+  public int encodedLength() {\n+    // the requestId, meta size, meta and bodyByteCount (body is not included)\n+    return 8 + 4 + ((int) meta.size()) + 8;\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    buf.writeLong(requestId);\n+    try {\n+      ByteBuffer metaBuf = meta.nioByteBuffer();\n+      buf.writeInt(metaBuf.remaining());\n+      buf.writeBytes(metaBuf);\n+    } catch (IOException io) {\n+      throw new RuntimeException(io);\n+    }\n+    buf.writeLong(bodyByteCount);\n+  }\n+\n+  public static UploadStream decode(ByteBuf buf) {\n+    long requestId = buf.readLong();\n+    int metaSize = buf.readInt();\n+    ManagedBuffer meta = new NettyManagedBuffer(buf.readRetainedSlice(metaSize));\n+    long bodyByteCount = buf.readLong();\n+    // This is called by the frame decoder, so the data is still null.  We need a StreamInterceptor\n+    // to read the data.\n+    return new UploadStream(requestId, meta, bodyByteCount);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(requestId, body());"
  }, {
    "author": {
      "login": "squito"
    },
    "body": "this is a good point.  Admittedly I just copied this from `StreamResponse` without thinking about it too much -- that class exhibits the same issue.  I'll remove `body` from both.\r\n\r\n(In practice, we're not using sticking them in hashmaps now so there wouldn't be any bugs in behavior because of this.)",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-31T03:10:02Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {\n+  /** Used to link an RPC request with its response. */\n+  public final long requestId;\n+  public final ManagedBuffer meta;\n+  public final long bodyByteCount;\n+\n+  public UploadStream(long requestId, ManagedBuffer meta, ManagedBuffer body) {\n+    super(body, false); // body is *not* included in the frame\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    bodyByteCount = body.size();\n+  }\n+\n+  // this version is called when decoding the bytes on the receiving end.  The body is handled\n+  // separately.\n+  private UploadStream(long requestId, ManagedBuffer meta, long bodyByteCount) {\n+    super(null, false);\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    this.bodyByteCount = bodyByteCount;\n+  }\n+\n+  @Override\n+  public Type type() { return Type.UploadStream; }\n+\n+  @Override\n+  public int encodedLength() {\n+    // the requestId, meta size, meta and bodyByteCount (body is not included)\n+    return 8 + 4 + ((int) meta.size()) + 8;\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    buf.writeLong(requestId);\n+    try {\n+      ByteBuffer metaBuf = meta.nioByteBuffer();\n+      buf.writeInt(metaBuf.remaining());\n+      buf.writeBytes(metaBuf);\n+    } catch (IOException io) {\n+      throw new RuntimeException(io);\n+    }\n+    buf.writeLong(bodyByteCount);\n+  }\n+\n+  public static UploadStream decode(ByteBuf buf) {\n+    long requestId = buf.readLong();\n+    int metaSize = buf.readInt();\n+    ManagedBuffer meta = new NettyManagedBuffer(buf.readRetainedSlice(metaSize));\n+    long bodyByteCount = buf.readLong();\n+    // This is called by the frame decoder, so the data is still null.  We need a StreamInterceptor\n+    // to read the data.\n+    return new UploadStream(requestId, meta, bodyByteCount);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(requestId, body());"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "JoshRosen"
    },
    "body": "Similar question here about whether `body()` is useful in this context: will this actually end up printing buffer contents, which are potentially huge? Or will it do something reasonable and print only the buffer type?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-30T22:17:25Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {\n+  /** Used to link an RPC request with its response. */\n+  public final long requestId;\n+  public final ManagedBuffer meta;\n+  public final long bodyByteCount;\n+\n+  public UploadStream(long requestId, ManagedBuffer meta, ManagedBuffer body) {\n+    super(body, false); // body is *not* included in the frame\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    bodyByteCount = body.size();\n+  }\n+\n+  // this version is called when decoding the bytes on the receiving end.  The body is handled\n+  // separately.\n+  private UploadStream(long requestId, ManagedBuffer meta, long bodyByteCount) {\n+    super(null, false);\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    this.bodyByteCount = bodyByteCount;\n+  }\n+\n+  @Override\n+  public Type type() { return Type.UploadStream; }\n+\n+  @Override\n+  public int encodedLength() {\n+    // the requestId, meta size, meta and bodyByteCount (body is not included)\n+    return 8 + 4 + ((int) meta.size()) + 8;\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    buf.writeLong(requestId);\n+    try {\n+      ByteBuffer metaBuf = meta.nioByteBuffer();\n+      buf.writeInt(metaBuf.remaining());\n+      buf.writeBytes(metaBuf);\n+    } catch (IOException io) {\n+      throw new RuntimeException(io);\n+    }\n+    buf.writeLong(bodyByteCount);\n+  }\n+\n+  public static UploadStream decode(ByteBuf buf) {\n+    long requestId = buf.readLong();\n+    int metaSize = buf.readInt();\n+    ManagedBuffer meta = new NettyManagedBuffer(buf.readRetainedSlice(metaSize));\n+    long bodyByteCount = buf.readLong();\n+    // This is called by the frame decoder, so the data is still null.  We need a StreamInterceptor\n+    // to read the data.\n+    return new UploadStream(requestId, meta, bodyByteCount);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(requestId, body());\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (other instanceof UploadStream) {\n+      UploadStream o = (UploadStream) other;\n+      return requestId == o.requestId && super.equals(o);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Objects.toStringHelper(this)\n+      .add(\"requestId\", requestId)\n+      .add(\"body\", body())",
    "line": 104
  }, {
    "author": {
      "login": "squito"
    },
    "body": "to be honest, this was also just parroted from other classes -- looking now at implementations of ManagedBuffer, if they have a `toString()` it does something reasonable.\r\n\r\nIs that actually useful for debugging?  maybe not, don't think I ever actually looked at this.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-31T03:14:05Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {\n+  /** Used to link an RPC request with its response. */\n+  public final long requestId;\n+  public final ManagedBuffer meta;\n+  public final long bodyByteCount;\n+\n+  public UploadStream(long requestId, ManagedBuffer meta, ManagedBuffer body) {\n+    super(body, false); // body is *not* included in the frame\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    bodyByteCount = body.size();\n+  }\n+\n+  // this version is called when decoding the bytes on the receiving end.  The body is handled\n+  // separately.\n+  private UploadStream(long requestId, ManagedBuffer meta, long bodyByteCount) {\n+    super(null, false);\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    this.bodyByteCount = bodyByteCount;\n+  }\n+\n+  @Override\n+  public Type type() { return Type.UploadStream; }\n+\n+  @Override\n+  public int encodedLength() {\n+    // the requestId, meta size, meta and bodyByteCount (body is not included)\n+    return 8 + 4 + ((int) meta.size()) + 8;\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    buf.writeLong(requestId);\n+    try {\n+      ByteBuffer metaBuf = meta.nioByteBuffer();\n+      buf.writeInt(metaBuf.remaining());\n+      buf.writeBytes(metaBuf);\n+    } catch (IOException io) {\n+      throw new RuntimeException(io);\n+    }\n+    buf.writeLong(bodyByteCount);\n+  }\n+\n+  public static UploadStream decode(ByteBuf buf) {\n+    long requestId = buf.readLong();\n+    int metaSize = buf.readInt();\n+    ManagedBuffer meta = new NettyManagedBuffer(buf.readRetainedSlice(metaSize));\n+    long bodyByteCount = buf.readLong();\n+    // This is called by the frame decoder, so the data is still null.  We need a StreamInterceptor\n+    // to read the data.\n+    return new UploadStream(requestId, meta, bodyByteCount);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(requestId, body());\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (other instanceof UploadStream) {\n+      UploadStream o = (UploadStream) other;\n+      return requestId == o.requestId && super.equals(o);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Objects.toStringHelper(this)\n+      .add(\"requestId\", requestId)\n+      .add(\"body\", body())",
    "line": 104
  }, {
    "author": {
      "login": "JoshRosen"
    },
    "body": "I'm not actually sure. I wonder if this is a latent problem in the old code waiting to happen in case we turn on trace logging. We can probably investigate that separately, but just wanted to note it since it seemed a little dodgy.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-02T17:38:14Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {\n+  /** Used to link an RPC request with its response. */\n+  public final long requestId;\n+  public final ManagedBuffer meta;\n+  public final long bodyByteCount;\n+\n+  public UploadStream(long requestId, ManagedBuffer meta, ManagedBuffer body) {\n+    super(body, false); // body is *not* included in the frame\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    bodyByteCount = body.size();\n+  }\n+\n+  // this version is called when decoding the bytes on the receiving end.  The body is handled\n+  // separately.\n+  private UploadStream(long requestId, ManagedBuffer meta, long bodyByteCount) {\n+    super(null, false);\n+    this.requestId = requestId;\n+    this.meta = meta;\n+    this.bodyByteCount = bodyByteCount;\n+  }\n+\n+  @Override\n+  public Type type() { return Type.UploadStream; }\n+\n+  @Override\n+  public int encodedLength() {\n+    // the requestId, meta size, meta and bodyByteCount (body is not included)\n+    return 8 + 4 + ((int) meta.size()) + 8;\n+  }\n+\n+  @Override\n+  public void encode(ByteBuf buf) {\n+    buf.writeLong(requestId);\n+    try {\n+      ByteBuffer metaBuf = meta.nioByteBuffer();\n+      buf.writeInt(metaBuf.remaining());\n+      buf.writeBytes(metaBuf);\n+    } catch (IOException io) {\n+      throw new RuntimeException(io);\n+    }\n+    buf.writeLong(bodyByteCount);\n+  }\n+\n+  public static UploadStream decode(ByteBuf buf) {\n+    long requestId = buf.readLong();\n+    int metaSize = buf.readInt();\n+    ManagedBuffer meta = new NettyManagedBuffer(buf.readRetainedSlice(metaSize));\n+    long bodyByteCount = buf.readLong();\n+    // This is called by the frame decoder, so the data is still null.  We need a StreamInterceptor\n+    // to read the data.\n+    return new UploadStream(requestId, meta, bodyByteCount);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(requestId, body());\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (other instanceof UploadStream) {\n+      UploadStream o = (UploadStream) other;\n+      return requestId == o.requestId && super.equals(o);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return Objects.toStringHelper(this)\n+      .add(\"requestId\", requestId)\n+      .add(\"body\", body())",
    "line": 104
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "witgo"
    },
    "body": "Is it possible to merge UploadStream and RpcRequest into a class?",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-14T02:23:07Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {",
    "line": 32
  }, {
    "author": {
      "login": "squito"
    },
    "body": "perhaps, but do you think that is really that useful?  the handling of them is different (both in the network layer and the outer RpcHandler).  And other things being equal, I'm biased to fewer changes to existing code paths.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-15T16:26:04Z",
    "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.network.protocol;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import com.google.common.base.Objects;\n+import io.netty.buffer.ByteBuf;\n+\n+import org.apache.spark.network.buffer.ManagedBuffer;\n+import org.apache.spark.network.buffer.NettyManagedBuffer;\n+\n+/**\n+ * An RPC with data that is sent outside of the frame, so it can be read as a stream.\n+ */\n+public final class UploadStream extends AbstractMessage implements RequestMessage {",
    "line": 32
  }],
  "prId": 21346
}]