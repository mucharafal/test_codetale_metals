[{
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "hm silent fallback isn't always the best idea. we should maybe at least log something.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T05:24:49Z",
    "diffHunk": "@@ -79,14 +80,27 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java native way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyForUnix(file);\n+        return;\n+      } catch (IOException e) {\n+        // ignore and fall back to the Java native way"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "Added logging\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T05:53:57Z",
    "diffHunk": "@@ -79,14 +80,27 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java native way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyForUnix(file);\n+        return;\n+      } catch (IOException e) {\n+        // ignore and fall back to the Java native way"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "rxin"
    },
    "body": "can we move this also into a private function named deleteRecursivelyUsingJavaIO\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T05:25:44Z",
    "diffHunk": "@@ -79,14 +80,27 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java native way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyForUnix(file);\n+        return;\n+      } catch (IOException e) {\n+        // ignore and fall back to the Java native way\n+      }\n+    }\n+\n     if (file.isDirectory() && !isSymlink(file)) {"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "done\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T05:54:16Z",
    "diffHunk": "@@ -79,14 +80,27 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java native way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyForUnix(file);\n+        return;\n+      } catch (IOException e) {\n+        // ignore and fall back to the Java native way\n+      }\n+    }\n+\n     if (file.isDirectory() && !isSymlink(file)) {"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "I think we already have a method for this, rather than need to pull in a new dependency just for this\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T06:49:40Z",
    "diffHunk": "@@ -79,14 +80,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {",
    "line": 26
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "It lead to cyclic dependency between spark-core and spark-network-common.\nI could move those methods related to finding OS from org.apache.spark.util.Utils (existing `isWindows`, `isMac` and new one `isUnix`) to a util class in `spark-network-common` (could be named as `OSIdentificationUtils`). That would need changing all instances in the codebase where those are being used to refer to the `OSIdentificationUtils` and also depend on `spark-network-common`. There are ~40 such places in the codebase. \nAs far as code organization is concerned, it would seem weird because `spark-core` seems to be a better place to host such utilities. Also, there are other methods related to OS stuff in spark-core's classes and one might as well move those to `OSIdentificationUtils` to make the logical grouping better but it means more refac and moving things around which will make this diff un-necessarily bigger than it is supposed to be.\n\nI have left this part as it is so get your comments.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T08:22:29Z",
    "diffHunk": "@@ -79,14 +80,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {",
    "line": 26
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Ah right, this is not somewhere that can use core. That's the same approach core uses already, so, LGTM. Yes, as a side point, the core module has fallen victim to the same problem it does in every project. It gets stuffed with miscellaneous code anytime something is needed in >1 module for convenience, rather than identify more specific new modules that need to be created to share dependencies, but soon becomes too heavy to be a dependency of everything and starts to fail in its purpose of hosting simple common code. You can see even \"more core\" modules trickling out into common/ now, as it kinda should have been.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T09:52:43Z",
    "diffHunk": "@@ -79,14 +80,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {",
    "line": 26
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Nits: this should happen after the builder is created\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T06:51:38Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "changed the order\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T08:22:44Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Invert this logic? if this isn't true, throw\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T06:51:58Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+\n+    try {\n+      process = builder.start();\n+      process.waitFor();\n+      if (process.exitValue() == 0 && !file.exists()) {"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "changed\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T08:22:50Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+\n+    try {\n+      process = builder.start();\n+      process.waitFor();\n+      if (process.exitValue() == 0 && !file.exists()) {"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This is caught by the containing block. Maybe store the status and take the check above out of the try block then for clarity\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T06:52:57Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+\n+    try {\n+      process = builder.start();\n+      process.waitFor();\n+      if (process.exitValue() == 0 && !file.exists()) {\n+        return;\n+      }\n+\n+      throw new IOException(\"Failed to delete: \" + file.getAbsolutePath());"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "done\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T08:23:00Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyForUnix(File file) throws IOException {\n+    Process process = null;\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+\n+    try {\n+      process = builder.start();\n+      process.waitFor();\n+      if (process.exitValue() == 0 && !file.exists()) {\n+        return;\n+      }\n+\n+      throw new IOException(\"Failed to delete: \" + file.getAbsolutePath());"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "When you create a process, you should always consume the input and error streams. Otherwise, when the underlying buffer is full, `waitFor` will be blocked forever. See Hadoop's Shell codes for example: https://github.com/apache/hadoop/blob/trunk/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java#L905\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T22:37:01Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyUsingUnixNative(File file) throws IOException {\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+    Process process = null;\n+    int exitCode = -1;\n+\n+    try {\n+      process = builder.start();\n+      exitCode = process.waitFor();"
  }, {
    "author": {
      "login": "zsxwing"
    },
    "body": "How about just using Hadoop's ShellCommandExecutor?\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-11T22:38:22Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyUsingUnixNative(File file) throws IOException {\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+    Process process = null;\n+    int exitCode = -1;\n+\n+    try {\n+      process = builder.start();\n+      exitCode = process.waitFor();"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "@zsxwing : Good catch. I am not going to use Hadoop's ShellCommandExecutor as it will lead to additional dependency for this small thing.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T03:17:36Z",
    "diffHunk": "@@ -109,6 +128,27 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyUsingUnixNative(File file) throws IOException {\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+    Process process = null;\n+    int exitCode = -1;\n+\n+    try {\n+      process = builder.start();\n+      exitCode = process.waitFor();"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "This works, but in Java 7 can we just redirect to `new File(\"/dev/null\")` because we know this is a Unix OS? Might be simpler. PS I don't think we generally put `final` on vars unless it's necessary.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T10:27:42Z",
    "diffHunk": "@@ -109,6 +129,40 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyUsingUnixNative(File file) throws IOException {\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+    Process process = null;\n+    int exitCode = -1;\n+\n+    try {\n+      // Merge error stream of the process with its stdout\n+      // Later stdout to be consumed using {@link Process#getInputStream()}\n+      builder.redirectErrorStream(true);\n+\n+      process = builder.start();\n+\n+      // In order to avoid deadlocks, consume the stdout (and stderr) of the process\n+      final BufferedInputStream in = new BufferedInputStream(process.getInputStream());"
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "changed\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T15:46:22Z",
    "diffHunk": "@@ -109,6 +129,40 @@ public static void deleteRecursively(File file) throws IOException {\n     }\n   }\n \n+  private static void deleteRecursivelyUsingUnixNative(File file) throws IOException {\n+    final ProcessBuilder builder = new ProcessBuilder(\"rm\", \"-rf\", file.getAbsolutePath());\n+    Process process = null;\n+    int exitCode = -1;\n+\n+    try {\n+      // Merge error stream of the process with its stdout\n+      // Later stdout to be consumed using {@link Process#getInputStream()}\n+      builder.redirectErrorStream(true);\n+\n+      process = builder.start();\n+\n+      // In order to avoid deadlocks, consume the stdout (and stderr) of the process\n+      final BufferedInputStream in = new BufferedInputStream(process.getInputStream());"
  }],
  "prId": 13042
}, {
  "comments": [{
    "author": {
      "login": "srowen"
    },
    "body": "Last nits: This could go after the log statement, in the catch clause, then the \"return;\" can be removed? might be simpler to keep it together like that. Also, if you're making one more pass, undo removing the blank line near the end of this file. It seems good to me at this stage.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T15:55:02Z",
    "diffHunk": "@@ -79,14 +81,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyUsingUnixNative(file);\n+        return;\n+      } catch (IOException e) {\n+        logger.warn(\"Attempt to delete using native Unix OS command failed for path = {}. \" +\n+                        \"Falling back to Java IO way\", file.getAbsolutePath(), e);\n+      }\n+    }\n+\n+    deleteRecursivelyUsingJavaIO(file);",
    "line": 36
  }, {
    "author": {
      "login": "tejasapatil"
    },
    "body": "- I kept it outside catch because we need to also take care of case when the OS is non unix\n- Reverted removing the blank line near the end of file\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T16:28:27Z",
    "diffHunk": "@@ -79,14 +81,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyUsingUnixNative(file);\n+        return;\n+      } catch (IOException e) {\n+        logger.warn(\"Attempt to delete using native Unix OS command failed for path = {}. \" +\n+                        \"Falling back to Java IO way\", file.getAbsolutePath(), e);\n+      }\n+    }\n+\n+    deleteRecursivelyUsingJavaIO(file);",
    "line": 36
  }, {
    "author": {
      "login": "srowen"
    },
    "body": "Oh duh my mistake, from reading the abbreviated diff. There's an extra level of logic here. Yes it's fine.\n",
    "commit": "a6eda9447daa8e404518eb16810824bc1a55af61",
    "createdAt": "2016-05-12T16:46:13Z",
    "diffHunk": "@@ -79,14 +81,32 @@ public static String bytesToString(ByteBuffer b) {\n     return Unpooled.wrappedBuffer(b).toString(StandardCharsets.UTF_8);\n   }\n \n-  /*\n+  /**\n    * Delete a file or directory and its contents recursively.\n    * Don't follow directories if they are symlinks.\n-   * Throws an exception if deletion is unsuccessful.\n+   *\n+   * @param file Input file / dir to be deleted\n+   * @throws IOException if deletion is unsuccessful\n    */\n   public static void deleteRecursively(File file) throws IOException {\n     if (file == null) { return; }\n \n+    // On Unix systems, use operating system command to run faster\n+    // If that does not work out, fallback to the Java IO way\n+    if (SystemUtils.IS_OS_UNIX) {\n+      try {\n+        deleteRecursivelyUsingUnixNative(file);\n+        return;\n+      } catch (IOException e) {\n+        logger.warn(\"Attempt to delete using native Unix OS command failed for path = {}. \" +\n+                        \"Falling back to Java IO way\", file.getAbsolutePath(), e);\n+      }\n+    }\n+\n+    deleteRecursivelyUsingJavaIO(file);",
    "line": 36
  }],
  "prId": 13042
}]