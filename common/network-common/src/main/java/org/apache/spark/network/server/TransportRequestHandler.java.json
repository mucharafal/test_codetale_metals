[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "These are in the wrong place.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-05-25T20:15:17Z",
    "diffHunk": "@@ -23,25 +23,16 @@\n import com.google.common.base.Throwables;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n+import org.apache.spark.network.protocol.*;"
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "it's",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-14T22:20:26Z",
    "diffHunk": "@@ -203,6 +197,76 @@ public void onFailure(Throwable e) {\n     }\n   }\n \n+  /**\n+   * Handle a request from the client to upload a stream of data.\n+   */\n+  private void processStreamUpload(final UploadStream req) {\n+    assert (req.body() == null);\n+    try {\n+      RpcResponseCallback callback = new RpcResponseCallback() {\n+        @Override\n+        public void onSuccess(ByteBuffer response) {\n+          respond(new RpcResponse(req.requestId, new NioManagedBuffer(response)));\n+        }\n+\n+        @Override\n+        public void onFailure(Throwable e) {\n+          respond(new RpcFailure(req.requestId, Throwables.getStackTraceAsString(e)));\n+        }\n+      };\n+      TransportFrameDecoder frameDecoder = (TransportFrameDecoder)\n+          channel.pipeline().get(TransportFrameDecoder.HANDLER_NAME);\n+      ByteBuffer meta = req.meta.nioByteBuffer();\n+      StreamCallbackWithID streamHandler = rpcHandler.receiveStream(reverseClient, meta, callback);\n+      StreamCallbackWithID wrappedCallback = new StreamCallbackWithID() {\n+        @Override\n+        public void onData(String streamId, ByteBuffer buf) throws IOException {\n+          streamHandler.onData(streamId, buf);\n+        }\n+\n+        @Override\n+        public void onComplete(String streamId) throws IOException {\n+           try {\n+             streamHandler.onComplete(streamId);\n+             callback.onSuccess(ByteBuffer.allocate(0));\n+           } catch (Exception ex) {\n+             IOException ioExc = new IOException(\"Failure post-processing complete stream;\" +\n+               \" failing this rpc and leaving channel active\");\n+             callback.onFailure(ioExc);\n+             streamHandler.onFailure(streamId, ioExc);\n+           }\n+        }\n+\n+        @Override\n+        public void onFailure(String streamId, Throwable cause) throws IOException {\n+          callback.onFailure(new IOException(\"Destination failed while reading stream\", cause));\n+          streamHandler.onFailure(streamId, cause);\n+        }\n+\n+        @Override\n+        public String getID() {\n+          return streamHandler.getID();\n+        }\n+      };\n+      if (req.bodyByteCount > 0) {\n+        StreamInterceptor interceptor = new StreamInterceptor(this, wrappedCallback.getID(),\n+          req.bodyByteCount, wrappedCallback);\n+        frameDecoder.setInterceptor(interceptor);\n+      } else {\n+        wrappedCallback.onComplete(wrappedCallback.getID());\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"Error while invoking RpcHandler#receive() on RPC id \" + req.requestId, e);\n+      respond(new RpcFailure(req.requestId, Throwables.getStackTraceAsString(e)));\n+      // We choose to totally fail the channel, rather than trying to recover as we do in other\n+      // cases.  We don't know how many bytes of the stream the client has already sent for the\n+      // stream, its not worth trying to recover."
  }],
  "prId": 21346
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Check for null? Otherwise you'll get some weird NPE buried in some other code path.",
    "commit": "cd11abc3261d6f37731aa4574705119e0ac57a93",
    "createdAt": "2018-06-15T17:50:59Z",
    "diffHunk": "@@ -203,6 +197,76 @@ public void onFailure(Throwable e) {\n     }\n   }\n \n+  /**\n+   * Handle a request from the client to upload a stream of data.\n+   */\n+  private void processStreamUpload(final UploadStream req) {\n+    assert (req.body() == null);\n+    try {\n+      RpcResponseCallback callback = new RpcResponseCallback() {\n+        @Override\n+        public void onSuccess(ByteBuffer response) {\n+          respond(new RpcResponse(req.requestId, new NioManagedBuffer(response)));\n+        }\n+\n+        @Override\n+        public void onFailure(Throwable e) {\n+          respond(new RpcFailure(req.requestId, Throwables.getStackTraceAsString(e)));\n+        }\n+      };\n+      TransportFrameDecoder frameDecoder = (TransportFrameDecoder)\n+          channel.pipeline().get(TransportFrameDecoder.HANDLER_NAME);\n+      ByteBuffer meta = req.meta.nioByteBuffer();\n+      StreamCallbackWithID streamHandler = rpcHandler.receiveStream(reverseClient, meta, callback);",
    "line": 74
  }],
  "prId": 21346
}]