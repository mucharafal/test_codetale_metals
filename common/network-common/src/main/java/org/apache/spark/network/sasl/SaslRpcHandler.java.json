[{
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Why are you catching this exception and doing nothing with it?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T22:43:42Z",
    "diffHunk": "@@ -71,56 +75,78 @@\n     this.secretKeyHolder = secretKeyHolder;\n     this.saslServer = null;\n     this.isComplete = false;\n+    this.isAuthenticated = false;\n   }\n \n   @Override\n   public void receive(TransportClient client, ByteBuffer message, RpcResponseCallback callback) {\n+    boolean encrypt = conf.saslServerAlwaysEncrypt();\n     if (isComplete) {\n       // Authentication complete, delegate to base handler.\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder, encrypt);\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n       if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n-        logger.debug(\"Enabling encryption for channel {}\", client);\n-        SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n+        try {\n+          if (conf.saslEncryptionAesEnabled()) {\n+            // Extra negotiation should happen after authentication, so return directly while\n+            // processing authenticate.\n+            if (!isAuthenticated) {\n+              logger.debug(\"SASL authentication successful for channel {}\", client);\n+              isAuthenticated = true;\n+              return ;\n+            } else {\n+              Object result = saslServer.negotiate(message, callback, conf);\n+              if (result instanceof AesCipher) {\n+                logger.debug(\"Enabling AES cipher for Server channel {}\", client);\n+                AesEncryption.addToChannel(channel, (AesCipher) result);\n+              }\n+            }\n+          } else {\n+            logger.info(\"Enabling encryption for channel {}\", client);\n+            SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n+          }\n+          saslServer = null;\n+        } catch (SaslException e) {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: move this later closer to where it's used; avoids the method call when not necessary.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T22:45:14Z",
    "diffHunk": "@@ -71,56 +75,78 @@\n     this.secretKeyHolder = secretKeyHolder;\n     this.saslServer = null;\n     this.isComplete = false;\n+    this.isAuthenticated = false;\n   }\n \n   @Override\n   public void receive(TransportClient client, ByteBuffer message, RpcResponseCallback callback) {\n+    boolean encrypt = conf.saslServerAlwaysEncrypt();"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "I think this would be easier to follow like this:\n\n```\nif (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n  // No encryption negotiated. Code around L145\n  return;\n}\n\nif (!conf.saslEncryptionAesEnabled()) {\n  // non-aes stuff\n  return;\n}\n\nif (!isAuthenticated) {\n  // code around current L125\n}\n\n// Here goes code to finish the AES key negotiation.\n```\n\nYou'll need to set `isComplete = true` in the appropriate places too (instead of the single statement at the end currently).\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-14T22:49:34Z",
    "diffHunk": "@@ -71,56 +75,78 @@\n     this.secretKeyHolder = secretKeyHolder;\n     this.saslServer = null;\n     this.isComplete = false;\n+    this.isAuthenticated = false;\n   }\n \n   @Override\n   public void receive(TransportClient client, ByteBuffer message, RpcResponseCallback callback) {\n+    boolean encrypt = conf.saslServerAlwaysEncrypt();\n     if (isComplete) {\n       // Authentication complete, delegate to base handler.\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder, encrypt);\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n       if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n-        logger.debug(\"Enabling encryption for channel {}\", client);\n-        SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n+        try {\n+          if (conf.saslEncryptionAesEnabled()) {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "At this point you're not using `saslServer` anymore, so you should dispose of it. I kinda prefer my previous suggestion where instead of `if..else` you have just `if`s and `return`s. I think it makes it a little easier to follow the code.\n\nYou can abstract the `saslServer` cleanup by adding a `complete(boolean dispose)` method that updates `isComplete` and `saslServer` and is called from this method where needed.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-24T20:32:55Z",
    "diffHunk": "@@ -80,47 +84,79 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        saslServer.dispose();\n+        saslServer = null;\n+        isComplete = true;\n+        return ;\n+      }\n+\n+      if (!conf.saslEncryptionAesEnabled()) {\n         logger.debug(\"Enabling encryption for channel {}\", client);\n         SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n       } else {\n-        saslServer.dispose();\n-        saslServer = null;\n+        // Extra negotiation should happen after authentication, so return directly while\n+        // processing authenticate.\n+        if (!isAuthenticated) {\n+          logger.debug(\"SASL authentication successful for channel {}\", client);\n+          isAuthenticated = true;\n+          return;\n+        } else {\n+          try {\n+            AesConfigMessage configMessage = AesConfigMessage.decodeMessage(message);\n+            configMessage = AesCipher.responseConfigMessage(configMessage);\n+            AesCipher cipher = new AesCipher(configMessage);\n+\n+            ByteBuffer buf = configMessage.encodeMessage();\n+\n+            // Encrypt the config message.\n+            ByteBuffer encrypted = ByteBuffer.wrap(\n+              saslServer.wrap(buf.array(), 0, buf.array().length));\n+            callback.onSuccess(encrypted);"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "nit: no space before `;`\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:27:40Z",
    "diffHunk": "@@ -80,46 +84,71 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        complete(true);\n+        return ;"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "This should really be the last statement (after `complete(true)`).\n\nIt's a little weird to use the name of the transformation as the success message here... I'd say a reply is not even needed, but it's nice for the client to know that this particular message succeeded or not. So it's ok to use this, but I'd prefer if the client ignored the contents of the reply and instead just handled exceptions for the error case.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-10-31T22:33:10Z",
    "diffHunk": "@@ -80,46 +84,71 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        complete(true);\n+        return ;\n+      }\n+\n+      if (!conf.AesEncryptionEnabled()) {\n         logger.debug(\"Enabling encryption for channel {}\", client);\n         SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n-      } else {\n-        saslServer.dispose();\n-        saslServer = null;\n+        complete(false);\n+        return;\n+      }\n+\n+      // Extra negotiation should happen after authentication, so return directly while\n+      // processing authenticate.\n+      if (!isAuthenticated) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        isAuthenticated = true;\n+        return;\n+      }\n+\n+      // Create AES cipher when it is authenticated\n+      try {\n+        AesConfigMessage configMessage = AesConfigMessage.decodeMessage(message);\n+        AesCipher cipher = new AesCipher(configMessage);\n+\n+        // Send response back to client to confirm that server accept config.\n+        callback.onSuccess(JavaUtils.stringToBytes(AesCipher.TRANSFORM));"
  }, {
    "author": {
      "login": "chenjunjiedada"
    },
    "body": "Callback.onSuccess should be called before addToChannel. Otherwise it will be sent with encrypted data while at the moment client is not ready for decryption.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-01T05:00:14Z",
    "diffHunk": "@@ -80,46 +84,71 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        complete(true);\n+        return ;\n+      }\n+\n+      if (!conf.AesEncryptionEnabled()) {\n         logger.debug(\"Enabling encryption for channel {}\", client);\n         SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n-      } else {\n-        saslServer.dispose();\n-        saslServer = null;\n+        complete(false);\n+        return;\n+      }\n+\n+      // Extra negotiation should happen after authentication, so return directly while\n+      // processing authenticate.\n+      if (!isAuthenticated) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        isAuthenticated = true;\n+        return;\n+      }\n+\n+      // Create AES cipher when it is authenticated\n+      try {\n+        AesConfigMessage configMessage = AesConfigMessage.decodeMessage(message);\n+        AesCipher cipher = new AesCipher(configMessage);\n+\n+        // Send response back to client to confirm that server accept config.\n+        callback.onSuccess(JavaUtils.stringToBytes(AesCipher.TRANSFORM));"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "`JavaUtils.bufferToArray` here too?\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T04:13:42Z",
    "diffHunk": "@@ -80,46 +84,80 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        complete(true);\n+        return;\n+      }\n+\n+      if (!conf.aesEncryptionEnabled()) {\n         logger.debug(\"Enabling encryption for channel {}\", client);\n         SaslEncryption.addToChannel(channel, saslServer, conf.maxSaslEncryptedBlockSize());\n-        saslServer = null;\n-      } else {\n-        saslServer.dispose();\n-        saslServer = null;\n+        complete(false);\n+        return;\n+      }\n+\n+      // Extra negotiation should happen after authentication, so return directly while\n+      // processing authenticate.\n+      if (!isAuthenticated) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);\n+        isAuthenticated = true;\n+        return;\n+      }\n+\n+      // Create AES cipher when it is authenticated\n+      try {\n+        byte[] encrypted;\n+        if (message.hasArray()) {"
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "zsxwing"
    },
    "body": "nit: this is a failure.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T06:31:47Z",
    "diffHunk": "@@ -80,46 +84,74 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);",
    "line": 86
  }, {
    "author": {
      "login": "vanzin"
    },
    "body": "No, the message is correct. This means auth was successful and encryption (`auth-conf`) isn't being used.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T17:37:44Z",
    "diffHunk": "@@ -80,46 +84,74 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n       delegate.receive(client, message, callback);\n       return;\n     }\n+    if (saslServer == null || !saslServer.isComplete()) {\n+      ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n+      SaslMessage saslMessage;\n+      try {\n+        saslMessage = SaslMessage.decode(nettyBuf);\n+      } finally {\n+        nettyBuf.release();\n+      }\n \n-    ByteBuf nettyBuf = Unpooled.wrappedBuffer(message);\n-    SaslMessage saslMessage;\n-    try {\n-      saslMessage = SaslMessage.decode(nettyBuf);\n-    } finally {\n-      nettyBuf.release();\n-    }\n-\n-    if (saslServer == null) {\n-      // First message in the handshake, setup the necessary state.\n-      client.setClientId(saslMessage.appId);\n-      saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n-        conf.saslServerAlwaysEncrypt());\n-    }\n+      if (saslServer == null) {\n+        // First message in the handshake, setup the necessary state.\n+        client.setClientId(saslMessage.appId);\n+        saslServer = new SparkSaslServer(saslMessage.appId, secretKeyHolder,\n+          conf.saslServerAlwaysEncrypt());\n+      }\n \n-    byte[] response;\n-    try {\n-      response = saslServer.response(JavaUtils.bufferToArray(\n-        saslMessage.body().nioByteBuffer()));\n-    } catch (IOException ioe) {\n-      throw new RuntimeException(ioe);\n+      byte[] response;\n+      try {\n+        response = saslServer.response(JavaUtils.bufferToArray(\n+          saslMessage.body().nioByteBuffer()));\n+      } catch (IOException ioe) {\n+        throw new RuntimeException(ioe);\n+      }\n+      callback.onSuccess(ByteBuffer.wrap(response));\n     }\n-    callback.onSuccess(ByteBuffer.wrap(response));\n \n     // Setup encryption after the SASL response is sent, otherwise the client can't parse the\n     // response. It's ok to change the channel pipeline here since we are processing an incoming\n     // message, so the pipeline is busy and no new incoming messages will be fed to it before this\n     // method returns. This assumes that the code ensures, through other means, that no outbound\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n-      logger.debug(\"SASL authentication successful for channel {}\", client);\n-      isComplete = true;\n-      if (SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+      if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n+        logger.debug(\"SASL authentication successful for channel {}\", client);",
    "line": 86
  }],
  "prId": 15172
}, {
  "comments": [{
    "author": {
      "login": "vanzin"
    },
    "body": "Please restore this message.\n",
    "commit": "6863efe77118f91c0f849d34d4698dad608213b1",
    "createdAt": "2016-11-10T18:54:14Z",
    "diffHunk": "@@ -117,7 +117,6 @@ public void receive(TransportClient client, ByteBuffer message, RpcResponseCallb\n     // messages are being written to the channel while negotiation is still going on.\n     if (saslServer.isComplete()) {\n       if (!SparkSaslServer.QOP_AUTH_CONF.equals(saslServer.getNegotiatedProperty(Sasl.QOP))) {\n-        logger.debug(\"SASL authentication successful for channel {}\", client);"
  }],
  "prId": 15172
}]