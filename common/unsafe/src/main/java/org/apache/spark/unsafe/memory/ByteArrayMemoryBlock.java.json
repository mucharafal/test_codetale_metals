[{
  "comments": [{
    "author": {
      "login": "tejasapatil"
    },
    "body": "but its `private` at L34 ",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-09-13T20:59:33Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.unsafe.memory;\r\n+\r\n+import org.apache.spark.unsafe.Platform;\r\n+\r\n+/**\r\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\r\n+ */\r\n+public class ByteArrayMemoryBlock extends MemoryLocation implements MemoryBlock {\r\n+\r\n+  private final long length;\r\n+\r\n+  /**\r\n+   * Optional page number; used when this MemoryBlock represents a page allocated by a\r\n+   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\r"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "thanks, updated comments",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-09-14T19:35:17Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.unsafe.memory;\r\n+\r\n+import org.apache.spark.unsafe.Platform;\r\n+\r\n+/**\r\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\r\n+ */\r\n+public class ByteArrayMemoryBlock extends MemoryLocation implements MemoryBlock {\r\n+\r\n+  private final long length;\r\n+\r\n+  /**\r\n+   * Optional page number; used when this MemoryBlock represents a page allocated by a\r\n+   * TaskMemoryManager. This field is public so that it can be modified by the TaskMemoryManager,\r"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "hvanhovell"
    },
    "body": "Why do we need different implementations of a MemoryBlock? We should be able to have all required functionality with one class, and a little bit of offset magic.\r\n\r\nI am opposed to creating a class hierarchy because this is super performance critical code. Polymorphism will slow us down.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-09-13T21:02:25Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.unsafe.memory;\r\n+\r\n+import org.apache.spark.unsafe.Platform;\r\n+\r\n+/**\r\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\r\n+ */\r\n+public class ByteArrayMemoryBlock extends MemoryLocation implements MemoryBlock {\r"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@hvanhovell I agree with your concern about performance due to creating a class hierarchy.\r\nThis implementation uses class hierarchy for two cases\r\n1. Statically select target method using signature (e.g. Platform.getInt())\r\n2. Dynamically select target method using receiver (e.g. MemoryBlock.getBaseOffset())\r\n\r\nCase 1 does not affect performance since it is resolved at javac. Case 2 is your concern. Since case 2. is used mainly for `getBaseObject()` and `getBaseOffset()` at performance critical path. These two methods must be `final method` (i.e. we expect method inlining by JIT compiler).\r\n\r\n1. `MemoryLocation` is dropped\r\n2. Several implementation classes extends `MemoryBlock` after making `MemoryBlock` abstract` as follows:\r\n\r\n```java\r\npublic abstract class MemoryBlock {\r\n  Object obj;\r\n  long offset;\r\n\r\n  public MemoryBlock(Object obj, long offset) {\r\n    this.obj = obj;\r\n    this.offset = offset;\r\n  }\r\n\r\n  public final Object getBaseObject() { return obj; }\r\n  public final long getBaseOffset() { return offset; }\r\n\r\n  abstract long size();\r\n  abstract void setPageNumber(int pageNum);\r\n  abstract int getPageNumber();\r\n  abstract void fill(byte value);\r\n  abstract MemoryBlock allocate(long offset, long size);\r\n}\r\n```\r\n\r\nWhat do you think?\r\n\r\n\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-09-14T02:50:23Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.unsafe.memory;\r\n+\r\n+import org.apache.spark.unsafe.Platform;\r\n+\r\n+/**\r\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\r\n+ */\r\n+public class ByteArrayMemoryBlock extends MemoryLocation implements MemoryBlock {\r"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Updated",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-09-14T19:34:49Z",
    "diffHunk": "@@ -0,0 +1,74 @@\n+/*\r\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\r\n+ * contributor license agreements.  See the NOTICE file distributed with\r\n+ * this work for additional information regarding copyright ownership.\r\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\r\n+ * (the \"License\"); you may not use this file except in compliance with\r\n+ * the License.  You may obtain a copy of the License at\r\n+ *\r\n+ *    http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+\r\n+package org.apache.spark.unsafe.memory;\r\n+\r\n+import org.apache.spark.unsafe.Platform;\r\n+\r\n+/**\r\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\r\n+ */\r\n+public class ByteArrayMemoryBlock extends MemoryLocation implements MemoryBlock {\r"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "just `array[offset]`?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-21T08:49:12Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {\n+    super(obj, offset, length);\n+    this.array = obj;\n+  }\n+\n+  @Override\n+  public MemoryBlock allocate(long offset, long size) {\n+    return new ByteArrayMemoryBlock(array, offset, size);\n+  }\n+\n+  public byte[] getByteArray() { return array; }\n+\n+  /**\n+   * Creates a memory block pointing to the memory used by the byte array.\n+   */\n+  public static ByteArrayMemoryBlock fromArray(final byte[] array) {\n+    return new ByteArrayMemoryBlock(array, Platform.BYTE_ARRAY_OFFSET, array.length);\n+  }\n+\n+\n+  public final int getInt(long offset) {\n+    return Platform.getInt(array, offset);\n+  }\n+\n+  public final void putInt(long offset, int value) {\n+    Platform.putInt(array, offset, value);\n+  }\n+\n+  public final boolean getBoolean(long offset) {\n+    return Platform.getBoolean(array, offset);\n+  }\n+\n+  public final void putBoolean(long offset, boolean value) {\n+    Platform.putBoolean(array, offset, value);\n+  }\n+\n+  public final byte getByte(long offset) {\n+    return Platform.getByte(array, offset);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "We can use `array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)]`",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-21T17:45:01Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {\n+    super(obj, offset, length);\n+    this.array = obj;\n+  }\n+\n+  @Override\n+  public MemoryBlock allocate(long offset, long size) {\n+    return new ByteArrayMemoryBlock(array, offset, size);\n+  }\n+\n+  public byte[] getByteArray() { return array; }\n+\n+  /**\n+   * Creates a memory block pointing to the memory used by the byte array.\n+   */\n+  public static ByteArrayMemoryBlock fromArray(final byte[] array) {\n+    return new ByteArrayMemoryBlock(array, Platform.BYTE_ARRAY_OFFSET, array.length);\n+  }\n+\n+\n+  public final int getInt(long offset) {\n+    return Platform.getInt(array, offset);\n+  }\n+\n+  public final void putInt(long offset, int value) {\n+    Platform.putInt(array, offset, value);\n+  }\n+\n+  public final boolean getBoolean(long offset) {\n+    return Platform.getBoolean(array, offset);\n+  }\n+\n+  public final void putBoolean(long offset, boolean value) {\n+    Platform.putBoolean(array, offset, value);\n+  }\n+\n+  public final byte getByte(long offset) {\n+    return Platform.getByte(array, offset);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "I don't see `MemoryLocation` used here.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-21T08:49:35Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size."
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Good catch. I will remove `MemoryLocation` and this comment.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-21T17:45:31Z",
    "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size."
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "let me raise my question again. Since `MemoryBlock` has `baseObj` and `baseOffset`, We can implement `getInt`, `copyTo`, etc. in `MemoryBlock` as final method. However we put them in concrete implementations, for performance concerns. This is not ideal as the implementation code are very similar, so we should only do it if it really has perf benefit.\r\n\r\nI'd like to create a benchmark for `MemoryBlock` and keep the benchmark in the codebase, so it's easy to verify the perf gains.\r\n\r\nParticularly, I'm a little worried about the `copyFrom`. By the theory, `Platform.copyMemory` should run faster if both the `srcObj` and `dstObj` has concrete type. To make `srcObj` has concrete type, we create many varieties of `copyFrom`, like `copyFom(byte[] ...)`, `copyFrom(long[] ...)`, etc. To make `dstObj` has concrete type, we implement various `copyFrom` in all kinds of memory blocks. My question is, do both of them have perf benefit?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-23T16:54:28Z",
    "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {\n+    super(obj, offset, length);\n+    this.array = obj;\n+  }\n+\n+  @Override\n+  public MemoryBlock allocate(long offset, long size) {\n+    return new ByteArrayMemoryBlock(array, offset, size);\n+  }\n+\n+  public byte[] getByteArray() { return array; }\n+\n+  /**\n+   * Creates a memory block pointing to the memory used by the byte array.\n+   */\n+  public static ByteArrayMemoryBlock fromArray(final byte[] array) {\n+    return new ByteArrayMemoryBlock(array, Platform.BYTE_ARRAY_OFFSET, array.length);\n+  }\n+\n+\n+  public final int getInt(long offset) {\n+    // UTF8String.getPrefix() assumes data is 4-byte aligned\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 3) / 4) * 4);\n+    return Platform.getInt(array, offset);\n+  }\n+\n+  public final void putInt(long offset, int value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putInt(array, offset, value);\n+  }\n+\n+  public final boolean getBoolean(long offset) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getBoolean(array, offset);\n+  }\n+\n+  public final void putBoolean(long offset, boolean value) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putBoolean(array, offset, value);\n+  }\n+\n+  public final byte getByte(long offset) {\n+    return array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)];\n+  }\n+\n+  public final void putByte(long offset, byte value) {\n+    array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)] = value;\n+  }\n+\n+  public final short getShort(long offset) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getShort(array, offset);\n+  }\n+\n+  public final void putShort(long offset, short value) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putShort(array, offset, value);\n+  }\n+\n+  public final long getLong(long offset) {\n+    // UTF8String.getPrefix() assumes data is 8-byte aligned\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 7) / 8) * 8);\n+    return Platform.getLong(array, offset);\n+  }\n+\n+  public final void putLong(long offset, long value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putLong(array, offset, value);\n+  }\n+\n+  public final float getFloat(long offset) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getFloat(array, offset);\n+  }\n+\n+  public final void putFloat(long offset, float value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putFloat(array, offset, value);\n+  }\n+\n+  public final double getDouble(long offset) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getDouble(array, offset);\n+  }\n+\n+  public final void putDouble(long offset, double value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putDouble(array, offset, value);\n+  }\n+\n+  public final void copyFrom(byte[] src, long srcOffset, long dstOffset, long length) {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Sure, I will create and run benchmark programs this weekend. Thus, I did not change this part in the last commit. I should have mentioned this postpone. Sorry.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-23T17:47:05Z",
    "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {\n+    super(obj, offset, length);\n+    this.array = obj;\n+  }\n+\n+  @Override\n+  public MemoryBlock allocate(long offset, long size) {\n+    return new ByteArrayMemoryBlock(array, offset, size);\n+  }\n+\n+  public byte[] getByteArray() { return array; }\n+\n+  /**\n+   * Creates a memory block pointing to the memory used by the byte array.\n+   */\n+  public static ByteArrayMemoryBlock fromArray(final byte[] array) {\n+    return new ByteArrayMemoryBlock(array, Platform.BYTE_ARRAY_OFFSET, array.length);\n+  }\n+\n+\n+  public final int getInt(long offset) {\n+    // UTF8String.getPrefix() assumes data is 4-byte aligned\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 3) / 4) * 4);\n+    return Platform.getInt(array, offset);\n+  }\n+\n+  public final void putInt(long offset, int value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putInt(array, offset, value);\n+  }\n+\n+  public final boolean getBoolean(long offset) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getBoolean(array, offset);\n+  }\n+\n+  public final void putBoolean(long offset, boolean value) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putBoolean(array, offset, value);\n+  }\n+\n+  public final byte getByte(long offset) {\n+    return array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)];\n+  }\n+\n+  public final void putByte(long offset, byte value) {\n+    array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)] = value;\n+  }\n+\n+  public final short getShort(long offset) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getShort(array, offset);\n+  }\n+\n+  public final void putShort(long offset, short value) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putShort(array, offset, value);\n+  }\n+\n+  public final long getLong(long offset) {\n+    // UTF8String.getPrefix() assumes data is 8-byte aligned\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 7) / 8) * 8);\n+    return Platform.getLong(array, offset);\n+  }\n+\n+  public final void putLong(long offset, long value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putLong(array, offset, value);\n+  }\n+\n+  public final float getFloat(long offset) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getFloat(array, offset);\n+  }\n+\n+  public final void putFloat(long offset, float value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putFloat(array, offset, value);\n+  }\n+\n+  public final double getDouble(long offset) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getDouble(array, offset);\n+  }\n+\n+  public final void putDouble(long offset, double value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putDouble(array, offset, value);\n+  }\n+\n+  public final void copyFrom(byte[] src, long srcOffset, long dstOffset, long length) {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@cloud-fan, I have noticed that I already ran [benchmark|https://github.com/apache/spark/pull/19222#issuecomment-331730515] for `Platform.copyMemory`. Here is the result.\r\n```\r\nPlatform copyMemory                             45 /   48       5903.9           0.2       9.3X\r\nPlatform copyMemory Object                      45 /   47       6004.0           0.2       9.5X\r\n```\r\n\r\nIt is enough to provide one method for `copyFrom` or `writeTo` with `Object` argument.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-02-25T09:18:24Z",
    "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {\n+    super(obj, offset, length);\n+    this.array = obj;\n+  }\n+\n+  @Override\n+  public MemoryBlock allocate(long offset, long size) {\n+    return new ByteArrayMemoryBlock(array, offset, size);\n+  }\n+\n+  public byte[] getByteArray() { return array; }\n+\n+  /**\n+   * Creates a memory block pointing to the memory used by the byte array.\n+   */\n+  public static ByteArrayMemoryBlock fromArray(final byte[] array) {\n+    return new ByteArrayMemoryBlock(array, Platform.BYTE_ARRAY_OFFSET, array.length);\n+  }\n+\n+\n+  public final int getInt(long offset) {\n+    // UTF8String.getPrefix() assumes data is 4-byte aligned\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 3) / 4) * 4);\n+    return Platform.getInt(array, offset);\n+  }\n+\n+  public final void putInt(long offset, int value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putInt(array, offset, value);\n+  }\n+\n+  public final boolean getBoolean(long offset) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getBoolean(array, offset);\n+  }\n+\n+  public final void putBoolean(long offset, boolean value) {\n+    assert(offset + 1 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putBoolean(array, offset, value);\n+  }\n+\n+  public final byte getByte(long offset) {\n+    return array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)];\n+  }\n+\n+  public final void putByte(long offset, byte value) {\n+    array[(int)(offset - Platform.BYTE_ARRAY_OFFSET)] = value;\n+  }\n+\n+  public final short getShort(long offset) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getShort(array, offset);\n+  }\n+\n+  public final void putShort(long offset, short value) {\n+    assert(offset + 2 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putShort(array, offset, value);\n+  }\n+\n+  public final long getLong(long offset) {\n+    // UTF8String.getPrefix() assumes data is 8-byte aligned\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= ((array.length + 7) / 8) * 8);\n+    return Platform.getLong(array, offset);\n+  }\n+\n+  public final void putLong(long offset, long value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putLong(array, offset, value);\n+  }\n+\n+  public final float getFloat(long offset) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getFloat(array, offset);\n+  }\n+\n+  public final void putFloat(long offset, float value) {\n+    assert(offset + 4 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putFloat(array, offset, value);\n+  }\n+\n+  public final double getDouble(long offset) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    return Platform.getDouble(array, offset);\n+  }\n+\n+  public final void putDouble(long offset, double value) {\n+    assert(offset + 8 - Platform.BYTE_ARRAY_OFFSET <= array.length);\n+    Platform.putDouble(array, offset, value);\n+  }\n+\n+  public final void copyFrom(byte[] src, long srcOffset, long dstOffset, long length) {"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "for convenient we can add\r\n```\r\npublic ByteArrayMemoryBlock(int size) {\r\n  this(new byte[size], Platform.BYTE_ARRAY_OFFSET, size)\r\n}\r\n```",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-01T15:14:20Z",
    "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long length) {"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "shall we check length overflow?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-05T23:13:35Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long size) {\n+    super(obj, offset, size);\n+    this.array = obj;\n+    assert(offset - Platform.BYTE_ARRAY_OFFSET + size <= obj.length * 8L) :\n+      \"The sum of size \" + size + \" and offset \" + offset + \" should not be larger than \" +\n+        \"the array size \" + ((obj.length) - Platform.BYTE_ARRAY_OFFSET);\n+  }\n+\n+  public ByteArrayMemoryBlock(long length) {\n+    this(new byte[(int)length], Platform.BYTE_ARRAY_OFFSET, length);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Yeah, I wanted to check. Now, I remember good check method `Ints.checkedCast()`.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-06T01:41:45Z",
    "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long size) {\n+    super(obj, offset, size);\n+    this.array = obj;\n+    assert(offset - Platform.BYTE_ARRAY_OFFSET + size <= obj.length * 8L) :\n+      \"The sum of size \" + size + \" and offset \" + offset + \" should not be larger than \" +\n+        \"the array size \" + ((obj.length) - Platform.BYTE_ARRAY_OFFSET);\n+  }\n+\n+  public ByteArrayMemoryBlock(long length) {\n+    this(new byte[(int)length], Platform.BYTE_ARRAY_OFFSET, length);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "why `* 8`?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-13T22:11:38Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import com.google.common.primitives.Ints;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long size) {\n+    super(obj, offset, size);\n+    this.array = obj;\n+    assert(offset - Platform.BYTE_ARRAY_OFFSET + size <= obj.length * 8L) :"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Oh, it's my mistake.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-14T01:44:12Z",
    "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.spark.unsafe.memory;\n+\n+import com.google.common.primitives.Ints;\n+\n+import org.apache.spark.unsafe.Platform;\n+\n+/**\n+ * A consecutive block of memory with a byte array on Java heap.\n+ */\n+public final class ByteArrayMemoryBlock extends MemoryBlock {\n+\n+  private final byte[] array;\n+\n+  public ByteArrayMemoryBlock(byte[] obj, long offset, long size) {\n+    super(obj, offset, size);\n+    this.array = obj;\n+    assert(offset - Platform.BYTE_ARRAY_OFFSET + size <= obj.length * 8L) :"
  }],
  "prId": 19222
}]