[{
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "do we still need this?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-28T22:47:52Z",
    "diffHunk": "@@ -33,15 +32,13 @@\n   private static final long WIDTH = 8;\n \n   private final MemoryBlock memory;\n-  private final Object baseObj;\n   private final long baseOffset;\n \n   private final long length;\n \n   public LongArray(MemoryBlock memory) {\n     assert memory.size() < (long) Integer.MAX_VALUE * 8: \"Array size >= Integer.MAX_VALUE elements\";\n     this.memory = memory;\n-    this.baseObj = memory.getBaseObject();\n     this.baseOffset = memory.getBaseOffset();"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "I see. I remove this.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2017-10-29T07:58:54Z",
    "diffHunk": "@@ -33,15 +32,13 @@\n   private static final long WIDTH = 8;\n \n   private final MemoryBlock memory;\n-  private final Object baseObj;\n   private final long baseOffset;\n \n   private final long length;\n \n   public LongArray(MemoryBlock memory) {\n     assert memory.size() < (long) Integer.MAX_VALUE * 8: \"Array size >= Integer.MAX_VALUE elements\";\n     this.memory = memory;\n-    this.baseObj = memory.getBaseObject();\n     this.baseOffset = memory.getBaseOffset();"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "in the future, shall we change the usage to `memory.putLong(index * WIDTH, value)`? One concern might be, under the hood, we need to do an add operation for each call, while we can avoid it by using a loop, e.g. https://github.com/apache/spark/pull/19222/files#diff-ecd88449f17ed41b7ce71d70a09429abR67",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-13T21:52:12Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@cloud-fan good point. We will want use `memory.putLong(index * WIDTH, value)`.\r\nI expect that JIT compiler could move loop invariants out of a loop or could map the sequence to a scaled index instruction `move targetreg, [basereg + scalereg * constant + offsetreg]` well.\r\n\r\nI will investigate what happens in the native code using the example that you pointed out.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-14T06:20:15Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "@cloud-fan sorry for my delay. I was busy with several stuffs.\r\nI ran a benchmark program for `LongArray.zeroOut` with two version. One is current implementation. The other is future implementation like `memory.putLong(index * WIDTH, value)`. I got almost the same performance using two versions.\r\nWDYT?\r\n\r\n```\r\nOpenJDK 64-Bit Server VM 1.8.0_151-8u151-b12-0ubuntu0.16.04.2-b12 on Linux 4.4.0-66-generic\r\nIntel(R) Xeon(R) CPU E5-2667 v3 @ 3.20GHz\r\nPlatform MemoryAccess:                   Best/Avg Time(ms)    Rate(M/s)   Per Row(ns)   Relative\r\n------------------------------------------------------------------------------------------------\r\nzeroOutCurrent                                1066 / 1071       1259.4           0.8       1.0X\r\nzeroOutFuture                                 1061 / 1063       1265.6           0.8       1.0X\r\n```\r\n\r\n```\r\nclass MemoryBlockLoopAccessBenchmark extends SparkFunSuite {\r\n  test(\"benchmark\") {\r\n    val N = 128 * 1024 * 1024\r\n    val iters = 2\r\n    val M = 5\r\n    val benchmark = new Benchmark(\"Platform MemoryAccess\", 1L * M * N * iters,\r\n      minNumIters = 20)\r\n\r\n    val array = new Array[Long](N)\r\n    val mb = OnHeapMemoryBlock.fromArray(array)\r\n    val la = new LongArray(mb)\r\n\r\n    benchmark.addCase(\"zeroOutCurrent\") { _: Int =>\r\n      for (_ <- 0L until iters) {\r\n        var i = 0\r\n        while (i < M) {\r\n          la.zeroOut()\r\n          i += 1\r\n        }\r\n      }\r\n    }\r\n\r\n    benchmark.addCase(\"zeroOutFuture\") { _: Int =>\r\n      for (_ <- 0L until iters) {\r\n        var i = 0\r\n        while (i < M) {\r\n          la.zeroOutFuture()\r\n          i += 1\r\n        }\r\n      }\r\n    }\r\n\r\n    benchmark.run()\r\n  }\r\n}\r\n\r\npublic final class LongArray {\r\n  ...\r\n  public void zeroOut() {\r\n    long baseOffset = memory.getBaseOffset();\r\n    for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {\r\n      memory.putLong(off, 0);\r\n    }\r\n  }\r\n\r\n  public void zeroOutFuture() {\r\n    for (long off = 0; off < length * WIDTH; off += WIDTH) {\r\n      memory.putLong2(off, 0);\r\n    }\r\n  }\r\n  ...\r\n}\r\n\r\npublic final class OnHeapMemoryBlock extends MemoryBlock {\r\n  ...\r\n  @Override\r\n  public final void putLong(long offset, long value) {\r\n    Platform.putLong(array, offset, value);\r\n  }\r\n  @Override\r\n  public final void putLong2(long ofs, long value) {\r\n    Platform.putLong(array, ofs + offset, value);\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n\r\n",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-19T18:53:08Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "Thanks for your data! I think it proves that we should make the API clearer and hide these offsets stuff in the implementation. If we could fix this in this patch, I think we can encourage more people to use the new way to operate memory. What do you think?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-19T20:49:26Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Yeah, we can encourage more people to use the new memory management and its API.\r\nOn the other hand, it would be good to take two-step approach:\r\n1. Use new MemoryBlock with the current explicit offset usage\r\n2. Hide offset stuff in the implementation.\r\n\r\nWDYT?",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-20T07:59:55Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }, {
    "author": {
      "login": "cloud-fan"
    },
    "body": "the problem is that, the semantic of the offset argument is pretty important to the `MemoryBlock` component. If we don't do it right at the first version, we bring a bad history to `MemoryBlock`, which may confuse other people.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-20T18:03:50Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);\n+    memory.putLong(memory.getBaseOffset() + index * WIDTH, value);"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "the `off` should starts with 0.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-27T03:02:18Z",
    "diffHunk": "@@ -69,8 +64,9 @@ public long size() {\n    * Fill this all with 0L.\n    */\n   public void zeroOut() {\n+    long baseOffset = memory.getBaseOffset();\n     for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {"
  }, {
    "author": {
      "login": "kiszk"
    },
    "body": "Good catch. These three unchanges seems to lead to failures.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-27T04:41:32Z",
    "diffHunk": "@@ -69,8 +64,9 @@ public long size() {\n    * Fill this all with 0L.\n    */\n   public void zeroOut() {\n+    long baseOffset = memory.getBaseOffset();\n     for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {"
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "update it to use 0-based offset.",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-27T03:03:17Z",
    "diffHunk": "@@ -80,7 +76,7 @@ public void zeroOut() {\n   public void set(int index, long value) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);",
    "line": 54
  }],
  "prId": 19222
}, {
  "comments": [{
    "author": {
      "login": "cloud-fan"
    },
    "body": "ditto",
    "commit": "50326ca2fff63ef0a88f3c7924fa8f1d53d17ec1",
    "createdAt": "2018-03-27T03:03:46Z",
    "diffHunk": "@@ -89,6 +85,6 @@ public void set(int index, long value) {\n   public long get(int index) {\n     assert index >= 0 : \"index (\" + index + \") should >= 0\";\n     assert index < length : \"index (\" + index + \") should < length (\" + length + \")\";\n-    return Platform.getLong(baseObj, baseOffset + index * WIDTH);\n+    return memory.getLong(memory.getBaseOffset() + index * WIDTH);"
  }],
  "prId": 19222
}]